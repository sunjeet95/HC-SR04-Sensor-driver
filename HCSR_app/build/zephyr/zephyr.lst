
zephyr.elf:     file format elf32-i386


Disassembly of section text:

00100000 <__start>:
        mov  %eax, %esi			/* low  value */
        mov  %edx, %edi			/* high value */
#endif

	/* Enable write-back caching by clearing the NW and CD bits */
	movl	%cr0, %eax
  100000:	0f 20 c0             	mov    %cr0,%eax
	andl	$0x9fffffff, %eax
  100003:	25 ff ff ff 9f       	and    $0x9fffffff,%eax
	movl	%eax, %cr0
  100008:	0f 22 c0             	mov    %eax,%cr0
	/*
	 * Ensure interrupts are disabled.  Interrupts are enabled when
	 * the first context switch occurs.
	 */

	cli
  10000b:	fa                   	cli    
	 * Although the bootloader sets up an Interrupt Descriptor Table (IDT)
	 * and a Global Descriptor Table (GDT), the specification encourages
	 * booted operating systems to setup their own IDT and GDT.
	 */
#if CONFIG_SET_GDT
	lgdt	_gdt_rom		/* load 32-bit operand size GDT */
  10000c:	0f 01 15 88 00 10 00 	lgdtl  0x100088


#ifdef CONFIG_SET_GDT
	/* If we set our own GDT, update the segment registers as well.
	 */
	movw	$DATA_SEG, %ax	/* data segment selector (entry = 3) */
  100013:	66 b8 10 00          	mov    $0x10,%ax
	movw	%ax, %ds	/* set DS */
  100017:	8e d8                	mov    %eax,%ds
	movw	%ax, %es	/* set ES */
  100019:	8e c0                	mov    %eax,%es
	movw	%ax, %ss	/* set SS */
  10001b:	8e d0                	mov    %eax,%ss
	xorw	%ax, %ax	/* AX = 0 */
  10001d:	66 31 c0             	xor    %ax,%ax
	movw	%ax, %fs	/* Zero FS */
  100020:	8e e0                	mov    %eax,%fs
	movw	%ax, %gs	/* Zero GS */
  100022:	8e e8                	mov    %eax,%gs

	ljmp	$CODE_SEG, $__csSet	/* set CS = 0x08 */
  100024:	ea 2b 00 10 00 08 00 	ljmp   $0x8,$0x10002b

0010002b <__csSet>:
	/*
	 * Force an #NM exception for floating point instructions
	 * since FP support hasn't been configured
	 */

	movl	%cr0, %eax		/* move CR0 to EAX */
  10002b:	0f 20 c0             	mov    %cr0,%eax
	orl	$0x2e, %eax		/* CR0[NE+TS+EM+MP]=1 */
  10002e:	83 c8 2e             	or     $0x2e,%eax
	movl	%eax, %cr0		/* move EAX to CR0 */
  100031:	0f 22 c0             	mov    %eax,%cr0
	 * interfering with interrupt handler use of this stack.
	 * If it is a cold boot then _sys_resume_from_deep_sleep() should
	 * not do anything and must return immediately.
	 */
#ifdef CONFIG_INIT_STACKS
	movl $0xAAAAAAAA, %eax
  100034:	b8 aa aa aa aa       	mov    $0xaaaaaaaa,%eax
	leal _interrupt_stack, %edi
  100039:	8d 3d b8 27 11 00    	lea    0x1127b8,%edi
#ifdef CONFIG_X86_STACK_PROTECTION
	addl $4096, %edi
#endif
	stack_size_dwords = (CONFIG_ISR_STACK_SIZE / 4)
	movl $stack_size_dwords, %ecx
  10003f:	b9 00 02 00 00       	mov    $0x200,%ecx
	rep  stosl
  100044:	f3 ab                	rep stos %eax,%es:(%edi)
#endif

	movl	$_interrupt_stack, %esp
  100046:	bc b8 27 11 00       	mov    $0x1127b8,%esp
	/* In this configuration, all stacks, including IRQ stack, are declared
	 * with a 4K non-present guard page preceding the stack buffer
	 */
	addl	$(CONFIG_ISR_STACK_SIZE + 4096), %esp
#else
	addl	$CONFIG_ISR_STACK_SIZE, %esp
  10004b:	81 c4 00 08 00 00    	add    $0x800,%esp
	 * Clear BSS: bzero (__bss_start, __bss_num_words*4)
	 *
	 * It's assumed that BSS size will be a multiple of a long (4 bytes),
	 * and aligned on a double word (32-bit) boundary
	 */
	movl	$__bss_start, %edi	/* load BSS start address */
  100051:	bf 00 f9 10 00       	mov    $0x10f900,%edi
	movl	$__bss_num_words, %ecx	/* number of quad bytes in .bss */
  100056:	b9 96 04 00 00       	mov    $0x496,%ecx
	call	_x86_bss_zero
  10005b:	e8 0c 00 00 00       	call   10006c <_x86_bss_zero>

#if defined(CONFIG_X86_ENABLE_TSS)
	mov $MAIN_TSS, %ax
	ltr %ax
#endif
	lidt	z_x86_idt		/* load 32-bit operand size IDT */
  100060:	0f 01 1d 72 00 10 00 	lidtl  0x100072

	/* Jump to C portion of kernel initialization and never return */

	jmp	z_cstart
  100067:	e9 19 9d 00 00       	jmp    109d85 <z_cstart>

0010006c <_x86_bss_zero>:

#else /* !CONFIG_SSE */

	/* clear out BSS double words (32-bits at a time) */

	xorl	%eax, %eax		/* fill memory with 0 */
  10006c:	31 c0                	xor    %eax,%eax
	cld
  10006e:	fc                   	cld    
	rep
  10006f:	f3 ab                	rep stos %eax,%es:(%edi)
	stosl				/* zero memory per 4 bytes */

#endif /* CONFIG_SSE */
	ret
  100071:	c3                   	ret    

00100072 <z_x86_idt>:
  100072:	ff 07 78 f0 10 00 02 b0 ad 1b 00 00 00 00 fe 4f     ..x............O
  100082:	52 e4 8d 74 26 00                                   R..t&.

00100088 <_gdt>:
  100088:	17 00 88 00 10 00 00 00 ff ff 00 00 00 9b cf 00     ................
  100098:	ff ff 00 00 00 93 cf 00                             ........

001000a0 <__divdi3>:
  1000a0:	55                   	push   %ebp
  1000a1:	89 e5                	mov    %esp,%ebp
  1000a3:	57                   	push   %edi
  1000a4:	56                   	push   %esi
  1000a5:	53                   	push   %ebx
  1000a6:	83 ec 2c             	sub    $0x2c,%esp
  1000a9:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
  1000b0:	8b 55 0c             	mov    0xc(%ebp),%edx
  1000b3:	8b 45 08             	mov    0x8(%ebp),%eax
  1000b6:	8b 75 10             	mov    0x10(%ebp),%esi
  1000b9:	8b 7d 14             	mov    0x14(%ebp),%edi
  1000bc:	85 d2                	test   %edx,%edx
  1000be:	79 0e                	jns    1000ce <__divdi3+0x2e>
  1000c0:	f7 d8                	neg    %eax
  1000c2:	83 d2 00             	adc    $0x0,%edx
  1000c5:	c7 45 dc ff ff ff ff 	movl   $0xffffffff,-0x24(%ebp)
  1000cc:	f7 da                	neg    %edx
  1000ce:	85 ff                	test   %edi,%edi
  1000d0:	79 0a                	jns    1000dc <__divdi3+0x3c>
  1000d2:	f7 de                	neg    %esi
  1000d4:	f7 55 dc             	notl   -0x24(%ebp)
  1000d7:	83 d7 00             	adc    $0x0,%edi
  1000da:	f7 df                	neg    %edi
  1000dc:	89 f3                	mov    %esi,%ebx
  1000de:	89 45 e0             	mov    %eax,-0x20(%ebp)
  1000e1:	89 d6                	mov    %edx,%esi
  1000e3:	85 ff                	test   %edi,%edi
  1000e5:	75 2d                	jne    100114 <__divdi3+0x74>
  1000e7:	39 d3                	cmp    %edx,%ebx
  1000e9:	76 04                	jbe    1000ef <__divdi3+0x4f>
  1000eb:	f7 f3                	div    %ebx
  1000ed:	eb 1e                	jmp    10010d <__divdi3+0x6d>
  1000ef:	85 db                	test   %ebx,%ebx
  1000f1:	75 0b                	jne    1000fe <__divdi3+0x5e>
  1000f3:	b8 01 00 00 00       	mov    $0x1,%eax
  1000f8:	31 d2                	xor    %edx,%edx
  1000fa:	f7 f3                	div    %ebx
  1000fc:	89 c3                	mov    %eax,%ebx
  1000fe:	89 f0                	mov    %esi,%eax
  100100:	31 d2                	xor    %edx,%edx
  100102:	f7 f3                	div    %ebx
  100104:	89 c6                	mov    %eax,%esi
  100106:	8b 45 e0             	mov    -0x20(%ebp),%eax
  100109:	89 f7                	mov    %esi,%edi
  10010b:	f7 f3                	div    %ebx
  10010d:	89 c3                	mov    %eax,%ebx
  10010f:	e9 90 00 00 00       	jmp    1001a4 <__divdi3+0x104>
  100114:	39 d7                	cmp    %edx,%edi
  100116:	0f 87 80 00 00 00    	ja     10019c <__divdi3+0xfc>
  10011c:	0f bd c7             	bsr    %edi,%eax
  10011f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  100122:	83 75 e4 1f          	xorl   $0x1f,-0x1c(%ebp)
  100126:	75 15                	jne    10013d <__divdi3+0x9d>
  100128:	39 d7                	cmp    %edx,%edi
  10012a:	bf 00 00 00 00       	mov    $0x0,%edi
  10012f:	72 05                	jb     100136 <__divdi3+0x96>
  100131:	3b 5d e0             	cmp    -0x20(%ebp),%ebx
  100134:	77 68                	ja     10019e <__divdi3+0xfe>
  100136:	bb 01 00 00 00       	mov    $0x1,%ebx
  10013b:	eb 67                	jmp    1001a4 <__divdi3+0x104>
  10013d:	b8 20 00 00 00       	mov    $0x20,%eax
  100142:	8a 4d e4             	mov    -0x1c(%ebp),%cl
  100145:	2b 45 e4             	sub    -0x1c(%ebp),%eax
  100148:	89 da                	mov    %ebx,%edx
  10014a:	d3 e7                	shl    %cl,%edi
  10014c:	88 c1                	mov    %al,%cl
  10014e:	d3 ea                	shr    %cl,%edx
  100150:	09 fa                	or     %edi,%edx
  100152:	8a 4d e4             	mov    -0x1c(%ebp),%cl
  100155:	d3 e3                	shl    %cl,%ebx
  100157:	89 55 d8             	mov    %edx,-0x28(%ebp)
  10015a:	88 c1                	mov    %al,%cl
  10015c:	89 f2                	mov    %esi,%edx
  10015e:	89 5d d4             	mov    %ebx,-0x2c(%ebp)
  100161:	d3 ea                	shr    %cl,%edx
  100163:	8a 4d e4             	mov    -0x1c(%ebp),%cl
  100166:	8b 5d e0             	mov    -0x20(%ebp),%ebx
  100169:	d3 e6                	shl    %cl,%esi
  10016b:	88 c1                	mov    %al,%cl
  10016d:	d3 eb                	shr    %cl,%ebx
  10016f:	09 f3                	or     %esi,%ebx
  100171:	89 d8                	mov    %ebx,%eax
  100173:	f7 75 d8             	divl   -0x28(%ebp)
  100176:	89 d6                	mov    %edx,%esi
  100178:	89 c7                	mov    %eax,%edi
  10017a:	89 c3                	mov    %eax,%ebx
  10017c:	f7 65 d4             	mull   -0x2c(%ebp)
  10017f:	89 45 d8             	mov    %eax,-0x28(%ebp)
  100182:	39 d6                	cmp    %edx,%esi
  100184:	72 11                	jb     100197 <__divdi3+0xf7>
  100186:	8b 45 e0             	mov    -0x20(%ebp),%eax
  100189:	8a 4d e4             	mov    -0x1c(%ebp),%cl
  10018c:	d3 e0                	shl    %cl,%eax
  10018e:	3b 45 d8             	cmp    -0x28(%ebp),%eax
  100191:	73 0f                	jae    1001a2 <__divdi3+0x102>
  100193:	39 d6                	cmp    %edx,%esi
  100195:	75 0b                	jne    1001a2 <__divdi3+0x102>
  100197:	8d 5f ff             	lea    -0x1(%edi),%ebx
  10019a:	eb 06                	jmp    1001a2 <__divdi3+0x102>
  10019c:	31 ff                	xor    %edi,%edi
  10019e:	31 db                	xor    %ebx,%ebx
  1001a0:	eb 02                	jmp    1001a4 <__divdi3+0x104>
  1001a2:	31 ff                	xor    %edi,%edi
  1001a4:	89 d8                	mov    %ebx,%eax
  1001a6:	89 fa                	mov    %edi,%edx
  1001a8:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
  1001ac:	74 07                	je     1001b5 <__divdi3+0x115>
  1001ae:	f7 d8                	neg    %eax
  1001b0:	83 d2 00             	adc    $0x0,%edx
  1001b3:	f7 da                	neg    %edx
  1001b5:	83 c4 2c             	add    $0x2c,%esp
  1001b8:	5b                   	pop    %ebx
  1001b9:	5e                   	pop    %esi
  1001ba:	5f                   	pop    %edi
  1001bb:	5d                   	pop    %ebp
  1001bc:	c3                   	ret    

001001bd <__udivdi3>:
  1001bd:	55                   	push   %ebp
  1001be:	89 e5                	mov    %esp,%ebp
  1001c0:	57                   	push   %edi
  1001c1:	56                   	push   %esi
  1001c2:	53                   	push   %ebx
  1001c3:	83 ec 1c             	sub    $0x1c,%esp
  1001c6:	8b 55 14             	mov    0x14(%ebp),%edx
  1001c9:	8b 45 08             	mov    0x8(%ebp),%eax
  1001cc:	89 45 e0             	mov    %eax,-0x20(%ebp)
  1001cf:	8b 7d 0c             	mov    0xc(%ebp),%edi
  1001d2:	8b 75 10             	mov    0x10(%ebp),%esi
  1001d5:	89 d1                	mov    %edx,%ecx
  1001d7:	85 d2                	test   %edx,%edx
  1001d9:	75 31                	jne    10020c <__udivdi3+0x4f>
  1001db:	39 fe                	cmp    %edi,%esi
  1001dd:	76 06                	jbe    1001e5 <__udivdi3+0x28>
  1001df:	89 fa                	mov    %edi,%edx
  1001e1:	f7 f6                	div    %esi
  1001e3:	eb 20                	jmp    100205 <__udivdi3+0x48>
  1001e5:	89 f3                	mov    %esi,%ebx
  1001e7:	85 f6                	test   %esi,%esi
  1001e9:	75 0b                	jne    1001f6 <__udivdi3+0x39>
  1001eb:	b8 01 00 00 00       	mov    $0x1,%eax
  1001f0:	31 d2                	xor    %edx,%edx
  1001f2:	f7 f6                	div    %esi
  1001f4:	89 c3                	mov    %eax,%ebx
  1001f6:	89 f8                	mov    %edi,%eax
  1001f8:	31 d2                	xor    %edx,%edx
  1001fa:	f7 f3                	div    %ebx
  1001fc:	89 c7                	mov    %eax,%edi
  1001fe:	8b 45 e0             	mov    -0x20(%ebp),%eax
  100201:	89 f9                	mov    %edi,%ecx
  100203:	f7 f3                	div    %ebx
  100205:	89 c3                	mov    %eax,%ebx
  100207:	e9 94 00 00 00       	jmp    1002a0 <__udivdi3+0xe3>
  10020c:	39 fa                	cmp    %edi,%edx
  10020e:	0f 87 84 00 00 00    	ja     100298 <__udivdi3+0xdb>
  100214:	0f bd c2             	bsr    %edx,%eax
  100217:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  10021a:	83 75 e4 1f          	xorl   $0x1f,-0x1c(%ebp)
  10021e:	75 15                	jne    100235 <__udivdi3+0x78>
  100220:	39 fa                	cmp    %edi,%edx
  100222:	b9 00 00 00 00       	mov    $0x0,%ecx
  100227:	72 05                	jb     10022e <__udivdi3+0x71>
  100229:	3b 75 e0             	cmp    -0x20(%ebp),%esi
  10022c:	77 6c                	ja     10029a <__udivdi3+0xdd>
  10022e:	bb 01 00 00 00       	mov    $0x1,%ebx
  100233:	eb 6b                	jmp    1002a0 <__udivdi3+0xe3>
  100235:	b8 20 00 00 00       	mov    $0x20,%eax
  10023a:	8a 4d e4             	mov    -0x1c(%ebp),%cl
  10023d:	2b 45 e4             	sub    -0x1c(%ebp),%eax
  100240:	89 f3                	mov    %esi,%ebx
  100242:	d3 e2                	shl    %cl,%edx
  100244:	88 c1                	mov    %al,%cl
  100246:	d3 eb                	shr    %cl,%ebx
  100248:	89 d9                	mov    %ebx,%ecx
  10024a:	8b 5d e0             	mov    -0x20(%ebp),%ebx
  10024d:	09 d1                	or     %edx,%ecx
  10024f:	89 4d dc             	mov    %ecx,-0x24(%ebp)
  100252:	8a 4d e4             	mov    -0x1c(%ebp),%cl
  100255:	d3 e6                	shl    %cl,%esi
  100257:	89 75 d8             	mov    %esi,-0x28(%ebp)
  10025a:	88 c1                	mov    %al,%cl
  10025c:	89 fe                	mov    %edi,%esi
  10025e:	d3 ee                	shr    %cl,%esi
  100260:	8a 4d e4             	mov    -0x1c(%ebp),%cl
  100263:	89 f2                	mov    %esi,%edx
  100265:	d3 e7                	shl    %cl,%edi
  100267:	88 c1                	mov    %al,%cl
  100269:	d3 eb                	shr    %cl,%ebx
  10026b:	09 fb                	or     %edi,%ebx
  10026d:	89 d8                	mov    %ebx,%eax
  10026f:	f7 75 dc             	divl   -0x24(%ebp)
  100272:	89 d6                	mov    %edx,%esi
  100274:	89 c7                	mov    %eax,%edi
  100276:	89 c3                	mov    %eax,%ebx
  100278:	f7 65 d8             	mull   -0x28(%ebp)
  10027b:	89 45 dc             	mov    %eax,-0x24(%ebp)
  10027e:	39 d6                	cmp    %edx,%esi
  100280:	72 11                	jb     100293 <__udivdi3+0xd6>
  100282:	8b 45 e0             	mov    -0x20(%ebp),%eax
  100285:	8a 4d e4             	mov    -0x1c(%ebp),%cl
  100288:	d3 e0                	shl    %cl,%eax
  10028a:	3b 45 dc             	cmp    -0x24(%ebp),%eax
  10028d:	73 0f                	jae    10029e <__udivdi3+0xe1>
  10028f:	39 d6                	cmp    %edx,%esi
  100291:	75 0b                	jne    10029e <__udivdi3+0xe1>
  100293:	8d 5f ff             	lea    -0x1(%edi),%ebx
  100296:	eb 06                	jmp    10029e <__udivdi3+0xe1>
  100298:	31 c9                	xor    %ecx,%ecx
  10029a:	31 db                	xor    %ebx,%ebx
  10029c:	eb 02                	jmp    1002a0 <__udivdi3+0xe3>
  10029e:	31 c9                	xor    %ecx,%ecx
  1002a0:	89 d8                	mov    %ebx,%eax
  1002a2:	89 ca                	mov    %ecx,%edx
  1002a4:	83 c4 1c             	add    $0x1c,%esp
  1002a7:	5b                   	pop    %ebx
  1002a8:	5e                   	pop    %esi
  1002a9:	5f                   	pop    %edi
  1002aa:	5d                   	pop    %ebp
  1002ab:	c3                   	ret    

001002ac <dump_data>:
//-----------------------Function to print/dump data ------------------------------
static int dump_data(const struct shell *shell, size_t argc, char **argv){


	return 0;
}
  1002ac:	31 c0                	xor    %eax,%eax
  1002ae:	c3                   	ret    

001002af <start_measurement>:
static int start_measurement(const struct shell *shell, size_t argc, char **argv){
  1002af:	55                   	push   %ebp
  1002b0:	89 e5                	mov    %esp,%ebp
	int numberofMeasurements_=atoi(*(argv+1));
  1002b2:	8b 45 10             	mov    0x10(%ebp),%eax
  1002b5:	ff 70 04             	pushl  0x4(%eax)
  1002b8:	e8 8c 69 00 00       	call   106c49 <atoi>
	printk("Measurement Collection Started......\n");
  1002bd:	c7 04 24 08 de 10 00 	movl   $0x10de08,(%esp)
  1002c4:	e8 48 06 00 00       	call   100911 <printk>
  1002c9:	58                   	pop    %eax
    __asm__ __volatile__("rdtsc" : "=a"(lo), "=d"(hi));
  1002ca:	0f 31                	rdtsc  
	start_measurement_timestamp=rdtsc();
  1002cc:	a3 58 0a 11 00       	mov    %eax,0x110a58
}
  1002d1:	31 c0                	xor    %eax,%eax
  1002d3:	c9                   	leave  
  1002d4:	c3                   	ret    

001002d5 <select_devices>:
static int select_devices(const struct shell *shell, size_t argc, char **argv){
  1002d5:	55                   	push   %ebp
  1002d6:	89 e5                	mov    %esp,%ebp
	int option_config=atoi(*(argv+1));
  1002d8:	8b 45 10             	mov    0x10(%ebp),%eax
  1002db:	ff 70 04             	pushl  0x4(%eax)
  1002de:	e8 66 69 00 00       	call   106c49 <atoi>
  1002e3:	5a                   	pop    %edx
	if(option_config==0){
  1002e4:	85 c0                	test   %eax,%eax
  1002e6:	75 07                	jne    1002ef <select_devices+0x1a>
		printk("No devices have been selected \n");
  1002e8:	68 2e de 10 00       	push   $0x10de2e
  1002ed:	eb 20                	jmp    10030f <select_devices+0x3a>
	else if(option_config==1){
  1002ef:	8d 50 ff             	lea    -0x1(%eax),%edx
  1002f2:	83 fa 01             	cmp    $0x1,%edx
  1002f5:	77 07                	ja     1002fe <select_devices+0x29>
		printk("HCSR_0 device been selected \n");
  1002f7:	68 4e de 10 00       	push   $0x10de4e
  1002fc:	eb 11                	jmp    10030f <select_devices+0x3a>
	else if(option_config==3){
  1002fe:	83 f8 03             	cmp    $0x3,%eax
  100301:	75 07                	jne    10030a <select_devices+0x35>
		printk("HCSR_0 and HCSR_1 devices been selected \n");
  100303:	68 6c de 10 00       	push   $0x10de6c
  100308:	eb 05                	jmp    10030f <select_devices+0x3a>
		printk("Please Select a Value Between 0-3 \n");
  10030a:	68 96 de 10 00       	push   $0x10de96
  10030f:	e8 fd 05 00 00       	call   100911 <printk>
  100314:	58                   	pop    %eax
}
  100315:	31 c0                	xor    %eax,%eax
  100317:	c9                   	leave  
  100318:	c3                   	ret    

00100319 <clear_buffer>:
  100319:	31 c0                	xor    %eax,%eax
  10031b:	c3                   	ret    

0010031c <main>:


	// int a=dev_config->triggerPin;
	// printk("%d", a);

}
  10031c:	c3                   	ret    

0010031d <get_bit_ptr>:
/* Places a 32 bit output pointer in word, and an integer bit index
 * within that word as the return value
 */
static int get_bit_ptr(struct sys_mem_pool_base *p, int level, int bn,
		       u32_t **word)
{
  10031d:	55                   	push   %ebp
  10031e:	89 e5                	mov    %esp,%ebp
  100320:	56                   	push   %esi
  100321:	53                   	push   %ebx
  100322:	6b da 0c             	imul   $0xc,%edx,%ebx
  100325:	03 58 0c             	add    0xc(%eax),%ebx
	u32_t *bitarray = level <= p->max_inline_level ?
  100328:	0f be 40 0b          	movsbl 0xb(%eax),%eax
		&p->levels[level].bits : p->levels[level].bits_p;
  10032c:	39 d0                	cmp    %edx,%eax
  10032e:	7d 02                	jge    100332 <get_bit_ptr+0x15>
  100330:	8b 1b                	mov    (%ebx),%ebx

	*word = &bitarray[bn / 32];
  100332:	89 c8                	mov    %ecx,%eax
  100334:	be 20 00 00 00       	mov    $0x20,%esi
  100339:	99                   	cltd   
  10033a:	f7 fe                	idiv   %esi
  10033c:	8d 14 83             	lea    (%ebx,%eax,4),%edx
  10033f:	8b 45 08             	mov    0x8(%ebp),%eax
  100342:	89 10                	mov    %edx,(%eax)

	return bn & 0x1f;
  100344:	89 c8                	mov    %ecx,%eax
}
  100346:	5b                   	pop    %ebx
	return bn & 0x1f;
  100347:	83 e0 1f             	and    $0x1f,%eax
}
  10034a:	5e                   	pop    %esi
  10034b:	5d                   	pop    %ebp
  10034c:	c3                   	ret    

0010034d <set_free_bit>:

static void set_free_bit(struct sys_mem_pool_base *p, int level, int bn)
{
  10034d:	55                   	push   %ebp
  10034e:	89 e5                	mov    %esp,%ebp
  100350:	53                   	push   %ebx
  100351:	53                   	push   %ebx
	u32_t *word;
	int bit = get_bit_ptr(p, level, bn, &word);
  100352:	8d 5d f8             	lea    -0x8(%ebp),%ebx
  100355:	53                   	push   %ebx
  100356:	e8 c2 ff ff ff       	call   10031d <get_bit_ptr>
  10035b:	5a                   	pop    %edx

	*word |= (1<<bit);
  10035c:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  10035f:	ba 01 00 00 00       	mov    $0x1,%edx
  100364:	88 c1                	mov    %al,%cl
  100366:	d3 e2                	shl    %cl,%edx
  100368:	09 13                	or     %edx,(%ebx)
}
  10036a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  10036d:	c9                   	leave  
  10036e:	c3                   	ret    

0010036f <z_sys_mem_pool_base_init>:

	return block_end <= (parent + parent_sz);
}

void z_sys_mem_pool_base_init(struct sys_mem_pool_base *p)
{
  10036f:	55                   	push   %ebp
	size_t buflen = p->n_max * p->max_sz, sz = p->max_sz;
	u32_t *bits = (u32_t *)((u8_t *)p->buf + buflen);

	p->max_inline_level = -1;

	for (i = 0; i < p->n_levels; i++) {
  100370:	31 c9                	xor    %ecx,%ecx
{
  100372:	89 e5                	mov    %esp,%ebp
  100374:	57                   	push   %edi
  100375:	56                   	push   %esi
  100376:	53                   	push   %ebx
  100377:	83 ec 0c             	sub    $0xc,%esp
  10037a:	8b 5d 08             	mov    0x8(%ebp),%ebx
	size_t buflen = p->n_max * p->max_sz, sz = p->max_sz;
  10037d:	8b 43 04             	mov    0x4(%ebx),%eax
	u32_t *bits = (u32_t *)((u8_t *)p->buf + buflen);
  100380:	8b 33                	mov    (%ebx),%esi
	size_t buflen = p->n_max * p->max_sz, sz = p->max_sz;
  100382:	89 45 f0             	mov    %eax,-0x10(%ebp)
	p->max_inline_level = -1;
  100385:	c6 43 0b ff          	movb   $0xff,0xb(%ebx)
	size_t buflen = p->n_max * p->max_sz, sz = p->max_sz;
  100389:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  10038d:	0f af 45 f0          	imul   -0x10(%ebp),%eax
  100391:	89 45 ec             	mov    %eax,-0x14(%ebp)
	u32_t *bits = (u32_t *)((u8_t *)p->buf + buflen);
  100394:	01 c6                	add    %eax,%esi
	for (i = 0; i < p->n_levels; i++) {
  100396:	0f b6 43 0a          	movzbl 0xa(%ebx),%eax
  10039a:	89 45 e8             	mov    %eax,-0x18(%ebp)
  10039d:	39 4d e8             	cmp    %ecx,-0x18(%ebp)
  1003a0:	7e 43                	jle    1003e5 <z_sys_mem_pool_base_init+0x76>
		int nblocks = buflen / sz;
  1003a2:	31 d2                	xor    %edx,%edx
  1003a4:	8b 45 ec             	mov    -0x14(%ebp),%eax
  1003a7:	f7 75 f0             	divl   -0x10(%ebp)

		sys_dlist_init(&p->levels[i].free_list);
  1003aa:	6b d1 0c             	imul   $0xc,%ecx,%edx
  1003ad:	03 53 0c             	add    0xc(%ebx),%edx

		if (nblocks < 32) {
  1003b0:	83 f8 1f             	cmp    $0x1f,%eax
		sys_dlist_init(&p->levels[i].free_list);
  1003b3:	8d 7a 04             	lea    0x4(%edx),%edi
 * @return N/A
 */

static inline void sys_dlist_init(sys_dlist_t *list)
{
	list->head = (sys_dnode_t *)list;
  1003b6:	89 7a 04             	mov    %edi,0x4(%edx)
	list->tail = (sys_dnode_t *)list;
  1003b9:	89 7a 08             	mov    %edi,0x8(%edx)
		if (nblocks < 32) {
  1003bc:	7f 05                	jg     1003c3 <z_sys_mem_pool_base_init+0x54>
			p->max_inline_level = i;
  1003be:	88 4b 0b             	mov    %cl,0xb(%ebx)
  1003c1:	eb 10                	jmp    1003d3 <z_sys_mem_pool_base_init+0x64>
		} else {
			p->levels[i].bits_p = bits;
			bits += (nblocks + 31)/32;
  1003c3:	83 c0 1f             	add    $0x1f,%eax
			p->levels[i].bits_p = bits;
  1003c6:	89 32                	mov    %esi,(%edx)
			bits += (nblocks + 31)/32;
  1003c8:	bf 20 00 00 00       	mov    $0x20,%edi
  1003cd:	99                   	cltd   
  1003ce:	f7 ff                	idiv   %edi
  1003d0:	8d 34 86             	lea    (%esi,%eax,4),%esi
		}

		sz = _ALIGN4(sz / 4);
  1003d3:	8b 45 f0             	mov    -0x10(%ebp),%eax
	for (i = 0; i < p->n_levels; i++) {
  1003d6:	41                   	inc    %ecx
		sz = _ALIGN4(sz / 4);
  1003d7:	c1 e8 02             	shr    $0x2,%eax
  1003da:	83 c0 03             	add    $0x3,%eax
  1003dd:	83 e0 fc             	and    $0xfffffffc,%eax
  1003e0:	89 45 f0             	mov    %eax,-0x10(%ebp)
  1003e3:	eb b8                	jmp    10039d <z_sys_mem_pool_base_init+0x2e>
	}

	for (i = 0; i < p->n_max; i++) {
  1003e5:	31 f6                	xor    %esi,%esi
  1003e7:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  1003eb:	39 f0                	cmp    %esi,%eax
  1003ed:	7e 2c                	jle    10041b <z_sys_mem_pool_base_init+0xac>
	return (u8_t *)p->buf + lsz * block;
  1003ef:	8b 43 04             	mov    0x4(%ebx),%eax
		void *block = block_ptr(p, p->max_sz, i);

		sys_dlist_append(&p->levels[0].free_list, block);
  1003f2:	8b 53 0c             	mov    0xc(%ebx),%edx
	return (u8_t *)p->buf + lsz * block;
  1003f5:	0f af c6             	imul   %esi,%eax
  1003f8:	03 03                	add    (%ebx),%eax
		sys_dlist_append(&p->levels[0].free_list, block);
  1003fa:	8d 4a 04             	lea    0x4(%edx),%ecx
  1003fd:	89 08                	mov    %ecx,(%eax)
 */

static inline void sys_dlist_append(sys_dlist_t *list, sys_dnode_t *node)
{
	node->next = list;
	node->prev = list->tail;
  1003ff:	8b 4a 08             	mov    0x8(%edx),%ecx
  100402:	89 48 04             	mov    %ecx,0x4(%eax)

	list->tail->next = node;
  100405:	8b 4a 08             	mov    0x8(%edx),%ecx
  100408:	89 01                	mov    %eax,(%ecx)
	list->tail = node;
  10040a:	89 42 08             	mov    %eax,0x8(%edx)
		set_free_bit(p, 0, i);
  10040d:	89 f1                	mov    %esi,%ecx
  10040f:	31 d2                	xor    %edx,%edx
  100411:	89 d8                	mov    %ebx,%eax
	for (i = 0; i < p->n_max; i++) {
  100413:	46                   	inc    %esi
		set_free_bit(p, 0, i);
  100414:	e8 34 ff ff ff       	call   10034d <set_free_bit>
  100419:	eb cc                	jmp    1003e7 <z_sys_mem_pool_base_init+0x78>
	}
}
  10041b:	83 c4 0c             	add    $0xc,%esp
  10041e:	5b                   	pop    %ebx
  10041f:	5e                   	pop    %esi
  100420:	5f                   	pop    %edi
  100421:	5d                   	pop    %ebp
  100422:	c3                   	ret    

00100423 <z_thread_entry>:
 * This routine does not return, and is marked as such so the compiler won't
 * generate preamble code that is only used by functions that actually return.
 */
FUNC_NORETURN void z_thread_entry(k_thread_entry_t entry,
				 void *p1, void *p2, void *p3)
{
  100423:	55                   	push   %ebp
  100424:	89 e5                	mov    %esp,%ebp
	entry(p1, p2, p3);
  100426:	ff 75 14             	pushl  0x14(%ebp)
  100429:	ff 75 10             	pushl  0x10(%ebp)
  10042c:	ff 75 0c             	pushl  0xc(%ebp)
  10042f:	ff 55 08             	call   *0x8(%ebp)
  100432:	83 c4 0c             	add    $0xc,%esp

K_SYSCALL_DECLARE0_VOID(K_SYSCALL_K_YIELD, k_yield)

K_SYSCALL_DECLARE1_VOID(K_SYSCALL_K_WAKEUP, k_wakeup, k_tid_t, thread)

K_SYSCALL_DECLARE0(K_SYSCALL_K_CURRENT_GET, k_current_get, k_tid_t)
  100435:	e8 e9 a6 00 00       	call   10ab23 <z_impl_k_current_get>

K_SYSCALL_DECLARE1_VOID(K_SYSCALL_K_THREAD_ABORT, k_thread_abort, k_tid_t, thread)
  10043a:	50                   	push   %eax
  10043b:	e8 15 ab 00 00       	call   10af55 <z_impl_k_thread_abort>
  100440:	58                   	pop    %eax

00100441 <z_arch_printk_char_out>:
{
	ARG_UNUSED(c);

	/* do nothing */
	return 0;
}
  100441:	31 c0                	xor    %eax,%eax
  100443:	c3                   	ret    

00100444 <print_err>:
{
	return _char_out;
}

static void print_err(out_func_t out, void *ctx)
{
  100444:	55                   	push   %ebp
  100445:	89 e5                	mov    %esp,%ebp
  100447:	56                   	push   %esi
  100448:	53                   	push   %ebx
  100449:	89 c3                	mov    %eax,%ebx
	out('E', ctx);
  10044b:	52                   	push   %edx
{
  10044c:	89 d6                	mov    %edx,%esi
	out('E', ctx);
  10044e:	6a 45                	push   $0x45
  100450:	ff d3                	call   *%ebx
  100452:	58                   	pop    %eax
  100453:	5a                   	pop    %edx
	out('R', ctx);
  100454:	56                   	push   %esi
  100455:	6a 52                	push   $0x52
  100457:	ff d3                	call   *%ebx
  100459:	59                   	pop    %ecx
  10045a:	58                   	pop    %eax
	out('R', ctx);
  10045b:	56                   	push   %esi
  10045c:	6a 52                	push   $0x52
  10045e:	ff d3                	call   *%ebx
  100460:	58                   	pop    %eax
  100461:	5a                   	pop    %edx
}
  100462:	8d 65 f8             	lea    -0x8(%ebp),%esp
  100465:	5b                   	pop    %ebx
  100466:	5e                   	pop    %esi
  100467:	5d                   	pop    %ebp
  100468:	c3                   	ret    

00100469 <char_out>:
struct out_context {
	int count;
};

static int char_out(int c, void *ctx_p)
{
  100469:	55                   	push   %ebp
  10046a:	89 e5                	mov    %esp,%ebp
  10046c:	8b 45 0c             	mov    0xc(%ebp),%eax
	struct out_context *ctx = ctx_p;

	ctx->count++;
  10046f:	ff 00                	incl   (%eax)
	return _char_out(c);
}
  100471:	5d                   	pop    %ebp
	return _char_out(c);
  100472:	ff 25 ec 31 11 00    	jmp    *0x1131ec

00100478 <_printk_dec_ulong>:
 * @return N/A
 */
static void _printk_dec_ulong(out_func_t out, void *ctx,
			      const unsigned long num, enum pad_type padding,
			      int min_width)
{
  100478:	55                   	push   %ebp
  100479:	89 e5                	mov    %esp,%ebp
  10047b:	57                   	push   %edi
  10047c:	56                   	push   %esi
  10047d:	89 c7                	mov    %eax,%edi
  10047f:	53                   	push   %ebx
  100480:	89 d6                	mov    %edx,%esi
  100482:	83 ec 1c             	sub    $0x1c,%esp
  100485:	89 4d f0             	mov    %ecx,-0x10(%ebp)
  100488:	8b 45 0c             	mov    0xc(%ebp),%eax
  10048b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  10048e:	85 c0                	test   %eax,%eax
  100490:	7f 07                	jg     100499 <_printk_dec_ulong+0x21>
  100492:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
  100499:	31 db                	xor    %ebx,%ebx
  10049b:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
  1004a2:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
  1004a6:	0f 94 c3             	sete   %bl
  1004a9:	4b                   	dec    %ebx
  1004aa:	c7 45 dc 0a 00 00 00 	movl   $0xa,-0x24(%ebp)
  1004b1:	83 e3 f0             	and    $0xfffffff0,%ebx
  1004b4:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  1004bb:	83 c3 30             	add    $0x30,%ebx
  1004be:	c7 45 e8 ff c9 9a 3b 	movl   $0x3b9ac9ff,-0x18(%ebp)
	if (min_width <= 0) {
		min_width = 1;
	}

	while (pos >= 9) {
		if (found_largest_digit != 0 || remainder > pos) {
  1004c5:	8b 45 e8             	mov    -0x18(%ebp),%eax
  1004c8:	40                   	inc    %eax
  1004c9:	89 45 d8             	mov    %eax,-0x28(%ebp)
  1004cc:	8b 45 e8             	mov    -0x18(%ebp),%eax
  1004cf:	3b 45 f0             	cmp    -0x10(%ebp),%eax
  1004d2:	72 06                	jb     1004da <_printk_dec_ulong+0x62>
  1004d4:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
  1004d8:	74 1d                	je     1004f7 <_printk_dec_ulong+0x7f>
			found_largest_digit = 1;
			out((int)((remainder / (pos + 1)) + 48), ctx);
  1004da:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1004dd:	31 d2                	xor    %edx,%edx
  1004df:	f7 75 d8             	divl   -0x28(%ebp)
  1004e2:	56                   	push   %esi
  1004e3:	83 c0 30             	add    $0x30,%eax
  1004e6:	50                   	push   %eax
  1004e7:	ff d7                	call   *%edi
  1004e9:	59                   	pop    %ecx
			digits++;
  1004ea:	ff 45 e0             	incl   -0x20(%ebp)
			out((int)((remainder / (pos + 1)) + 48), ctx);
  1004ed:	58                   	pop    %eax
			found_largest_digit = 1;
  1004ee:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
  1004f5:	eb 1e                	jmp    100515 <_printk_dec_ulong+0x9d>
		} else if (remaining <= min_width
  1004f7:	8b 55 dc             	mov    -0x24(%ebp),%edx
  1004fa:	39 55 e4             	cmp    %edx,-0x1c(%ebp)
  1004fd:	7c 0f                	jl     10050e <_printk_dec_ulong+0x96>
  1004ff:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
  100503:	77 09                	ja     10050e <_printk_dec_ulong+0x96>
				&& padding < PAD_SPACE_AFTER) {
			out((int)(padding == PAD_ZERO_BEFORE ? '0' : ' '), ctx);
  100505:	56                   	push   %esi
  100506:	53                   	push   %ebx
  100507:	ff d7                	call   *%edi
			digits++;
  100509:	ff 45 e0             	incl   -0x20(%ebp)
			out((int)(padding == PAD_ZERO_BEFORE ? '0' : ' '), ctx);
  10050c:	58                   	pop    %eax
  10050d:	5a                   	pop    %edx
			digits++;
  10050e:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
		}
		remaining--;
		remainder %= (pos + 1);
  100515:	8b 45 f0             	mov    -0x10(%ebp),%eax
  100518:	31 d2                	xor    %edx,%edx
  10051a:	f7 75 d8             	divl   -0x28(%ebp)
		remaining--;
  10051d:	ff 4d dc             	decl   -0x24(%ebp)
		pos /= 10;
  100520:	8b 45 e8             	mov    -0x18(%ebp),%eax
		remainder %= (pos + 1);
  100523:	89 55 f0             	mov    %edx,-0x10(%ebp)
		pos /= 10;
  100526:	b9 0a 00 00 00       	mov    $0xa,%ecx
  10052b:	31 d2                	xor    %edx,%edx
  10052d:	f7 f1                	div    %ecx
  10052f:	89 45 e8             	mov    %eax,-0x18(%ebp)
	while (pos >= 9) {
  100532:	83 7d dc 01          	cmpl   $0x1,-0x24(%ebp)
  100536:	75 8d                	jne    1004c5 <_printk_dec_ulong+0x4d>
	}
	out((int)(remainder + 48), ctx);
  100538:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10053b:	56                   	push   %esi
  10053c:	83 c0 30             	add    $0x30,%eax
  10053f:	50                   	push   %eax
  100540:	ff d7                	call   *%edi
  100542:	59                   	pop    %ecx
  100543:	5b                   	pop    %ebx

	if (padding == PAD_SPACE_AFTER) {
  100544:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
  100548:	75 14                	jne    10055e <_printk_dec_ulong+0xe6>
		remaining = min_width - digits;
  10054a:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
  10054d:	2b 5d e0             	sub    -0x20(%ebp),%ebx
		while (remaining-- > 0) {
  100550:	85 db                	test   %ebx,%ebx
  100552:	7e 0a                	jle    10055e <_printk_dec_ulong+0xe6>
			out(' ', ctx);
  100554:	56                   	push   %esi
  100555:	4b                   	dec    %ebx
  100556:	6a 20                	push   $0x20
  100558:	ff d7                	call   *%edi
  10055a:	58                   	pop    %eax
  10055b:	5a                   	pop    %edx
  10055c:	eb f2                	jmp    100550 <_printk_dec_ulong+0xd8>
		}
	}
}
  10055e:	8d 65 f4             	lea    -0xc(%ebp),%esp
  100561:	5b                   	pop    %ebx
  100562:	5e                   	pop    %esi
  100563:	5f                   	pop    %edi
  100564:	5d                   	pop    %ebp
  100565:	c3                   	ret    

00100566 <__printk_hook_install>:
{
  100566:	55                   	push   %ebp
  100567:	89 e5                	mov    %esp,%ebp
	_char_out = fn;
  100569:	8b 45 08             	mov    0x8(%ebp),%eax
}
  10056c:	5d                   	pop    %ebp
	_char_out = fn;
  10056d:	a3 ec 31 11 00       	mov    %eax,0x1131ec
}
  100572:	c3                   	ret    

00100573 <z_vprintk>:
{
  100573:	55                   	push   %ebp
  100574:	89 e5                	mov    %esp,%ebp
  100576:	57                   	push   %edi
  100577:	56                   	push   %esi
	int might_format = 0; /* 1 if encountered a '%' */
  100578:	31 ff                	xor    %edi,%edi
{
  10057a:	53                   	push   %ebx
  10057b:	83 ec 24             	sub    $0x24,%esp
	int long_ctr = 0;
  10057e:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
{
  100585:	8b 5d 14             	mov    0x14(%ebp),%ebx
	int min_width = -1;
  100588:	c7 45 f0 ff ff ff ff 	movl   $0xffffffff,-0x10(%ebp)
	enum pad_type padding = PAD_NONE;
  10058f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	while (*fmt) {
  100596:	8b 45 10             	mov    0x10(%ebp),%eax
  100599:	0f be 00             	movsbl (%eax),%eax
  10059c:	84 c0                	test   %al,%al
  10059e:	0f 84 41 03 00 00    	je     1008e5 <z_vprintk+0x372>
		if (!might_format) {
  1005a4:	85 ff                	test   %edi,%edi
  1005a6:	75 16                	jne    1005be <z_vprintk+0x4b>
			if (*fmt != '%') {
  1005a8:	3c 25                	cmp    $0x25,%al
  1005aa:	0f 84 f1 02 00 00    	je     1008a1 <z_vprintk+0x32e>
				out((int)*fmt, ctx);
  1005b0:	ff 75 0c             	pushl  0xc(%ebp)
  1005b3:	50                   	push   %eax
  1005b4:	ff 55 08             	call   *0x8(%ebp)
  1005b7:	5e                   	pop    %esi
  1005b8:	58                   	pop    %eax
  1005b9:	e9 15 03 00 00       	jmp    1008d3 <z_vprintk+0x360>
			switch (*fmt) {
  1005be:	3c 64                	cmp    $0x64,%al
  1005c0:	0f 84 d9 00 00 00    	je     10069f <z_vprintk+0x12c>
  1005c6:	7f 4a                	jg     100612 <z_vprintk+0x9f>
  1005c8:	3c 39                	cmp    $0x39,%al
  1005ca:	7f 26                	jg     1005f2 <z_vprintk+0x7f>
  1005cc:	3c 31                	cmp    $0x31,%al
  1005ce:	0f 8d 97 00 00 00    	jge    10066b <z_vprintk+0xf8>
  1005d4:	3c 2d                	cmp    $0x2d,%al
  1005d6:	0f 84 e1 02 00 00    	je     1008bd <z_vprintk+0x34a>
  1005dc:	3c 30                	cmp    $0x30,%al
  1005de:	74 7b                	je     10065b <z_vprintk+0xe8>
  1005e0:	3c 25                	cmp    $0x25,%al
  1005e2:	0f 85 9e 02 00 00    	jne    100886 <z_vprintk+0x313>
				out((int)'%', ctx);
  1005e8:	ff 75 0c             	pushl  0xc(%ebp)
  1005eb:	6a 25                	push   $0x25
  1005ed:	e9 a8 02 00 00       	jmp    10089a <z_vprintk+0x327>
			switch (*fmt) {
  1005f2:	3c 58                	cmp    $0x58,%al
  1005f4:	0f 84 5f 01 00 00    	je     100759 <z_vprintk+0x1e6>
  1005fa:	3c 63                	cmp    $0x63,%al
  1005fc:	0f 85 84 02 00 00    	jne    100886 <z_vprintk+0x313>
				out(c, ctx);
  100602:	ff 75 0c             	pushl  0xc(%ebp)
  100605:	ff 33                	pushl  (%ebx)
				int c = va_arg(ap, int);
  100607:	8d 73 04             	lea    0x4(%ebx),%esi
				out(c, ctx);
  10060a:	ff 55 08             	call   *0x8(%ebp)
  10060d:	e9 70 02 00 00       	jmp    100882 <z_vprintk+0x30f>
			switch (*fmt) {
  100612:	3c 70                	cmp    $0x70,%al
  100614:	0f 84 1d 01 00 00    	je     100737 <z_vprintk+0x1c4>
  10061a:	7f 0c                	jg     100628 <z_vprintk+0xb5>
  10061c:	3c 69                	cmp    $0x69,%al
  10061e:	74 7f                	je     10069f <z_vprintk+0x12c>
  100620:	3c 6c                	cmp    $0x6c,%al
  100622:	74 73                	je     100697 <z_vprintk+0x124>
  100624:	3c 68                	cmp    $0x68,%al
  100626:	eb 28                	jmp    100650 <z_vprintk+0xdd>
  100628:	3c 75                	cmp    $0x75,%al
  10062a:	0f 84 b6 00 00 00    	je     1006e6 <z_vprintk+0x173>
  100630:	7f 14                	jg     100646 <z_vprintk+0xd3>
  100632:	3c 73                	cmp    $0x73,%al
  100634:	0f 85 4c 02 00 00    	jne    100886 <z_vprintk+0x313>
				char *s = va_arg(ap, char *);
  10063a:	8b 3b                	mov    (%ebx),%edi
  10063c:	8d 73 04             	lea    0x4(%ebx),%esi
  10063f:	89 fb                	mov    %edi,%ebx
				while (*s)
  100641:	e9 09 02 00 00       	jmp    10084f <z_vprintk+0x2dc>
			switch (*fmt) {
  100646:	3c 78                	cmp    $0x78,%al
  100648:	0f 84 0b 01 00 00    	je     100759 <z_vprintk+0x1e6>
  10064e:	3c 7a                	cmp    $0x7a,%al
  100650:	0f 84 7d 02 00 00    	je     1008d3 <z_vprintk+0x360>
  100656:	e9 2b 02 00 00       	jmp    100886 <z_vprintk+0x313>
				if (min_width < 0 && padding == PAD_NONE) {
  10065b:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
  10065f:	79 0a                	jns    10066b <z_vprintk+0xf8>
  100661:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
  100665:	0f 84 5b 02 00 00    	je     1008c6 <z_vprintk+0x353>
				if (min_width < 0) {
  10066b:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
  10066f:	79 05                	jns    100676 <z_vprintk+0x103>
					min_width = *fmt - '0';
  100671:	83 e8 30             	sub    $0x30,%eax
  100674:	eb 08                	jmp    10067e <z_vprintk+0x10b>
					min_width = 10 * min_width + *fmt - '0';
  100676:	6b 55 f0 0a          	imul   $0xa,-0x10(%ebp),%edx
  10067a:	8d 44 10 d0          	lea    -0x30(%eax,%edx,1),%eax
  10067e:	89 45 f0             	mov    %eax,-0x10(%ebp)
				if (padding == PAD_NONE) {
  100681:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
  100685:	0f 85 48 02 00 00    	jne    1008d3 <z_vprintk+0x360>
					padding = PAD_SPACE_BEFORE;
  10068b:	c7 45 ec 02 00 00 00 	movl   $0x2,-0x14(%ebp)
  100692:	e9 3c 02 00 00       	jmp    1008d3 <z_vprintk+0x360>
				long_ctr++;
  100697:	ff 45 e8             	incl   -0x18(%ebp)
  10069a:	e9 34 02 00 00       	jmp    1008d3 <z_vprintk+0x360>
				if (long_ctr == 0) {
  10069f:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
  1006a3:	74 06                	je     1006ab <z_vprintk+0x138>
				} else if (long_ctr == 1) {
  1006a5:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
  1006a9:	75 07                	jne    1006b2 <z_vprintk+0x13f>
					long ld = va_arg(ap, long);
  1006ab:	8d 73 04             	lea    0x4(%ebx),%esi
  1006ae:	8b 0b                	mov    (%ebx),%ecx
					d = (s32_t)ld;
  1006b0:	eb 19                	jmp    1006cb <z_vprintk+0x158>
					long long lld = va_arg(ap, long long);
  1006b2:	8b 0b                	mov    (%ebx),%ecx
  1006b4:	8d 73 08             	lea    0x8(%ebx),%esi
					if (lld > INT32_MAX ||
  1006b7:	89 c8                	mov    %ecx,%eax
					long long lld = va_arg(ap, long long);
  1006b9:	8b 5b 04             	mov    0x4(%ebx),%ebx
					if (lld > INT32_MAX ||
  1006bc:	05 00 00 00 80       	add    $0x80000000,%eax
  1006c1:	89 da                	mov    %ebx,%edx
  1006c3:	83 d2 00             	adc    $0x0,%edx
  1006c6:	83 fa 00             	cmp    $0x0,%edx
  1006c9:	77 46                	ja     100711 <z_vprintk+0x19e>
				if (d < 0) {
  1006cb:	85 c9                	test   %ecx,%ecx
  1006cd:	79 52                	jns    100721 <z_vprintk+0x1ae>
					out((int)'-', ctx);
  1006cf:	ff 75 0c             	pushl  0xc(%ebp)
  1006d2:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
  1006d5:	6a 2d                	push   $0x2d
  1006d7:	ff 55 08             	call   *0x8(%ebp)
  1006da:	59                   	pop    %ecx
					d = -d;
  1006db:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
					out((int)'-', ctx);
  1006de:	5b                   	pop    %ebx
					min_width--;
  1006df:	ff 4d f0             	decl   -0x10(%ebp)
					d = -d;
  1006e2:	f7 d9                	neg    %ecx
				_printk_dec_ulong(out, ctx, d, padding,
  1006e4:	eb 3b                	jmp    100721 <z_vprintk+0x1ae>
				if (long_ctr == 0) {
  1006e6:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
  1006ea:	74 06                	je     1006f2 <z_vprintk+0x17f>
				} else if (long_ctr == 1) {
  1006ec:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
  1006f0:	75 07                	jne    1006f9 <z_vprintk+0x186>
					long lu = va_arg(ap, unsigned long);
  1006f2:	8d 73 04             	lea    0x4(%ebx),%esi
  1006f5:	8b 0b                	mov    (%ebx),%ecx
					u = (u32_t)lu;
  1006f7:	eb 28                	jmp    100721 <z_vprintk+0x1ae>
					if (llu > INT32_MAX) {
  1006f9:	ba ff ff ff 7f       	mov    $0x7fffffff,%edx
					unsigned long long llu =
  1006fe:	8b 0b                	mov    (%ebx),%ecx
					if (llu > INT32_MAX) {
  100700:	39 ca                	cmp    %ecx,%edx
					unsigned long long llu =
  100702:	8b 43 04             	mov    0x4(%ebx),%eax
					if (llu > INT32_MAX) {
  100705:	ba 00 00 00 00       	mov    $0x0,%edx
					unsigned long long llu =
  10070a:	8d 73 08             	lea    0x8(%ebx),%esi
					if (llu > INT32_MAX) {
  10070d:	19 c2                	sbb    %eax,%edx
  10070f:	73 10                	jae    100721 <z_vprintk+0x1ae>
						print_err(out, ctx);
  100711:	8b 55 0c             	mov    0xc(%ebp),%edx
  100714:	8b 45 08             	mov    0x8(%ebp),%eax
  100717:	e8 28 fd ff ff       	call   100444 <print_err>
						break;
  10071c:	e9 ae 01 00 00       	jmp    1008cf <z_vprintk+0x35c>
				_printk_dec_ulong(out, ctx, u, padding,
  100721:	ff 75 f0             	pushl  -0x10(%ebp)
  100724:	ff 75 ec             	pushl  -0x14(%ebp)
  100727:	8b 55 0c             	mov    0xc(%ebp),%edx
  10072a:	8b 45 08             	mov    0x8(%ebp),%eax
  10072d:	e8 46 fd ff ff       	call   100478 <_printk_dec_ulong>
  100732:	e9 4b 01 00 00       	jmp    100882 <z_vprintk+0x30f>
				  out('0', ctx);
  100737:	ff 75 0c             	pushl  0xc(%ebp)
  10073a:	6a 30                	push   $0x30
  10073c:	ff 55 08             	call   *0x8(%ebp)
  10073f:	59                   	pop    %ecx
  100740:	5e                   	pop    %esi
				  out('x', ctx);
  100741:	ff 75 0c             	pushl  0xc(%ebp)
  100744:	6a 78                	push   $0x78
  100746:	ff 55 08             	call   *0x8(%ebp)
  100749:	58                   	pop    %eax
				  min_width = 8;
  10074a:	c7 45 f0 08 00 00 00 	movl   $0x8,-0x10(%ebp)
				  out('x', ctx);
  100751:	5a                   	pop    %edx
				  padding = PAD_ZERO_BEFORE;
  100752:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
					x = va_arg(ap, unsigned long);
  100759:	8b 03                	mov    (%ebx),%eax
				if (long_ctr < 2) {
  10075b:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
  10075f:	7f 0d                	jg     10076e <z_vprintk+0x1fb>
					x = va_arg(ap, unsigned long);
  100761:	31 d2                	xor    %edx,%edx
  100763:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  100766:	89 55 d8             	mov    %edx,-0x28(%ebp)
  100769:	83 c3 04             	add    $0x4,%ebx
  10076c:	eb 0c                	jmp    10077a <z_vprintk+0x207>
					x = va_arg(ap, unsigned long long);
  10076e:	8b 53 04             	mov    0x4(%ebx),%edx
  100771:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  100774:	89 55 d8             	mov    %edx,-0x28(%ebp)
  100777:	83 c3 08             	add    $0x8,%ebx
	int remaining = 16; /* 16 digits max */
  10077a:	c7 45 e0 10 00 00 00 	movl   $0x10,-0x20(%ebp)
	int digits = 0;
  100781:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
	int found_largest_digit = 0;
  100788:	31 f6                	xor    %esi,%esi
	int size = sizeof(num) * 2;
  10078a:	c7 45 dc 10 00 00 00 	movl   $0x10,-0x24(%ebp)
		char nibble = (num >> ((size - 1) << 2) & 0xf);
  100791:	8b 45 dc             	mov    -0x24(%ebp),%eax
  100794:	8b 55 d8             	mov    -0x28(%ebp),%edx
  100797:	48                   	dec    %eax
  100798:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  10079b:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
  1007a2:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  1007a5:	0f ad d0             	shrd   %cl,%edx,%eax
  1007a8:	d3 ea                	shr    %cl,%edx
  1007aa:	f6 c1 20             	test   $0x20,%cl
  1007ad:	74 02                	je     1007b1 <z_vprintk+0x23e>
  1007af:	89 d0                	mov    %edx,%eax
		if (nibble != 0 || found_largest_digit != 0 || size == 1) {
  1007b1:	24 0f                	and    $0xf,%al
  1007b3:	75 0f                	jne    1007c4 <z_vprintk+0x251>
  1007b5:	83 e6 01             	and    $0x1,%esi
  1007b8:	75 0a                	jne    1007c4 <z_vprintk+0x251>
			nibble += nibble > 9 ? 87 : 48;
  1007ba:	b2 30                	mov    $0x30,%dl
		if (nibble != 0 || found_largest_digit != 0 || size == 1) {
  1007bc:	83 7d dc 01          	cmpl   $0x1,-0x24(%ebp)
  1007c0:	75 2f                	jne    1007f1 <z_vprintk+0x27e>
  1007c2:	eb 0c                	jmp    1007d0 <z_vprintk+0x25d>
			nibble += nibble > 9 ? 87 : 48;
  1007c4:	3c 09                	cmp    $0x9,%al
  1007c6:	0f 9f c2             	setg   %dl
  1007c9:	4a                   	dec    %edx
  1007ca:	83 e2 d9             	and    $0xffffffd9,%edx
  1007cd:	83 c2 57             	add    $0x57,%edx
			out((int)nibble, ctx);
  1007d0:	ff 75 0c             	pushl  0xc(%ebp)
			nibble += nibble > 9 ? 87 : 48;
  1007d3:	01 d0                	add    %edx,%eax
			out((int)nibble, ctx);
  1007d5:	0f be c0             	movsbl %al,%eax
  1007d8:	50                   	push   %eax
  1007d9:	ff 55 08             	call   *0x8(%ebp)
  1007dc:	58                   	pop    %eax
			digits++;
  1007dd:	ff 45 d0             	incl   -0x30(%ebp)
			out((int)nibble, ctx);
  1007e0:	5a                   	pop    %edx
	for (; size != 0; size--) {
  1007e1:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
  1007e5:	74 3f                	je     100826 <z_vprintk+0x2b3>
			found_largest_digit = 1;
  1007e7:	89 fe                	mov    %edi,%esi
		char nibble = (num >> ((size - 1) << 2) & 0xf);
  1007e9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  1007ec:	89 45 dc             	mov    %eax,-0x24(%ebp)
  1007ef:	eb a0                	jmp    100791 <z_vprintk+0x21e>
		if (remaining-- <= min_width) {
  1007f1:	8b 45 e0             	mov    -0x20(%ebp),%eax
  1007f4:	39 45 f0             	cmp    %eax,-0x10(%ebp)
  1007f7:	8d 70 ff             	lea    -0x1(%eax),%esi
  1007fa:	0f 8c db 00 00 00    	jl     1008db <z_vprintk+0x368>
			if (padding == PAD_ZERO_BEFORE) {
  100800:	83 7d ec 01          	cmpl   $0x1,-0x14(%ebp)
  100804:	75 07                	jne    10080d <z_vprintk+0x29a>
				out('0', ctx);
  100806:	ff 75 0c             	pushl  0xc(%ebp)
  100809:	6a 30                	push   $0x30
  10080b:	eb 0f                	jmp    10081c <z_vprintk+0x2a9>
			} else if (padding == PAD_SPACE_BEFORE) {
  10080d:	83 7d ec 02          	cmpl   $0x2,-0x14(%ebp)
  100811:	0f 85 c4 00 00 00    	jne    1008db <z_vprintk+0x368>
				out(' ', ctx);
  100817:	ff 75 0c             	pushl  0xc(%ebp)
  10081a:	6a 20                	push   $0x20
  10081c:	ff 55 08             	call   *0x8(%ebp)
  10081f:	59                   	pop    %ecx
  100820:	58                   	pop    %eax
  100821:	e9 b5 00 00 00       	jmp    1008db <z_vprintk+0x368>
			might_format = 0;
  100826:	31 ff                	xor    %edi,%edi
	if (padding == PAD_SPACE_AFTER) {
  100828:	83 7d ec 03          	cmpl   $0x3,-0x14(%ebp)
  10082c:	0f 85 a1 00 00 00    	jne    1008d3 <z_vprintk+0x360>
		remaining = min_width * 2 - digits;
  100832:	8b 75 f0             	mov    -0x10(%ebp),%esi
  100835:	01 f6                	add    %esi,%esi
  100837:	2b 75 d0             	sub    -0x30(%ebp),%esi
		while (remaining-- > 0) {
  10083a:	85 f6                	test   %esi,%esi
  10083c:	0f 8e 8f 00 00 00    	jle    1008d1 <z_vprintk+0x35e>
			out(' ', ctx);
  100842:	ff 75 0c             	pushl  0xc(%ebp)
  100845:	4e                   	dec    %esi
  100846:	6a 20                	push   $0x20
  100848:	ff 55 08             	call   *0x8(%ebp)
  10084b:	58                   	pop    %eax
  10084c:	5a                   	pop    %edx
  10084d:	eb eb                	jmp    10083a <z_vprintk+0x2c7>
				while (*s)
  10084f:	0f be 03             	movsbl (%ebx),%eax
  100852:	84 c0                	test   %al,%al
  100854:	74 0c                	je     100862 <z_vprintk+0x2ef>
					out((int)(*s++), ctx);
  100856:	ff 75 0c             	pushl  0xc(%ebp)
  100859:	43                   	inc    %ebx
  10085a:	50                   	push   %eax
  10085b:	ff 55 08             	call   *0x8(%ebp)
  10085e:	59                   	pop    %ecx
  10085f:	58                   	pop    %eax
  100860:	eb ed                	jmp    10084f <z_vprintk+0x2dc>
				if (padding == PAD_SPACE_AFTER) {
  100862:	83 7d ec 03          	cmpl   $0x3,-0x14(%ebp)
  100866:	75 67                	jne    1008cf <z_vprintk+0x35c>
					int remaining = min_width - (s - start);
  100868:	29 fb                	sub    %edi,%ebx
  10086a:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10086d:	29 d8                	sub    %ebx,%eax
  10086f:	89 c3                	mov    %eax,%ebx
					while (remaining-- > 0) {
  100871:	85 db                	test   %ebx,%ebx
  100873:	7e 5a                	jle    1008cf <z_vprintk+0x35c>
						out(' ', ctx);
  100875:	ff 75 0c             	pushl  0xc(%ebp)
  100878:	4b                   	dec    %ebx
  100879:	6a 20                	push   $0x20
  10087b:	ff 55 08             	call   *0x8(%ebp)
  10087e:	58                   	pop    %eax
  10087f:	5a                   	pop    %edx
  100880:	eb ef                	jmp    100871 <z_vprintk+0x2fe>
				out(c, ctx);
  100882:	5f                   	pop    %edi
  100883:	58                   	pop    %eax
				break;
  100884:	eb 49                	jmp    1008cf <z_vprintk+0x35c>
				out((int)'%', ctx);
  100886:	ff 75 0c             	pushl  0xc(%ebp)
  100889:	6a 25                	push   $0x25
  10088b:	ff 55 08             	call   *0x8(%ebp)
  10088e:	59                   	pop    %ecx
				out((int)*fmt, ctx);
  10088f:	8b 45 10             	mov    0x10(%ebp),%eax
				out((int)'%', ctx);
  100892:	5e                   	pop    %esi
				out((int)*fmt, ctx);
  100893:	ff 75 0c             	pushl  0xc(%ebp)
  100896:	0f be 00             	movsbl (%eax),%eax
  100899:	50                   	push   %eax
  10089a:	ff 55 08             	call   *0x8(%ebp)
  10089d:	58                   	pop    %eax
  10089e:	5a                   	pop    %edx
				break;
  10089f:	eb 30                	jmp    1008d1 <z_vprintk+0x35e>
				long_ctr = 0;
  1008a1:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
				min_width = -1;
  1008a8:	c7 45 f0 ff ff ff ff 	movl   $0xffffffff,-0x10(%ebp)
				padding = PAD_NONE;
  1008af:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
				might_format = 1;
  1008b6:	bf 01 00 00 00       	mov    $0x1,%edi
  1008bb:	eb 16                	jmp    1008d3 <z_vprintk+0x360>
				padding = PAD_SPACE_AFTER;
  1008bd:	c7 45 ec 03 00 00 00 	movl   $0x3,-0x14(%ebp)
  1008c4:	eb 0d                	jmp    1008d3 <z_vprintk+0x360>
					padding = PAD_ZERO_BEFORE;
  1008c6:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
  1008cd:	eb 04                	jmp    1008d3 <z_vprintk+0x360>
				char *s = va_arg(ap, char *);
  1008cf:	89 f3                	mov    %esi,%ebx
			might_format = 0;
  1008d1:	31 ff                	xor    %edi,%edi
		++fmt;
  1008d3:	ff 45 10             	incl   0x10(%ebp)
  1008d6:	e9 bb fc ff ff       	jmp    100596 <z_vprintk+0x23>
					x = va_arg(ap, unsigned long long);
  1008db:	89 75 e0             	mov    %esi,-0x20(%ebp)
  1008de:	31 f6                	xor    %esi,%esi
  1008e0:	e9 04 ff ff ff       	jmp    1007e9 <z_vprintk+0x276>
}
  1008e5:	8d 65 f4             	lea    -0xc(%ebp),%esp
  1008e8:	5b                   	pop    %ebx
  1008e9:	5e                   	pop    %esi
  1008ea:	5f                   	pop    %edi
  1008eb:	5d                   	pop    %ebp
  1008ec:	c3                   	ret    

001008ed <vprintk>:
{
  1008ed:	55                   	push   %ebp
  1008ee:	89 e5                	mov    %esp,%ebp
  1008f0:	50                   	push   %eax
	z_vprintk(char_out, &ctx, fmt, ap);
  1008f1:	ff 75 0c             	pushl  0xc(%ebp)
  1008f4:	ff 75 08             	pushl  0x8(%ebp)
  1008f7:	8d 45 fc             	lea    -0x4(%ebp),%eax
	struct out_context ctx = { 0 };
  1008fa:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	z_vprintk(char_out, &ctx, fmt, ap);
  100901:	50                   	push   %eax
  100902:	68 69 04 10 00       	push   $0x100469
  100907:	e8 67 fc ff ff       	call   100573 <z_vprintk>
  10090c:	83 c4 10             	add    $0x10,%esp
}
  10090f:	c9                   	leave  
  100910:	c3                   	ret    

00100911 <printk>:
{
  100911:	55                   	push   %ebp
  100912:	89 e5                	mov    %esp,%ebp
	va_start(ap, fmt);
  100914:	8d 45 0c             	lea    0xc(%ebp),%eax
		vprintk(fmt, ap);
  100917:	50                   	push   %eax
  100918:	ff 75 08             	pushl  0x8(%ebp)
  10091b:	e8 cd ff ff ff       	call   1008ed <vprintk>
  100920:	58                   	pop    %eax
  100921:	5a                   	pop    %edx
}
  100922:	c9                   	leave  
  100923:	c3                   	ret    

00100924 <ring_buf_space_get>:
 *
 * @return Ring buffer free space (in 32-bit words or bytes).
 */
static inline int ring_buf_space_get(struct ring_buf *buf)
{
	return z_ring_buf_custom_space_get(buf->size, buf->head, buf->tail);
  100924:	8b 10                	mov    (%eax),%edx
  100926:	8b 48 04             	mov    0x4(%eax),%ecx
  100929:	8b 40 10             	mov    0x10(%eax),%eax
	if (tail < head) {
  10092c:	39 d1                	cmp    %edx,%ecx
	return (size - tail) + head - 1;
  10092e:	8d 44 02 ff          	lea    -0x1(%edx,%eax,1),%eax
	if (tail < head) {
  100932:	73 03                	jae    100937 <ring_buf_space_get+0x13>
		return head - tail - 1;
  100934:	8d 42 ff             	lea    -0x1(%edx),%eax
	return (size - tail) + head - 1;
  100937:	29 c8                	sub    %ecx,%eax
}
  100939:	c3                   	ret    

0010093a <ring_buf_put_claim>:
{
	return val >= max ? (val - max) : val;
}

u32_t ring_buf_put_claim(struct ring_buf *buf, u8_t **data, u32_t size)
{
  10093a:	55                   	push   %ebp
  10093b:	89 e5                	mov    %esp,%ebp
  10093d:	57                   	push   %edi
  10093e:	56                   	push   %esi
  10093f:	53                   	push   %ebx
  100940:	8b 5d 08             	mov    0x8(%ebp),%ebx
	u32_t space, trail_size, allocated;

	space = z_ring_buf_custom_space_get(buf->size, buf->head,
  100943:	8b 53 08             	mov    0x8(%ebx),%edx
  100946:	8b 0b                	mov    (%ebx),%ecx
  100948:	8b 73 10             	mov    0x10(%ebx),%esi
	if (tail < head) {
  10094b:	39 ca                	cmp    %ecx,%edx
  10094d:	73 03                	jae    100952 <ring_buf_put_claim+0x18>
		return head - tail - 1;
  10094f:	49                   	dec    %ecx
  100950:	eb 04                	jmp    100956 <ring_buf_put_claim+0x1c>
	return (size - tail) + head - 1;
  100952:	8d 4c 31 ff          	lea    -0x1(%ecx,%esi,1),%ecx
	/* Limit requested size to available size. */
	size = MIN(size, space);
	trail_size = buf->size - buf->misc.byte_mode.tmp_tail;

	/* Limit allocated size to trail size. */
	allocated = MIN(trail_size, size);
  100956:	89 f0                	mov    %esi,%eax
  100958:	29 d1                	sub    %edx,%ecx
  10095a:	29 d0                	sub    %edx,%eax
  10095c:	3b 45 10             	cmp    0x10(%ebp),%eax
  10095f:	76 03                	jbe    100964 <ring_buf_put_claim+0x2a>
  100961:	8b 45 10             	mov    0x10(%ebp),%eax
  100964:	39 c8                	cmp    %ecx,%eax
  100966:	76 02                	jbe    10096a <ring_buf_put_claim+0x30>
  100968:	89 c8                	mov    %ecx,%eax

	*data = &buf->buf.buf8[buf->misc.byte_mode.tmp_tail];
  10096a:	8b 7b 14             	mov    0x14(%ebx),%edi
  10096d:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  100970:	01 d7                	add    %edx,%edi
	buf->misc.byte_mode.tmp_tail =
		wrap(buf->misc.byte_mode.tmp_tail + allocated, buf->size);
  100972:	01 c2                	add    %eax,%edx
	*data = &buf->buf.buf8[buf->misc.byte_mode.tmp_tail];
  100974:	89 39                	mov    %edi,(%ecx)
	return val >= max ? (val - max) : val;
  100976:	39 d6                	cmp    %edx,%esi
  100978:	77 02                	ja     10097c <ring_buf_put_claim+0x42>
  10097a:	29 f2                	sub    %esi,%edx
	buf->misc.byte_mode.tmp_tail =
  10097c:	89 53 08             	mov    %edx,0x8(%ebx)

	return allocated;
}
  10097f:	5b                   	pop    %ebx
  100980:	5e                   	pop    %esi
  100981:	5f                   	pop    %edi
  100982:	5d                   	pop    %ebp
  100983:	c3                   	ret    

00100984 <ring_buf_put_finish>:

int ring_buf_put_finish(struct ring_buf *buf, u32_t size)
{
  100984:	55                   	push   %ebp
  100985:	89 e5                	mov    %esp,%ebp
  100987:	56                   	push   %esi
  100988:	53                   	push   %ebx
  100989:	8b 75 08             	mov    0x8(%ebp),%esi
  10098c:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	if (size > ring_buf_space_get(buf)) {
  10098f:	89 f0                	mov    %esi,%eax
  100991:	e8 8e ff ff ff       	call   100924 <ring_buf_space_get>
  100996:	ba ea ff ff ff       	mov    $0xffffffea,%edx
  10099b:	39 d8                	cmp    %ebx,%eax
  10099d:	72 16                	jb     1009b5 <ring_buf_put_finish+0x31>
		return -EINVAL;
	}

	buf->tail = wrap(buf->tail + size, buf->size);
  10099f:	8b 46 04             	mov    0x4(%esi),%eax
  1009a2:	8b 56 10             	mov    0x10(%esi),%edx
  1009a5:	01 d8                	add    %ebx,%eax
	return val >= max ? (val - max) : val;
  1009a7:	39 c2                	cmp    %eax,%edx
  1009a9:	77 02                	ja     1009ad <ring_buf_put_finish+0x29>
  1009ab:	29 d0                	sub    %edx,%eax
	buf->tail = wrap(buf->tail + size, buf->size);
  1009ad:	89 46 04             	mov    %eax,0x4(%esi)
	buf->misc.byte_mode.tmp_tail = buf->tail;
  1009b0:	89 46 08             	mov    %eax,0x8(%esi)

	return 0;
  1009b3:	31 d2                	xor    %edx,%edx
}
  1009b5:	5b                   	pop    %ebx
  1009b6:	89 d0                	mov    %edx,%eax
  1009b8:	5e                   	pop    %esi
  1009b9:	5d                   	pop    %ebp
  1009ba:	c3                   	ret    

001009bb <ring_buf_put>:

u32_t ring_buf_put(struct ring_buf *buf, const u8_t *data, u32_t size)
{
  1009bb:	55                   	push   %ebp
  1009bc:	89 e5                	mov    %esp,%ebp
  1009be:	57                   	push   %edi
  1009bf:	56                   	push   %esi
  1009c0:	53                   	push   %ebx
	u8_t *dst;
	u32_t partial_size;
	u32_t total_size = 0U;
  1009c1:	31 db                	xor    %ebx,%ebx
{
  1009c3:	51                   	push   %ecx
  1009c4:	8b 7d 0c             	mov    0xc(%ebp),%edi
	int err;

	do {
		partial_size = ring_buf_put_claim(buf, &dst, size);
  1009c7:	ff 75 10             	pushl  0x10(%ebp)
  1009ca:	8d 45 f0             	lea    -0x10(%ebp),%eax
  1009cd:	50                   	push   %eax
  1009ce:	ff 75 08             	pushl  0x8(%ebp)
  1009d1:	e8 64 ff ff ff       	call   10093a <ring_buf_put_claim>
  1009d6:	83 c4 0c             	add    $0xc,%esp
		memcpy(dst, data, partial_size);
  1009d9:	50                   	push   %eax
		partial_size = ring_buf_put_claim(buf, &dst, size);
  1009da:	89 c6                	mov    %eax,%esi
		memcpy(dst, data, partial_size);
  1009dc:	57                   	push   %edi
		total_size += partial_size;
  1009dd:	01 f3                	add    %esi,%ebx
		memcpy(dst, data, partial_size);
  1009df:	ff 75 f0             	pushl  -0x10(%ebp)
		size -= partial_size;
		data += partial_size;
  1009e2:	01 f7                	add    %esi,%edi
		memcpy(dst, data, partial_size);
  1009e4:	e8 29 64 00 00       	call   106e12 <memcpy>
  1009e9:	83 c4 0c             	add    $0xc,%esp
	} while (size && partial_size);
  1009ec:	29 75 10             	sub    %esi,0x10(%ebp)
  1009ef:	74 04                	je     1009f5 <ring_buf_put+0x3a>
  1009f1:	85 f6                	test   %esi,%esi
  1009f3:	75 d2                	jne    1009c7 <ring_buf_put+0xc>

	err = ring_buf_put_finish(buf, total_size);
  1009f5:	53                   	push   %ebx
  1009f6:	ff 75 08             	pushl  0x8(%ebp)
  1009f9:	e8 86 ff ff ff       	call   100984 <ring_buf_put_finish>
  1009fe:	58                   	pop    %eax
	__ASSERT_NO_MSG(err == 0);

	return total_size;
}
  1009ff:	89 d8                	mov    %ebx,%eax
	err = ring_buf_put_finish(buf, total_size);
  100a01:	5a                   	pop    %edx
}
  100a02:	8d 65 f4             	lea    -0xc(%ebp),%esp
  100a05:	5b                   	pop    %ebx
  100a06:	5e                   	pop    %esi
  100a07:	5f                   	pop    %edi
  100a08:	5d                   	pop    %ebp
  100a09:	c3                   	ret    

00100a0a <ring_buf_get_claim>:

u32_t ring_buf_get_claim(struct ring_buf *buf, u8_t **data, u32_t size)
{
  100a0a:	55                   	push   %ebp
  100a0b:	89 e5                	mov    %esp,%ebp
  100a0d:	57                   	push   %edi
  100a0e:	56                   	push   %esi
  100a0f:	53                   	push   %ebx
  100a10:	8b 5d 08             	mov    0x8(%ebp),%ebx
	u32_t space, granted_size, trail_size;

	space = (buf->size - 1) -
		z_ring_buf_custom_space_get(buf->size,
  100a13:	8b 53 0c             	mov    0xc(%ebx),%edx
  100a16:	8b 43 04             	mov    0x4(%ebx),%eax
	space = (buf->size - 1) -
  100a19:	8b 73 10             	mov    0x10(%ebx),%esi
	if (tail < head) {
  100a1c:	39 d0                	cmp    %edx,%eax
		return head - tail - 1;
  100a1e:	8d 4a ff             	lea    -0x1(%edx),%ecx
	if (tail < head) {
  100a21:	72 04                	jb     100a27 <ring_buf_get_claim+0x1d>
	return (size - tail) + head - 1;
  100a23:	8d 4c 16 ff          	lea    -0x1(%esi,%edx,1),%ecx
  100a27:	29 c1                	sub    %eax,%ecx
  100a29:	8d 46 ff             	lea    -0x1(%esi),%eax
  100a2c:	29 c8                	sub    %ecx,%eax

	/* Limit requested size to available size. */
	granted_size = MIN(size, space);

	/* Limit allocated size to trail size. */
	granted_size = MIN(trail_size, granted_size);
  100a2e:	89 f1                	mov    %esi,%ecx
  100a30:	29 d1                	sub    %edx,%ecx
  100a32:	3b 4d 10             	cmp    0x10(%ebp),%ecx
  100a35:	76 03                	jbe    100a3a <ring_buf_get_claim+0x30>
  100a37:	8b 4d 10             	mov    0x10(%ebp),%ecx
  100a3a:	39 c8                	cmp    %ecx,%eax
  100a3c:	76 02                	jbe    100a40 <ring_buf_get_claim+0x36>
  100a3e:	89 c8                	mov    %ecx,%eax

	*data = &buf->buf.buf8[buf->misc.byte_mode.tmp_head];
  100a40:	8b 7b 14             	mov    0x14(%ebx),%edi
  100a43:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  100a46:	01 d7                	add    %edx,%edi
	buf->misc.byte_mode.tmp_head =
		wrap(buf->misc.byte_mode.tmp_head + granted_size, buf->size);
  100a48:	01 c2                	add    %eax,%edx
	*data = &buf->buf.buf8[buf->misc.byte_mode.tmp_head];
  100a4a:	89 39                	mov    %edi,(%ecx)
	return val >= max ? (val - max) : val;
  100a4c:	39 d6                	cmp    %edx,%esi
  100a4e:	77 02                	ja     100a52 <ring_buf_get_claim+0x48>
  100a50:	29 f2                	sub    %esi,%edx
	buf->misc.byte_mode.tmp_head =
  100a52:	89 53 0c             	mov    %edx,0xc(%ebx)

	return granted_size;
}
  100a55:	5b                   	pop    %ebx
  100a56:	5e                   	pop    %esi
  100a57:	5f                   	pop    %edi
  100a58:	5d                   	pop    %ebp
  100a59:	c3                   	ret    

00100a5a <ring_buf_get_finish>:

int ring_buf_get_finish(struct ring_buf *buf, u32_t size)
{
  100a5a:	55                   	push   %ebp
  100a5b:	89 e5                	mov    %esp,%ebp
  100a5d:	57                   	push   %edi
  100a5e:	56                   	push   %esi
  100a5f:	8b 75 08             	mov    0x8(%ebp),%esi
  100a62:	53                   	push   %ebx
	u32_t allocated = (buf->size - 1) - ring_buf_space_get(buf);
  100a63:	89 f0                	mov    %esi,%eax
{
  100a65:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	u32_t allocated = (buf->size - 1) - ring_buf_space_get(buf);
  100a68:	e8 b7 fe ff ff       	call   100924 <ring_buf_space_get>
  100a6d:	8b 7e 10             	mov    0x10(%esi),%edi
  100a70:	8d 57 ff             	lea    -0x1(%edi),%edx
  100a73:	29 c2                	sub    %eax,%edx
  100a75:	b8 ea ff ff ff       	mov    $0xffffffea,%eax

	if (size > allocated) {
  100a7a:	39 da                	cmp    %ebx,%edx
  100a7c:	72 11                	jb     100a8f <ring_buf_get_finish+0x35>
		return -EINVAL;
	}

	buf->head = wrap(buf->head + size, buf->size);
  100a7e:	8b 06                	mov    (%esi),%eax
  100a80:	01 d8                	add    %ebx,%eax
	return val >= max ? (val - max) : val;
  100a82:	39 c7                	cmp    %eax,%edi
  100a84:	77 02                	ja     100a88 <ring_buf_get_finish+0x2e>
  100a86:	29 f8                	sub    %edi,%eax
	buf->head = wrap(buf->head + size, buf->size);
  100a88:	89 06                	mov    %eax,(%esi)
	buf->misc.byte_mode.tmp_head = buf->head;
  100a8a:	89 46 0c             	mov    %eax,0xc(%esi)

	return 0;
  100a8d:	31 c0                	xor    %eax,%eax
}
  100a8f:	5b                   	pop    %ebx
  100a90:	5e                   	pop    %esi
  100a91:	5f                   	pop    %edi
  100a92:	5d                   	pop    %ebp
  100a93:	c3                   	ret    

00100a94 <ring_buf_get>:

u32_t ring_buf_get(struct ring_buf *buf, u8_t *data, u32_t size)
{
  100a94:	55                   	push   %ebp
  100a95:	89 e5                	mov    %esp,%ebp
  100a97:	57                   	push   %edi
  100a98:	56                   	push   %esi
  100a99:	53                   	push   %ebx
	u8_t *src;
	u32_t partial_size;
	u32_t total_size = 0U;
  100a9a:	31 db                	xor    %ebx,%ebx
{
  100a9c:	51                   	push   %ecx
  100a9d:	8b 7d 0c             	mov    0xc(%ebp),%edi
	int err;

	do {
		partial_size = ring_buf_get_claim(buf, &src, size);
  100aa0:	ff 75 10             	pushl  0x10(%ebp)
  100aa3:	8d 45 f0             	lea    -0x10(%ebp),%eax
  100aa6:	50                   	push   %eax
  100aa7:	ff 75 08             	pushl  0x8(%ebp)
  100aaa:	e8 5b ff ff ff       	call   100a0a <ring_buf_get_claim>
  100aaf:	83 c4 0c             	add    $0xc,%esp
		memcpy(data, src, partial_size);
  100ab2:	50                   	push   %eax
		partial_size = ring_buf_get_claim(buf, &src, size);
  100ab3:	89 c6                	mov    %eax,%esi
		memcpy(data, src, partial_size);
  100ab5:	ff 75 f0             	pushl  -0x10(%ebp)
		total_size += partial_size;
  100ab8:	01 f3                	add    %esi,%ebx
		memcpy(data, src, partial_size);
  100aba:	57                   	push   %edi
		size -= partial_size;
		data += partial_size;
  100abb:	01 f7                	add    %esi,%edi
		memcpy(data, src, partial_size);
  100abd:	e8 50 63 00 00       	call   106e12 <memcpy>
  100ac2:	83 c4 0c             	add    $0xc,%esp
	} while (size && partial_size);
  100ac5:	29 75 10             	sub    %esi,0x10(%ebp)
  100ac8:	74 04                	je     100ace <ring_buf_get+0x3a>
  100aca:	85 f6                	test   %esi,%esi
  100acc:	75 d2                	jne    100aa0 <ring_buf_get+0xc>

	err = ring_buf_get_finish(buf, total_size);
  100ace:	53                   	push   %ebx
  100acf:	ff 75 08             	pushl  0x8(%ebp)
  100ad2:	e8 83 ff ff ff       	call   100a5a <ring_buf_get_finish>
  100ad7:	58                   	pop    %eax
	__ASSERT_NO_MSG(err == 0);

	return total_size;
}
  100ad8:	89 d8                	mov    %ebx,%eax
	err = ring_buf_get_finish(buf, total_size);
  100ada:	5a                   	pop    %edx
}
  100adb:	8d 65 f4             	lea    -0xc(%ebp),%esp
  100ade:	5b                   	pop    %ebx
  100adf:	5e                   	pop    %esi
  100ae0:	5f                   	pop    %edi
  100ae1:	5d                   	pop    %ebp
  100ae2:	c3                   	ret    

00100ae3 <_ConfigAbsSyms>:
GEN_ABSOLUTE_SYM(CONFIG_OUTPUT_DISASSEMBLY, 1);
GEN_ABSOLUTE_SYM(CONFIG_OUTPUT_PRINT_MEMORY_USAGE, 1);
GEN_ABSOLUTE_SYM(CONFIG_BUILD_OUTPUT_BIN, 1);
GEN_ABSOLUTE_SYM(CONFIG_BOOTLOADER_UNKNOWN, 1);

GEN_ABS_SYM_END
  100ae3:	c3                   	ret    

00100ae4 <pci_legacy_bridge_irq_config>:
 * - GPIO;
 * - UART0, UART1;
 * - SDIO/eMMC, USB, Ethernet.
 */
static int pci_legacy_bridge_irq_config(struct device *unused)
{
  100ae4:	55                   	push   %ebp
	ARG_UNUSED(unused);
	struct pci_dev_info info = {
  100ae5:	31 c0                	xor    %eax,%eax
{
  100ae7:	89 e5                	mov    %esp,%ebp
  100ae9:	57                   	push   %edi
  100aea:	53                   	push   %ebx
	struct pci_dev_info info = {
  100aeb:	b9 05 00 00 00       	mov    $0x5,%ecx
{
  100af0:	83 ec 14             	sub    $0x14,%esp
	struct pci_dev_info info = {
  100af3:	8d 7d e4             	lea    -0x1c(%ebp),%edi
		.function = PCI_FUNCTION_ANY,
		.bar = PCI_BAR_ANY,
	};
	if (pci_legacy_bridge_detect(&info) == 0) {
  100af6:	8d 5d e4             	lea    -0x1c(%ebp),%ebx
	struct pci_dev_info info = {
  100af9:	f3 ab                	rep stos %eax,%es:(%edi)
	if (pci_legacy_bridge_detect(&info) == 0) {
  100afb:	53                   	push   %ebx
	struct pci_dev_info info = {
  100afc:	c7 45 f0 00 00 01 18 	movl   $0x18010000,-0x10(%ebp)
	if (pci_legacy_bridge_detect(&info) == 0) {
  100b03:	e8 a6 59 00 00       	call   1064ae <pci_legacy_bridge_detect>
  100b08:	5a                   	pop    %edx
  100b09:	85 c0                	test   %eax,%eax
  100b0b:	75 78                	jne    100b85 <pci_legacy_bridge_irq_config+0xa1>
		pci_legacy_bridge_configure(&info, 1, PCI_INTA, 16);
  100b0d:	6a 10                	push   $0x10
  100b0f:	6a 01                	push   $0x1
  100b11:	6a 01                	push   $0x1
  100b13:	53                   	push   %ebx
  100b14:	e8 b4 5a 00 00       	call   1065cd <pci_legacy_bridge_configure>
  100b19:	83 c4 10             	add    $0x10,%esp
		pci_legacy_bridge_configure(&info, 1, PCI_INTB, 17);
  100b1c:	6a 11                	push   $0x11
  100b1e:	6a 02                	push   $0x2
  100b20:	6a 01                	push   $0x1
  100b22:	53                   	push   %ebx
  100b23:	e8 a5 5a 00 00       	call   1065cd <pci_legacy_bridge_configure>
  100b28:	83 c4 10             	add    $0x10,%esp
		pci_legacy_bridge_configure(&info, 1, PCI_INTC, 18);
  100b2b:	6a 12                	push   $0x12
  100b2d:	6a 03                	push   $0x3
  100b2f:	6a 01                	push   $0x1
  100b31:	53                   	push   %ebx
  100b32:	e8 96 5a 00 00       	call   1065cd <pci_legacy_bridge_configure>
  100b37:	83 c4 10             	add    $0x10,%esp
		pci_legacy_bridge_configure(&info, 1, PCI_INTD, 19);
  100b3a:	6a 13                	push   $0x13
  100b3c:	6a 04                	push   $0x4
  100b3e:	6a 01                	push   $0x1
  100b40:	53                   	push   %ebx
  100b41:	e8 87 5a 00 00       	call   1065cd <pci_legacy_bridge_configure>
  100b46:	83 c4 10             	add    $0x10,%esp
		pci_legacy_bridge_configure(&info, 0, PCI_INTA, 17);
  100b49:	6a 11                	push   $0x11
  100b4b:	6a 01                	push   $0x1
  100b4d:	6a 00                	push   $0x0
  100b4f:	53                   	push   %ebx
  100b50:	e8 78 5a 00 00       	call   1065cd <pci_legacy_bridge_configure>
  100b55:	83 c4 10             	add    $0x10,%esp
		pci_legacy_bridge_configure(&info, 0, PCI_INTB, 18);
  100b58:	6a 12                	push   $0x12
  100b5a:	6a 02                	push   $0x2
  100b5c:	6a 00                	push   $0x0
  100b5e:	53                   	push   %ebx
  100b5f:	e8 69 5a 00 00       	call   1065cd <pci_legacy_bridge_configure>
  100b64:	83 c4 10             	add    $0x10,%esp
		pci_legacy_bridge_configure(&info, 0, PCI_INTC, 19);
  100b67:	6a 13                	push   $0x13
  100b69:	6a 03                	push   $0x3
  100b6b:	6a 00                	push   $0x0
  100b6d:	53                   	push   %ebx
  100b6e:	e8 5a 5a 00 00       	call   1065cd <pci_legacy_bridge_configure>
  100b73:	83 c4 10             	add    $0x10,%esp
		pci_legacy_bridge_configure(&info, 0, PCI_INTD, 16);
  100b76:	6a 10                	push   $0x10
  100b78:	6a 04                	push   $0x4
  100b7a:	6a 00                	push   $0x0
  100b7c:	53                   	push   %ebx
  100b7d:	e8 4b 5a 00 00       	call   1065cd <pci_legacy_bridge_configure>
  100b82:	83 c4 10             	add    $0x10,%esp
	}
	return 0;
}
  100b85:	8d 65 f8             	lea    -0x8(%ebp),%esp
  100b88:	31 c0                	xor    %eax,%eax
  100b8a:	5b                   	pop    %ebx
  100b8b:	5f                   	pop    %edi
  100b8c:	5d                   	pop    %ebp
  100b8d:	c3                   	ret    

00100b8e <foldcase>:
#define EOS    '\0'

static inline int foldcase(int ch, int flags)
{

    if ((flags & FNM_CASEFOLD) != 0 && isupper(ch))
  100b8e:	80 e2 08             	and    $0x8,%dl
  100b91:	74 0b                	je     100b9e <foldcase+0x10>
extern "C" {
#endif

static inline int isupper(int a)
{
	return (int)(((unsigned)(a)-(unsigned)'A') < 26U);
  100b93:	8d 50 bf             	lea    -0x41(%eax),%edx
  100b96:	83 fa 19             	cmp    $0x19,%edx
  100b99:	77 03                	ja     100b9e <foldcase+0x10>
			((ua | 32U) - (unsigned)'a' < 6U));
}

static inline int tolower(int chr)
{
	return (chr >= (int)'A' && chr <= (int)'Z') ? (chr + 32) : (chr);
  100b9b:	83 c0 20             	add    $0x20,%eax
        return tolower(ch);
    return ch;
}
  100b9e:	c3                   	ret    

00100b9f <fnmatchx>:
    return ok == negate ? NULL : pattern;
}


static int fnmatchx(const char *pattern, const char *string, int flags, size_t recursion)
{
  100b9f:	55                   	push   %ebp
  100ba0:	89 e5                	mov    %esp,%ebp
  100ba2:	57                   	push   %edi
  100ba3:	56                   	push   %esi
  100ba4:	53                   	push   %ebx
  100ba5:	83 ec 20             	sub    $0x20,%esp
  100ba8:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    const char *stringstart, *r;
    char c, test;

    if ((pattern == NULL) || (string == NULL))
  100bab:	85 c0                	test   %eax,%eax
  100bad:	74 04                	je     100bb3 <fnmatchx+0x14>
  100baf:	85 d2                	test   %edx,%edx
  100bb1:	75 0a                	jne    100bbd <fnmatchx+0x1e>
    {
        return FNM_NOMATCH;
  100bb3:	b8 01 00 00 00       	mov    $0x1,%eax
  100bb8:	e9 33 03 00 00       	jmp    100ef0 <fnmatchx+0x351>
  100bbd:	89 c3                	mov    %eax,%ebx
    }

    if (recursion-- == 0)
        return FNM_NORES;
  100bbf:	b8 03 00 00 00       	mov    $0x3,%eax
    if (recursion-- == 0)
  100bc4:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  100bc8:	0f 84 22 03 00 00    	je     100ef0 <fnmatchx+0x351>
  100bce:	89 cf                	mov    %ecx,%edi
  100bd0:	8b 75 e4             	mov    -0x1c(%ebp),%esi

    for (stringstart = string;;) {
        switch (c = FOLDCASE(*pattern++, flags)) {
  100bd3:	8d 43 01             	lea    0x1(%ebx),%eax
  100bd6:	89 fa                	mov    %edi,%edx
  100bd8:	89 45 ec             	mov    %eax,-0x14(%ebp)
  100bdb:	0f b6 03             	movzbl (%ebx),%eax
  100bde:	e8 ab ff ff ff       	call   100b8e <foldcase>
  100be3:	8a 16                	mov    (%esi),%dl
  100be5:	0f be c8             	movsbl %al,%ecx
  100be8:	88 55 f3             	mov    %dl,-0xd(%ebp)
  100beb:	3c 3f                	cmp    $0x3f,%al
  100bed:	74 43                	je     100c32 <fnmatchx+0x93>
  100bef:	7f 12                	jg     100c03 <fnmatchx+0x64>
  100bf1:	84 c0                	test   %al,%al
  100bf3:	74 23                	je     100c18 <fnmatchx+0x79>
  100bf5:	3c 2a                	cmp    $0x2a,%al
  100bf7:	0f 85 da 02 00 00    	jne    100ed7 <fnmatchx+0x338>
                ((flags & FNM_PATHNAME) && *(string - 1) == '/')))
                return FNM_NOMATCH;
            ++string;
            break;
        case '*':
            c = FOLDCASE(*pattern, flags);
  100bfd:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
  100c01:	eb 7e                	jmp    100c81 <fnmatchx+0xe2>
        switch (c = FOLDCASE(*pattern++, flags)) {
  100c03:	3c 5b                	cmp    $0x5b,%al
  100c05:	0f 84 51 01 00 00    	je     100d5c <fnmatchx+0x1bd>
  100c0b:	3c 5c                	cmp    $0x5c,%al
  100c0d:	0f 84 a4 02 00 00    	je     100eb7 <fnmatchx+0x318>
  100c13:	e9 bf 02 00 00       	jmp    100ed7 <fnmatchx+0x338>
            if ((flags & FNM_LEADING_DIR) && *string == '/')
  100c18:	83 e7 10             	and    $0x10,%edi
  100c1b:	74 0c                	je     100c29 <fnmatchx+0x8a>
                return 0;
  100c1d:	31 c0                	xor    %eax,%eax
            if ((flags & FNM_LEADING_DIR) && *string == '/')
  100c1f:	80 7d f3 2f          	cmpb   $0x2f,-0xd(%ebp)
  100c23:	0f 84 c7 02 00 00    	je     100ef0 <fnmatchx+0x351>
            return *string == EOS ? 0 : FNM_NOMATCH;
  100c29:	80 7d f3 00          	cmpb   $0x0,-0xd(%ebp)
  100c2d:	e9 b4 00 00 00       	jmp    100ce6 <fnmatchx+0x147>
            if (*string == EOS)
  100c32:	80 7d f3 00          	cmpb   $0x0,-0xd(%ebp)
  100c36:	0f 84 77 ff ff ff    	je     100bb3 <fnmatchx+0x14>
            if (*string == '/' && (flags & FNM_PATHNAME))
  100c3c:	80 7d f3 2f          	cmpb   $0x2f,-0xd(%ebp)
  100c40:	75 0d                	jne    100c4f <fnmatchx+0xb0>
  100c42:	f7 c7 02 00 00 00    	test   $0x2,%edi
  100c48:	74 2e                	je     100c78 <fnmatchx+0xd9>
  100c4a:	e9 64 ff ff ff       	jmp    100bb3 <fnmatchx+0x14>
            if (*string == '.' && (flags & FNM_PERIOD) &&
  100c4f:	80 7d f3 2e          	cmpb   $0x2e,-0xd(%ebp)
  100c53:	75 23                	jne    100c78 <fnmatchx+0xd9>
  100c55:	f7 c7 04 00 00 00    	test   $0x4,%edi
  100c5b:	74 1b                	je     100c78 <fnmatchx+0xd9>
  100c5d:	3b 75 e4             	cmp    -0x1c(%ebp),%esi
  100c60:	0f 84 4d ff ff ff    	je     100bb3 <fnmatchx+0x14>
                (string == stringstart ||
  100c66:	f7 c7 02 00 00 00    	test   $0x2,%edi
  100c6c:	74 0a                	je     100c78 <fnmatchx+0xd9>
                ((flags & FNM_PATHNAME) && *(string - 1) == '/')))
  100c6e:	80 7e ff 2f          	cmpb   $0x2f,-0x1(%esi)
  100c72:	0f 84 3b ff ff ff    	je     100bb3 <fnmatchx+0x14>
            ++string;
  100c78:	46                   	inc    %esi
                if (*string != '[')
                    return FNM_NOMATCH;
            } else
                pattern = r;
            ++string;
            break;
  100c79:	8b 5d ec             	mov    -0x14(%ebp),%ebx
  100c7c:	e9 52 ff ff ff       	jmp    100bd3 <fnmatchx+0x34>
                c = FOLDCASE(*++pattern, flags);
  100c81:	89 fa                	mov    %edi,%edx
  100c83:	e8 06 ff ff ff       	call   100b8e <foldcase>
            while (c == '*')
  100c88:	3c 2a                	cmp    $0x2a,%al
  100c8a:	75 0b                	jne    100c97 <fnmatchx+0xf8>
                c = FOLDCASE(*++pattern, flags);
  100c8c:	ff 45 ec             	incl   -0x14(%ebp)
  100c8f:	8b 45 ec             	mov    -0x14(%ebp),%eax
  100c92:	0f b6 00             	movzbl (%eax),%eax
  100c95:	eb ea                	jmp    100c81 <fnmatchx+0xe2>
            if (*string == '.' && (flags & FNM_PERIOD) &&
  100c97:	80 7d f3 2e          	cmpb   $0x2e,-0xd(%ebp)
  100c9b:	75 23                	jne    100cc0 <fnmatchx+0x121>
  100c9d:	f7 c7 04 00 00 00    	test   $0x4,%edi
  100ca3:	74 1b                	je     100cc0 <fnmatchx+0x121>
  100ca5:	3b 75 e4             	cmp    -0x1c(%ebp),%esi
  100ca8:	0f 84 05 ff ff ff    	je     100bb3 <fnmatchx+0x14>
                (string == stringstart ||
  100cae:	f7 c7 02 00 00 00    	test   $0x2,%edi
  100cb4:	74 0a                	je     100cc0 <fnmatchx+0x121>
                ((flags & FNM_PATHNAME) && *(string - 1) == '/')))
  100cb6:	80 7e ff 2f          	cmpb   $0x2f,-0x1(%esi)
  100cba:	0f 84 f3 fe ff ff    	je     100bb3 <fnmatchx+0x14>
            if (c == EOS) {
  100cc0:	84 c0                	test   %al,%al
  100cc2:	75 2d                	jne    100cf1 <fnmatchx+0x152>
                if (flags & FNM_PATHNAME)
  100cc4:	89 f8                	mov    %edi,%eax
  100cc6:	83 e0 02             	and    $0x2,%eax
  100cc9:	0f 84 21 02 00 00    	je     100ef0 <fnmatchx+0x351>
                return 0;
  100ccf:	31 c0                	xor    %eax,%eax
                        0 : FNM_NOMATCH;
  100cd1:	83 e7 10             	and    $0x10,%edi
  100cd4:	0f 85 16 02 00 00    	jne    100ef0 <fnmatchx+0x351>
                        strchr(string, '/') == NULL ?
  100cda:	6a 2f                	push   $0x2f
  100cdc:	56                   	push   %esi
  100cdd:	e8 72 60 00 00       	call   106d54 <strchr>
  100ce2:	5e                   	pop    %esi
                        0 : FNM_NOMATCH;
  100ce3:	85 c0                	test   %eax,%eax
                        strchr(string, '/') == NULL ?
  100ce5:	5f                   	pop    %edi
                        0 : FNM_NOMATCH;
  100ce6:	0f 95 c0             	setne  %al
  100ce9:	0f b6 c0             	movzbl %al,%eax
  100cec:	e9 ff 01 00 00       	jmp    100ef0 <fnmatchx+0x351>
            } else if (c == '/' && flags & FNM_PATHNAME) {
  100cf1:	3c 2f                	cmp    $0x2f,%al
  100cf3:	75 45                	jne    100d3a <fnmatchx+0x19b>
  100cf5:	f7 c7 02 00 00 00    	test   $0x2,%edi
  100cfb:	74 3d                	je     100d3a <fnmatchx+0x19b>
                if ((string = strchr(string, '/')) == NULL)
  100cfd:	6a 2f                	push   $0x2f
  100cff:	56                   	push   %esi
  100d00:	e8 4f 60 00 00       	call   106d54 <strchr>
  100d05:	59                   	pop    %ecx
  100d06:	89 c6                	mov    %eax,%esi
  100d08:	5b                   	pop    %ebx
  100d09:	85 c0                	test   %eax,%eax
  100d0b:	0f 85 68 ff ff ff    	jne    100c79 <fnmatchx+0xda>
  100d11:	e9 9d fe ff ff       	jmp    100bb3 <fnmatchx+0x14>
    if (recursion-- == 0)
  100d16:	8b 45 08             	mov    0x8(%ebp),%eax
                switch ((e = fnmatchx(pattern, string,
  100d19:	89 f9                	mov    %edi,%ecx
    if (recursion-- == 0)
  100d1b:	48                   	dec    %eax
                switch ((e = fnmatchx(pattern, string,
  100d1c:	83 e1 fb             	and    $0xfffffffb,%ecx
  100d1f:	50                   	push   %eax
  100d20:	89 f2                	mov    %esi,%edx
  100d22:	8b 45 ec             	mov    -0x14(%ebp),%eax
  100d25:	e8 75 fe ff ff       	call   100b9f <fnmatchx>
  100d2a:	5a                   	pop    %edx
  100d2b:	83 f8 01             	cmp    $0x1,%eax
  100d2e:	0f 85 bc 01 00 00    	jne    100ef0 <fnmatchx+0x351>
                if (test == '/' && flags & FNM_PATHNAME)
  100d34:	80 fb 2f             	cmp    $0x2f,%bl
  100d37:	74 16                	je     100d4f <fnmatchx+0x1b0>
                ++string;
  100d39:	46                   	inc    %esi
            while ((test = FOLDCASE(*string, flags)) != EOS) {
  100d3a:	0f b6 06             	movzbl (%esi),%eax
  100d3d:	89 fa                	mov    %edi,%edx
  100d3f:	e8 4a fe ff ff       	call   100b8e <foldcase>
  100d44:	89 c3                	mov    %eax,%ebx
  100d46:	84 c0                	test   %al,%al
  100d48:	75 cc                	jne    100d16 <fnmatchx+0x177>
  100d4a:	e9 64 fe ff ff       	jmp    100bb3 <fnmatchx+0x14>
                if (test == '/' && flags & FNM_PATHNAME)
  100d4f:	f7 c7 02 00 00 00    	test   $0x2,%edi
  100d55:	74 e2                	je     100d39 <fnmatchx+0x19a>
  100d57:	e9 57 fe ff ff       	jmp    100bb3 <fnmatchx+0x14>
            if (*string == EOS)
  100d5c:	80 7d f3 00          	cmpb   $0x0,-0xd(%ebp)
  100d60:	0f 84 4d fe ff ff    	je     100bb3 <fnmatchx+0x14>
            if (*string == '/' && flags & FNM_PATHNAME)
  100d66:	80 7d f3 2f          	cmpb   $0x2f,-0xd(%ebp)
  100d6a:	75 0c                	jne    100d78 <fnmatchx+0x1d9>
  100d6c:	f7 c7 02 00 00 00    	test   $0x2,%edi
  100d72:	0f 85 3b fe ff ff    	jne    100bb3 <fnmatchx+0x14>
            if ((r = rangematch(pattern,
  100d78:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
  100d7c:	89 fa                	mov    %edi,%edx
  100d7e:	e8 0b fe ff ff       	call   100b8e <foldcase>
    if (pattern == NULL)
  100d83:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
            if ((r = rangematch(pattern,
  100d87:	89 45 e0             	mov    %eax,-0x20(%ebp)
    if (pattern == NULL)
  100d8a:	0f 84 23 fe ff ff    	je     100bb3 <fnmatchx+0x14>
    if ((negate = (*pattern == '!' || *pattern == '^')) != 0)
  100d90:	8a 43 01             	mov    0x1(%ebx),%al
  100d93:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  100d96:	3c 21                	cmp    $0x21,%al
  100d98:	89 4d e8             	mov    %ecx,-0x18(%ebp)
  100d9b:	0f 94 c2             	sete   %dl
  100d9e:	3c 5e                	cmp    $0x5e,%al
  100da0:	0f 94 c0             	sete   %al
  100da3:	08 c2                	or     %al,%dl
  100da5:	88 55 f2             	mov    %dl,-0xe(%ebp)
  100da8:	74 06                	je     100db0 <fnmatchx+0x211>
        ++pattern;
  100daa:	8d 43 02             	lea    0x2(%ebx),%eax
  100dad:	89 45 e8             	mov    %eax,-0x18(%ebp)
        if (c == '\\' && !(flags & FNM_NOESCAPE))
  100db0:	89 f8                	mov    %edi,%eax
            ok = 1;
  100db2:	c7 45 d8 01 00 00 00 	movl   $0x1,-0x28(%ebp)
        if (c == '\\' && !(flags & FNM_NOESCAPE))
  100db9:	83 e0 01             	and    $0x1,%eax
            ok = 1;
  100dbc:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
        if (c == '\\' && !(flags & FNM_NOESCAPE))
  100dc3:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    for (ok = 0; (c = FOLDCASE(*pattern++, flags)) != ']' || need;) {
  100dc6:	8b 45 e8             	mov    -0x18(%ebp),%eax
  100dc9:	89 fa                	mov    %edi,%edx
  100dcb:	8d 48 01             	lea    0x1(%eax),%ecx
  100dce:	0f b6 00             	movzbl (%eax),%eax
  100dd1:	e8 b8 fd ff ff       	call   100b8e <foldcase>
  100dd6:	0f be d8             	movsbl %al,%ebx
  100dd9:	3c 5d                	cmp    $0x5d,%al
  100ddb:	0f 84 a0 00 00 00    	je     100e81 <fnmatchx+0x2e2>
        if (c == '/')
  100de1:	3c 2f                	cmp    $0x2f,%al
  100de3:	0f 84 b8 00 00 00    	je     100ea1 <fnmatchx+0x302>
        if (c == '\\' && !(flags & FNM_NOESCAPE))
  100de9:	3c 5c                	cmp    $0x5c,%al
  100deb:	75 1a                	jne    100e07 <fnmatchx+0x268>
  100ded:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
  100df1:	75 1c                	jne    100e0f <fnmatchx+0x270>
            c = FOLDCASE(*pattern++, flags);
  100df3:	8b 45 e8             	mov    -0x18(%ebp),%eax
  100df6:	89 fa                	mov    %edi,%edx
  100df8:	8d 48 02             	lea    0x2(%eax),%ecx
  100dfb:	0f b6 40 01          	movzbl 0x1(%eax),%eax
  100dff:	e8 8a fd ff ff       	call   100b8e <foldcase>
  100e04:	0f be d8             	movsbl %al,%ebx
        if (c == EOS)
  100e07:	84 db                	test   %bl,%bl
  100e09:	0f 84 a4 fd ff ff    	je     100bb3 <fnmatchx+0x14>
        if (*pattern == '-' 
  100e0f:	80 39 2d             	cmpb   $0x2d,(%ecx)
  100e12:	75 52                	jne    100e66 <fnmatchx+0x2c7>
            && (c2 = FOLDCASE(*(pattern + 1), flags)) != EOS &&
  100e14:	0f b6 41 01          	movzbl 0x1(%ecx),%eax
  100e18:	89 fa                	mov    %edi,%edx
  100e1a:	e8 6f fd ff ff       	call   100b8e <foldcase>
  100e1f:	88 45 d8             	mov    %al,-0x28(%ebp)
  100e22:	3c 5d                	cmp    $0x5d,%al
  100e24:	74 40                	je     100e66 <fnmatchx+0x2c7>
  100e26:	84 c0                	test   %al,%al
  100e28:	74 3c                	je     100e66 <fnmatchx+0x2c7>
            pattern += 2;
  100e2a:	8d 51 02             	lea    0x2(%ecx),%edx
            if (c2 == '\\' && !(flags & FNM_NOESCAPE))
  100e2d:	3c 5c                	cmp    $0x5c,%al
            pattern += 2;
  100e2f:	89 55 e8             	mov    %edx,-0x18(%ebp)
            if (c2 == '\\' && !(flags & FNM_NOESCAPE))
  100e32:	75 22                	jne    100e56 <fnmatchx+0x2b7>
  100e34:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
  100e38:	75 1c                	jne    100e56 <fnmatchx+0x2b7>
                c2 = FOLDCASE(*pattern++, flags);
  100e3a:	8d 41 03             	lea    0x3(%ecx),%eax
  100e3d:	89 fa                	mov    %edi,%edx
  100e3f:	89 45 e8             	mov    %eax,-0x18(%ebp)
  100e42:	0f b6 41 02          	movzbl 0x2(%ecx),%eax
  100e46:	e8 43 fd ff ff       	call   100b8e <foldcase>
  100e4b:	88 45 d8             	mov    %al,-0x28(%ebp)
            if (c2 == EOS)
  100e4e:	84 c0                	test   %al,%al
  100e50:	0f 84 5d fd ff ff    	je     100bb3 <fnmatchx+0x14>
            if (c <= test && test <= c2)
  100e56:	39 5d e0             	cmp    %ebx,-0x20(%ebp)
  100e59:	7c 1a                	jl     100e75 <fnmatchx+0x2d6>
  100e5b:	0f be 55 d8          	movsbl -0x28(%ebp),%edx
  100e5f:	39 55 e0             	cmp    %edx,-0x20(%ebp)
  100e62:	7f 11                	jg     100e75 <fnmatchx+0x2d6>
  100e64:	eb 08                	jmp    100e6e <fnmatchx+0x2cf>
        } else if (c == test)
  100e66:	89 4d e8             	mov    %ecx,-0x18(%ebp)
  100e69:	39 5d e0             	cmp    %ebx,-0x20(%ebp)
  100e6c:	75 07                	jne    100e75 <fnmatchx+0x2d6>
            ok = 1;
  100e6e:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
  100e75:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
  100e7c:	e9 45 ff ff ff       	jmp    100dc6 <fnmatchx+0x227>
    for (ok = 0; (c = FOLDCASE(*pattern++, flags)) != ']' || need;) {
  100e81:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
  100e85:	75 88                	jne    100e0f <fnmatchx+0x270>
    if ((negate = (*pattern == '!' || *pattern == '^')) != 0)
  100e87:	0f b6 45 f2          	movzbl -0xe(%ebp),%eax
            if ((r = rangematch(pattern,
  100e8b:	3b 45 dc             	cmp    -0x24(%ebp),%eax
  100e8e:	0f 84 1f fd ff ff    	je     100bb3 <fnmatchx+0x14>
  100e94:	85 c9                	test   %ecx,%ecx
  100e96:	0f 84 17 fd ff ff    	je     100bb3 <fnmatchx+0x14>
            if (r == (void *)-1) {
  100e9c:	83 f9 ff             	cmp    $0xffffffff,%ecx
  100e9f:	75 0d                	jne    100eae <fnmatchx+0x30f>
                if (*string != '[')
  100ea1:	80 7d f3 5b          	cmpb   $0x5b,-0xd(%ebp)
  100ea5:	0f 85 08 fd ff ff    	jne    100bb3 <fnmatchx+0x14>
  100eab:	8b 4d ec             	mov    -0x14(%ebp),%ecx
            ++string;
  100eae:	46                   	inc    %esi
            break;
  100eaf:	89 4d ec             	mov    %ecx,-0x14(%ebp)
  100eb2:	e9 c2 fd ff ff       	jmp    100c79 <fnmatchx+0xda>
        case '\\':
            if (!(flags & FNM_NOESCAPE)) {
  100eb7:	f7 c7 01 00 00 00    	test   $0x1,%edi
  100ebd:	75 18                	jne    100ed7 <fnmatchx+0x338>
                if ((c = FOLDCASE(*pattern++, flags)) == EOS) {
  100ebf:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
  100ec3:	89 fa                	mov    %edi,%edx
  100ec5:	e8 c4 fc ff ff       	call   100b8e <foldcase>
  100eca:	0f be c8             	movsbl %al,%ecx
  100ecd:	84 c0                	test   %al,%al
  100ecf:	74 06                	je     100ed7 <fnmatchx+0x338>
  100ed1:	8d 43 02             	lea    0x2(%ebx),%eax
  100ed4:	89 45 ec             	mov    %eax,-0x14(%ebp)
                    --pattern;
                }
            }
            /* FALLTHROUGH */
        default:
            if (c != FOLDCASE(*string++, flags))
  100ed7:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
  100edb:	89 fa                	mov    %edi,%edx
  100edd:	46                   	inc    %esi
  100ede:	e8 ab fc ff ff       	call   100b8e <foldcase>
  100ee3:	39 c1                	cmp    %eax,%ecx
  100ee5:	0f 84 8e fd ff ff    	je     100c79 <fnmatchx+0xda>
  100eeb:	e9 c3 fc ff ff       	jmp    100bb3 <fnmatchx+0x14>
                return FNM_NOMATCH;
            break;
        }
    }
    /* NOTREACHED */
}
  100ef0:	8d 65 f4             	lea    -0xc(%ebp),%esp
  100ef3:	5b                   	pop    %ebx
  100ef4:	5e                   	pop    %esi
  100ef5:	5f                   	pop    %edi
  100ef6:	5d                   	pop    %ebp
  100ef7:	c3                   	ret    

00100ef8 <fnmatch>:

int fnmatch(const char *pattern, const char *string, int flags)
{
  100ef8:	55                   	push   %ebp
  100ef9:	89 e5                	mov    %esp,%ebp
  100efb:	8b 45 08             	mov    0x8(%ebp),%eax
    return fnmatchx(pattern, string, flags, 64);
  100efe:	8b 4d 10             	mov    0x10(%ebp),%ecx
  100f01:	8b 55 0c             	mov    0xc(%ebp),%edx
  100f04:	c7 45 08 40 00 00 00 	movl   $0x40,0x8(%ebp)
}
  100f0b:	5d                   	pop    %ebp
    return fnmatchx(pattern, string, flags, 64);
  100f0c:	e9 8e fc ff ff       	jmp    100b9f <fnmatchx>

00100f11 <log_list_init>:
 */

#include "log_list.h"

void log_list_init(struct log_list_t *list)
{
  100f11:	55                   	push   %ebp
  100f12:	89 e5                	mov    %esp,%ebp
  100f14:	8b 45 08             	mov    0x8(%ebp),%eax
	list->tail = NULL;
  100f17:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
	list->head = NULL;
  100f1e:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
}
  100f24:	5d                   	pop    %ebp
  100f25:	c3                   	ret    

00100f26 <log_list_add_tail>:

void log_list_add_tail(struct log_list_t *list, struct log_msg *msg)
{
  100f26:	55                   	push   %ebp
  100f27:	89 e5                	mov    %esp,%ebp
  100f29:	8b 55 08             	mov    0x8(%ebp),%edx
  100f2c:	8b 45 0c             	mov    0xc(%ebp),%eax
	if (list->head == NULL) {
  100f2f:	83 3a 00             	cmpl   $0x0,(%edx)
  100f32:	75 04                	jne    100f38 <log_list_add_tail+0x12>
		list->head = msg;
  100f34:	89 02                	mov    %eax,(%edx)
  100f36:	eb 05                	jmp    100f3d <log_list_add_tail+0x17>
	} else {
		list->tail->next = msg;
  100f38:	8b 4a 04             	mov    0x4(%edx),%ecx
  100f3b:	89 01                	mov    %eax,(%ecx)
	}

	list->tail = msg;
  100f3d:	89 42 04             	mov    %eax,0x4(%edx)
	msg->next = NULL;
  100f40:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
}
  100f46:	5d                   	pop    %ebp
  100f47:	c3                   	ret    

00100f48 <log_list_head_peek>:

struct log_msg *log_list_head_peek(struct log_list_t *list)
{
  100f48:	55                   	push   %ebp
  100f49:	89 e5                	mov    %esp,%ebp
	return list->head;
  100f4b:	8b 45 08             	mov    0x8(%ebp),%eax
}
  100f4e:	5d                   	pop    %ebp
	return list->head;
  100f4f:	8b 00                	mov    (%eax),%eax
}
  100f51:	c3                   	ret    

00100f52 <log_list_head_get>:

struct log_msg *log_list_head_get(struct log_list_t *list)
{
  100f52:	55                   	push   %ebp
  100f53:	89 e5                	mov    %esp,%ebp
  100f55:	8b 55 08             	mov    0x8(%ebp),%edx
	struct log_msg *msg = list->head;
  100f58:	8b 02                	mov    (%edx),%eax

	if (list->head != NULL) {
  100f5a:	85 c0                	test   %eax,%eax
  100f5c:	74 04                	je     100f62 <log_list_head_get+0x10>
		list->head = list->head->next;
  100f5e:	8b 08                	mov    (%eax),%ecx
  100f60:	89 0a                	mov    %ecx,(%edx)
	}

	return msg;
}
  100f62:	5d                   	pop    %ebp
  100f63:	c3                   	ret    

00100f64 <dummy_timestamp>:
static timestamp_get_t timestamp_func = dummy_timestamp;

static u32_t dummy_timestamp(void)
{
	return 0;
}
  100f64:	31 c0                	xor    %eax,%eax
  100f66:	c3                   	ret    

00100f67 <z_log_msg_std_alloc>:
/** @brief Allocate chunk for standard log message.
 *
 *  @return Allocated chunk of NULL.
 */
static inline struct log_msg *z_log_msg_std_alloc(void)
{
  100f67:	55                   	push   %ebp
  100f68:	89 e5                	mov    %esp,%ebp
  100f6a:	50                   	push   %eax
	int err = k_mem_slab_alloc(&log_msg_pool, (void **)&msg, K_NO_WAIT);
  100f6b:	6a 00                	push   $0x0
  100f6d:	8d 45 fc             	lea    -0x4(%ebp),%eax
	union log_msg_chunk *msg = NULL;
  100f70:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	int err = k_mem_slab_alloc(&log_msg_pool, (void **)&msg, K_NO_WAIT);
  100f77:	50                   	push   %eax
  100f78:	68 90 0a 11 00       	push   $0x110a90
  100f7d:	e8 9c 8f 00 00       	call   109f1e <k_mem_slab_alloc>
  100f82:	83 c4 0c             	add    $0xc,%esp
	if (err != 0) {
  100f85:	85 c0                	test   %eax,%eax
  100f87:	74 08                	je     100f91 <z_log_msg_std_alloc+0x2a>
		msg = log_msg_no_space_handle();
  100f89:	e8 3c 07 00 00       	call   1016ca <log_msg_no_space_handle>
  100f8e:	89 45 fc             	mov    %eax,-0x4(%ebp)
	return msg;
  100f91:	8b 45 fc             	mov    -0x4(%ebp),%eax
	struct  log_msg *msg = (struct  log_msg *)log_msg_chunk_alloc();

	if (msg != NULL) {
  100f94:	85 c0                	test   %eax,%eax
  100f96:	74 0d                	je     100fa5 <z_log_msg_std_alloc+0x3e>
		/* all fields reset to 0, reference counter to 1 */
		msg->hdr.ref_cnt = 1;
  100f98:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
		msg->hdr.params.raw = 0U;
  100f9f:	66 c7 40 08 00 00    	movw   $0x0,0x8(%eax)
		msg->hdr.params.std.type = LOG_MSG_TYPE_STD;
	}

	return msg;
}
  100fa5:	c9                   	leave  
  100fa6:	c3                   	ret    

00100fa7 <timestamp_get>:
		}
	}
}

static u32_t timestamp_get(void)
{
  100fa7:	55                   	push   %ebp
  100fa8:	89 e5                	mov    %esp,%ebp

K_SYSCALL_DECLARE2_VOID(K_SYSCALL_K_TIMER_USER_DATA_SET, k_timer_user_data_set, struct k_timer *, timer, void *, user_data)

K_SYSCALL_DECLARE1(K_SYSCALL_K_TIMER_USER_DATA_GET, k_timer_user_data_get, void *, struct k_timer *, timer)

K_SYSCALL_DECLARE0_RET64(K_SYSCALL_K_UPTIME_GET, k_uptime_get, s64_t)
  100faa:	e8 ad a2 00 00       	call   10b25c <z_impl_k_uptime_get>
	if (CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC > 1000000) {
		return k_uptime_get_32();
	} else {
		return k_cycle_get_32();
	}
}
  100faf:	5d                   	pop    %ebp
  100fb0:	c3                   	ret    

00100fb1 <enable_logger>:

K_THREAD_STACK_DEFINE(logging_stack, CONFIG_LOG_PROCESS_THREAD_STACK_SIZE);
struct k_thread logging_thread;

static int enable_logger(struct device *arg)
{
  100fb1:	55                   	push   %ebp
  100fb2:	89 e5                	mov    %esp,%ebp
K_SYSCALL_DECLARE10(K_SYSCALL_K_THREAD_CREATE, k_thread_create, k_tid_t, struct k_thread *, new_thread, k_thread_stack_t *, stack, size_t, stack_size, k_thread_entry_t, entry, void *, p1, void *, p2, void *, p3, int, prio, u32_t, options, s32_t, delay)
  100fb4:	6a 00                	push   $0x0
  100fb6:	6a 00                	push   $0x0
  100fb8:	6a 0e                	push   $0xe
  100fba:	6a 00                	push   $0x0
  100fbc:	6a 00                	push   $0x0
  100fbe:	6a 00                	push   $0x0
  100fc0:	68 c5 14 10 00       	push   $0x1014c5
  100fc5:	68 00 03 00 00       	push   $0x300
  100fca:	68 58 0b 11 00       	push   $0x110b58
  100fcf:	68 00 f9 10 00       	push   $0x10f900
  100fd4:	e8 39 9e 00 00       	call   10ae12 <z_impl_k_thread_create>
  100fd9:	83 c4 28             	add    $0x28,%esp
K_SYSCALL_DECLARE2(K_SYSCALL_K_THREAD_NAME_SET, k_thread_name_set, int, k_tid_t, thread_id, const char *, value)
  100fdc:	68 4b e2 10 00       	push   $0x10e24b
  100fe1:	68 00 f9 10 00       	push   $0x10f900
  100fe6:	e8 31 9d 00 00       	call   10ad1c <z_impl_k_thread_name_set>
  100feb:	58                   	pop    %eax
	} else {
		log_init();
	}

	return 0;
}
  100fec:	31 c0                	xor    %eax,%eax
  100fee:	5a                   	pop    %edx
  100fef:	c9                   	leave  
  100ff0:	c3                   	ret    

00100ff1 <log_core_init>:
{
  100ff1:	55                   	push   %ebp
  100ff2:	89 e5                	mov    %esp,%ebp
  100ff4:	53                   	push   %ebx
		log_msg_pool_init();
  100ff5:	e8 a9 06 00 00       	call   1016a3 <log_msg_pool_init>
		log_list_init(&list);
  100ffa:	68 6c 0a 11 00       	push   $0x110a6c
  100fff:	e8 0d ff ff ff       	call   100f11 <log_list_init>
		k_mem_slab_init(&log_strdup_pool, log_strdup_pool_buf,
  101004:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
  10100b:	6a 28                	push   $0x28
  10100d:	68 58 0e 11 00       	push   $0x110e58
  101012:	68 74 0a 11 00       	push   $0x110a74
  101017:	e8 bc 8e 00 00       	call   109ed8 <k_mem_slab_init>
  10101c:	83 c4 10             	add    $0x10,%esp
	timestamp_func = timestamp_get;
  10101f:	c7 05 f0 31 11 00 a7 	movl   $0x100fa7,0x1131f0
  101026:	0f 10 00 
	log_output_timestamp_freq_set(freq);
  101029:	68 e8 03 00 00       	push   $0x3e8
  10102e:	e8 6a 0f 00 00       	call   101f9d <log_output_timestamp_freq_set>
 * @return Source ID.
 */
static inline u32_t log_const_source_id(
				const struct log_source_const_data *data)
{
	return ((u8_t *)data - (u8_t *)__log_const_start)/
  101033:	ba 18 ba 10 00       	mov    $0x10ba18,%edx
  101038:	58                   	pop    %eax
  101039:	81 ea e0 b9 10 00    	sub    $0x10b9e0,%edx
		for (int i = 0; i < log_sources_count(); i++) {
  10103f:	31 c0                	xor    %eax,%eax
  101041:	c1 ea 03             	shr    $0x3,%edx
  101044:	39 d0                	cmp    %edx,%eax
  101046:	74 20                	je     101068 <log_core_init+0x77>
			LOG_FILTER_SLOT_SET(filters,
  101048:	8b 0c 85 04 34 11 00 	mov    0x113404(,%eax,4),%ecx
  10104f:	8a 1c c5 e4 b9 10 00 	mov    0x10b9e4(,%eax,8),%bl
  101056:	83 e1 f8             	and    $0xfffffff8,%ecx
  101059:	83 e3 07             	and    $0x7,%ebx
  10105c:	09 d9                	or     %ebx,%ecx
  10105e:	89 0c 85 04 34 11 00 	mov    %ecx,0x113404(,%eax,4)
		for (int i = 0; i < log_sources_count(); i++) {
  101065:	40                   	inc    %eax
  101066:	eb dc                	jmp    101044 <log_core_init+0x53>
}
  101068:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  10106b:	c9                   	leave  
  10106c:	c3                   	ret    

0010106d <dropped_notify>:
{
  10106d:	55                   	push   %ebp
{
	/* This builtin, as described by Intel, is not a traditional
	 * test-and-set operation, but rather an atomic exchange operation. It
	 * writes value into *ptr, and returns the previous contents of *ptr.
	 */
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
  10106e:	31 c0                	xor    %eax,%eax
  101070:	89 e5                	mov    %esp,%ebp
  101072:	57                   	push   %edi
  101073:	56                   	push   %esi
  101074:	53                   	push   %ebx
  101075:	51                   	push   %ecx
  101076:	87 05 60 0a 11 00    	xchg   %eax,0x110a60
 *
 * @return Number of backends.
 */
static inline int log_backend_count_get(void)
{
	return __log_backends_end - __log_backends_start;
  10107c:	bb 28 ba 10 00       	mov    $0x10ba28,%ebx
  101081:	be 18 ba 10 00       	mov    $0x10ba18,%esi
  101086:	81 eb 18 ba 10 00    	sub    $0x10ba18,%ebx
	for (int i = 0; i < log_backend_count_get(); i++) {
  10108c:	31 ff                	xor    %edi,%edi
  10108e:	c1 fb 04             	sar    $0x4,%ebx
  101091:	39 df                	cmp    %ebx,%edi
  101093:	7d 24                	jge    1010b9 <dropped_notify+0x4c>
 */
static inline bool log_backend_is_active(
				const struct log_backend *const backend)
{
	__ASSERT_NO_MSG(backend != NULL);
	return backend->cb->active;
  101095:	8b 56 04             	mov    0x4(%esi),%edx
		if (log_backend_is_active(backend)) {
  101098:	80 7a 05 00          	cmpb   $0x0,0x5(%edx)
  10109c:	74 15                	je     1010b3 <dropped_notify+0x46>
	if (backend->api->dropped != NULL) {
  10109e:	8b 16                	mov    (%esi),%edx
  1010a0:	8b 52 0c             	mov    0xc(%edx),%edx
  1010a3:	85 d2                	test   %edx,%edx
  1010a5:	74 0c                	je     1010b3 <dropped_notify+0x46>
		backend->api->dropped(backend, cnt);
  1010a7:	50                   	push   %eax
  1010a8:	89 45 f0             	mov    %eax,-0x10(%ebp)
  1010ab:	56                   	push   %esi
  1010ac:	ff d2                	call   *%edx
  1010ae:	58                   	pop    %eax
  1010af:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1010b2:	5a                   	pop    %edx
	for (int i = 0; i < log_backend_count_get(); i++) {
  1010b3:	47                   	inc    %edi
  1010b4:	83 c6 10             	add    $0x10,%esi
  1010b7:	eb d8                	jmp    101091 <dropped_notify+0x24>
}
  1010b9:	8d 65 f4             	lea    -0xc(%ebp),%esp
  1010bc:	5b                   	pop    %ebx
  1010bd:	5e                   	pop    %esi
  1010be:	5f                   	pop    %edi
  1010bf:	5d                   	pop    %ebp
  1010c0:	c3                   	ret    

001010c1 <z_impl_log_process>:
{
  1010c1:	55                   	push   %ebp
  1010c2:	89 e5                	mov    %esp,%ebp
  1010c4:	57                   	push   %edi
  1010c5:	56                   	push   %esi
  1010c6:	53                   	push   %ebx
  1010c7:	83 ec 08             	sub    $0x8,%esp
  1010ca:	8b 45 08             	mov    0x8(%ebp),%eax
  1010cd:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (!backend_attached && !bypass) {
  1010d0:	8a 45 f0             	mov    -0x10(%ebp),%al
  1010d3:	0a 05 54 0b 11 00    	or     0x110b54,%al
  1010d9:	0f 84 b0 00 00 00    	je     10118f <z_impl_log_process+0xce>

static ALWAYS_INLINE unsigned int _do_irq_lock(void)
{
	unsigned int key;

	__asm__ volatile (
  1010df:	9c                   	pushf  
  1010e0:	fa                   	cli    
  1010e1:	5e                   	pop    %esi
	msg = log_list_head_get(&list);
  1010e2:	68 6c 0a 11 00       	push   $0x110a6c
  1010e7:	e8 66 fe ff ff       	call   100f52 <log_list_head_get>
  1010ec:	5a                   	pop    %edx
  1010ed:	89 c3                	mov    %eax,%ebx
 *
 */

static ALWAYS_INLINE void z_arch_irq_unlock(unsigned int key)
{
	if ((key & 0x200U) == 0U) {
  1010ef:	0f ba e6 09          	bt     $0x9,%esi
  1010f3:	73 01                	jae    1010f6 <z_impl_log_process+0x35>
 * @return N/A
 */

static ALWAYS_INLINE void z_do_irq_unlock(void)
{
	__asm__ volatile (
  1010f5:	fb                   	sti    
	if (msg != NULL) {
  1010f6:	85 db                	test   %ebx,%ebx
  1010f8:	74 71                	je     10116b <z_impl_log_process+0xaa>
	return __atomic_fetch_sub(target, value, __ATOMIC_SEQ_CST);
  1010fa:	f0 ff 0d 64 0a 11 00 	lock decl 0x110a64
	if (!bypass) {
  101101:	80 7d f0 00          	cmpb   $0x0,-0x10(%ebp)
  101105:	74 09                	je     101110 <z_impl_log_process+0x4f>
	log_msg_put(msg);
  101107:	53                   	push   %ebx
  101108:	e8 e5 06 00 00       	call   1017f2 <log_msg_put>
  10110d:	58                   	pop    %eax
  10110e:	eb 5b                	jmp    10116b <z_impl_log_process+0xaa>
	return __log_backends_end - __log_backends_start;
  101110:	b8 28 ba 10 00       	mov    $0x10ba28,%eax
  101115:	be 18 ba 10 00       	mov    $0x10ba18,%esi
  10111a:	2d 18 ba 10 00       	sub    $0x10ba18,%eax
		for (int i = 0; i < log_backend_count_get(); i++) {
  10111f:	31 ff                	xor    %edi,%edi
  101121:	c1 f8 04             	sar    $0x4,%eax
  101124:	89 45 ec             	mov    %eax,-0x14(%ebp)
  101127:	3b 7d ec             	cmp    -0x14(%ebp),%edi
  10112a:	7d db                	jge    101107 <z_impl_log_process+0x46>
			if (log_backend_is_active(backend) &&
  10112c:	8b 4e 04             	mov    0x4(%esi),%ecx
  10112f:	80 79 05 00          	cmpb   $0x0,0x5(%ecx)
  101133:	74 30                	je     101165 <z_impl_log_process+0xa4>
	return msg->hdr.ids.source_id;
  101135:	66 8b 43 0a          	mov    0xa(%ebx),%ax
	return msg->hdr.ids.level;
  101139:	8a 53 0a             	mov    0xa(%ebx),%dl
	return msg->hdr.ids.source_id;
  10113c:	66 c1 e8 06          	shr    $0x6,%ax
	return msg->hdr.ids.level;
  101140:	83 e2 07             	and    $0x7,%edx
		return LOG_FILTER_SLOT_GET(filters,
  101143:	0f b6 49 04          	movzbl 0x4(%ecx),%ecx
	return msg->hdr.ids.source_id;
  101147:	0f b7 c0             	movzwl %ax,%eax
  10114a:	8d 0c 49             	lea    (%ecx,%ecx,2),%ecx
  10114d:	8b 04 85 04 34 11 00 	mov    0x113404(,%eax,4),%eax
  101154:	d3 e8                	shr    %cl,%eax
  101156:	83 e0 07             	and    $0x7,%eax
			if (log_backend_is_active(backend) &&
  101159:	39 c2                	cmp    %eax,%edx
  10115b:	77 08                	ja     101165 <z_impl_log_process+0xa4>
	backend->api->put(backend, msg);
  10115d:	8b 06                	mov    (%esi),%eax
  10115f:	53                   	push   %ebx
  101160:	56                   	push   %esi
  101161:	ff 10                	call   *(%eax)
  101163:	59                   	pop    %ecx
  101164:	58                   	pop    %eax
		for (int i = 0; i < log_backend_count_get(); i++) {
  101165:	47                   	inc    %edi
  101166:	83 c6 10             	add    $0x10,%esi
  101169:	eb bc                	jmp    101127 <z_impl_log_process+0x66>
	if (!bypass && dropped_cnt) {
  10116b:	80 7d f0 00          	cmpb   $0x0,-0x10(%ebp)
  10116f:	75 0e                	jne    10117f <z_impl_log_process+0xbe>
  101171:	83 3d 60 0a 11 00 00 	cmpl   $0x0,0x110a60
  101178:	74 05                	je     10117f <z_impl_log_process+0xbe>
		dropped_notify();
  10117a:	e8 ee fe ff ff       	call   10106d <dropped_notify>
	return (log_list_head_peek(&list) != NULL);
  10117f:	68 6c 0a 11 00       	push   $0x110a6c
  101184:	e8 bf fd ff ff       	call   100f48 <log_list_head_peek>
  101189:	5a                   	pop    %edx
  10118a:	85 c0                	test   %eax,%eax
  10118c:	0f 95 c0             	setne  %al
}
  10118f:	8d 65 f4             	lea    -0xc(%ebp),%esp
  101192:	5b                   	pop    %ebx
  101193:	5e                   	pop    %esi
  101194:	5f                   	pop    %edi
  101195:	5d                   	pop    %ebp
  101196:	c3                   	ret    

00101197 <msg_finalize>:
{
  101197:	55                   	push   %ebp
  101198:	89 e5                	mov    %esp,%ebp
  10119a:	56                   	push   %esi
  10119b:	53                   	push   %ebx
	msg->hdr.ids = src_level;
  10119c:	66 89 50 0a          	mov    %dx,0xa(%eax)
{
  1011a0:	89 c3                	mov    %eax,%ebx
	msg->hdr.timestamp = timestamp_func();
  1011a2:	ff 15 f0 31 11 00    	call   *0x1131f0
  1011a8:	89 43 0c             	mov    %eax,0xc(%ebx)
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
  1011ab:	f0 ff 05 64 0a 11 00 	lock incl 0x110a64
	__asm__ volatile (
  1011b2:	9c                   	pushf  
  1011b3:	fa                   	cli    
  1011b4:	5e                   	pop    %esi
	log_list_add_tail(&list, msg);
  1011b5:	53                   	push   %ebx
  1011b6:	68 6c 0a 11 00       	push   $0x110a6c
  1011bb:	e8 66 fd ff ff       	call   100f26 <log_list_add_tail>
  1011c0:	0f ba e6 09          	bt     $0x9,%esi
  1011c4:	59                   	pop    %ecx
  1011c5:	5b                   	pop    %ebx
  1011c6:	73 01                	jae    1011c9 <msg_finalize+0x32>
	__asm__ volatile (
  1011c8:	fb                   	sti    
	if (panic_mode) {
  1011c9:	80 3d 55 0b 11 00 00 	cmpb   $0x0,0x110b55
  1011d0:	74 14                	je     1011e6 <msg_finalize+0x4f>
	__asm__ volatile (
  1011d2:	9c                   	pushf  
  1011d3:	fa                   	cli    
  1011d4:	5b                   	pop    %ebx
extern "C" {
#endif

K_SYSCALL_DECLARE0_VOID(K_SYSCALL_LOG_PANIC, log_panic)

K_SYSCALL_DECLARE1(K_SYSCALL_LOG_PROCESS, log_process, bool, bool, bypass)
  1011d5:	6a 00                	push   $0x0
  1011d7:	e8 e5 fe ff ff       	call   1010c1 <z_impl_log_process>
  1011dc:	0f ba e3 09          	bt     $0x9,%ebx
  1011e0:	5a                   	pop    %edx
  1011e1:	73 1c                	jae    1011ff <msg_finalize+0x68>
	__asm__ volatile (
  1011e3:	fb                   	sti    
  1011e4:	eb 19                	jmp    1011ff <msg_finalize+0x68>
		if ((buffered_cnt == CONFIG_LOG_PROCESS_TRIGGER_THRESHOLD) &&
  1011e6:	83 3d 64 0a 11 00 0a 	cmpl   $0xa,0x110a64
  1011ed:	75 10                	jne    1011ff <msg_finalize+0x68>
		    (proc_tid != NULL)) {
  1011ef:	a1 5c 0a 11 00       	mov    0x110a5c,%eax
		if ((buffered_cnt == CONFIG_LOG_PROCESS_TRIGGER_THRESHOLD) &&
  1011f4:	85 c0                	test   %eax,%eax
  1011f6:	74 07                	je     1011ff <msg_finalize+0x68>
K_SYSCALL_DECLARE1_VOID(K_SYSCALL_K_WAKEUP, k_wakeup, k_tid_t, thread)
  1011f8:	50                   	push   %eax
  1011f9:	e8 dd 98 00 00       	call   10aadb <z_impl_k_wakeup>
  1011fe:	58                   	pop    %eax
}
  1011ff:	8d 65 f8             	lea    -0x8(%ebp),%esp
  101202:	5b                   	pop    %ebx
  101203:	5e                   	pop    %esi
  101204:	5d                   	pop    %ebp
  101205:	c3                   	ret    

00101206 <log_0>:
{
  101206:	55                   	push   %ebp
  101207:	89 e5                	mov    %esp,%ebp
  101209:	56                   	push   %esi
  10120a:	53                   	push   %ebx
  10120b:	8b 75 08             	mov    0x8(%ebp),%esi
  10120e:	8b 5d 0c             	mov    0xc(%ebp),%ebx
 *
 *  @return Pointer to allocated head of the message or NULL.
 */
static inline struct log_msg *log_msg_create_0(const char *str)
{
	struct log_msg *msg = z_log_msg_std_alloc();
  101211:	e8 51 fd ff ff       	call   100f67 <z_log_msg_std_alloc>

	if (msg != NULL) {
  101216:	85 c0                	test   %eax,%eax
  101218:	74 0d                	je     101227 <log_0+0x21>
		msg->str = str;
  10121a:	89 70 10             	mov    %esi,0x10(%eax)
	msg_finalize(msg, src_level);
  10121d:	89 da                	mov    %ebx,%edx
}
  10121f:	5b                   	pop    %ebx
  101220:	5e                   	pop    %esi
  101221:	5d                   	pop    %ebp
	msg_finalize(msg, src_level);
  101222:	e9 70 ff ff ff       	jmp    101197 <msg_finalize>
}
  101227:	5b                   	pop    %ebx
  101228:	5e                   	pop    %esi
  101229:	5d                   	pop    %ebp
  10122a:	c3                   	ret    

0010122b <log_2>:
{
  10122b:	55                   	push   %ebp
  10122c:	89 e5                	mov    %esp,%ebp
  10122e:	57                   	push   %edi
  10122f:	56                   	push   %esi
  101230:	53                   	push   %ebx
  101231:	53                   	push   %ebx
  101232:	8b 55 14             	mov    0x14(%ebp),%edx
  101235:	8b 5d 08             	mov    0x8(%ebp),%ebx
  101238:	8b 7d 0c             	mov    0xc(%ebp),%edi
  10123b:	8b 75 10             	mov    0x10(%ebp),%esi
  10123e:	89 55 f0             	mov    %edx,-0x10(%ebp)
 */
static inline struct log_msg *log_msg_create_2(const char *str,
					       u32_t arg1,
					       u32_t arg2)
{
	struct  log_msg *msg = z_log_msg_std_alloc();
  101241:	e8 21 fd ff ff       	call   100f67 <z_log_msg_std_alloc>

	if (msg != NULL) {
  101246:	85 c0                	test   %eax,%eax
  101248:	74 22                	je     10126c <log_2+0x41>
		msg->str = str;
		msg->hdr.params.std.nargs = 2U;
  10124a:	8a 48 09             	mov    0x9(%eax),%cl
		msg->str = str;
  10124d:	89 58 10             	mov    %ebx,0x10(%eax)
		msg->hdr.params.std.nargs = 2U;
  101250:	83 e1 0f             	and    $0xf,%ecx
		msg->payload.single.args[0] = arg1;
  101253:	89 78 14             	mov    %edi,0x14(%eax)
		msg->hdr.params.std.nargs = 2U;
  101256:	83 c9 20             	or     $0x20,%ecx
		msg->payload.single.args[1] = arg2;
  101259:	89 70 18             	mov    %esi,0x18(%eax)
		msg->hdr.params.std.nargs = 2U;
  10125c:	88 48 09             	mov    %cl,0x9(%eax)
	msg_finalize(msg, src_level);
  10125f:	8b 55 f0             	mov    -0x10(%ebp),%edx
}
  101262:	59                   	pop    %ecx
  101263:	5b                   	pop    %ebx
  101264:	5e                   	pop    %esi
  101265:	5f                   	pop    %edi
  101266:	5d                   	pop    %ebp
	msg_finalize(msg, src_level);
  101267:	e9 2b ff ff ff       	jmp    101197 <msg_finalize>
}
  10126c:	58                   	pop    %eax
  10126d:	5b                   	pop    %ebx
  10126e:	5e                   	pop    %esi
  10126f:	5f                   	pop    %edi
  101270:	5d                   	pop    %ebp
  101271:	c3                   	ret    

00101272 <log_3>:
{
  101272:	55                   	push   %ebp
  101273:	89 e5                	mov    %esp,%ebp
  101275:	57                   	push   %edi
  101276:	56                   	push   %esi
  101277:	53                   	push   %ebx
  101278:	83 ec 08             	sub    $0x8,%esp
  10127b:	8b 55 08             	mov    0x8(%ebp),%edx
  10127e:	8b 45 18             	mov    0x18(%ebp),%eax
  101281:	89 55 ec             	mov    %edx,-0x14(%ebp)
  101284:	8b 7d 0c             	mov    0xc(%ebp),%edi
  101287:	8b 75 10             	mov    0x10(%ebp),%esi
  10128a:	8b 5d 14             	mov    0x14(%ebp),%ebx
  10128d:	66 89 45 f2          	mov    %ax,-0xe(%ebp)
static inline struct log_msg *log_msg_create_3(const char *str,
					       u32_t arg1,
					       u32_t arg2,
					       u32_t arg3)
{
	struct  log_msg *msg = z_log_msg_std_alloc();
  101291:	e8 d1 fc ff ff       	call   100f67 <z_log_msg_std_alloc>

	if (msg != NULL) {
  101296:	85 c0                	test   %eax,%eax
  101298:	74 2a                	je     1012c4 <log_3+0x52>
		msg->str = str;
  10129a:	8b 55 ec             	mov    -0x14(%ebp),%edx
		msg->hdr.params.std.nargs = 3U;
		msg->payload.single.args[0] = arg1;
  10129d:	89 78 14             	mov    %edi,0x14(%eax)
		msg->str = str;
  1012a0:	89 50 10             	mov    %edx,0x10(%eax)
		msg->hdr.params.std.nargs = 3U;
  1012a3:	8a 50 09             	mov    0x9(%eax),%dl
  1012a6:	83 e2 0f             	and    $0xf,%edx
		msg->payload.single.args[1] = arg2;
  1012a9:	89 70 18             	mov    %esi,0x18(%eax)
		msg->hdr.params.std.nargs = 3U;
  1012ac:	83 ca 30             	or     $0x30,%edx
		msg->payload.single.args[2] = arg3;
  1012af:	89 58 1c             	mov    %ebx,0x1c(%eax)
		msg->hdr.params.std.nargs = 3U;
  1012b2:	88 50 09             	mov    %dl,0x9(%eax)
	msg_finalize(msg, src_level);
  1012b5:	66 8b 55 f2          	mov    -0xe(%ebp),%dx
}
  1012b9:	59                   	pop    %ecx
  1012ba:	5b                   	pop    %ebx
  1012bb:	5b                   	pop    %ebx
  1012bc:	5e                   	pop    %esi
  1012bd:	5f                   	pop    %edi
  1012be:	5d                   	pop    %ebp
	msg_finalize(msg, src_level);
  1012bf:	e9 d3 fe ff ff       	jmp    101197 <msg_finalize>
}
  1012c4:	58                   	pop    %eax
  1012c5:	5a                   	pop    %edx
  1012c6:	5b                   	pop    %ebx
  1012c7:	5e                   	pop    %esi
  1012c8:	5f                   	pop    %edi
  1012c9:	5d                   	pop    %ebp
  1012ca:	c3                   	ret    

001012cb <log_dropped>:
  1012cb:	f0 ff 05 60 0a 11 00 	lock incl 0x110a60
}
  1012d2:	c3                   	ret    

001012d3 <log_source_name_get>:
{
  1012d3:	55                   	push   %ebp
  1012d4:	ba 18 ba 10 00       	mov    $0x10ba18,%edx
  1012d9:	89 e5                	mov    %esp,%ebp
  1012db:	81 ea e0 b9 10 00    	sub    $0x10b9e0,%edx
  1012e1:	c1 ea 03             	shr    $0x3,%edx
  1012e4:	31 c0                	xor    %eax,%eax
  1012e6:	8b 4d 0c             	mov    0xc(%ebp),%ecx
	return src_id < log_sources_count() ? log_name_get(src_id) : NULL;
  1012e9:	39 d1                	cmp    %edx,%ecx
  1012eb:	73 07                	jae    1012f4 <log_source_name_get+0x21>
	return __log_const_start[source_id].name;
  1012ed:	8b 04 cd e0 b9 10 00 	mov    0x10b9e0(,%ecx,8),%eax
}
  1012f4:	5d                   	pop    %ebp
  1012f5:	c3                   	ret    

001012f6 <z_impl_log_filter_set>:
{
  1012f6:	55                   	push   %ebp
  1012f7:	89 e5                	mov    %esp,%ebp
  1012f9:	57                   	push   %edi
  1012fa:	56                   	push   %esi
  1012fb:	8b 45 08             	mov    0x8(%ebp),%eax
  1012fe:	53                   	push   %ebx
  1012ff:	8b 55 10             	mov    0x10(%ebp),%edx
		if (backend == NULL) {
  101302:	85 c0                	test   %eax,%eax
  101304:	75 43                	jne    101349 <z_impl_log_filter_set+0x53>
	return __log_backends_end - __log_backends_start;
  101306:	be 28 ba 10 00       	mov    $0x10ba28,%esi
			for (int i = 0; i < log_backend_count_get(); i++) {
  10130b:	31 ff                	xor    %edi,%edi
  10130d:	81 ee 18 ba 10 00    	sub    $0x10ba18,%esi
			u32_t max = 0U;
  101313:	31 db                	xor    %ebx,%ebx
  101315:	c1 fe 04             	sar    $0x4,%esi
			for (int i = 0; i < log_backend_count_get(); i++) {
  101318:	39 f7                	cmp    %esi,%edi
  10131a:	0f 8d 84 00 00 00    	jge    1013a4 <z_impl_log_filter_set+0xae>

K_SYSCALL_DECLARE0(K_SYSCALL_LOG_BUFFERED_CNT, log_buffered_cnt, u32_t)

K_SYSCALL_DECLARE4(K_SYSCALL_LOG_FILTER_SET, log_filter_set, u32_t, struct log_backend const *const, backend, u32_t, domain_id, u32_t, src_id, u32_t, level)
  101320:	ff 75 14             	pushl  0x14(%ebp)
  101323:	89 f8                	mov    %edi,%eax
  101325:	89 55 10             	mov    %edx,0x10(%ebp)
  101328:	c1 e0 04             	shl    $0x4,%eax
  10132b:	52                   	push   %edx
  10132c:	ff 75 0c             	pushl  0xc(%ebp)
  10132f:	05 18 ba 10 00       	add    $0x10ba18,%eax
  101334:	50                   	push   %eax
  101335:	e8 bc ff ff ff       	call   1012f6 <z_impl_log_filter_set>
  10133a:	83 c4 10             	add    $0x10,%esp
				max = MAX(current, max);
  10133d:	8b 55 10             	mov    0x10(%ebp),%edx
  101340:	39 c3                	cmp    %eax,%ebx
  101342:	73 02                	jae    101346 <z_impl_log_filter_set+0x50>
  101344:	89 c3                	mov    %eax,%ebx
			for (int i = 0; i < log_backend_count_get(); i++) {
  101346:	47                   	inc    %edi
  101347:	eb cf                	jmp    101318 <z_impl_log_filter_set+0x22>
		return log_compiled_level_get(src_id);
  101349:	0f b6 1c d5 e4 b9 10 	movzbl 0x10b9e4(,%edx,8),%ebx
  101350:	00 
			level = MIN(level, max);
  101351:	3b 5d 14             	cmp    0x14(%ebp),%ebx
  101354:	76 03                	jbe    101359 <z_impl_log_filter_set+0x63>
  101356:	8b 5d 14             	mov    0x14(%ebp),%ebx
	return backend->cb->id;
  101359:	8b 40 04             	mov    0x4(%eax),%eax
			LOG_FILTER_SLOT_SET(filters,
  10135c:	89 de                	mov    %ebx,%esi
  10135e:	83 e6 07             	and    $0x7,%esi
  101361:	0f b6 48 04          	movzbl 0x4(%eax),%ecx
  101365:	b8 07 00 00 00       	mov    $0x7,%eax
  10136a:	8d 0c 49             	lea    (%ecx,%ecx,2),%ecx
  10136d:	d3 e0                	shl    %cl,%eax
  10136f:	f7 d0                	not    %eax
  101371:	23 04 95 04 34 11 00 	and    0x113404(,%edx,4),%eax
  101378:	d3 e6                	shl    %cl,%esi
  10137a:	09 f0                	or     %esi,%eax
  10137c:	b9 03 00 00 00       	mov    $0x3,%ecx
	u32_t max_filter = LOG_LEVEL_NONE;
  101381:	31 f6                	xor    %esi,%esi
		u32_t tmp_filter = LOG_FILTER_SLOT_GET(&filters, i);
  101383:	89 c7                	mov    %eax,%edi
  101385:	d3 ef                	shr    %cl,%edi
  101387:	83 e7 07             	and    $0x7,%edi
  10138a:	39 fe                	cmp    %edi,%esi
  10138c:	73 02                	jae    101390 <z_impl_log_filter_set+0x9a>
  10138e:	89 fe                	mov    %edi,%esi
  101390:	83 c1 03             	add    $0x3,%ecx
	for (i = first_slot; i < LOG_FILTERS_NUM_OF_SLOTS; i++) {
  101393:	83 f9 1e             	cmp    $0x1e,%ecx
  101396:	75 eb                	jne    101383 <z_impl_log_filter_set+0x8d>
			LOG_FILTER_SLOT_SET(filters,
  101398:	83 e0 f8             	and    $0xfffffff8,%eax
  10139b:	09 f0                	or     %esi,%eax
  10139d:	89 04 95 04 34 11 00 	mov    %eax,0x113404(,%edx,4)
}
  1013a4:	8d 65 f4             	lea    -0xc(%ebp),%esp
  1013a7:	89 d8                	mov    %ebx,%eax
  1013a9:	5b                   	pop    %ebx
  1013aa:	5e                   	pop    %esi
  1013ab:	5f                   	pop    %edi
  1013ac:	5d                   	pop    %ebp
  1013ad:	c3                   	ret    

001013ae <log_backend_enable>:
{
  1013ae:	55                   	push   %ebp
  1013af:	89 e5                	mov    %esp,%ebp
  1013b1:	57                   	push   %edi
  1013b2:	56                   	push   %esi
		for (int i = 0; i < log_sources_count(); i++) {
  1013b3:	31 ff                	xor    %edi,%edi
{
  1013b5:	8b 75 08             	mov    0x8(%ebp),%esi
  1013b8:	53                   	push   %ebx
	id += backend - log_backend_get(0);
  1013b9:	89 f0                	mov    %esi,%eax
	return ((u8_t *)data - (u8_t *)__log_const_start)/
  1013bb:	bb 18 ba 10 00       	mov    $0x10ba18,%ebx
  1013c0:	2d 18 ba 10 00       	sub    $0x10ba18,%eax
	backend->cb->id = id;
  1013c5:	8b 56 04             	mov    0x4(%esi),%edx
  1013c8:	c1 f8 04             	sar    $0x4,%eax
  1013cb:	81 eb e0 b9 10 00    	sub    $0x10b9e0,%ebx
  1013d1:	c1 eb 03             	shr    $0x3,%ebx
  1013d4:	40                   	inc    %eax
	log_backend_id_set(backend, id);
  1013d5:	88 42 04             	mov    %al,0x4(%edx)
		for (int i = 0; i < log_sources_count(); i++) {
  1013d8:	39 df                	cmp    %ebx,%edi
  1013da:	74 12                	je     1013ee <log_backend_enable+0x40>
  1013dc:	ff 75 10             	pushl  0x10(%ebp)
  1013df:	57                   	push   %edi
  1013e0:	47                   	inc    %edi
  1013e1:	6a 00                	push   $0x0
  1013e3:	56                   	push   %esi
  1013e4:	e8 0d ff ff ff       	call   1012f6 <z_impl_log_filter_set>
  1013e9:	83 c4 10             	add    $0x10,%esp
  1013ec:	eb ea                	jmp    1013d8 <log_backend_enable+0x2a>
	log_backend_activate(backend, ctx);
  1013ee:	8b 46 04             	mov    0x4(%esi),%eax
	backend->cb->ctx = ctx;
  1013f1:	8b 55 0c             	mov    0xc(%ebp),%edx
	backend_attached = true;
  1013f4:	c6 05 54 0b 11 00 01 	movb   $0x1,0x110b54
  1013fb:	89 10                	mov    %edx,(%eax)
	backend->cb->active = true;
  1013fd:	c6 40 05 01          	movb   $0x1,0x5(%eax)
}
  101401:	8d 65 f4             	lea    -0xc(%ebp),%esp
  101404:	5b                   	pop    %ebx
  101405:	5e                   	pop    %esi
  101406:	5f                   	pop    %edi
  101407:	5d                   	pop    %ebp
  101408:	c3                   	ret    

00101409 <log_init>:
  101409:	b8 01 00 00 00       	mov    $0x1,%eax
  10140e:	f0 0f c1 05 68 0a 11 	lock xadd %eax,0x110a68
  101415:	00 
	if (atomic_inc(&initialized) != 0) {
  101416:	85 c0                	test   %eax,%eax
  101418:	75 4b                	jne    101465 <log_init+0x5c>
{
  10141a:	55                   	push   %ebp
  10141b:	89 e5                	mov    %esp,%ebp
  10141d:	57                   	push   %edi
  10141e:	56                   	push   %esi
	for (i = 0; i < log_backend_count_get(); i++) {
  10141f:	31 ff                	xor    %edi,%edi
{
  101421:	53                   	push   %ebx
	return __log_backends_end - __log_backends_start;
  101422:	bb 28 ba 10 00       	mov    $0x10ba28,%ebx
  101427:	81 eb 18 ba 10 00    	sub    $0x10ba18,%ebx
  10142d:	be 18 ba 10 00       	mov    $0x10ba18,%esi
  101432:	c1 fb 04             	sar    $0x4,%ebx
	for (i = 0; i < log_backend_count_get(); i++) {
  101435:	39 df                	cmp    %ebx,%edi
  101437:	7d 24                	jge    10145d <log_init+0x54>
		if (backend->autostart) {
  101439:	80 7e 0c 00          	cmpb   $0x0,0xc(%esi)
  10143d:	74 18                	je     101457 <log_init+0x4e>
			if (backend->api->init != NULL) {
  10143f:	8b 06                	mov    (%esi),%eax
  101441:	8b 40 14             	mov    0x14(%eax),%eax
  101444:	85 c0                	test   %eax,%eax
  101446:	74 02                	je     10144a <log_init+0x41>
				backend->api->init();
  101448:	ff d0                	call   *%eax
			log_backend_enable(backend, NULL, CONFIG_LOG_MAX_LEVEL);
  10144a:	6a 04                	push   $0x4
  10144c:	6a 00                	push   $0x0
  10144e:	56                   	push   %esi
  10144f:	e8 5a ff ff ff       	call   1013ae <log_backend_enable>
  101454:	83 c4 0c             	add    $0xc,%esp
	for (i = 0; i < log_backend_count_get(); i++) {
  101457:	47                   	inc    %edi
  101458:	83 c6 10             	add    $0x10,%esi
  10145b:	eb d8                	jmp    101435 <log_init+0x2c>
}
  10145d:	8d 65 f4             	lea    -0xc(%ebp),%esp
  101460:	5b                   	pop    %ebx
  101461:	5e                   	pop    %esi
  101462:	5f                   	pop    %edi
  101463:	5d                   	pop    %ebp
  101464:	c3                   	ret    
  101465:	c3                   	ret    

00101466 <z_impl_log_panic>:
	if (panic_mode) {
  101466:	80 3d 55 0b 11 00 00 	cmpb   $0x0,0x110b55
  10146d:	75 55                	jne    1014c4 <z_impl_log_panic+0x5e>
{
  10146f:	55                   	push   %ebp
  101470:	89 e5                	mov    %esp,%ebp
  101472:	57                   	push   %edi
  101473:	56                   	push   %esi
	for (int i = 0; i < log_backend_count_get(); i++) {
  101474:	31 ff                	xor    %edi,%edi
{
  101476:	53                   	push   %ebx
	log_init();
  101477:	e8 8d ff ff ff       	call   101409 <log_init>
  10147c:	bb 28 ba 10 00       	mov    $0x10ba28,%ebx
  101481:	be 18 ba 10 00       	mov    $0x10ba18,%esi
  101486:	81 eb 18 ba 10 00    	sub    $0x10ba18,%ebx
  10148c:	c1 fb 04             	sar    $0x4,%ebx
	for (int i = 0; i < log_backend_count_get(); i++) {
  10148f:	39 df                	cmp    %ebx,%edi
  101491:	7d 16                	jge    1014a9 <z_impl_log_panic+0x43>
	return backend->cb->active;
  101493:	8b 46 04             	mov    0x4(%esi),%eax
		if (log_backend_is_active(backend)) {
  101496:	80 78 05 00          	cmpb   $0x0,0x5(%eax)
  10149a:	74 07                	je     1014a3 <z_impl_log_panic+0x3d>
	backend->api->panic(backend);
  10149c:	8b 06                	mov    (%esi),%eax
  10149e:	56                   	push   %esi
  10149f:	ff 50 10             	call   *0x10(%eax)
  1014a2:	59                   	pop    %ecx
	for (int i = 0; i < log_backend_count_get(); i++) {
  1014a3:	47                   	inc    %edi
  1014a4:	83 c6 10             	add    $0x10,%esi
  1014a7:	eb e6                	jmp    10148f <z_impl_log_panic+0x29>
K_SYSCALL_DECLARE1(K_SYSCALL_LOG_PROCESS, log_process, bool, bool, bypass)
  1014a9:	6a 00                	push   $0x0
  1014ab:	e8 11 fc ff ff       	call   1010c1 <z_impl_log_process>
  1014b0:	5a                   	pop    %edx
		while (log_process(false) == true) {
  1014b1:	84 c0                	test   %al,%al
  1014b3:	75 f4                	jne    1014a9 <z_impl_log_panic+0x43>
	panic_mode = true;
  1014b5:	c6 05 55 0b 11 00 01 	movb   $0x1,0x110b55
}
  1014bc:	8d 65 f4             	lea    -0xc(%ebp),%esp
  1014bf:	5b                   	pop    %ebx
  1014c0:	5e                   	pop    %esi
  1014c1:	5f                   	pop    %edi
  1014c2:	5d                   	pop    %ebp
  1014c3:	c3                   	ret    
  1014c4:	c3                   	ret    

001014c5 <log_process_thread_func>:
{
  1014c5:	55                   	push   %ebp
  1014c6:	89 e5                	mov    %esp,%ebp
	log_init();
  1014c8:	e8 3c ff ff ff       	call   101409 <log_init>
K_SYSCALL_DECLARE0(K_SYSCALL_K_CURRENT_GET, k_current_get, k_tid_t)
  1014cd:	e8 51 96 00 00       	call   10ab23 <z_impl_k_current_get>
	proc_tid = process_tid;
  1014d2:	a3 5c 0a 11 00       	mov    %eax,0x110a5c
	if (CONFIG_LOG_PROCESS_TRIGGER_THRESHOLD &&
  1014d7:	85 c0                	test   %eax,%eax
  1014d9:	74 10                	je     1014eb <log_process_thread_func+0x26>
	    process_tid &&
  1014db:	83 3d 64 0a 11 00 09 	cmpl   $0x9,0x110a64
  1014e2:	7e 07                	jle    1014eb <log_process_thread_func+0x26>
K_SYSCALL_DECLARE1_VOID(K_SYSCALL_K_WAKEUP, k_wakeup, k_tid_t, thread)
  1014e4:	50                   	push   %eax
  1014e5:	e8 f1 95 00 00       	call   10aadb <z_impl_k_wakeup>
  1014ea:	59                   	pop    %ecx
  1014eb:	6a 00                	push   $0x0
  1014ed:	e8 cf fb ff ff       	call   1010c1 <z_impl_log_process>
  1014f2:	5a                   	pop    %edx
		if (log_process(false) == false) {
  1014f3:	84 c0                	test   %al,%al
  1014f5:	75 f4                	jne    1014eb <log_process_thread_func+0x26>
K_SYSCALL_DECLARE1(K_SYSCALL_K_SLEEP, k_sleep, s32_t, s32_t, duration)
  1014f7:	68 e8 03 00 00       	push   $0x3e8
  1014fc:	e8 0d 95 00 00       	call   10aa0e <z_impl_k_sleep>
  101501:	eb e7                	jmp    1014ea <log_process_thread_func+0x25>

00101503 <log_backend_disable>:
{
  101503:	55                   	push   %ebp
  101504:	89 e5                	mov    %esp,%ebp
  101506:	57                   	push   %edi
  101507:	56                   	push   %esi
		for (int i = 0; i < log_sources_count(); i++) {
  101508:	31 f6                	xor    %esi,%esi
{
  10150a:	8b 7d 08             	mov    0x8(%ebp),%edi
  10150d:	53                   	push   %ebx
  10150e:	bb 18 ba 10 00       	mov    $0x10ba18,%ebx
	backend->cb->active = false;
  101513:	8b 47 04             	mov    0x4(%edi),%eax
  101516:	81 eb e0 b9 10 00    	sub    $0x10b9e0,%ebx
  10151c:	c1 eb 03             	shr    $0x3,%ebx
  10151f:	c6 40 05 00          	movb   $0x0,0x5(%eax)
		for (int i = 0; i < log_sources_count(); i++) {
  101523:	39 de                	cmp    %ebx,%esi
  101525:	74 11                	je     101538 <log_backend_disable+0x35>
K_SYSCALL_DECLARE4(K_SYSCALL_LOG_FILTER_SET, log_filter_set, u32_t, struct log_backend const *const, backend, u32_t, domain_id, u32_t, src_id, u32_t, level)
  101527:	6a 00                	push   $0x0
  101529:	56                   	push   %esi
  10152a:	46                   	inc    %esi
  10152b:	6a 00                	push   $0x0
  10152d:	57                   	push   %edi
  10152e:	e8 c3 fd ff ff       	call   1012f6 <z_impl_log_filter_set>
  101533:	83 c4 10             	add    $0x10,%esp
  101536:	eb eb                	jmp    101523 <log_backend_disable+0x20>
}
  101538:	8d 65 f4             	lea    -0xc(%ebp),%esp
  10153b:	5b                   	pop    %ebx
  10153c:	5e                   	pop    %esi
  10153d:	5f                   	pop    %edi
  10153e:	5d                   	pop    %ebp
  10153f:	c3                   	ret    

00101540 <log_filter_get>:
{
  101540:	55                   	push   %ebp
  101541:	89 e5                	mov    %esp,%ebp
  101543:	8b 45 10             	mov    0x10(%ebp),%eax
	if (IS_ENABLED(CONFIG_LOG_RUNTIME_FILTERING) && runtime) {
  101546:	80 7d 14 00          	cmpb   $0x0,0x14(%ebp)
  10154a:	74 1b                	je     101567 <log_filter_get+0x27>
	return backend->cb->id;
  10154c:	8b 55 08             	mov    0x8(%ebp),%edx
		return LOG_FILTER_SLOT_GET(filters,
  10154f:	8b 04 85 04 34 11 00 	mov    0x113404(,%eax,4),%eax
  101556:	8b 52 04             	mov    0x4(%edx),%edx
  101559:	0f b6 4a 04          	movzbl 0x4(%edx),%ecx
  10155d:	8d 0c 49             	lea    (%ecx,%ecx,2),%ecx
  101560:	d3 e8                	shr    %cl,%eax
  101562:	83 e0 07             	and    $0x7,%eax
  101565:	eb 08                	jmp    10156f <log_filter_get+0x2f>
		return log_compiled_level_get(src_id);
  101567:	0f b6 04 c5 e4 b9 10 	movzbl 0x10b9e4(,%eax,8),%eax
  10156e:	00 
}
  10156f:	5d                   	pop    %ebp
  101570:	c3                   	ret    

00101571 <log_is_strdup>:
{
  101571:	55                   	push   %ebp
  101572:	89 e5                	mov    %esp,%ebp
  101574:	8b 55 08             	mov    0x8(%ebp),%edx
}
  101577:	5d                   	pop    %ebp
	return ((char *)buf >= pool_first->buf) &&
  101578:	81 fa d4 0e 11 00    	cmp    $0x110ed4,%edx
  10157e:	0f 96 c0             	setbe  %al
  101581:	81 fa 5c 0e 11 00    	cmp    $0x110e5c,%edx
  101587:	0f 93 c2             	setae  %dl
  10158a:	21 d0                	and    %edx,%eax
}
  10158c:	c3                   	ret    

0010158d <log_free>:
{
  10158d:	55                   	push   %ebp
  10158e:	89 e5                	mov    %esp,%ebp
  101590:	51                   	push   %ecx
  101591:	8b 45 08             	mov    0x8(%ebp),%eax
	struct log_strdup_buf *dup = CONTAINER_OF(str, struct log_strdup_buf,
  101594:	8d 50 fc             	lea    -0x4(%eax),%edx
  101597:	89 55 fc             	mov    %edx,-0x4(%ebp)
	if (atomic_dec(&dup->refcount) == 1) {
  10159a:	f0 ff 48 fc          	lock decl -0x4(%eax)
  10159e:	75 10                	jne    1015b0 <log_free+0x23>
		k_mem_slab_free(&log_strdup_pool, (void **)&dup);
  1015a0:	8d 45 fc             	lea    -0x4(%ebp),%eax
  1015a3:	50                   	push   %eax
  1015a4:	68 74 0a 11 00       	push   $0x110a74
  1015a9:	e8 d6 89 00 00       	call   109f84 <k_mem_slab_free>
  1015ae:	58                   	pop    %eax
  1015af:	5a                   	pop    %edx
}
  1015b0:	c9                   	leave  
  1015b1:	c3                   	ret    

001015b2 <log_msg_hexdump_data_op>:
static void log_msg_hexdump_data_op(struct log_msg *msg,
				    u8_t *data,
				    size_t *length,
				    size_t offset,
				    bool put_op)
{
  1015b2:	55                   	push   %ebp
  1015b3:	89 e5                	mov    %esp,%ebp
  1015b5:	57                   	push   %edi
  1015b6:	56                   	push   %esi
  1015b7:	89 d6                	mov    %edx,%esi
  1015b9:	53                   	push   %ebx
  1015ba:	83 ec 08             	sub    $0x8,%esp
  1015bd:	8b 7d 0c             	mov    0xc(%ebp),%edi
	u32_t available_len = msg->hdr.params.hexdump.length;
  1015c0:	8b 50 08             	mov    0x8(%eax),%edx
  1015c3:	66 c1 ea 02          	shr    $0x2,%dx
{
  1015c7:	89 7d f0             	mov    %edi,-0x10(%ebp)
  1015ca:	8a 5d f0             	mov    -0x10(%ebp),%bl
	u32_t available_len = msg->hdr.params.hexdump.length;
  1015cd:	0f b7 d2             	movzwl %dx,%edx
{
  1015d0:	88 5d ef             	mov    %bl,-0x11(%ebp)
	u8_t *head_data;
	u32_t chunk_len;
	u32_t req_len;
	u32_t cpy_len;

	if (offset >= available_len) {
  1015d3:	3b 55 08             	cmp    0x8(%ebp),%edx
  1015d6:	77 0b                	ja     1015e3 <log_msg_hexdump_data_op+0x31>
		*length = 0;
  1015d8:	c7 01 00 00 00 00    	movl   $0x0,(%ecx)
		return;
  1015de:	e9 b8 00 00 00       	jmp    10169b <log_msg_hexdump_data_op+0xe9>
	}

	if ((offset + *length) > available_len) {
  1015e3:	8b 5d 08             	mov    0x8(%ebp),%ebx
  1015e6:	03 19                	add    (%ecx),%ebx
  1015e8:	39 d3                	cmp    %edx,%ebx
  1015ea:	76 07                	jbe    1015f3 <log_msg_hexdump_data_op+0x41>
		*length = available_len - offset;
  1015ec:	89 d3                	mov    %edx,%ebx
  1015ee:	2b 5d 08             	sub    0x8(%ebp),%ebx
  1015f1:	89 19                	mov    %ebx,(%ecx)
	}

	req_len = *length;
  1015f3:	8b 19                	mov    (%ecx),%ebx

	if (available_len > LOG_MSG_HEXDUMP_BYTES_SINGLE_CHUNK) {
  1015f5:	83 fa 0c             	cmp    $0xc,%edx
  1015f8:	76 13                	jbe    10160d <log_msg_hexdump_data_op+0x5b>
		chunk_len = LOG_MSG_HEXDUMP_BYTES_HEAD_CHUNK;
		head_data = msg->payload.ext.data.bytes;
		cont = msg->payload.ext.next;
  1015fa:	8b 78 14             	mov    0x14(%eax),%edi
		head_data = msg->payload.single.bytes;
		chunk_len = available_len;

	}

	if (offset < chunk_len) {
  1015fd:	83 7d 08 07          	cmpl   $0x7,0x8(%ebp)
  101601:	77 3f                	ja     101642 <log_msg_hexdump_data_op+0x90>
		head_data = msg->payload.ext.data.bytes;
  101603:	83 c0 18             	add    $0x18,%eax
		chunk_len = LOG_MSG_HEXDUMP_BYTES_HEAD_CHUNK;
  101606:	ba 08 00 00 00       	mov    $0x8,%edx
  10160b:	eb 05                	jmp    101612 <log_msg_hexdump_data_op+0x60>
		head_data = msg->payload.single.bytes;
  10160d:	83 c0 14             	add    $0x14,%eax
	struct log_msg_cont *cont = NULL;
  101610:	31 ff                	xor    %edi,%edi
		cpy_len = req_len > chunk_len ? chunk_len : req_len;
  101612:	89 d9                	mov    %ebx,%ecx
  101614:	39 d3                	cmp    %edx,%ebx
  101616:	76 02                	jbe    10161a <log_msg_hexdump_data_op+0x68>
  101618:	89 d1                	mov    %edx,%ecx

		if (put_op) {
  10161a:	03 45 08             	add    0x8(%ebp),%eax
  10161d:	80 7d f0 00          	cmpb   $0x0,-0x10(%ebp)
  101621:	74 08                	je     10162b <log_msg_hexdump_data_op+0x79>
			(void)memcpy(&head_data[offset], data, cpy_len);
  101623:	51                   	push   %ecx
  101624:	89 4d f0             	mov    %ecx,-0x10(%ebp)
  101627:	56                   	push   %esi
  101628:	50                   	push   %eax
  101629:	eb 06                	jmp    101631 <log_msg_hexdump_data_op+0x7f>
		} else {
			(void)memcpy(data, &head_data[offset], cpy_len);
  10162b:	51                   	push   %ecx
  10162c:	89 4d f0             	mov    %ecx,-0x10(%ebp)
  10162f:	50                   	push   %eax
  101630:	56                   	push   %esi
  101631:	e8 dc 57 00 00       	call   106e12 <memcpy>
  101636:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  101639:	83 c4 0c             	add    $0xc,%esp
		}

		req_len -= cpy_len;
  10163c:	29 cb                	sub    %ecx,%ebx
		data += cpy_len;
  10163e:	01 ce                	add    %ecx,%esi
  101640:	eb 4b                	jmp    10168d <log_msg_hexdump_data_op+0xdb>
	} else {
		offset -= chunk_len;
  101642:	83 6d 08 08          	subl   $0x8,0x8(%ebp)
		chunk_len = HEXDUMP_BYTES_CONT_MSG;
		if (cont == NULL) {
			cont = msg->payload.ext.next;
		}

		while (offset >= chunk_len) {
  101646:	83 7d 08 1b          	cmpl   $0x1b,0x8(%ebp)
  10164a:	76 41                	jbe    10168d <log_msg_hexdump_data_op+0xdb>
			cont = cont->next;
  10164c:	8b 3f                	mov    (%edi),%edi
			offset -= chunk_len;
  10164e:	83 6d 08 1c          	subl   $0x1c,0x8(%ebp)
  101652:	eb f2                	jmp    101646 <log_msg_hexdump_data_op+0x94>
		}
	}

	while (req_len > 0) {
		chunk_len = HEXDUMP_BYTES_CONT_MSG - offset;
		cpy_len = req_len > chunk_len ? chunk_len : req_len;
  101654:	ba 1c 00 00 00       	mov    $0x1c,%edx
  101659:	2b 55 08             	sub    0x8(%ebp),%edx
  10165c:	39 da                	cmp    %ebx,%edx
  10165e:	76 02                	jbe    101662 <log_msg_hexdump_data_op+0xb0>
  101660:	89 da                	mov    %ebx,%edx

		if (put_op) {
  101662:	8b 45 08             	mov    0x8(%ebp),%eax
  101665:	80 7d ef 00          	cmpb   $0x0,-0x11(%ebp)
  101669:	8d 44 07 04          	lea    0x4(%edi,%eax,1),%eax
  10166d:	74 24                	je     101693 <log_msg_hexdump_data_op+0xe1>
			(void)memcpy(&cont->payload.bytes[offset],
  10166f:	52                   	push   %edx
  101670:	89 55 f0             	mov    %edx,-0x10(%ebp)
  101673:	56                   	push   %esi
  101674:	50                   	push   %eax
				     data, cpy_len);
		} else {
			(void)memcpy(data, &cont->payload.bytes[offset],
  101675:	e8 98 57 00 00       	call   106e12 <memcpy>
  10167a:	8b 55 f0             	mov    -0x10(%ebp),%edx
  10167d:	83 c4 0c             	add    $0xc,%esp
				     cpy_len);
		}

		offset = 0;
		cont = cont->next;
  101680:	8b 3f                	mov    (%edi),%edi
		req_len -= cpy_len;
  101682:	29 d3                	sub    %edx,%ebx
		data += cpy_len;
  101684:	01 d6                	add    %edx,%esi
		offset = 0;
  101686:	c7 45 08 00 00 00 00 	movl   $0x0,0x8(%ebp)
	while (req_len > 0) {
  10168d:	85 db                	test   %ebx,%ebx
  10168f:	75 c3                	jne    101654 <log_msg_hexdump_data_op+0xa2>
  101691:	eb 08                	jmp    10169b <log_msg_hexdump_data_op+0xe9>
			(void)memcpy(data, &cont->payload.bytes[offset],
  101693:	52                   	push   %edx
  101694:	89 55 f0             	mov    %edx,-0x10(%ebp)
  101697:	50                   	push   %eax
  101698:	56                   	push   %esi
  101699:	eb da                	jmp    101675 <log_msg_hexdump_data_op+0xc3>
	}
}
  10169b:	8d 65 f4             	lea    -0xc(%ebp),%esp
  10169e:	5b                   	pop    %ebx
  10169f:	5e                   	pop    %esi
  1016a0:	5f                   	pop    %edi
  1016a1:	5d                   	pop    %ebp
  1016a2:	c3                   	ret    

001016a3 <log_msg_pool_init>:
{
  1016a3:	55                   	push   %ebp
  1016a4:	89 e5                	mov    %esp,%ebp
	k_mem_slab_init(&log_msg_pool, log_msg_pool_buf, MSG_SIZE, NUM_OF_MSGS);
  1016a6:	6a 20                	push   $0x20
  1016a8:	6a 20                	push   $0x20
  1016aa:	68 f8 0e 11 00       	push   $0x110ef8
  1016af:	68 90 0a 11 00       	push   $0x110a90
  1016b4:	e8 1f 88 00 00       	call   109ed8 <k_mem_slab_init>
  1016b9:	83 c4 10             	add    $0x10,%esp
}
  1016bc:	c9                   	leave  
  1016bd:	c3                   	ret    

001016be <log_msg_get>:
{
  1016be:	55                   	push   %ebp
  1016bf:	89 e5                	mov    %esp,%ebp
  1016c1:	8b 45 08             	mov    0x8(%ebp),%eax
  1016c4:	f0 ff 40 04          	lock incl 0x4(%eax)
}
  1016c8:	5d                   	pop    %ebp
  1016c9:	c3                   	ret    

001016ca <log_msg_no_space_handle>:
{
  1016ca:	55                   	push   %ebp
  1016cb:	89 e5                	mov    %esp,%ebp
  1016cd:	53                   	push   %ebx
  1016ce:	51                   	push   %ecx
	union log_msg_chunk *msg = NULL;
  1016cf:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
K_SYSCALL_DECLARE1(K_SYSCALL_LOG_PROCESS, log_process, bool, bool, bypass)
  1016d6:	6a 01                	push   $0x1
  1016d8:	e8 e4 f9 ff ff       	call   1010c1 <z_impl_log_process>
  1016dd:	5a                   	pop    %edx
  1016de:	88 c3                	mov    %al,%bl
			log_dropped();
  1016e0:	e8 e6 fb ff ff       	call   1012cb <log_dropped>
			err = k_mem_slab_alloc(&log_msg_pool,
  1016e5:	6a 00                	push   $0x0
  1016e7:	8d 45 f8             	lea    -0x8(%ebp),%eax
  1016ea:	50                   	push   %eax
  1016eb:	68 90 0a 11 00       	push   $0x110a90
  1016f0:	e8 29 88 00 00       	call   109f1e <k_mem_slab_alloc>
  1016f5:	83 c4 0c             	add    $0xc,%esp
		} while ((err != 0) && more);
  1016f8:	85 c0                	test   %eax,%eax
  1016fa:	74 04                	je     101700 <log_msg_no_space_handle+0x36>
  1016fc:	84 db                	test   %bl,%bl
  1016fe:	75 d6                	jne    1016d6 <log_msg_no_space_handle+0xc>
}
  101700:	8b 45 f8             	mov    -0x8(%ebp),%eax
  101703:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  101706:	c9                   	leave  
  101707:	c3                   	ret    

00101708 <log_msg_nargs_get>:
{
  101708:	55                   	push   %ebp
  101709:	89 e5                	mov    %esp,%ebp
	return msg->hdr.params.std.nargs;
  10170b:	8b 45 08             	mov    0x8(%ebp),%eax
}
  10170e:	5d                   	pop    %ebp
	return msg->hdr.params.std.nargs;
  10170f:	8a 40 09             	mov    0x9(%eax),%al
  101712:	c0 e8 04             	shr    $0x4,%al
  101715:	0f b6 c0             	movzbl %al,%eax
}
  101718:	c3                   	ret    

00101719 <log_msg_arg_get>:
{
  101719:	55                   	push   %ebp
		return 0;
  10171a:	31 c0                	xor    %eax,%eax
{
  10171c:	89 e5                	mov    %esp,%ebp
  10171e:	56                   	push   %esi
  10171f:	53                   	push   %ebx
  101720:	8b 4d 08             	mov    0x8(%ebp),%ecx
  101723:	8b 55 0c             	mov    0xc(%ebp),%edx
	if (arg_idx >= msg->hdr.params.std.nargs) {
  101726:	8a 59 09             	mov    0x9(%ecx),%bl
  101729:	c0 eb 04             	shr    $0x4,%bl
  10172c:	0f b6 f3             	movzbl %bl,%esi
  10172f:	39 d6                	cmp    %edx,%esi
  101731:	76 2c                	jbe    10175f <log_msg_arg_get+0x46>
	if (msg->hdr.params.std.nargs <= LOG_MSG_NARGS_SINGLE_CHUNK) {
  101733:	80 fb 03             	cmp    $0x3,%bl
  101736:	77 06                	ja     10173e <log_msg_arg_get+0x25>
		arg = msg->payload.single.args[arg_idx];
  101738:	8b 44 91 14          	mov    0x14(%ecx,%edx,4),%eax
  10173c:	eb 21                	jmp    10175f <log_msg_arg_get+0x46>
	if (arg_idx < LOG_MSG_NARGS_HEAD_CHUNK) {
  10173e:	83 fa 01             	cmp    $0x1,%edx
  101741:	77 06                	ja     101749 <log_msg_arg_get+0x30>
		return msg->payload.ext.data.args[arg_idx];
  101743:	8b 44 91 18          	mov    0x18(%ecx,%edx,4),%eax
  101747:	eb 16                	jmp    10175f <log_msg_arg_get+0x46>
	cont = msg->payload.ext.next;
  101749:	8b 41 14             	mov    0x14(%ecx),%eax
	arg_idx -= LOG_MSG_NARGS_HEAD_CHUNK;
  10174c:	83 ea 02             	sub    $0x2,%edx
	while (arg_idx >= ARGS_CONT_MSG) {
  10174f:	83 fa 06             	cmp    $0x6,%edx
  101752:	76 07                	jbe    10175b <log_msg_arg_get+0x42>
		arg_idx -= ARGS_CONT_MSG;
  101754:	83 ea 07             	sub    $0x7,%edx
		cont = cont->next;
  101757:	8b 00                	mov    (%eax),%eax
  101759:	eb f4                	jmp    10174f <log_msg_arg_get+0x36>
	return cont->payload.args[arg_idx];
  10175b:	8b 44 90 04          	mov    0x4(%eax,%edx,4),%eax
}
  10175f:	5b                   	pop    %ebx
  101760:	5e                   	pop    %esi
  101761:	5d                   	pop    %ebp
  101762:	c3                   	ret    

00101763 <msg_free>:
{
  101763:	55                   	push   %ebp
  101764:	89 e5                	mov    %esp,%ebp
  101766:	57                   	push   %edi
  101767:	56                   	push   %esi
  101768:	53                   	push   %ebx
  101769:	83 ec 08             	sub    $0x8,%esp
  10176c:	89 45 ec             	mov    %eax,-0x14(%ebp)
	u32_t nargs = msg->hdr.params.std.nargs;
  10176f:	8a 58 09             	mov    0x9(%eax),%bl
  101772:	c0 eb 04             	shr    $0x4,%bl
	if (log_msg_is_std(msg) && nargs) {
  101775:	f6 40 08 01          	testb  $0x1,0x8(%eax)
  101779:	75 07                	jne    101782 <msg_free+0x1f>
  10177b:	0f b6 db             	movzbl %bl,%ebx
  10177e:	85 db                	test   %ebx,%ebx
  101780:	75 11                	jne    101793 <msg_free+0x30>
	if (msg->hdr.params.generic.ext == 1) {
  101782:	8b 45 ec             	mov    -0x14(%ebp),%eax
  101785:	f6 40 08 02          	testb  $0x2,0x8(%eax)
  101789:	74 4f                	je     1017da <msg_free+0x77>
		cont_free(msg->payload.ext.next);
  10178b:	8b 40 14             	mov    0x14(%eax),%eax
  10178e:	89 45 f0             	mov    %eax,-0x10(%ebp)
	while (cont != NULL) {
  101791:	eb 29                	jmp    1017bc <msg_free+0x59>
		for (i = 0; i < nargs; i++) {
  101793:	31 f6                	xor    %esi,%esi
  101795:	8b 45 ec             	mov    -0x14(%ebp),%eax
  101798:	39 f3                	cmp    %esi,%ebx
  10179a:	76 e6                	jbe    101782 <msg_free+0x1f>
			void *buf = (void *)log_msg_arg_get(msg, i);
  10179c:	56                   	push   %esi
  10179d:	50                   	push   %eax
  10179e:	e8 76 ff ff ff       	call   101719 <log_msg_arg_get>
  1017a3:	5a                   	pop    %edx
  1017a4:	89 c7                	mov    %eax,%edi
  1017a6:	59                   	pop    %ecx
			if (log_is_strdup(buf)) {
  1017a7:	50                   	push   %eax
  1017a8:	e8 c4 fd ff ff       	call   101571 <log_is_strdup>
  1017ad:	5a                   	pop    %edx
  1017ae:	84 c0                	test   %al,%al
  1017b0:	74 07                	je     1017b9 <msg_free+0x56>
				log_free(buf);
  1017b2:	57                   	push   %edi
  1017b3:	e8 d5 fd ff ff       	call   10158d <log_free>
  1017b8:	5f                   	pop    %edi
		for (i = 0; i < nargs; i++) {
  1017b9:	46                   	inc    %esi
  1017ba:	eb d9                	jmp    101795 <msg_free+0x32>
	while (cont != NULL) {
  1017bc:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1017bf:	85 c0                	test   %eax,%eax
  1017c1:	74 17                	je     1017da <msg_free+0x77>
		next = cont->next;
  1017c3:	8b 18                	mov    (%eax),%ebx
		k_mem_slab_free(&log_msg_pool, (void **)&cont);
  1017c5:	8d 45 f0             	lea    -0x10(%ebp),%eax
  1017c8:	50                   	push   %eax
  1017c9:	68 90 0a 11 00       	push   $0x110a90
  1017ce:	e8 b1 87 00 00       	call   109f84 <k_mem_slab_free>
  1017d3:	59                   	pop    %ecx
		cont = next;
  1017d4:	89 5d f0             	mov    %ebx,-0x10(%ebp)
		k_mem_slab_free(&log_msg_pool, (void **)&cont);
  1017d7:	5e                   	pop    %esi
		cont = next;
  1017d8:	eb e2                	jmp    1017bc <msg_free+0x59>
	k_mem_slab_free(&log_msg_pool, (void **)&msg);
  1017da:	8d 45 ec             	lea    -0x14(%ebp),%eax
  1017dd:	50                   	push   %eax
  1017de:	68 90 0a 11 00       	push   $0x110a90
  1017e3:	e8 9c 87 00 00       	call   109f84 <k_mem_slab_free>
  1017e8:	58                   	pop    %eax
  1017e9:	5a                   	pop    %edx
}
  1017ea:	8d 65 f4             	lea    -0xc(%ebp),%esp
  1017ed:	5b                   	pop    %ebx
  1017ee:	5e                   	pop    %esi
  1017ef:	5f                   	pop    %edi
  1017f0:	5d                   	pop    %ebp
  1017f1:	c3                   	ret    

001017f2 <log_msg_put>:
{
  1017f2:	55                   	push   %ebp
  1017f3:	89 e5                	mov    %esp,%ebp
  1017f5:	8b 45 08             	mov    0x8(%ebp),%eax
	return __atomic_fetch_sub(target, value, __ATOMIC_SEQ_CST);
  1017f8:	f0 ff 48 04          	lock decl 0x4(%eax)
	if (msg->hdr.ref_cnt == 0) {
  1017fc:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
  101800:	75 06                	jne    101808 <log_msg_put+0x16>
}
  101802:	5d                   	pop    %ebp
		msg_free(msg);
  101803:	e9 5b ff ff ff       	jmp    101763 <msg_free>
}
  101808:	5d                   	pop    %ebp
  101809:	c3                   	ret    

0010180a <log_msg_str_get>:
{
  10180a:	55                   	push   %ebp
  10180b:	89 e5                	mov    %esp,%ebp
	return msg->str;
  10180d:	8b 45 08             	mov    0x8(%ebp),%eax
}
  101810:	5d                   	pop    %ebp
	return msg->str;
  101811:	8b 40 10             	mov    0x10(%eax),%eax
}
  101814:	c3                   	ret    

00101815 <log_msg_hexdump_data_get>:

void log_msg_hexdump_data_get(struct log_msg *msg,
			      u8_t *data,
			      size_t *length,
			      size_t offset)
{
  101815:	55                   	push   %ebp
  101816:	89 e5                	mov    %esp,%ebp
	log_msg_hexdump_data_op(msg, data, length, offset, false);
  101818:	8b 4d 14             	mov    0x14(%ebp),%ecx
{
  10181b:	8b 45 08             	mov    0x8(%ebp),%eax
  10181e:	8b 55 0c             	mov    0xc(%ebp),%edx
	log_msg_hexdump_data_op(msg, data, length, offset, false);
  101821:	89 4d 08             	mov    %ecx,0x8(%ebp)
  101824:	8b 4d 10             	mov    0x10(%ebp),%ecx
  101827:	c7 45 0c 00 00 00 00 	movl   $0x0,0xc(%ebp)
}
  10182e:	5d                   	pop    %ebp
	log_msg_hexdump_data_op(msg, data, length, offset, false);
  10182f:	e9 7e fd ff ff       	jmp    1015b2 <log_msg_hexdump_data_op>

00101834 <buffer_write>:
	return length;
}

static void buffer_write(log_output_func_t outf, u8_t *buf, size_t len,
			 void *ctx)
{
  101834:	55                   	push   %ebp
  101835:	89 e5                	mov    %esp,%ebp
  101837:	57                   	push   %edi
  101838:	56                   	push   %esi
  101839:	89 d7                	mov    %edx,%edi
  10183b:	53                   	push   %ebx
  10183c:	89 c6                	mov    %eax,%esi
  10183e:	89 cb                	mov    %ecx,%ebx
	int processed;

	do {
		processed = outf(buf, len, ctx);
  101840:	ff 75 08             	pushl  0x8(%ebp)
  101843:	53                   	push   %ebx
  101844:	57                   	push   %edi
  101845:	ff d6                	call   *%esi
  101847:	83 c4 0c             	add    $0xc,%esp
		len -= processed;
		buf += processed;
  10184a:	01 c7                	add    %eax,%edi
	} while (len != 0);
  10184c:	29 c3                	sub    %eax,%ebx
  10184e:	75 f0                	jne    101840 <buffer_write+0xc>
}
  101850:	8d 65 f4             	lea    -0xc(%ebp),%esp
  101853:	5b                   	pop    %ebx
  101854:	5e                   	pop    %esi
  101855:	5f                   	pop    %edi
  101856:	5d                   	pop    %ebp
  101857:	c3                   	ret    

00101858 <print_formatted>:
{
  101858:	55                   	push   %ebp
  101859:	89 e5                	mov    %esp,%ebp
	va_start(args, fmt);
  10185b:	8d 45 10             	lea    0x10(%ebp),%eax
	z_vprintk(out_func, (void *)log_output, fmt, args);
  10185e:	50                   	push   %eax
  10185f:	ff 75 0c             	pushl  0xc(%ebp)
  101862:	ff 75 08             	pushl  0x8(%ebp)
  101865:	68 b1 1d 10 00       	push   $0x101db1
  10186a:	e8 04 ed ff ff       	call   100573 <z_vprintk>
  10186f:	83 c4 10             	add    $0x10,%esp
}
  101872:	31 c0                	xor    %eax,%eax
  101874:	c9                   	leave  
  101875:	c3                   	ret    

00101876 <std_print>:
	}
}

static void std_print(struct log_msg *msg,
		      const struct log_output *log_output)
{
  101876:	55                   	push   %ebp
  101877:	89 e5                	mov    %esp,%ebp
  101879:	57                   	push   %edi
  10187a:	56                   	push   %esi
  10187b:	89 d6                	mov    %edx,%esi
  10187d:	53                   	push   %ebx
  10187e:	83 ec 0c             	sub    $0xc,%esp
  101881:	89 45 f0             	mov    %eax,-0x10(%ebp)
	const char *str = log_msg_str_get(msg);
  101884:	50                   	push   %eax
  101885:	e8 80 ff ff ff       	call   10180a <log_msg_str_get>
  10188a:	5b                   	pop    %ebx
  10188b:	89 c7                	mov    %eax,%edi
	u32_t nargs = log_msg_nargs_get(msg);
  10188d:	ff 75 f0             	pushl  -0x10(%ebp)
  101890:	e8 73 fe ff ff       	call   101708 <log_msg_nargs_get>
	u32_t *args = alloca(sizeof(u32_t)*nargs);
	int i;

	for (i = 0; i < nargs; i++) {
  101895:	31 c9                	xor    %ecx,%ecx
	u32_t nargs = log_msg_nargs_get(msg);
  101897:	5a                   	pop    %edx
  101898:	89 c2                	mov    %eax,%edx
	u32_t *args = alloca(sizeof(u32_t)*nargs);
  10189a:	8d 04 85 0c 00 00 00 	lea    0xc(,%eax,4),%eax
  1018a1:	29 c4                	sub    %eax,%esp
  1018a3:	8d 5c 24 0f          	lea    0xf(%esp),%ebx
  1018a7:	83 e3 f0             	and    $0xfffffff0,%ebx
	for (i = 0; i < nargs; i++) {
  1018aa:	39 d1                	cmp    %edx,%ecx
  1018ac:	74 1d                	je     1018cb <std_print+0x55>
		args[i] = log_msg_arg_get(msg, i);
  1018ae:	51                   	push   %ecx
  1018af:	89 55 e8             	mov    %edx,-0x18(%ebp)
  1018b2:	ff 75 f0             	pushl  -0x10(%ebp)
  1018b5:	89 4d ec             	mov    %ecx,-0x14(%ebp)
  1018b8:	e8 5c fe ff ff       	call   101719 <log_msg_arg_get>
  1018bd:	5a                   	pop    %edx
	for (i = 0; i < nargs; i++) {
  1018be:	8b 55 e8             	mov    -0x18(%ebp),%edx
		args[i] = log_msg_arg_get(msg, i);
  1018c1:	59                   	pop    %ecx
  1018c2:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  1018c5:	89 04 8b             	mov    %eax,(%ebx,%ecx,4)
	for (i = 0; i < nargs; i++) {
  1018c8:	41                   	inc    %ecx
  1018c9:	eb df                	jmp    1018aa <std_print+0x34>
	}

	switch (log_msg_nargs_get(msg)) {
  1018cb:	ff 75 f0             	pushl  -0x10(%ebp)
  1018ce:	e8 35 fe ff ff       	call   101708 <log_msg_nargs_get>
  1018d3:	59                   	pop    %ecx
  1018d4:	83 f8 0f             	cmp    $0xf,%eax
  1018d7:	0f 87 44 02 00 00    	ja     101b21 <std_print+0x2ab>
  1018dd:	ff 24 85 68 d9 10 00 	jmp    *0x10d968(,%eax,4)
	case 0:
		print_formatted(log_output, str);
  1018e4:	57                   	push   %edi
  1018e5:	56                   	push   %esi
  1018e6:	e8 6d ff ff ff       	call   101858 <print_formatted>
  1018eb:	58                   	pop    %eax
  1018ec:	5a                   	pop    %edx
		break;
  1018ed:	e9 2f 02 00 00       	jmp    101b21 <std_print+0x2ab>
	case 1:
		print_formatted(log_output, str, args[0]);
  1018f2:	ff 33                	pushl  (%ebx)
  1018f4:	57                   	push   %edi
  1018f5:	56                   	push   %esi
  1018f6:	e8 5d ff ff ff       	call   101858 <print_formatted>
  1018fb:	83 c4 0c             	add    $0xc,%esp
		break;
  1018fe:	e9 1e 02 00 00       	jmp    101b21 <std_print+0x2ab>
	case 2:
		print_formatted(log_output, str, args[0], args[1]);
  101903:	ff 73 04             	pushl  0x4(%ebx)
  101906:	ff 33                	pushl  (%ebx)
  101908:	57                   	push   %edi
  101909:	56                   	push   %esi
  10190a:	e8 49 ff ff ff       	call   101858 <print_formatted>
  10190f:	83 c4 10             	add    $0x10,%esp
		break;
  101912:	e9 0a 02 00 00       	jmp    101b21 <std_print+0x2ab>
	case 3:
		print_formatted(log_output, str, args[0], args[1], args[2]);
  101917:	ff 73 08             	pushl  0x8(%ebx)
  10191a:	ff 73 04             	pushl  0x4(%ebx)
  10191d:	ff 33                	pushl  (%ebx)
  10191f:	57                   	push   %edi
  101920:	56                   	push   %esi
  101921:	e8 32 ff ff ff       	call   101858 <print_formatted>
  101926:	83 c4 14             	add    $0x14,%esp
		break;
  101929:	e9 f3 01 00 00       	jmp    101b21 <std_print+0x2ab>
	case 4:
		print_formatted(log_output, str, args[0], args[1], args[2],
  10192e:	ff 73 0c             	pushl  0xc(%ebx)
  101931:	ff 73 08             	pushl  0x8(%ebx)
  101934:	ff 73 04             	pushl  0x4(%ebx)
  101937:	ff 33                	pushl  (%ebx)
  101939:	57                   	push   %edi
  10193a:	56                   	push   %esi
  10193b:	e8 18 ff ff ff       	call   101858 <print_formatted>
  101940:	83 c4 18             	add    $0x18,%esp
				args[3]);
		break;
  101943:	e9 d9 01 00 00       	jmp    101b21 <std_print+0x2ab>
	case 5:
		print_formatted(log_output, str, args[0], args[1], args[2],
  101948:	ff 73 10             	pushl  0x10(%ebx)
  10194b:	ff 73 0c             	pushl  0xc(%ebx)
  10194e:	ff 73 08             	pushl  0x8(%ebx)
  101951:	ff 73 04             	pushl  0x4(%ebx)
  101954:	ff 33                	pushl  (%ebx)
  101956:	57                   	push   %edi
  101957:	56                   	push   %esi
  101958:	e8 fb fe ff ff       	call   101858 <print_formatted>
  10195d:	83 c4 1c             	add    $0x1c,%esp
				args[3], args[4]);
		break;
  101960:	e9 bc 01 00 00       	jmp    101b21 <std_print+0x2ab>
	case 6:
		print_formatted(log_output, str, args[0], args[1], args[2],
  101965:	ff 73 14             	pushl  0x14(%ebx)
  101968:	ff 73 10             	pushl  0x10(%ebx)
  10196b:	ff 73 0c             	pushl  0xc(%ebx)
  10196e:	ff 73 08             	pushl  0x8(%ebx)
  101971:	ff 73 04             	pushl  0x4(%ebx)
  101974:	ff 33                	pushl  (%ebx)
  101976:	57                   	push   %edi
  101977:	56                   	push   %esi
  101978:	e8 db fe ff ff       	call   101858 <print_formatted>
  10197d:	83 c4 20             	add    $0x20,%esp
				args[3], args[4], args[5]);
		break;
  101980:	e9 9c 01 00 00       	jmp    101b21 <std_print+0x2ab>
	case 7:
		print_formatted(log_output, str, args[0], args[1], args[2],
  101985:	ff 73 18             	pushl  0x18(%ebx)
  101988:	ff 73 14             	pushl  0x14(%ebx)
  10198b:	ff 73 10             	pushl  0x10(%ebx)
  10198e:	ff 73 0c             	pushl  0xc(%ebx)
  101991:	ff 73 08             	pushl  0x8(%ebx)
  101994:	ff 73 04             	pushl  0x4(%ebx)
  101997:	ff 33                	pushl  (%ebx)
  101999:	57                   	push   %edi
  10199a:	56                   	push   %esi
  10199b:	e8 b8 fe ff ff       	call   101858 <print_formatted>
  1019a0:	83 c4 24             	add    $0x24,%esp
				args[3], args[4], args[5], args[6]);
		break;
  1019a3:	e9 79 01 00 00       	jmp    101b21 <std_print+0x2ab>
	case 8:
		print_formatted(log_output, str, args[0], args[1], args[2],
  1019a8:	ff 73 1c             	pushl  0x1c(%ebx)
  1019ab:	ff 73 18             	pushl  0x18(%ebx)
  1019ae:	ff 73 14             	pushl  0x14(%ebx)
  1019b1:	ff 73 10             	pushl  0x10(%ebx)
  1019b4:	ff 73 0c             	pushl  0xc(%ebx)
  1019b7:	ff 73 08             	pushl  0x8(%ebx)
  1019ba:	ff 73 04             	pushl  0x4(%ebx)
  1019bd:	ff 33                	pushl  (%ebx)
  1019bf:	57                   	push   %edi
  1019c0:	56                   	push   %esi
  1019c1:	e8 92 fe ff ff       	call   101858 <print_formatted>
  1019c6:	83 c4 28             	add    $0x28,%esp
				args[3], args[4], args[5], args[6], args[7]);
		break;
  1019c9:	e9 53 01 00 00       	jmp    101b21 <std_print+0x2ab>
	case 9:
		print_formatted(log_output, str, args[0], args[1], args[2],
  1019ce:	ff 73 20             	pushl  0x20(%ebx)
  1019d1:	ff 73 1c             	pushl  0x1c(%ebx)
  1019d4:	ff 73 18             	pushl  0x18(%ebx)
  1019d7:	ff 73 14             	pushl  0x14(%ebx)
  1019da:	ff 73 10             	pushl  0x10(%ebx)
  1019dd:	ff 73 0c             	pushl  0xc(%ebx)
  1019e0:	ff 73 08             	pushl  0x8(%ebx)
  1019e3:	ff 73 04             	pushl  0x4(%ebx)
  1019e6:	ff 33                	pushl  (%ebx)
  1019e8:	57                   	push   %edi
  1019e9:	56                   	push   %esi
  1019ea:	e8 69 fe ff ff       	call   101858 <print_formatted>
  1019ef:	83 c4 2c             	add    $0x2c,%esp
				args[3], args[4], args[5], args[6],  args[7],
				args[8]);
		break;
  1019f2:	e9 2a 01 00 00       	jmp    101b21 <std_print+0x2ab>
	case 10:
		print_formatted(log_output, str, args[0], args[1], args[2],
  1019f7:	ff 73 24             	pushl  0x24(%ebx)
  1019fa:	ff 73 20             	pushl  0x20(%ebx)
  1019fd:	ff 73 1c             	pushl  0x1c(%ebx)
  101a00:	ff 73 18             	pushl  0x18(%ebx)
  101a03:	ff 73 14             	pushl  0x14(%ebx)
  101a06:	ff 73 10             	pushl  0x10(%ebx)
  101a09:	ff 73 0c             	pushl  0xc(%ebx)
  101a0c:	ff 73 08             	pushl  0x8(%ebx)
  101a0f:	ff 73 04             	pushl  0x4(%ebx)
  101a12:	ff 33                	pushl  (%ebx)
  101a14:	57                   	push   %edi
  101a15:	56                   	push   %esi
  101a16:	e8 3d fe ff ff       	call   101858 <print_formatted>
  101a1b:	83 c4 30             	add    $0x30,%esp
				args[3], args[4], args[5], args[6],  args[7],
				args[8], args[9]);
		break;
  101a1e:	e9 fe 00 00 00       	jmp    101b21 <std_print+0x2ab>
	case 11:
		print_formatted(log_output, str, args[0], args[1], args[2],
  101a23:	ff 73 28             	pushl  0x28(%ebx)
  101a26:	ff 73 24             	pushl  0x24(%ebx)
  101a29:	ff 73 20             	pushl  0x20(%ebx)
  101a2c:	ff 73 1c             	pushl  0x1c(%ebx)
  101a2f:	ff 73 18             	pushl  0x18(%ebx)
  101a32:	ff 73 14             	pushl  0x14(%ebx)
  101a35:	ff 73 10             	pushl  0x10(%ebx)
  101a38:	ff 73 0c             	pushl  0xc(%ebx)
  101a3b:	ff 73 08             	pushl  0x8(%ebx)
  101a3e:	ff 73 04             	pushl  0x4(%ebx)
  101a41:	ff 33                	pushl  (%ebx)
  101a43:	57                   	push   %edi
  101a44:	56                   	push   %esi
  101a45:	e8 0e fe ff ff       	call   101858 <print_formatted>
  101a4a:	83 c4 34             	add    $0x34,%esp
				args[3], args[4], args[5], args[6],  args[7],
				args[8], args[9], args[10]);
		break;
  101a4d:	e9 cf 00 00 00       	jmp    101b21 <std_print+0x2ab>
	case 12:
		print_formatted(log_output, str, args[0], args[1], args[2],
  101a52:	ff 73 2c             	pushl  0x2c(%ebx)
  101a55:	ff 73 28             	pushl  0x28(%ebx)
  101a58:	ff 73 24             	pushl  0x24(%ebx)
  101a5b:	ff 73 20             	pushl  0x20(%ebx)
  101a5e:	ff 73 1c             	pushl  0x1c(%ebx)
  101a61:	ff 73 18             	pushl  0x18(%ebx)
  101a64:	ff 73 14             	pushl  0x14(%ebx)
  101a67:	ff 73 10             	pushl  0x10(%ebx)
  101a6a:	ff 73 0c             	pushl  0xc(%ebx)
  101a6d:	ff 73 08             	pushl  0x8(%ebx)
  101a70:	ff 73 04             	pushl  0x4(%ebx)
  101a73:	ff 33                	pushl  (%ebx)
  101a75:	57                   	push   %edi
  101a76:	56                   	push   %esi
  101a77:	e8 dc fd ff ff       	call   101858 <print_formatted>
  101a7c:	83 c4 38             	add    $0x38,%esp
				args[3], args[4], args[5], args[6],  args[7],
				args[8], args[9], args[10], args[11]);
		break;
  101a7f:	e9 9d 00 00 00       	jmp    101b21 <std_print+0x2ab>
	case 13:
		print_formatted(log_output, str, args[0], args[1], args[2],
  101a84:	ff 73 30             	pushl  0x30(%ebx)
  101a87:	ff 73 2c             	pushl  0x2c(%ebx)
  101a8a:	ff 73 28             	pushl  0x28(%ebx)
  101a8d:	ff 73 24             	pushl  0x24(%ebx)
  101a90:	ff 73 20             	pushl  0x20(%ebx)
  101a93:	ff 73 1c             	pushl  0x1c(%ebx)
  101a96:	ff 73 18             	pushl  0x18(%ebx)
  101a99:	ff 73 14             	pushl  0x14(%ebx)
  101a9c:	ff 73 10             	pushl  0x10(%ebx)
  101a9f:	ff 73 0c             	pushl  0xc(%ebx)
  101aa2:	ff 73 08             	pushl  0x8(%ebx)
  101aa5:	ff 73 04             	pushl  0x4(%ebx)
  101aa8:	ff 33                	pushl  (%ebx)
  101aaa:	57                   	push   %edi
  101aab:	56                   	push   %esi
  101aac:	e8 a7 fd ff ff       	call   101858 <print_formatted>
  101ab1:	83 c4 3c             	add    $0x3c,%esp
				args[3], args[4], args[5], args[6],  args[7],
				args[8], args[9], args[10], args[11], args[12]);
		break;
  101ab4:	eb 6b                	jmp    101b21 <std_print+0x2ab>
	case 14:
		print_formatted(log_output, str, args[0], args[1], args[2],
  101ab6:	ff 73 34             	pushl  0x34(%ebx)
  101ab9:	ff 73 30             	pushl  0x30(%ebx)
  101abc:	ff 73 2c             	pushl  0x2c(%ebx)
  101abf:	ff 73 28             	pushl  0x28(%ebx)
  101ac2:	ff 73 24             	pushl  0x24(%ebx)
  101ac5:	ff 73 20             	pushl  0x20(%ebx)
  101ac8:	ff 73 1c             	pushl  0x1c(%ebx)
  101acb:	ff 73 18             	pushl  0x18(%ebx)
  101ace:	ff 73 14             	pushl  0x14(%ebx)
  101ad1:	ff 73 10             	pushl  0x10(%ebx)
  101ad4:	ff 73 0c             	pushl  0xc(%ebx)
  101ad7:	ff 73 08             	pushl  0x8(%ebx)
  101ada:	ff 73 04             	pushl  0x4(%ebx)
  101add:	ff 33                	pushl  (%ebx)
  101adf:	57                   	push   %edi
  101ae0:	56                   	push   %esi
  101ae1:	e8 72 fd ff ff       	call   101858 <print_formatted>
  101ae6:	83 c4 40             	add    $0x40,%esp
				args[3], args[4], args[5], args[6],  args[7],
				args[8], args[9], args[10], args[11], args[12],
				args[13]);
		break;
  101ae9:	eb 36                	jmp    101b21 <std_print+0x2ab>
	case 15:
		print_formatted(log_output, str, args[0], args[1], args[2],
  101aeb:	ff 73 38             	pushl  0x38(%ebx)
  101aee:	ff 73 34             	pushl  0x34(%ebx)
  101af1:	ff 73 30             	pushl  0x30(%ebx)
  101af4:	ff 73 2c             	pushl  0x2c(%ebx)
  101af7:	ff 73 28             	pushl  0x28(%ebx)
  101afa:	ff 73 24             	pushl  0x24(%ebx)
  101afd:	ff 73 20             	pushl  0x20(%ebx)
  101b00:	ff 73 1c             	pushl  0x1c(%ebx)
  101b03:	ff 73 18             	pushl  0x18(%ebx)
  101b06:	ff 73 14             	pushl  0x14(%ebx)
  101b09:	ff 73 10             	pushl  0x10(%ebx)
  101b0c:	ff 73 0c             	pushl  0xc(%ebx)
  101b0f:	ff 73 08             	pushl  0x8(%ebx)
  101b12:	ff 73 04             	pushl  0x4(%ebx)
  101b15:	ff 33                	pushl  (%ebx)
  101b17:	57                   	push   %edi
  101b18:	56                   	push   %esi
  101b19:	e8 3a fd ff ff       	call   101858 <print_formatted>
  101b1e:	83 c4 44             	add    $0x44,%esp
	default:
		/* Unsupported number of arguments. */
		__ASSERT_NO_MSG(true);
		break;
	}
}
  101b21:	8d 65 f4             	lea    -0xc(%ebp),%esp
  101b24:	5b                   	pop    %ebx
  101b25:	5e                   	pop    %esi
  101b26:	5f                   	pop    %edi
  101b27:	5d                   	pop    %ebp
  101b28:	c3                   	ret    

00101b29 <prefix_print>:
}

static u32_t prefix_print(const struct log_output *log_output,
			 u32_t flags, bool func_on, u32_t timestamp, u8_t level,
			 u8_t domain_id, u16_t source_id)
{
  101b29:	55                   	push   %ebp
  101b2a:	89 e5                	mov    %esp,%ebp
  101b2c:	57                   	push   %edi
  101b2d:	56                   	push   %esi
  101b2e:	89 c6                	mov    %eax,%esi
  101b30:	53                   	push   %ebx
  101b31:	83 ec 1c             	sub    $0x1c,%esp
  101b34:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
  101b37:	8b 45 0c             	mov    0xc(%ebp),%eax
  101b3a:	8b 5d 08             	mov    0x8(%ebp),%ebx
  101b3d:	89 45 e0             	mov    %eax,-0x20(%ebp)
  101b40:	8b 45 10             	mov    0x10(%ebp),%eax
  101b43:	89 45 dc             	mov    %eax,-0x24(%ebp)
  101b46:	8b 45 14             	mov    0x14(%ebp),%eax
  101b49:	89 45 d8             	mov    %eax,-0x28(%ebp)
	u32_t length = 0U;

	bool stamp = flags & LOG_OUTPUT_FLAG_TIMESTAMP;
	bool colors_on = flags & LOG_OUTPUT_FLAG_COLORS;
  101b4c:	89 d0                	mov    %edx,%eax
  101b4e:	83 e0 01             	and    $0x1,%eax
  101b51:	89 45 ec             	mov    %eax,-0x14(%ebp)
	bool level_on = flags & LOG_OUTPUT_FLAG_LEVEL;
  101b54:	89 d0                	mov    %edx,%eax
  101b56:	83 e0 08             	and    $0x8,%eax
  101b59:	89 45 e8             	mov    %eax,-0x18(%ebp)
			"<%d>1 ",
			facility * 8 +
			level_to_rfc5424_severity(level));
	}

	if (stamp) {
  101b5c:	89 d0                	mov    %edx,%eax
  101b5e:	83 e0 02             	and    $0x2,%eax
  101b61:	89 45 f0             	mov    %eax,-0x10(%ebp)
  101b64:	74 7a                	je     101be0 <prefix_print+0xb7>
	if (!format) {
  101b66:	80 e2 44             	and    $0x44,%dl
  101b69:	75 11                	jne    101b7c <prefix_print+0x53>
		length = print_formatted(log_output, "[%08lu] ", timestamp);
  101b6b:	53                   	push   %ebx
  101b6c:	68 5c df 10 00       	push   $0x10df5c
  101b71:	56                   	push   %esi
  101b72:	e8 e1 fc ff ff       	call   101858 <print_formatted>
  101b77:	83 c4 0c             	add    $0xc,%esp
  101b7a:	eb 61                	jmp    101bdd <prefix_print+0xb4>
	} else if (freq != 0U) {
  101b7c:	8b 3d b0 0a 11 00    	mov    0x110ab0,%edi
		length = 0;
  101b82:	31 c0                	xor    %eax,%eax
	} else if (freq != 0U) {
  101b84:	85 ff                	test   %edi,%edi
  101b86:	74 55                	je     101bdd <prefix_print+0xb4>
		timestamp /= timestamp_div;
  101b88:	89 d8                	mov    %ebx,%eax
  101b8a:	31 d2                	xor    %edx,%edx
  101b8c:	f7 35 ac 0a 11 00    	divl   0x110aac
  101b92:	31 d2                	xor    %edx,%edx
  101b94:	b9 10 0e 00 00       	mov    $0xe10,%ecx
  101b99:	f7 f7                	div    %edi
  101b9b:	89 d3                	mov    %edx,%ebx
		seconds -= hours * 3600U;
  101b9d:	31 d2                	xor    %edx,%edx
		ms = (remainder * 1000U) / freq;
  101b9f:	69 db e8 03 00 00    	imul   $0x3e8,%ebx,%ebx
  101ba5:	f7 f1                	div    %ecx
  101ba7:	89 55 f0             	mov    %edx,-0x10(%ebp)
  101baa:	89 c1                	mov    %eax,%ecx
  101bac:	31 d2                	xor    %edx,%edx
  101bae:	89 d8                	mov    %ebx,%eax
  101bb0:	f7 f7                	div    %edi
  101bb2:	89 c3                	mov    %eax,%ebx
		us = (1000 * (remainder * 1000U - (ms * freq))) / freq;
  101bb4:	69 c2 e8 03 00 00    	imul   $0x3e8,%edx,%eax
  101bba:	31 d2                	xor    %edx,%edx
  101bbc:	f7 f7                	div    %edi
			length = print_formatted(log_output,
  101bbe:	50                   	push   %eax
  101bbf:	31 d2                	xor    %edx,%edx
  101bc1:	53                   	push   %ebx
  101bc2:	8b 45 f0             	mov    -0x10(%ebp),%eax
  101bc5:	bb 3c 00 00 00       	mov    $0x3c,%ebx
  101bca:	f7 f3                	div    %ebx
  101bcc:	52                   	push   %edx
  101bcd:	50                   	push   %eax
  101bce:	51                   	push   %ecx
  101bcf:	68 65 df 10 00       	push   $0x10df65
  101bd4:	56                   	push   %esi
  101bd5:	e8 7e fc ff ff       	call   101858 <print_formatted>
  101bda:	83 c4 1c             	add    $0x1c,%esp
		length += timestamp_print(log_output, flags, timestamp);
  101bdd:	89 45 f0             	mov    %eax,-0x10(%ebp)
			log_output->control_block->hostname ?
			log_output->control_block->hostname :
			"zephyr");

	} else {
		color_prefix(log_output, colors_on, level);
  101be0:	0f b6 5d e0          	movzbl -0x20(%ebp),%ebx
	if (color) {
  101be4:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
  101be8:	74 1f                	je     101c09 <prefix_print+0xe0>
		const char *color = start && (colors[level] != NULL) ?
  101bea:	8b 04 9d c8 d9 10 00 	mov    0x10d9c8(,%ebx,4),%eax
  101bf1:	85 c0                	test   %eax,%eax
  101bf3:	75 05                	jne    101bfa <prefix_print+0xd1>
				colors[level] : LOG_COLOR_CODE_DEFAULT;
  101bf5:	b8 4e df 10 00       	mov    $0x10df4e,%eax
		print_formatted(log_output, "%s", color);
  101bfa:	50                   	push   %eax
  101bfb:	68 7b e4 10 00       	push   $0x10e47b
  101c00:	56                   	push   %esi
  101c01:	e8 52 fc ff ff       	call   101858 <print_formatted>
  101c06:	83 c4 0c             	add    $0xc,%esp
		length += ids_print(log_output, level_on, func_on,
  101c09:	0f b7 55 d8          	movzwl -0x28(%ebp),%edx
  101c0d:	0f b6 7d dc          	movzbl -0x24(%ebp),%edi
	int total = 0;
  101c11:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	if (level_on) {
  101c18:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
  101c1c:	74 1e                	je     101c3c <prefix_print+0x113>
		total += print_formatted(log_output, "<%s> ", severity[level]);
  101c1e:	ff 34 9d dc d9 10 00 	pushl  0x10d9dc(,%ebx,4)
  101c25:	89 55 e8             	mov    %edx,-0x18(%ebp)
  101c28:	68 81 df 10 00       	push   $0x10df81
  101c2d:	56                   	push   %esi
  101c2e:	e8 25 fc ff ff       	call   101858 <print_formatted>
  101c33:	83 c4 0c             	add    $0xc,%esp
  101c36:	89 45 ec             	mov    %eax,-0x14(%ebp)
  101c39:	8b 55 e8             	mov    -0x18(%ebp),%edx
	total += print_formatted(log_output,
  101c3c:	52                   	push   %edx
  101c3d:	57                   	push   %edi
  101c3e:	e8 90 f6 ff ff       	call   1012d3 <log_source_name_get>
  101c43:	5a                   	pop    %edx
  101c44:	bf 53 df 10 00       	mov    $0x10df53,%edi
  101c49:	59                   	pop    %ecx
  101c4a:	80 7d e4 00          	cmpb   $0x0,-0x1c(%ebp)
  101c4e:	74 13                	je     101c63 <prefix_print+0x13a>
				((1 << level) & LOG_FUNCTION_PREFIX_MASK)) ?
  101c50:	ba 01 00 00 00       	mov    $0x1,%edx
  101c55:	88 d9                	mov    %bl,%cl
  101c57:	d3 e2                	shl    %cl,%edx
				(func_on &&
  101c59:	80 e2 10             	and    $0x10,%dl
  101c5c:	74 05                	je     101c63 <prefix_print+0x13a>
	total += print_formatted(log_output,
  101c5e:	bf 58 df 10 00       	mov    $0x10df58,%edi
  101c63:	50                   	push   %eax
  101c64:	57                   	push   %edi
  101c65:	56                   	push   %esi
  101c66:	e8 ed fb ff ff       	call   101858 <print_formatted>
  101c6b:	03 45 ec             	add    -0x14(%ebp),%eax
  101c6e:	83 c4 0c             	add    $0xc,%esp
		length += ids_print(log_output, level_on, func_on,
  101c71:	03 45 f0             	add    -0x10(%ebp),%eax
				    domain_id, source_id, level);
	}

	return length;
}
  101c74:	8d 65 f4             	lea    -0xc(%ebp),%esp
  101c77:	5b                   	pop    %ebx
  101c78:	5e                   	pop    %esi
  101c79:	5f                   	pop    %edi
  101c7a:	5d                   	pop    %ebp
  101c7b:	c3                   	ret    

00101c7c <hexdump_line_print>:
{
  101c7c:	55                   	push   %ebp
  101c7d:	89 e5                	mov    %esp,%ebp
  101c7f:	57                   	push   %edi
  101c80:	56                   	push   %esi
  101c81:	89 d6                	mov    %edx,%esi
  101c83:	53                   	push   %ebx
  101c84:	53                   	push   %ebx
  101c85:	89 c3                	mov    %eax,%ebx
  101c87:	8b 45 0c             	mov    0xc(%ebp),%eax
  101c8a:	89 4d f0             	mov    %ecx,-0x10(%ebp)
	if ((flags & LOG_OUTPUT_FLAG_CRLF_NONE) != 0U) {
  101c8d:	a8 10                	test   $0x10,%al
  101c8f:	75 18                	jne    101ca9 <hexdump_line_print+0x2d>
	if ((flags & LOG_OUTPUT_FLAG_CRLF_LFONLY) != 0U) {
  101c91:	a8 20                	test   $0x20,%al
  101c93:	74 07                	je     101c9c <hexdump_line_print+0x20>
		print_formatted(ctx, "\n");
  101c95:	68 7f e4 10 00       	push   $0x10e47f
  101c9a:	eb 05                	jmp    101ca1 <hexdump_line_print+0x25>
		print_formatted(ctx, "\r\n");
  101c9c:	68 e4 df 10 00       	push   $0x10dfe4
  101ca1:	53                   	push   %ebx
  101ca2:	e8 b1 fb ff ff       	call   101858 <print_formatted>
  101ca7:	58                   	pop    %eax
  101ca8:	5a                   	pop    %edx
{
  101ca9:	31 ff                	xor    %edi,%edi
	for (int i = 0; i < prefix_offset; i++) {
  101cab:	3b 7d 08             	cmp    0x8(%ebp),%edi
  101cae:	7d 10                	jge    101cc0 <hexdump_line_print+0x44>
		print_formatted(log_output, " ");
  101cb0:	68 8f df 10 00       	push   $0x10df8f
	for (int i = 0; i < prefix_offset; i++) {
  101cb5:	47                   	inc    %edi
		print_formatted(log_output, " ");
  101cb6:	53                   	push   %ebx
  101cb7:	e8 9c fb ff ff       	call   101858 <print_formatted>
  101cbc:	59                   	pop    %ecx
  101cbd:	58                   	pop    %eax
  101cbe:	eb eb                	jmp    101cab <hexdump_line_print+0x2f>
	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
  101cc0:	31 ff                	xor    %edi,%edi
		if (i < length) {
  101cc2:	39 7d f0             	cmp    %edi,-0x10(%ebp)
  101cc5:	76 15                	jbe    101cdc <hexdump_line_print+0x60>
			print_formatted(log_output, "%02x ", data[i]);
  101cc7:	0f b6 04 3e          	movzbl (%esi,%edi,1),%eax
  101ccb:	50                   	push   %eax
  101ccc:	68 87 df 10 00       	push   $0x10df87
  101cd1:	53                   	push   %ebx
  101cd2:	e8 81 fb ff ff       	call   101858 <print_formatted>
  101cd7:	83 c4 0c             	add    $0xc,%esp
  101cda:	eb 0d                	jmp    101ce9 <hexdump_line_print+0x6d>
			print_formatted(log_output, "   ");
  101cdc:	68 8d df 10 00       	push   $0x10df8d
  101ce1:	53                   	push   %ebx
  101ce2:	e8 71 fb ff ff       	call   101858 <print_formatted>
  101ce7:	58                   	pop    %eax
  101ce8:	5a                   	pop    %edx
	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
  101ce9:	47                   	inc    %edi
  101cea:	83 ff 08             	cmp    $0x8,%edi
  101ced:	75 d3                	jne    101cc2 <hexdump_line_print+0x46>
	print_formatted(log_output, "|");
  101cef:	68 91 df 10 00       	push   $0x10df91
  101cf4:	53                   	push   %ebx
  101cf5:	e8 5e fb ff ff       	call   101858 <print_formatted>
  101cfa:	59                   	pop    %ecx
  101cfb:	5f                   	pop    %edi
	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
  101cfc:	31 ff                	xor    %edi,%edi
		if (i < length) {
  101cfe:	39 7d f0             	cmp    %edi,-0x10(%ebp)
  101d01:	76 22                	jbe    101d25 <hexdump_line_print+0xa9>
			      isprint((int)c) ? c : '.');
  101d03:	0f be 04 3e          	movsbl (%esi,%edi,1),%eax
	return (int)((((unsigned)c) >= ' ') &&
  101d07:	8d 48 e0             	lea    -0x20(%eax),%ecx
			print_formatted(log_output, "%c",
  101d0a:	83 f9 5e             	cmp    $0x5e,%ecx
  101d0d:	76 05                	jbe    101d14 <hexdump_line_print+0x98>
  101d0f:	b8 2e 00 00 00       	mov    $0x2e,%eax
  101d14:	50                   	push   %eax
  101d15:	68 9c e4 10 00       	push   $0x10e49c
  101d1a:	53                   	push   %ebx
  101d1b:	e8 38 fb ff ff       	call   101858 <print_formatted>
  101d20:	83 c4 0c             	add    $0xc,%esp
  101d23:	eb 0d                	jmp    101d32 <hexdump_line_print+0xb6>
			print_formatted(log_output, " ");
  101d25:	68 8f df 10 00       	push   $0x10df8f
  101d2a:	53                   	push   %ebx
  101d2b:	e8 28 fb ff ff       	call   101858 <print_formatted>
  101d30:	58                   	pop    %eax
  101d31:	5a                   	pop    %edx
	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
  101d32:	47                   	inc    %edi
  101d33:	83 ff 08             	cmp    $0x8,%edi
  101d36:	75 c6                	jne    101cfe <hexdump_line_print+0x82>
}
  101d38:	8d 65 f4             	lea    -0xc(%ebp),%esp
  101d3b:	5b                   	pop    %ebx
  101d3c:	5e                   	pop    %esi
  101d3d:	5f                   	pop    %edi
  101d3e:	5d                   	pop    %ebp
  101d3f:	c3                   	ret    

00101d40 <postfix_print>:

static void postfix_print(const struct log_output *log_output,
			  u32_t flags, u8_t level)
{
  101d40:	55                   	push   %ebp
  101d41:	89 e5                	mov    %esp,%ebp
  101d43:	56                   	push   %esi
  101d44:	53                   	push   %ebx
  101d45:	89 d6                	mov    %edx,%esi
  101d47:	89 c3                	mov    %eax,%ebx
	if (color) {
  101d49:	83 e2 01             	and    $0x1,%edx
  101d4c:	74 13                	je     101d61 <postfix_print+0x21>
		print_formatted(log_output, "%s", color);
  101d4e:	68 4e df 10 00       	push   $0x10df4e
  101d53:	68 7b e4 10 00       	push   $0x10e47b
  101d58:	50                   	push   %eax
  101d59:	e8 fa fa ff ff       	call   101858 <print_formatted>
  101d5e:	83 c4 0c             	add    $0xc,%esp
	if ((flags & LOG_OUTPUT_FLAG_CRLF_NONE) != 0U) {
  101d61:	f7 c6 10 00 00 00    	test   $0x10,%esi
  101d67:	75 19                	jne    101d82 <postfix_print+0x42>
	if ((flags & LOG_OUTPUT_FLAG_CRLF_LFONLY) != 0U) {
  101d69:	83 e6 20             	and    $0x20,%esi
  101d6c:	74 07                	je     101d75 <postfix_print+0x35>
		print_formatted(ctx, "\n");
  101d6e:	68 7f e4 10 00       	push   $0x10e47f
  101d73:	eb 05                	jmp    101d7a <postfix_print+0x3a>
		print_formatted(ctx, "\r\n");
  101d75:	68 e4 df 10 00       	push   $0x10dfe4
  101d7a:	53                   	push   %ebx
  101d7b:	e8 d8 fa ff ff       	call   101858 <print_formatted>
  101d80:	58                   	pop    %eax
  101d81:	5a                   	pop    %edx
	color_postfix(log_output, (flags & LOG_OUTPUT_FLAG_COLORS),
			      level);
	newline_print(log_output, flags);
}
  101d82:	8d 65 f8             	lea    -0x8(%ebp),%esp
  101d85:	5b                   	pop    %ebx
  101d86:	5e                   	pop    %esi
  101d87:	5d                   	pop    %ebp
  101d88:	c3                   	ret    

00101d89 <log_output_flush>:
{
  101d89:	55                   	push   %ebp
  101d8a:	89 e5                	mov    %esp,%ebp
  101d8c:	53                   	push   %ebx
  101d8d:	8b 5d 08             	mov    0x8(%ebp),%ebx
		     log_output->control_block->ctx);
  101d90:	8b 43 04             	mov    0x4(%ebx),%eax
	buffer_write(log_output->func, log_output->buf,
  101d93:	8b 53 08             	mov    0x8(%ebx),%edx
  101d96:	ff 70 04             	pushl  0x4(%eax)
  101d99:	8b 08                	mov    (%eax),%ecx
  101d9b:	8b 03                	mov    (%ebx),%eax
  101d9d:	e8 92 fa ff ff       	call   101834 <buffer_write>
  101da2:	58                   	pop    %eax
	log_output->control_block->offset = 0;
  101da3:	8b 43 04             	mov    0x4(%ebx),%eax
}
  101da6:	8b 5d fc             	mov    -0x4(%ebp),%ebx
	log_output->control_block->offset = 0;
  101da9:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
}
  101daf:	c9                   	leave  
  101db0:	c3                   	ret    

00101db1 <out_func>:
{
  101db1:	55                   	push   %ebp
  101db2:	89 e5                	mov    %esp,%ebp
  101db4:	53                   	push   %ebx
  101db5:	8b 45 0c             	mov    0xc(%ebp),%eax
	out_ctx->buf[out_ctx->control_block->offset] = (u8_t)c;
  101db8:	8a 5d 08             	mov    0x8(%ebp),%bl
  101dbb:	8b 50 04             	mov    0x4(%eax),%edx
  101dbe:	8b 48 08             	mov    0x8(%eax),%ecx
  101dc1:	8b 12                	mov    (%edx),%edx
  101dc3:	88 1c 11             	mov    %bl,(%ecx,%edx,1)
	out_ctx->control_block->offset++;
  101dc6:	8b 48 04             	mov    0x4(%eax),%ecx
  101dc9:	8b 19                	mov    (%ecx),%ebx
  101dcb:	8d 53 01             	lea    0x1(%ebx),%edx
  101dce:	89 11                	mov    %edx,(%ecx)
	if (out_ctx->control_block->offset == out_ctx->size) {
  101dd0:	3b 50 0c             	cmp    0xc(%eax),%edx
  101dd3:	75 07                	jne    101ddc <out_func+0x2b>
		log_output_flush(out_ctx);
  101dd5:	50                   	push   %eax
  101dd6:	e8 ae ff ff ff       	call   101d89 <log_output_flush>
  101ddb:	58                   	pop    %eax
}
  101ddc:	31 c0                	xor    %eax,%eax
  101dde:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  101de1:	c9                   	leave  
  101de2:	c3                   	ret    

00101de3 <log_output_msg_process>:

void log_output_msg_process(const struct log_output *log_output,
			    struct log_msg *msg,
			    u32_t flags)
{
  101de3:	55                   	push   %ebp
  101de4:	89 e5                	mov    %esp,%ebp
  101de6:	57                   	push   %edi
  101de7:	56                   	push   %esi
  101de8:	53                   	push   %ebx
  101de9:	83 ec 14             	sub    $0x14,%esp
	u16_t source_id = (u16_t)log_msg_source_id_get(msg);
	bool raw_string = (level == LOG_LEVEL_INTERNAL_RAW_STRING);
	int prefix_offset;

	prefix_offset = raw_string ?
			0 : prefix_print(log_output, flags, std_msg, timestamp,
  101dec:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
{
  101df3:	8b 7d 0c             	mov    0xc(%ebp),%edi
  101df6:	8b 5d 08             	mov    0x8(%ebp),%ebx
	return msg->hdr.ids.level;
  101df9:	8a 47 0a             	mov    0xa(%edi),%al
  101dfc:	66 8b 4f 08          	mov    0x8(%edi),%cx
			0 : prefix_print(log_output, flags, std_msg, timestamp,
  101e00:	88 c2                	mov    %al,%dl
  101e02:	80 e2 07             	and    $0x7,%dl
  101e05:	88 55 e7             	mov    %dl,-0x19(%ebp)
  101e08:	74 30                	je     101e3a <log_output_msg_process+0x57>
	return msg->hdr.ids.domain_id;
  101e0a:	c0 e8 03             	shr    $0x3,%al
	return msg->hdr.ids.source_id;
  101e0d:	66 8b 57 0a          	mov    0xa(%edi),%dx
  101e11:	66 c1 ea 06          	shr    $0x6,%dx
  101e15:	83 e0 07             	and    $0x7,%eax
  101e18:	0f b7 d2             	movzwl %dx,%edx
  101e1b:	52                   	push   %edx
  101e1c:	8b 55 10             	mov    0x10(%ebp),%edx
  101e1f:	50                   	push   %eax
  101e20:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
  101e24:	50                   	push   %eax
  101e25:	89 d8                	mov    %ebx,%eax
  101e27:	ff 77 0c             	pushl  0xc(%edi)
  101e2a:	f7 d1                	not    %ecx
  101e2c:	83 e1 01             	and    $0x1,%ecx
  101e2f:	e8 f5 fc ff ff       	call   101b29 <prefix_print>
  101e34:	83 c4 10             	add    $0x10,%esp
  101e37:	89 45 e0             	mov    %eax,-0x20(%ebp)
					 level, domain_id, source_id);

	if (log_msg_is_std(msg)) {
  101e3a:	f6 47 08 01          	testb  $0x1,0x8(%edi)
  101e3e:	75 18                	jne    101e58 <log_output_msg_process+0x75>
		std_print(msg, log_output);
  101e40:	89 da                	mov    %ebx,%edx
  101e42:	89 f8                	mov    %edi,%eax
  101e44:	e8 2d fa ff ff       	call   101876 <std_print>
		raw_string_print(msg, log_output);
	} else {
		hexdump_print(msg, log_output, prefix_offset, flags);
	}

	if (!raw_string) {
  101e49:	80 7d e7 00          	cmpb   $0x0,-0x19(%ebp)
  101e4d:	0f 84 c3 00 00 00    	je     101f16 <log_output_msg_process+0x133>
  101e53:	e9 b0 00 00 00       	jmp    101f08 <log_output_msg_process+0x125>
	} else if (raw_string) {
  101e58:	80 7d e7 00          	cmpb   $0x0,-0x19(%ebp)
  101e5c:	75 5a                	jne    101eb8 <log_output_msg_process+0xd5>
	bool eol = false;
  101e5e:	c6 45 e7 00          	movb   $0x0,-0x19(%ebp)
	size_t offset = 0;
  101e62:	31 f6                	xor    %esi,%esi
		length = log_output->size;
  101e64:	8b 43 0c             	mov    0xc(%ebx),%eax
		log_msg_hexdump_data_get(msg, log_output->buf, &length, offset);
  101e67:	56                   	push   %esi
		length = log_output->size;
  101e68:	89 45 ec             	mov    %eax,-0x14(%ebp)
		log_msg_hexdump_data_get(msg, log_output->buf, &length, offset);
  101e6b:	8d 45 ec             	lea    -0x14(%ebp),%eax
  101e6e:	50                   	push   %eax
  101e6f:	ff 73 08             	pushl  0x8(%ebx)
  101e72:	57                   	push   %edi
  101e73:	e8 9d f9 ff ff       	call   101815 <log_msg_hexdump_data_get>
		log_output->control_block->offset = length;
  101e78:	8b 53 04             	mov    0x4(%ebx),%edx
  101e7b:	8b 45 ec             	mov    -0x14(%ebp),%eax
		log_msg_hexdump_data_get(msg, log_output->buf, &length, offset);
  101e7e:	83 c4 10             	add    $0x10,%esp
		if (length != 0) {
  101e81:	85 c0                	test   %eax,%eax
		log_output->control_block->offset = length;
  101e83:	89 02                	mov    %eax,(%edx)
		if (length != 0) {
  101e85:	74 0c                	je     101e93 <log_output_msg_process+0xb0>
			eol = (log_output->buf[length - 1] == '\n');
  101e87:	8b 53 08             	mov    0x8(%ebx),%edx
  101e8a:	80 7c 02 ff 0a       	cmpb   $0xa,-0x1(%edx,%eax,1)
  101e8f:	0f 94 45 e7          	sete   -0x19(%ebp)
		log_output_flush(log_output);
  101e93:	53                   	push   %ebx
  101e94:	e8 f0 fe ff ff       	call   101d89 <log_output_flush>
  101e99:	58                   	pop    %eax
		offset += length;
  101e9a:	8b 45 ec             	mov    -0x14(%ebp),%eax
  101e9d:	01 c6                	add    %eax,%esi
	} while (length > 0);
  101e9f:	85 c0                	test   %eax,%eax
  101ea1:	75 c1                	jne    101e64 <log_output_msg_process+0x81>
	if (eol) {
  101ea3:	80 7d e7 00          	cmpb   $0x0,-0x19(%ebp)
  101ea7:	74 6d                	je     101f16 <log_output_msg_process+0x133>
		print_formatted(log_output, "\r");
  101ea9:	68 93 df 10 00       	push   $0x10df93
  101eae:	53                   	push   %ebx
  101eaf:	e8 a4 f9 ff ff       	call   101858 <print_formatted>
  101eb4:	5e                   	pop    %esi
  101eb5:	5f                   	pop    %edi
	if (!raw_string) {
  101eb6:	eb 5e                	jmp    101f16 <log_output_msg_process+0x133>
	print_formatted(log_output, "%s", log_msg_str_get(msg));
  101eb8:	57                   	push   %edi
  101eb9:	e8 4c f9 ff ff       	call   10180a <log_msg_str_get>
  101ebe:	89 04 24             	mov    %eax,(%esp)
  101ec1:	68 7b e4 10 00       	push   $0x10e47b
  101ec6:	53                   	push   %ebx
	u32_t offset = 0U;
  101ec7:	31 f6                	xor    %esi,%esi
	print_formatted(log_output, "%s", log_msg_str_get(msg));
  101ec9:	e8 8a f9 ff ff       	call   101858 <print_formatted>
  101ece:	83 c4 0c             	add    $0xc,%esp
		log_msg_hexdump_data_get(msg, buf, &length, offset);
  101ed1:	56                   	push   %esi
  101ed2:	8d 45 e8             	lea    -0x18(%ebp),%eax
  101ed5:	50                   	push   %eax
  101ed6:	8d 55 ec             	lea    -0x14(%ebp),%edx
  101ed9:	52                   	push   %edx
		length = sizeof(buf);
  101eda:	c7 45 e8 08 00 00 00 	movl   $0x8,-0x18(%ebp)
		log_msg_hexdump_data_get(msg, buf, &length, offset);
  101ee1:	57                   	push   %edi
  101ee2:	e8 2e f9 ff ff       	call   101815 <log_msg_hexdump_data_get>
		if (length) {
  101ee7:	8b 4d e8             	mov    -0x18(%ebp),%ecx
		log_msg_hexdump_data_get(msg, buf, &length, offset);
  101eea:	83 c4 10             	add    $0x10,%esp
		if (length) {
  101eed:	85 c9                	test   %ecx,%ecx
  101eef:	74 17                	je     101f08 <log_output_msg_process+0x125>
			hexdump_line_print(log_output, buf, length,
  101ef1:	ff 75 10             	pushl  0x10(%ebp)
  101ef4:	ff 75 e0             	pushl  -0x20(%ebp)
  101ef7:	8d 55 ec             	lea    -0x14(%ebp),%edx
  101efa:	89 d8                	mov    %ebx,%eax
  101efc:	e8 7b fd ff ff       	call   101c7c <hexdump_line_print>
  101f01:	5a                   	pop    %edx
  101f02:	59                   	pop    %ecx
			offset += length;
  101f03:	03 75 e8             	add    -0x18(%ebp),%esi
  101f06:	eb c9                	jmp    101ed1 <log_output_msg_process+0xee>
		postfix_print(log_output, flags, level);
  101f08:	0f b6 4d e7          	movzbl -0x19(%ebp),%ecx
  101f0c:	8b 55 10             	mov    0x10(%ebp),%edx
  101f0f:	89 d8                	mov    %ebx,%eax
  101f11:	e8 2a fe ff ff       	call   101d40 <postfix_print>
	}

	log_output_flush(log_output);
  101f16:	53                   	push   %ebx
  101f17:	e8 6d fe ff ff       	call   101d89 <log_output_flush>
  101f1c:	58                   	pop    %eax
}
  101f1d:	8d 65 f4             	lea    -0xc(%ebp),%esp
  101f20:	5b                   	pop    %ebx
  101f21:	5e                   	pop    %esi
  101f22:	5f                   	pop    %edi
  101f23:	5d                   	pop    %ebp
  101f24:	c3                   	ret    

00101f25 <log_output_dropped_process>:
	postfix_print(log_output, flags, level);
	log_output_flush(log_output);
}

void log_output_dropped_process(const struct log_output *log_output, u32_t cnt)
{
  101f25:	55                   	push   %ebp
  101f26:	89 e5                	mov    %esp,%ebp
  101f28:	57                   	push   %edi
  101f29:	56                   	push   %esi
  101f2a:	53                   	push   %ebx
  101f2b:	83 ec 0c             	sub    $0xc,%esp
  101f2e:	8b 45 08             	mov    0x8(%ebp),%eax
	char buf[5];
	int len;
	static const char prefix[] = DROPPED_COLOR_PREFIX "--- ";
	static const char postfix[] =
			" messages dropped ---\r\n" DROPPED_COLOR_POSTFIX;
	log_output_func_t outf = log_output->func;
  101f31:	8b 18                	mov    (%eax),%ebx
	struct device *dev = (struct device *)log_output->control_block->ctx;
  101f33:	8b 40 04             	mov    0x4(%eax),%eax
  101f36:	8b 70 04             	mov    0x4(%eax),%esi

	cnt = MIN(cnt, 9999);
  101f39:	8b 45 0c             	mov    0xc(%ebp),%eax
  101f3c:	3d 0f 27 00 00       	cmp    $0x270f,%eax
  101f41:	76 05                	jbe    101f48 <log_output_dropped_process+0x23>
  101f43:	b8 0f 27 00 00       	mov    $0x270f,%eax
	len = snprintf(buf, sizeof(buf), "%d", cnt);
  101f48:	50                   	push   %eax
  101f49:	8d 7d ef             	lea    -0x11(%ebp),%edi
  101f4c:	68 95 e4 10 00       	push   $0x10e495
  101f51:	6a 05                	push   $0x5
  101f53:	57                   	push   %edi
  101f54:	e8 2a 5d 00 00       	call   107c83 <snprintf>
  101f59:	83 c4 10             	add    $0x10,%esp
  101f5c:	89 45 e8             	mov    %eax,-0x18(%ebp)

	buffer_write(outf, (u8_t *)prefix, sizeof(prefix) - 1, dev);
  101f5f:	b9 04 00 00 00       	mov    $0x4,%ecx
  101f64:	89 d8                	mov    %ebx,%eax
  101f66:	ba c0 d9 10 00       	mov    $0x10d9c0,%edx
  101f6b:	56                   	push   %esi
  101f6c:	e8 c3 f8 ff ff       	call   101834 <buffer_write>
	buffer_write(outf, buf, len, dev);
  101f71:	8b 4d e8             	mov    -0x18(%ebp),%ecx
  101f74:	89 fa                	mov    %edi,%edx
  101f76:	89 d8                	mov    %ebx,%eax
  101f78:	89 34 24             	mov    %esi,(%esp)
  101f7b:	e8 b4 f8 ff ff       	call   101834 <buffer_write>
	buffer_write(outf, (u8_t *)postfix, sizeof(postfix) - 1, dev);
  101f80:	89 d8                	mov    %ebx,%eax
  101f82:	b9 17 00 00 00       	mov    $0x17,%ecx
  101f87:	ba a8 d9 10 00       	mov    $0x10d9a8,%edx
  101f8c:	89 34 24             	mov    %esi,(%esp)
  101f8f:	e8 a0 f8 ff ff       	call   101834 <buffer_write>
  101f94:	58                   	pop    %eax
}
  101f95:	8d 65 f4             	lea    -0xc(%ebp),%esp
  101f98:	5b                   	pop    %ebx
  101f99:	5e                   	pop    %esi
  101f9a:	5f                   	pop    %edi
  101f9b:	5d                   	pop    %ebp
  101f9c:	c3                   	ret    

00101f9d <log_output_timestamp_freq_set>:

void log_output_timestamp_freq_set(u32_t frequency)
{
  101f9d:	55                   	push   %ebp
	timestamp_div = 1U;
  101f9e:	c7 05 ac 0a 11 00 01 	movl   $0x1,0x110aac
  101fa5:	00 00 00 
{
  101fa8:	89 e5                	mov    %esp,%ebp
	/* There is no point to have frequency higher than 1MHz (ns are not
	 * printed) and too high frequency leads to overflows in calculations.
	 */
	while (frequency > 1000000) {
  101faa:	31 c9                	xor    %ecx,%ecx
  101fac:	ba 01 00 00 00       	mov    $0x1,%edx
{
  101fb1:	8b 45 08             	mov    0x8(%ebp),%eax
	while (frequency > 1000000) {
  101fb4:	3d 40 42 0f 00       	cmp    $0xf4240,%eax
  101fb9:	76 08                	jbe    101fc3 <log_output_timestamp_freq_set+0x26>
		frequency /= 2U;
  101fbb:	d1 e8                	shr    %eax
		timestamp_div *= 2U;
  101fbd:	01 d2                	add    %edx,%edx
  101fbf:	b1 01                	mov    $0x1,%cl
  101fc1:	eb f1                	jmp    101fb4 <log_output_timestamp_freq_set+0x17>
  101fc3:	84 c9                	test   %cl,%cl
  101fc5:	74 06                	je     101fcd <log_output_timestamp_freq_set+0x30>
  101fc7:	89 15 ac 0a 11 00    	mov    %edx,0x110aac
	}

	freq = frequency;
  101fcd:	a3 b0 0a 11 00       	mov    %eax,0x110ab0
}
  101fd2:	5d                   	pop    %ebp
  101fd3:	c3                   	ret    

00101fd4 <severity_lvl_get>:
	entry->syntax = log_source_name_get(CONFIG_LOG_DOMAIN_ID, idx);
}


static void severity_lvl_get(size_t idx, struct shell_static_entry *entry)
{
  101fd4:	55                   	push   %ebp
  101fd5:	31 d2                	xor    %edx,%edx
  101fd7:	89 e5                	mov    %esp,%ebp
  101fd9:	8b 45 0c             	mov    0xc(%ebp),%eax
  101fdc:	8b 4d 08             	mov    0x8(%ebp),%ecx
	entry->handler = NULL;
	entry->help  = NULL;
	entry->subcmd = &dsub_module_name;
	entry->syntax = (idx < ARRAY_SIZE(severity_lvls_sorted)) ?
					severity_lvls_sorted[idx] : NULL;
  101fdf:	83 f9 04             	cmp    $0x4,%ecx
	entry->handler = NULL;
  101fe2:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
	entry->help  = NULL;
  101fe9:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
	entry->subcmd = &dsub_module_name;
  101ff0:	c7 40 08 24 da 10 00 	movl   $0x10da24,0x8(%eax)
					severity_lvls_sorted[idx] : NULL;
  101ff7:	77 07                	ja     102000 <severity_lvl_get+0x2c>
  101ff9:	8b 14 8d 2c da 10 00 	mov    0x10da2c(,%ecx,4),%edx
	entry->syntax = (idx < ARRAY_SIZE(severity_lvls_sorted)) ?
  102000:	89 10                	mov    %edx,(%eax)
}
  102002:	5d                   	pop    %ebp
  102003:	c3                   	ret    

00102004 <log_halt>:

static int log_halt(const struct shell *shell,
		    const struct log_backend *backend,
		    size_t argc,
		    char **argv)
{
  102004:	55                   	push   %ebp
  102005:	89 e5                	mov    %esp,%ebp
	backend->cb->active = false;
  102007:	8b 45 0c             	mov    0xc(%ebp),%eax
  10200a:	8b 40 04             	mov    0x4(%eax),%eax
  10200d:	c6 40 05 00          	movb   $0x0,0x5(%eax)
	log_backend_deactivate(backend);
	return 0;
}
  102011:	31 c0                	xor    %eax,%eax
  102013:	5d                   	pop    %ebp
  102014:	c3                   	ret    

00102015 <log_go>:

static int log_go(const struct shell *shell,
		  const struct log_backend *backend,
		  size_t argc,
		  char **argv)
{
  102015:	55                   	push   %ebp
  102016:	89 e5                	mov    %esp,%ebp
	backend->cb->active = true;
  102018:	8b 45 0c             	mov    0xc(%ebp),%eax
  10201b:	8b 40 04             	mov    0x4(%eax),%eax
  10201e:	c6 40 05 01          	movb   $0x1,0x5(%eax)
	log_backend_activate(backend, backend->cb->ctx);
	return 0;
}
  102022:	31 c0                	xor    %eax,%eax
  102024:	5d                   	pop    %ebp
  102025:	c3                   	ret    

00102026 <backend_name_get>:
	SHELL_CMD(status, NULL, "Logger status", cmd_log_backend_status),
	SHELL_SUBCMD_SET_END
);

static void backend_name_get(size_t idx, struct shell_static_entry *entry)
{
  102026:	55                   	push   %ebp
	return __log_backends_end - __log_backends_start;
  102027:	ba 28 ba 10 00       	mov    $0x10ba28,%edx
  10202c:	89 e5                	mov    %esp,%ebp
  10202e:	81 ea 18 ba 10 00    	sub    $0x10ba18,%edx
  102034:	c1 fa 04             	sar    $0x4,%edx
  102037:	8b 45 0c             	mov    0xc(%ebp),%eax
  10203a:	8b 4d 08             	mov    0x8(%ebp),%ecx
	entry->handler = NULL;
	entry->help  = NULL;
	entry->subcmd = &sub_log_backend;
	entry->syntax  = NULL;

	if (idx < log_backend_count_get()) {
  10203d:	39 ca                	cmp    %ecx,%edx
	entry->handler = NULL;
  10203f:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
	entry->help  = NULL;
  102046:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
	entry->subcmd = &sub_log_backend;
  10204d:	c7 40 08 14 da 10 00 	movl   $0x10da14,0x8(%eax)
	entry->syntax  = NULL;
  102054:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	if (idx < log_backend_count_get()) {
  10205a:	76 0b                	jbe    102067 <backend_name_get+0x41>
		const struct log_backend *backend = log_backend_get(idx);

		entry->syntax = backend->name;
  10205c:	c1 e1 04             	shl    $0x4,%ecx
  10205f:	8b 91 20 ba 10 00    	mov    0x10ba20(%ecx),%edx
  102065:	89 10                	mov    %edx,(%eax)
	}
}
  102067:	5d                   	pop    %ebp
  102068:	c3                   	ret    

00102069 <cmd_log_backends_list>:
{
  102069:	55                   	push   %ebp
  10206a:	89 e5                	mov    %esp,%ebp
  10206c:	57                   	push   %edi
  10206d:	56                   	push   %esi
	for (int i = 0; i < backend_count; i++) {
  10206e:	31 ff                	xor    %edi,%edi
{
  102070:	53                   	push   %ebx
  102071:	bb 28 ba 10 00       	mov    $0x10ba28,%ebx
  102076:	81 eb 18 ba 10 00    	sub    $0x10ba18,%ebx
  10207c:	be 18 ba 10 00       	mov    $0x10ba18,%esi
  102081:	c1 fb 04             	sar    $0x4,%ebx
	for (int i = 0; i < backend_count; i++) {
  102084:	39 df                	cmp    %ebx,%edi
  102086:	7d 34                	jge    1020bc <cmd_log_backends_list+0x53>
			      backend->cb->id);
  102088:	8b 56 04             	mov    0x4(%esi),%edx
		shell_fprintf(shell, SHELL_NORMAL,
  10208b:	b8 b5 df 10 00       	mov    $0x10dfb5,%eax
  102090:	0f b6 4a 04          	movzbl 0x4(%edx),%ecx
  102094:	80 7a 05 00          	cmpb   $0x0,0x5(%edx)
  102098:	75 05                	jne    10209f <cmd_log_backends_list+0x36>
  10209a:	b8 bd df 10 00       	mov    $0x10dfbd,%eax
  10209f:	51                   	push   %ecx
	for (int i = 0; i < backend_count; i++) {
  1020a0:	47                   	inc    %edi
		shell_fprintf(shell, SHELL_NORMAL,
  1020a1:	50                   	push   %eax
  1020a2:	83 c6 10             	add    $0x10,%esi
  1020a5:	ff 76 f8             	pushl  -0x8(%esi)
  1020a8:	68 c6 df 10 00       	push   $0x10dfc6
  1020ad:	6a 00                	push   $0x0
  1020af:	ff 75 08             	pushl  0x8(%ebp)
  1020b2:	e8 68 18 00 00       	call   10391f <shell_fprintf>
  1020b7:	83 c4 18             	add    $0x18,%esp
  1020ba:	eb c8                	jmp    102084 <cmd_log_backends_list+0x1b>
}
  1020bc:	8d 65 f4             	lea    -0xc(%ebp),%esp
  1020bf:	31 c0                	xor    %eax,%eax
  1020c1:	5b                   	pop    %ebx
  1020c2:	5e                   	pop    %esi
  1020c3:	5f                   	pop    %edi
  1020c4:	5d                   	pop    %ebp
  1020c5:	c3                   	ret    

001020c6 <log_status>:
{
  1020c6:	55                   	push   %ebp
  1020c7:	b8 18 ba 10 00       	mov    $0x10ba18,%eax
  1020cc:	89 e5                	mov    %esp,%ebp
  1020ce:	57                   	push   %edi
  1020cf:	56                   	push   %esi
  1020d0:	2d e0 b9 10 00       	sub    $0x10b9e0,%eax
  1020d5:	c1 e8 03             	shr    $0x3,%eax
  1020d8:	53                   	push   %ebx
  1020d9:	83 ec 0c             	sub    $0xc,%esp
  1020dc:	89 45 f0             	mov    %eax,-0x10(%ebp)
  1020df:	8b 7d 0c             	mov    0xc(%ebp),%edi
  1020e2:	8b 75 08             	mov    0x8(%ebp),%esi
	return backend->cb->active;
  1020e5:	8b 47 04             	mov    0x4(%edi),%eax
	if (!log_backend_is_active(backend)) {
  1020e8:	80 78 05 00          	cmpb   $0x0,0x5(%eax)
  1020ec:	75 10                	jne    1020fe <log_status+0x38>
		shell_warn(shell, "Logs are halted!");
  1020ee:	68 e7 df 10 00       	push   $0x10dfe7
  1020f3:	6a 04                	push   $0x4
  1020f5:	56                   	push   %esi
  1020f6:	e8 24 18 00 00       	call   10391f <shell_fprintf>
  1020fb:	83 c4 0c             	add    $0xc,%esp
	shell_fprintf(shell, SHELL_NORMAL, "%-40s | current | built-in \r\n",
  1020fe:	68 f9 df 10 00       	push   $0x10dff9
	for (i = 0U; i < modules_cnt; i++) {
  102103:	31 db                	xor    %ebx,%ebx
	shell_fprintf(shell, SHELL_NORMAL, "%-40s | current | built-in \r\n",
  102105:	68 05 e0 10 00       	push   $0x10e005
  10210a:	6a 00                	push   $0x0
  10210c:	56                   	push   %esi
  10210d:	e8 0d 18 00 00       	call   10391f <shell_fprintf>
  102112:	83 c4 10             	add    $0x10,%esp
	shell_fprintf(shell, SHELL_NORMAL,
  102115:	68 23 e0 10 00       	push   $0x10e023
  10211a:	6a 00                	push   $0x0
  10211c:	56                   	push   %esi
  10211d:	e8 fd 17 00 00       	call   10391f <shell_fprintf>
  102122:	83 c4 0c             	add    $0xc,%esp
	for (i = 0U; i < modules_cnt; i++) {
  102125:	3b 5d f0             	cmp    -0x10(%ebp),%ebx
  102128:	74 5c                	je     102186 <log_status+0xc0>
		dynamic_lvl = log_filter_get(backend, CONFIG_LOG_DOMAIN_ID,
  10212a:	6a 01                	push   $0x1
  10212c:	53                   	push   %ebx
  10212d:	6a 00                	push   $0x0
  10212f:	57                   	push   %edi
  102130:	e8 0b f4 ff ff       	call   101540 <log_filter_get>
  102135:	83 c4 10             	add    $0x10,%esp
  102138:	89 45 ec             	mov    %eax,-0x14(%ebp)
		compiled_lvl = log_filter_get(backend, CONFIG_LOG_DOMAIN_ID,
  10213b:	6a 00                	push   $0x0
  10213d:	53                   	push   %ebx
  10213e:	6a 00                	push   $0x0
  102140:	57                   	push   %edi
  102141:	e8 fa f3 ff ff       	call   101540 <log_filter_get>
  102146:	83 c4 10             	add    $0x10,%esp
		shell_fprintf(shell, SHELL_NORMAL, "%-40s | %-7s | %s\r\n",
  102149:	8b 55 ec             	mov    -0x14(%ebp),%edx
  10214c:	8b 0c 85 40 da 10 00 	mov    0x10da40(,%eax,4),%ecx
  102153:	53                   	push   %ebx
  102154:	8b 14 95 40 da 10 00 	mov    0x10da40(,%edx,4),%edx
  10215b:	6a 00                	push   $0x0
  10215d:	89 4d e8             	mov    %ecx,-0x18(%ebp)
  102160:	89 55 ec             	mov    %edx,-0x14(%ebp)
  102163:	e8 6b f1 ff ff       	call   1012d3 <log_source_name_get>
  102168:	5a                   	pop    %edx
  102169:	8b 55 ec             	mov    -0x14(%ebp),%edx
  10216c:	59                   	pop    %ecx
  10216d:	8b 4d e8             	mov    -0x18(%ebp),%ecx
  102170:	51                   	push   %ecx
	for (i = 0U; i < modules_cnt; i++) {
  102171:	43                   	inc    %ebx
		shell_fprintf(shell, SHELL_NORMAL, "%-40s | %-7s | %s\r\n",
  102172:	52                   	push   %edx
  102173:	50                   	push   %eax
  102174:	68 60 e0 10 00       	push   $0x10e060
  102179:	6a 00                	push   $0x0
  10217b:	56                   	push   %esi
  10217c:	e8 9e 17 00 00       	call   10391f <shell_fprintf>
  102181:	83 c4 18             	add    $0x18,%esp
  102184:	eb 9f                	jmp    102125 <log_status+0x5f>
}
  102186:	8d 65 f4             	lea    -0xc(%ebp),%esp
  102189:	31 c0                	xor    %eax,%eax
  10218b:	5b                   	pop    %ebx
  10218c:	5e                   	pop    %esi
  10218d:	5f                   	pop    %edi
  10218e:	5d                   	pop    %ebp
  10218f:	c3                   	ret    

00102190 <module_name_get>:
{
  102190:	55                   	push   %ebp
  102191:	89 e5                	mov    %esp,%ebp
  102193:	53                   	push   %ebx
  102194:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	entry->handler = NULL;
  102197:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
	entry->help  = NULL;
  10219e:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
	entry->subcmd = &dsub_module_name;
  1021a5:	c7 43 08 24 da 10 00 	movl   $0x10da24,0x8(%ebx)
	entry->syntax = log_source_name_get(CONFIG_LOG_DOMAIN_ID, idx);
  1021ac:	ff 75 08             	pushl  0x8(%ebp)
  1021af:	6a 00                	push   $0x0
  1021b1:	e8 1d f1 ff ff       	call   1012d3 <log_source_name_get>
  1021b6:	5a                   	pop    %edx
  1021b7:	59                   	pop    %ecx
  1021b8:	89 03                	mov    %eax,(%ebx)
}
  1021ba:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  1021bd:	c9                   	leave  
  1021be:	c3                   	ret    

001021bf <filters_set>:
{
  1021bf:	55                   	push   %ebp
  1021c0:	89 e5                	mov    %esp,%ebp
  1021c2:	57                   	push   %edi
  1021c3:	56                   	push   %esi
  1021c4:	89 ce                	mov    %ecx,%esi
  1021c6:	53                   	push   %ebx
  1021c7:	83 ec 14             	sub    $0x14,%esp
  1021ca:	89 45 f0             	mov    %eax,-0x10(%ebp)
  1021cd:	b8 18 ba 10 00       	mov    $0x10ba18,%eax
  1021d2:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  1021d5:	2d e0 b9 10 00       	sub    $0x10b9e0,%eax
	int cnt = all ? log_sources_count() : argc;
  1021da:	89 4d e8             	mov    %ecx,-0x18(%ebp)
  1021dd:	c1 e8 03             	shr    $0x3,%eax
  1021e0:	85 c9                	test   %ecx,%ecx
  1021e2:	89 45 ec             	mov    %eax,-0x14(%ebp)
  1021e5:	75 03                	jne    1021ea <filters_set+0x2b>
  1021e7:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (!backend->cb->active) {
  1021ea:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  1021ed:	8b 40 04             	mov    0x4(%eax),%eax
  1021f0:	80 78 05 00          	cmpb   $0x0,0x5(%eax)
  1021f4:	75 12                	jne    102208 <filters_set+0x49>
		shell_warn(shell, "Backend not active.");
  1021f6:	68 74 e0 10 00       	push   $0x10e074
  1021fb:	6a 04                	push   $0x4
  1021fd:	ff 75 f0             	pushl  -0x10(%ebp)
  102200:	e8 1a 17 00 00       	call   10391f <shell_fprintf>
  102205:	83 c4 0c             	add    $0xc,%esp
	for (i = 0U; i < modules_cnt; i++) {
  102208:	31 db                	xor    %ebx,%ebx
	for (i = 0; i < cnt; i++) {
  10220a:	3b 5d e8             	cmp    -0x18(%ebp),%ebx
  10220d:	0f 8d 9b 00 00 00    	jge    1022ae <filters_set+0xef>
		id = all ? i : module_id_get(argv[i]);
  102213:	89 da                	mov    %ebx,%edx
  102215:	85 f6                	test   %esi,%esi
  102217:	74 4b                	je     102264 <filters_set+0xa5>
  102219:	8b 45 08             	mov    0x8(%ebp),%eax
	for (i = 0U; i < modules_cnt; i++) {
  10221c:	31 d2                	xor    %edx,%edx
		id = all ? i : module_id_get(argv[i]);
  10221e:	8b 3c 98             	mov    (%eax,%ebx,4),%edi
	for (i = 0U; i < modules_cnt; i++) {
  102221:	39 55 ec             	cmp    %edx,-0x14(%ebp)
  102224:	74 23                	je     102249 <filters_set+0x8a>
		tmp_name = log_source_name_get(CONFIG_LOG_DOMAIN_ID, i);
  102226:	52                   	push   %edx
  102227:	89 55 e0             	mov    %edx,-0x20(%ebp)
  10222a:	6a 00                	push   $0x0
  10222c:	e8 a2 f0 ff ff       	call   1012d3 <log_source_name_get>
  102231:	5a                   	pop    %edx
  102232:	59                   	pop    %ecx
		if (strncmp(tmp_name, name, 64) == 0) {
  102233:	6a 40                	push   $0x40
  102235:	57                   	push   %edi
  102236:	50                   	push   %eax
  102237:	e8 6d 4b 00 00       	call   106da9 <strncmp>
  10223c:	83 c4 0c             	add    $0xc,%esp
  10223f:	8b 55 e0             	mov    -0x20(%ebp),%edx
  102242:	85 c0                	test   %eax,%eax
  102244:	74 1e                	je     102264 <filters_set+0xa5>
	for (i = 0U; i < modules_cnt; i++) {
  102246:	42                   	inc    %edx
  102247:	eb d8                	jmp    102221 <filters_set+0x62>
			shell_error(shell, "%s: unknown source name.", argv[i]);
  102249:	8b 45 08             	mov    0x8(%ebp),%eax
  10224c:	ff 34 98             	pushl  (%eax,%ebx,4)
  10224f:	68 9f e0 10 00       	push   $0x10e09f
  102254:	6a 02                	push   $0x2
  102256:	ff 75 f0             	pushl  -0x10(%ebp)
  102259:	e8 c1 16 00 00       	call   10391f <shell_fprintf>
  10225e:	83 c4 10             	add    $0x10,%esp
	for (i = 0; i < cnt; i++) {
  102261:	43                   	inc    %ebx
  102262:	eb a6                	jmp    10220a <filters_set+0x4b>
K_SYSCALL_DECLARE4(K_SYSCALL_LOG_FILTER_SET, log_filter_set, u32_t, struct log_backend const *const, backend, u32_t, domain_id, u32_t, src_id, u32_t, level)
  102264:	ff 75 0c             	pushl  0xc(%ebp)
  102267:	52                   	push   %edx
  102268:	6a 00                	push   $0x0
  10226a:	ff 75 e4             	pushl  -0x1c(%ebp)
  10226d:	e8 84 f0 ff ff       	call   1012f6 <z_impl_log_filter_set>
  102272:	83 c4 10             	add    $0x10,%esp
  102275:	89 c7                	mov    %eax,%edi
			if (set_lvl != level) {
  102277:	39 45 0c             	cmp    %eax,0xc(%ebp)
  10227a:	74 e5                	je     102261 <filters_set+0xa2>
						CONFIG_LOG_DOMAIN_ID, i) :
  10227c:	85 f6                	test   %esi,%esi
  10227e:	75 0c                	jne    10228c <filters_set+0xcd>
					log_source_name_get(
  102280:	53                   	push   %ebx
  102281:	6a 00                	push   $0x0
  102283:	e8 4b f0 ff ff       	call   1012d3 <log_source_name_get>
  102288:	5a                   	pop    %edx
  102289:	59                   	pop    %ecx
  10228a:	eb 06                	jmp    102292 <filters_set+0xd3>
						CONFIG_LOG_DOMAIN_ID, i) :
  10228c:	8b 45 08             	mov    0x8(%ebp),%eax
  10228f:	8b 04 98             	mov    (%eax,%ebx,4),%eax
				shell_warn(shell, "%s: level set to %s.",
  102292:	ff 34 bd 40 da 10 00 	pushl  0x10da40(,%edi,4)
  102299:	50                   	push   %eax
  10229a:	68 89 e0 10 00       	push   $0x10e089
  10229f:	6a 04                	push   $0x4
  1022a1:	ff 75 f0             	pushl  -0x10(%ebp)
  1022a4:	e8 76 16 00 00       	call   10391f <shell_fprintf>
  1022a9:	83 c4 14             	add    $0x14,%esp
  1022ac:	eb b3                	jmp    102261 <filters_set+0xa2>
}
  1022ae:	8d 65 f4             	lea    -0xc(%ebp),%esp
  1022b1:	5b                   	pop    %ebx
  1022b2:	5e                   	pop    %esi
  1022b3:	5f                   	pop    %edi
  1022b4:	5d                   	pop    %ebp
  1022b5:	c3                   	ret    

001022b6 <log_disable>:
{
  1022b6:	55                   	push   %ebp
  1022b7:	89 e5                	mov    %esp,%ebp
	filters_set(shell, backend, argc - 1, &argv[1], LOG_LEVEL_NONE);
  1022b9:	6a 00                	push   $0x0
  1022bb:	8b 45 10             	mov    0x10(%ebp),%eax
  1022be:	8b 55 0c             	mov    0xc(%ebp),%edx
  1022c1:	8d 48 ff             	lea    -0x1(%eax),%ecx
  1022c4:	8b 45 14             	mov    0x14(%ebp),%eax
  1022c7:	83 c0 04             	add    $0x4,%eax
  1022ca:	50                   	push   %eax
  1022cb:	8b 45 08             	mov    0x8(%ebp),%eax
  1022ce:	e8 ec fe ff ff       	call   1021bf <filters_set>
  1022d3:	58                   	pop    %eax
  1022d4:	5a                   	pop    %edx
}
  1022d5:	31 c0                	xor    %eax,%eax
  1022d7:	c9                   	leave  
  1022d8:	c3                   	ret    

001022d9 <shell_backend_cmd_execute>:
{
  1022d9:	55                   	push   %ebp
  1022da:	89 e5                	mov    %esp,%ebp
  1022dc:	57                   	push   %edi
  1022dd:	56                   	push   %esi
	for (int i = 0; i < log_backend_count_get(); i++) {
  1022de:	31 f6                	xor    %esi,%esi
{
  1022e0:	53                   	push   %ebx
  1022e1:	83 ec 18             	sub    $0x18,%esp
  1022e4:	89 55 e8             	mov    %edx,-0x18(%ebp)
	char const *name = argv[-1];
  1022e7:	8b 59 fc             	mov    -0x4(%ecx),%ebx
  1022ea:	89 4d e0             	mov    %ecx,-0x20(%ebp)
	size_t slen = strlen(name);
  1022ed:	53                   	push   %ebx
{
  1022ee:	89 45 f0             	mov    %eax,-0x10(%ebp)
	size_t slen = strlen(name);
  1022f1:	e8 80 4a 00 00       	call   106d76 <strlen>
  1022f6:	5a                   	pop    %edx
  1022f7:	89 45 ec             	mov    %eax,-0x14(%ebp)
	return __log_backends_end - __log_backends_start;
  1022fa:	b8 28 ba 10 00       	mov    $0x10ba28,%eax
  1022ff:	2d 18 ba 10 00       	sub    $0x10ba18,%eax
  102304:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  102307:	c1 f8 04             	sar    $0x4,%eax
  10230a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	for (int i = 0; i < log_backend_count_get(); i++) {
  10230d:	3b 75 e4             	cmp    -0x1c(%ebp),%esi
  102310:	7d 42                	jge    102354 <shell_backend_cmd_execute+0x7b>
		if (strncmp(name, backend->name, slen) == 0) {
  102312:	ff 75 ec             	pushl  -0x14(%ebp)
  102315:	89 f2                	mov    %esi,%edx
  102317:	89 4d dc             	mov    %ecx,-0x24(%ebp)
  10231a:	c1 e2 04             	shl    $0x4,%edx
  10231d:	89 55 e0             	mov    %edx,-0x20(%ebp)
  102320:	ff b2 20 ba 10 00    	pushl  0x10ba20(%edx)
  102326:	53                   	push   %ebx
  102327:	e8 7d 4a 00 00       	call   106da9 <strncmp>
  10232c:	83 c4 0c             	add    $0xc,%esp
  10232f:	89 c7                	mov    %eax,%edi
  102331:	85 c0                	test   %eax,%eax
  102333:	8b 55 e0             	mov    -0x20(%ebp),%edx
  102336:	8b 4d dc             	mov    -0x24(%ebp),%ecx
  102339:	74 03                	je     10233e <shell_backend_cmd_execute+0x65>
	for (int i = 0; i < log_backend_count_get(); i++) {
  10233b:	46                   	inc    %esi
  10233c:	eb cf                	jmp    10230d <shell_backend_cmd_execute+0x34>
		func(shell, backend, argc, argv);
  10233e:	51                   	push   %ecx
	return &__log_backends_start[idx];
  10233f:	8d 9a 18 ba 10 00    	lea    0x10ba18(%edx),%ebx
  102345:	ff 75 e8             	pushl  -0x18(%ebp)
  102348:	53                   	push   %ebx
  102349:	ff 75 f0             	pushl  -0x10(%ebp)
  10234c:	ff 55 08             	call   *0x8(%ebp)
  10234f:	83 c4 10             	add    $0x10,%esp
	return 0;
  102352:	eb 18                	jmp    10236c <shell_backend_cmd_execute+0x93>
		shell_error(shell, "Invalid backend: %s", name);
  102354:	53                   	push   %ebx
		return -ENOEXEC;
  102355:	bf f8 ff ff ff       	mov    $0xfffffff8,%edi
		shell_error(shell, "Invalid backend: %s", name);
  10235a:	68 b9 e0 10 00       	push   $0x10e0b9
  10235f:	6a 02                	push   $0x2
  102361:	ff 75 f0             	pushl  -0x10(%ebp)
  102364:	e8 b6 15 00 00       	call   10391f <shell_fprintf>
  102369:	83 c4 10             	add    $0x10,%esp
}
  10236c:	8d 65 f4             	lea    -0xc(%ebp),%esp
  10236f:	89 f8                	mov    %edi,%eax
  102371:	5b                   	pop    %ebx
  102372:	5e                   	pop    %esi
  102373:	5f                   	pop    %edi
  102374:	5d                   	pop    %ebp
  102375:	c3                   	ret    

00102376 <cmd_log_backend_status>:
{
  102376:	55                   	push   %ebp
  102377:	89 e5                	mov    %esp,%ebp
	shell_backend_cmd_execute(shell, argc, argv, log_status);
  102379:	68 c6 20 10 00       	push   $0x1020c6
  10237e:	8b 4d 10             	mov    0x10(%ebp),%ecx
  102381:	8b 55 0c             	mov    0xc(%ebp),%edx
  102384:	8b 45 08             	mov    0x8(%ebp),%eax
  102387:	e8 4d ff ff ff       	call   1022d9 <shell_backend_cmd_execute>
  10238c:	58                   	pop    %eax
}
  10238d:	31 c0                	xor    %eax,%eax
  10238f:	c9                   	leave  
  102390:	c3                   	ret    

00102391 <cmd_log_backend_halt>:
{
  102391:	55                   	push   %ebp
  102392:	89 e5                	mov    %esp,%ebp
  102394:	8b 45 08             	mov    0x8(%ebp),%eax
	return shell_backend_cmd_execute(shell, argc, argv, log_halt);
  102397:	8b 4d 10             	mov    0x10(%ebp),%ecx
  10239a:	8b 55 0c             	mov    0xc(%ebp),%edx
  10239d:	c7 45 08 04 20 10 00 	movl   $0x102004,0x8(%ebp)
}
  1023a4:	5d                   	pop    %ebp
	return shell_backend_cmd_execute(shell, argc, argv, log_halt);
  1023a5:	e9 2f ff ff ff       	jmp    1022d9 <shell_backend_cmd_execute>

001023aa <cmd_log_backend_go>:
{
  1023aa:	55                   	push   %ebp
  1023ab:	89 e5                	mov    %esp,%ebp
  1023ad:	8b 45 08             	mov    0x8(%ebp),%eax
	return shell_backend_cmd_execute(shell, argc, argv, log_go);
  1023b0:	8b 4d 10             	mov    0x10(%ebp),%ecx
  1023b3:	8b 55 0c             	mov    0xc(%ebp),%edx
  1023b6:	c7 45 08 15 20 10 00 	movl   $0x102015,0x8(%ebp)
}
  1023bd:	5d                   	pop    %ebp
	return shell_backend_cmd_execute(shell, argc, argv, log_go);
  1023be:	e9 16 ff ff ff       	jmp    1022d9 <shell_backend_cmd_execute>

001023c3 <cmd_log_backend_enable>:
{
  1023c3:	55                   	push   %ebp
  1023c4:	89 e5                	mov    %esp,%ebp
  1023c6:	8b 45 08             	mov    0x8(%ebp),%eax
	return shell_backend_cmd_execute(shell, argc, argv, log_enable);
  1023c9:	8b 4d 10             	mov    0x10(%ebp),%ecx
  1023cc:	8b 55 0c             	mov    0xc(%ebp),%edx
  1023cf:	c7 45 08 8e 24 10 00 	movl   $0x10248e,0x8(%ebp)
}
  1023d6:	5d                   	pop    %ebp
	return shell_backend_cmd_execute(shell, argc, argv, log_enable);
  1023d7:	e9 fd fe ff ff       	jmp    1022d9 <shell_backend_cmd_execute>

001023dc <cmd_log_backend_disable>:
{
  1023dc:	55                   	push   %ebp
  1023dd:	89 e5                	mov    %esp,%ebp
  1023df:	8b 45 08             	mov    0x8(%ebp),%eax
	return shell_backend_cmd_execute(shell, argc, argv, log_disable);
  1023e2:	8b 4d 10             	mov    0x10(%ebp),%ecx
  1023e5:	8b 55 0c             	mov    0xc(%ebp),%edx
  1023e8:	c7 45 08 b6 22 10 00 	movl   $0x1022b6,0x8(%ebp)
}
  1023ef:	5d                   	pop    %ebp
	return shell_backend_cmd_execute(shell, argc, argv, log_disable);
  1023f0:	e9 e4 fe ff ff       	jmp    1022d9 <shell_backend_cmd_execute>

001023f5 <shell_state_precheck>:
	if (shell->log_backend->control_block->state
  1023f5:	8b 50 1c             	mov    0x1c(%eax),%edx
  1023f8:	8b 52 0c             	mov    0xc(%edx),%edx
  1023fb:	83 7a 04 00          	cmpl   $0x0,0x4(%edx)
  1023ff:	75 17                	jne    102418 <shell_state_precheck+0x23>
{
  102401:	55                   	push   %ebp
  102402:	89 e5                	mov    %esp,%ebp
		shell_error(shell, "Shell log backend not initialized.");
  102404:	68 ce e0 10 00       	push   $0x10e0ce
  102409:	6a 02                	push   $0x2
  10240b:	50                   	push   %eax
  10240c:	e8 0e 15 00 00       	call   10391f <shell_fprintf>
  102411:	83 c4 0c             	add    $0xc,%esp
  102414:	31 c0                	xor    %eax,%eax
}
  102416:	c9                   	leave  
  102417:	c3                   	ret    
	return true;
  102418:	b0 01                	mov    $0x1,%al
}
  10241a:	c3                   	ret    

0010241b <cmd_log_self_halt>:
{
  10241b:	55                   	push   %ebp
  10241c:	89 e5                	mov    %esp,%ebp
  10241e:	53                   	push   %ebx
  10241f:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (!shell_state_precheck(shell)) {
  102422:	89 d8                	mov    %ebx,%eax
  102424:	e8 cc ff ff ff       	call   1023f5 <shell_state_precheck>
  102429:	84 c0                	test   %al,%al
  10242b:	74 0c                	je     102439 <cmd_log_self_halt+0x1e>
	return log_halt(shell, shell->log_backend->backend, argc, argv);
  10242d:	8b 43 1c             	mov    0x1c(%ebx),%eax
	log_backend_deactivate(backend);
  102430:	8b 00                	mov    (%eax),%eax
	backend->cb->active = false;
  102432:	8b 40 04             	mov    0x4(%eax),%eax
  102435:	c6 40 05 00          	movb   $0x0,0x5(%eax)
}
  102439:	5b                   	pop    %ebx
  10243a:	31 c0                	xor    %eax,%eax
  10243c:	5d                   	pop    %ebp
  10243d:	c3                   	ret    

0010243e <cmd_log_self_go>:
{
  10243e:	55                   	push   %ebp
  10243f:	89 e5                	mov    %esp,%ebp
  102441:	53                   	push   %ebx
  102442:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (!shell_state_precheck(shell)) {
  102445:	89 d8                	mov    %ebx,%eax
  102447:	e8 a9 ff ff ff       	call   1023f5 <shell_state_precheck>
  10244c:	84 c0                	test   %al,%al
  10244e:	74 0c                	je     10245c <cmd_log_self_go+0x1e>
	return log_go(shell, shell->log_backend->backend, argc, argv);
  102450:	8b 43 1c             	mov    0x1c(%ebx),%eax
	log_backend_activate(backend, backend->cb->ctx);
  102453:	8b 00                	mov    (%eax),%eax
	backend->cb->active = true;
  102455:	8b 40 04             	mov    0x4(%eax),%eax
  102458:	c6 40 05 01          	movb   $0x1,0x5(%eax)
}
  10245c:	5b                   	pop    %ebx
  10245d:	31 c0                	xor    %eax,%eax
  10245f:	5d                   	pop    %ebp
  102460:	c3                   	ret    

00102461 <cmd_log_self_status>:
{
  102461:	55                   	push   %ebp
  102462:	89 e5                	mov    %esp,%ebp
  102464:	53                   	push   %ebx
  102465:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (!shell_state_precheck(shell)) {
  102468:	89 d8                	mov    %ebx,%eax
  10246a:	e8 86 ff ff ff       	call   1023f5 <shell_state_precheck>
  10246f:	84 c0                	test   %al,%al
  102471:	74 14                	je     102487 <cmd_log_self_status+0x26>
	log_status(shell, shell->log_backend->backend, argc, argv);
  102473:	ff 75 10             	pushl  0x10(%ebp)
  102476:	ff 75 0c             	pushl  0xc(%ebp)
  102479:	8b 43 1c             	mov    0x1c(%ebx),%eax
  10247c:	ff 30                	pushl  (%eax)
  10247e:	53                   	push   %ebx
  10247f:	e8 42 fc ff ff       	call   1020c6 <log_status>
  102484:	83 c4 10             	add    $0x10,%esp
}
  102487:	31 c0                	xor    %eax,%eax
  102489:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  10248c:	c9                   	leave  
  10248d:	c3                   	ret    

0010248e <log_enable>:
{
  10248e:	55                   	push   %ebp
  10248f:	89 e5                	mov    %esp,%ebp
  102491:	57                   	push   %edi
  102492:	56                   	push   %esi
	for (i = 0; i < ARRAY_SIZE(severity_lvls); i++) {
  102493:	31 ff                	xor    %edi,%edi
	severity_level = severity_level_get(argv[1]);
  102495:	8b 45 14             	mov    0x14(%ebp),%eax
{
  102498:	53                   	push   %ebx
	severity_level = severity_level_get(argv[1]);
  102499:	8b 58 04             	mov    0x4(%eax),%ebx
		if (strncmp(str, severity_lvls[i], 4) == 0) {
  10249c:	6a 04                	push   $0x4
  10249e:	ff 34 bd 40 da 10 00 	pushl  0x10da40(,%edi,4)
  1024a5:	53                   	push   %ebx
  1024a6:	e8 fe 48 00 00       	call   106da9 <strncmp>
  1024ab:	83 c4 0c             	add    $0xc,%esp
  1024ae:	89 c6                	mov    %eax,%esi
  1024b0:	85 c0                	test   %eax,%eax
  1024b2:	74 25                	je     1024d9 <log_enable+0x4b>
	for (i = 0; i < ARRAY_SIZE(severity_lvls); i++) {
  1024b4:	47                   	inc    %edi
  1024b5:	83 ff 05             	cmp    $0x5,%edi
  1024b8:	75 e2                	jne    10249c <log_enable+0xe>
		shell_error(shell, "Invalid severity: %s", argv[1]);
  1024ba:	8b 45 14             	mov    0x14(%ebp),%eax
  1024bd:	be f8 ff ff ff       	mov    $0xfffffff8,%esi
  1024c2:	ff 70 04             	pushl  0x4(%eax)
  1024c5:	68 f2 e0 10 00       	push   $0x10e0f2
  1024ca:	6a 02                	push   $0x2
  1024cc:	ff 75 08             	pushl  0x8(%ebp)
  1024cf:	e8 4b 14 00 00       	call   10391f <shell_fprintf>
  1024d4:	83 c4 10             	add    $0x10,%esp
		return -ENOEXEC;
  1024d7:	eb 1b                	jmp    1024f4 <log_enable+0x66>
	filters_set(shell, backend, argc - 2, &argv[2], severity_level);
  1024d9:	8b 45 10             	mov    0x10(%ebp),%eax
  1024dc:	57                   	push   %edi
  1024dd:	8b 55 0c             	mov    0xc(%ebp),%edx
  1024e0:	8d 48 fe             	lea    -0x2(%eax),%ecx
  1024e3:	8b 45 14             	mov    0x14(%ebp),%eax
  1024e6:	8d 58 08             	lea    0x8(%eax),%ebx
  1024e9:	8b 45 08             	mov    0x8(%ebp),%eax
  1024ec:	53                   	push   %ebx
  1024ed:	e8 cd fc ff ff       	call   1021bf <filters_set>
  1024f2:	58                   	pop    %eax
  1024f3:	5a                   	pop    %edx
}
  1024f4:	8d 65 f4             	lea    -0xc(%ebp),%esp
  1024f7:	89 f0                	mov    %esi,%eax
  1024f9:	5b                   	pop    %ebx
  1024fa:	5e                   	pop    %esi
  1024fb:	5f                   	pop    %edi
  1024fc:	5d                   	pop    %ebp
  1024fd:	c3                   	ret    

001024fe <cmd_log_self_enable>:
{
  1024fe:	55                   	push   %ebp
  1024ff:	89 e5                	mov    %esp,%ebp
  102501:	53                   	push   %ebx
  102502:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (!shell_state_precheck(shell)) {
  102505:	89 d8                	mov    %ebx,%eax
  102507:	e8 e9 fe ff ff       	call   1023f5 <shell_state_precheck>
  10250c:	88 c2                	mov    %al,%dl
  10250e:	31 c0                	xor    %eax,%eax
  102510:	84 d2                	test   %dl,%dl
  102512:	74 14                	je     102528 <cmd_log_self_enable+0x2a>
	return log_enable(shell, shell->log_backend->backend, argc, argv);
  102514:	ff 75 10             	pushl  0x10(%ebp)
  102517:	ff 75 0c             	pushl  0xc(%ebp)
  10251a:	8b 43 1c             	mov    0x1c(%ebx),%eax
  10251d:	ff 30                	pushl  (%eax)
  10251f:	53                   	push   %ebx
  102520:	e8 69 ff ff ff       	call   10248e <log_enable>
  102525:	83 c4 10             	add    $0x10,%esp
}
  102528:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  10252b:	c9                   	leave  
  10252c:	c3                   	ret    

0010252d <cmd_log_self_disable>:
{
  10252d:	55                   	push   %ebp
  10252e:	89 e5                	mov    %esp,%ebp
  102530:	53                   	push   %ebx
  102531:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (!shell_state_precheck(shell)) {
  102534:	89 d8                	mov    %ebx,%eax
  102536:	e8 ba fe ff ff       	call   1023f5 <shell_state_precheck>
  10253b:	88 c2                	mov    %al,%dl
  10253d:	31 c0                	xor    %eax,%eax
  10253f:	84 d2                	test   %dl,%dl
  102541:	74 14                	je     102557 <cmd_log_self_disable+0x2a>
	return log_disable(shell, shell->log_backend->backend, argc, argv);
  102543:	ff 75 10             	pushl  0x10(%ebp)
  102546:	ff 75 0c             	pushl  0xc(%ebp)
  102549:	8b 43 1c             	mov    0x1c(%ebx),%eax
  10254c:	ff 30                	pushl  (%eax)
  10254e:	53                   	push   %ebx
  10254f:	e8 62 fd ff ff       	call   1022b6 <log_disable>
  102554:	83 c4 10             	add    $0x10,%esp
}
  102557:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  10255a:	c9                   	leave  
  10255b:	c3                   	ret    

0010255c <cmd_kernel_version>:
#include <string.h>
#include <device.h>

static int cmd_kernel_version(const struct shell *shell,
			      size_t argc, char **argv)
{
  10255c:	55                   	push   %ebp
  10255d:	89 e5                	mov    %esp,%ebp
	u32_t version = sys_kernel_version_get();
  10255f:	e8 20 8a 00 00       	call   10af84 <sys_kernel_version_get>

	ARG_UNUSED(argc);
	ARG_UNUSED(argv);

	shell_fprintf(shell, SHELL_NORMAL, "Zephyr version %d.%d.%d\n",
  102564:	0f b6 d4             	movzbl %ah,%edx
  102567:	52                   	push   %edx
		      SYS_KERNEL_VER_MAJOR(version),
		      SYS_KERNEL_VER_MINOR(version),
  102568:	89 c2                	mov    %eax,%edx
  10256a:	c1 ea 10             	shr    $0x10,%edx
	shell_fprintf(shell, SHELL_NORMAL, "Zephyr version %d.%d.%d\n",
  10256d:	0f b6 d2             	movzbl %dl,%edx
  102570:	c1 e8 18             	shr    $0x18,%eax
  102573:	52                   	push   %edx
  102574:	50                   	push   %eax
  102575:	68 9d e2 10 00       	push   $0x10e29d
  10257a:	6a 00                	push   $0x0
  10257c:	ff 75 08             	pushl  0x8(%ebp)
  10257f:	e8 9b 13 00 00       	call   10391f <shell_fprintf>
  102584:	83 c4 18             	add    $0x18,%esp
		      SYS_KERNEL_VER_PATCHLEVEL(version));
	return 0;
}
  102587:	31 c0                	xor    %eax,%eax
  102589:	c9                   	leave  
  10258a:	c3                   	ret    

0010258b <cmd_kernel_uptime>:

static int cmd_kernel_uptime(const struct shell *shell,
			     size_t argc, char **argv)
{
  10258b:	55                   	push   %ebp
  10258c:	89 e5                	mov    %esp,%ebp
K_SYSCALL_DECLARE0_RET64(K_SYSCALL_K_UPTIME_GET, k_uptime_get, s64_t)
  10258e:	e8 c9 8c 00 00       	call   10b25c <z_impl_k_uptime_get>
	ARG_UNUSED(argc);
	ARG_UNUSED(argv);

	shell_fprintf(shell, SHELL_NORMAL, "Uptime: %u ms\n",
  102593:	50                   	push   %eax
  102594:	68 b6 e2 10 00       	push   $0x10e2b6
  102599:	6a 00                	push   $0x0
  10259b:	ff 75 08             	pushl  0x8(%ebp)
  10259e:	e8 7c 13 00 00       	call   10391f <shell_fprintf>
  1025a3:	83 c4 10             	add    $0x10,%esp
			k_uptime_get_32());
	return 0;
}
  1025a6:	31 c0                	xor    %eax,%eax
  1025a8:	c9                   	leave  
  1025a9:	c3                   	ret    

001025aa <cmd_kernel_cycles>:

static int cmd_kernel_cycles(const struct shell *shell,
			      size_t argc, char **argv)
{
  1025aa:	55                   	push   %ebp
  1025ab:	89 e5                	mov    %esp,%ebp
	ARG_UNUSED(argc);
	ARG_UNUSED(argv);

	shell_fprintf(shell, SHELL_NORMAL, "cycles: %u hw cycles\n",
  1025ad:	e8 14 42 00 00       	call   1067c6 <z_timer_cycle_get_32>
  1025b2:	50                   	push   %eax
  1025b3:	68 c5 e2 10 00       	push   $0x10e2c5
  1025b8:	6a 00                	push   $0x0
  1025ba:	ff 75 08             	pushl  0x8(%ebp)
  1025bd:	e8 5d 13 00 00       	call   10391f <shell_fprintf>
  1025c2:	83 c4 10             	add    $0x10,%esp
			k_cycle_get_32());
	return 0;
}
  1025c5:	31 c0                	xor    %eax,%eax
  1025c7:	c9                   	leave  
  1025c8:	c3                   	ret    

001025c9 <cmd_device_list>:
	return 0;
}

static int cmd_device_list(const struct shell *shell,
			      size_t argc, char **argv)
{
  1025c9:	55                   	push   %ebp
  1025ca:	89 e5                	mov    %esp,%ebp
  1025cc:	56                   	push   %esi
  1025cd:	53                   	push   %ebx
	struct device *info;
	ARG_UNUSED(argc);
	ARG_UNUSED(argv);

	shell_fprintf(shell, SHELL_NORMAL, "devices:\n");
	for (info = __device_init_start; info != __device_init_end; info++) {
  1025ce:	bb d8 32 11 00       	mov    $0x1132d8,%ebx
	shell_fprintf(shell, SHELL_NORMAL, "devices:\n");
  1025d3:	68 36 e3 10 00       	push   $0x10e336
{
  1025d8:	8b 75 08             	mov    0x8(%ebp),%esi
	shell_fprintf(shell, SHELL_NORMAL, "devices:\n");
  1025db:	6a 00                	push   $0x0
  1025dd:	56                   	push   %esi
  1025de:	e8 3c 13 00 00       	call   10391f <shell_fprintf>
  1025e3:	83 c4 0c             	add    $0xc,%esp
	for (info = __device_init_start; info != __device_init_end; info++) {
  1025e6:	81 fb 04 34 11 00    	cmp    $0x113404,%ebx
  1025ec:	74 1f                	je     10260d <cmd_device_list+0x44>
		if (info->driver_api != NULL) {
  1025ee:	83 7b 04 00          	cmpl   $0x0,0x4(%ebx)
  1025f2:	74 14                	je     102608 <cmd_device_list+0x3f>
			shell_fprintf(shell, SHELL_NORMAL, "- %s\n",
  1025f4:	8b 03                	mov    (%ebx),%eax
  1025f6:	ff 30                	pushl  (%eax)
  1025f8:	68 40 e3 10 00       	push   $0x10e340
  1025fd:	6a 00                	push   $0x0
  1025ff:	56                   	push   %esi
  102600:	e8 1a 13 00 00       	call   10391f <shell_fprintf>
  102605:	83 c4 10             	add    $0x10,%esp
	for (info = __device_init_start; info != __device_init_end; info++) {
  102608:	83 c3 0c             	add    $0xc,%ebx
  10260b:	eb d9                	jmp    1025e6 <cmd_device_list+0x1d>
					info->config->name);
		}
	}

	return 0;
}
  10260d:	8d 65 f8             	lea    -0x8(%ebp),%esp
  102610:	31 c0                	xor    %eax,%eax
  102612:	5b                   	pop    %ebx
  102613:	5e                   	pop    %esi
  102614:	5d                   	pop    %ebp
  102615:	c3                   	ret    

00102616 <device_get_config_level>:
{
  102616:	55                   	push   %ebp
  102617:	89 e5                	mov    %esp,%ebp
  102619:	57                   	push   %edi
  10261a:	56                   	push   %esi
  10261b:	89 c7                	mov    %eax,%edi
  10261d:	53                   	push   %ebx
  10261e:	89 d6                	mov    %edx,%esi
	for (info = config_levels[level]; info < config_levels[level+1];
  102620:	8b 1c 95 8c da 10 00 	mov    0x10da8c(,%edx,4),%ebx
	bool devices = false;
  102627:	31 c0                	xor    %eax,%eax
	for (info = config_levels[level]; info < config_levels[level+1];
  102629:	39 1c b5 90 da 10 00 	cmp    %ebx,0x10da90(,%esi,4)
  102630:	76 21                	jbe    102653 <device_get_config_level+0x3d>
		if (info->driver_api != NULL) {
  102632:	83 7b 04 00          	cmpl   $0x0,0x4(%ebx)
  102636:	74 16                	je     10264e <device_get_config_level+0x38>
			shell_fprintf(shell, SHELL_NORMAL, "- %s\n",
  102638:	8b 03                	mov    (%ebx),%eax
  10263a:	ff 30                	pushl  (%eax)
  10263c:	68 40 e3 10 00       	push   $0x10e340
  102641:	6a 00                	push   $0x0
  102643:	57                   	push   %edi
  102644:	e8 d6 12 00 00       	call   10391f <shell_fprintf>
  102649:	83 c4 10             	add    $0x10,%esp
			devices = true;
  10264c:	b0 01                	mov    $0x1,%al
								info++) {
  10264e:	83 c3 0c             	add    $0xc,%ebx
  102651:	eb d6                	jmp    102629 <device_get_config_level+0x13>
}
  102653:	8d 65 f4             	lea    -0xc(%ebp),%esp
  102656:	5b                   	pop    %ebx
  102657:	5e                   	pop    %esi
  102658:	5f                   	pop    %edi
  102659:	5d                   	pop    %ebp
  10265a:	c3                   	ret    

0010265b <cmd_device_levels>:
{
  10265b:	55                   	push   %ebp
  10265c:	89 e5                	mov    %esp,%ebp
  10265e:	53                   	push   %ebx
	shell_fprintf(shell, SHELL_NORMAL, "POST_KERNEL:\n");
  10265f:	68 46 e3 10 00       	push   $0x10e346
{
  102664:	8b 5d 08             	mov    0x8(%ebp),%ebx
	shell_fprintf(shell, SHELL_NORMAL, "POST_KERNEL:\n");
  102667:	6a 00                	push   $0x0
  102669:	53                   	push   %ebx
  10266a:	e8 b0 12 00 00       	call   10391f <shell_fprintf>
  10266f:	83 c4 0c             	add    $0xc,%esp
	ret = device_get_config_level(shell, _SYS_INIT_LEVEL_POST_KERNEL);
  102672:	ba 02 00 00 00       	mov    $0x2,%edx
  102677:	89 d8                	mov    %ebx,%eax
  102679:	e8 98 ff ff ff       	call   102616 <device_get_config_level>
	if (ret == false) {
  10267e:	84 c0                	test   %al,%al
  102680:	75 10                	jne    102692 <cmd_device_levels+0x37>
		shell_fprintf(shell, SHELL_NORMAL, "- None\n");
  102682:	68 54 e3 10 00       	push   $0x10e354
  102687:	6a 00                	push   $0x0
  102689:	53                   	push   %ebx
  10268a:	e8 90 12 00 00       	call   10391f <shell_fprintf>
  10268f:	83 c4 0c             	add    $0xc,%esp
	shell_fprintf(shell, SHELL_NORMAL, "APPLICATION:\n");
  102692:	68 5c e3 10 00       	push   $0x10e35c
  102697:	6a 00                	push   $0x0
  102699:	53                   	push   %ebx
  10269a:	e8 80 12 00 00       	call   10391f <shell_fprintf>
  10269f:	83 c4 0c             	add    $0xc,%esp
	ret = device_get_config_level(shell, _SYS_INIT_LEVEL_APPLICATION);
  1026a2:	ba 03 00 00 00       	mov    $0x3,%edx
  1026a7:	89 d8                	mov    %ebx,%eax
  1026a9:	e8 68 ff ff ff       	call   102616 <device_get_config_level>
	if (ret == false) {
  1026ae:	84 c0                	test   %al,%al
  1026b0:	75 10                	jne    1026c2 <cmd_device_levels+0x67>
		shell_fprintf(shell, SHELL_NORMAL, "- None\n");
  1026b2:	68 54 e3 10 00       	push   $0x10e354
  1026b7:	6a 00                	push   $0x0
  1026b9:	53                   	push   %ebx
  1026ba:	e8 60 12 00 00       	call   10391f <shell_fprintf>
  1026bf:	83 c4 0c             	add    $0xc,%esp
	shell_fprintf(shell, SHELL_NORMAL, "PRE KERNEL 1:\n");
  1026c2:	68 6a e3 10 00       	push   $0x10e36a
  1026c7:	6a 00                	push   $0x0
  1026c9:	53                   	push   %ebx
  1026ca:	e8 50 12 00 00       	call   10391f <shell_fprintf>
  1026cf:	83 c4 0c             	add    $0xc,%esp
	ret = device_get_config_level(shell, _SYS_INIT_LEVEL_PRE_KERNEL_1);
  1026d2:	31 d2                	xor    %edx,%edx
  1026d4:	89 d8                	mov    %ebx,%eax
  1026d6:	e8 3b ff ff ff       	call   102616 <device_get_config_level>
	if (ret == false) {
  1026db:	84 c0                	test   %al,%al
  1026dd:	75 10                	jne    1026ef <cmd_device_levels+0x94>
		shell_fprintf(shell, SHELL_NORMAL, "- None\n");
  1026df:	68 54 e3 10 00       	push   $0x10e354
  1026e4:	6a 00                	push   $0x0
  1026e6:	53                   	push   %ebx
  1026e7:	e8 33 12 00 00       	call   10391f <shell_fprintf>
  1026ec:	83 c4 0c             	add    $0xc,%esp
	shell_fprintf(shell, SHELL_NORMAL, "PRE KERNEL 2:\n");
  1026ef:	68 79 e3 10 00       	push   $0x10e379
  1026f4:	6a 00                	push   $0x0
  1026f6:	53                   	push   %ebx
  1026f7:	e8 23 12 00 00       	call   10391f <shell_fprintf>
  1026fc:	83 c4 0c             	add    $0xc,%esp
	ret = device_get_config_level(shell, _SYS_INIT_LEVEL_PRE_KERNEL_2);
  1026ff:	ba 01 00 00 00       	mov    $0x1,%edx
  102704:	89 d8                	mov    %ebx,%eax
  102706:	e8 0b ff ff ff       	call   102616 <device_get_config_level>
	if (ret == false) {
  10270b:	84 c0                	test   %al,%al
  10270d:	75 10                	jne    10271f <cmd_device_levels+0xc4>
		shell_fprintf(shell, SHELL_NORMAL, "- None\n");
  10270f:	68 54 e3 10 00       	push   $0x10e354
  102714:	6a 00                	push   $0x0
  102716:	53                   	push   %ebx
  102717:	e8 03 12 00 00       	call   10391f <shell_fprintf>
  10271c:	83 c4 0c             	add    $0xc,%esp
}
  10271f:	31 c0                	xor    %eax,%eax
  102721:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  102724:	c9                   	leave  
  102725:	c3                   	ret    

00102726 <shell_signal_handle>:

static void shell_signal_handle(const struct shell *shell,
				enum shell_signal sig_idx,
				shell_signal_handler_t handler)
{
	struct k_poll_signal *signal = &shell->ctx->signals[sig_idx];
  102726:	c1 e2 04             	shl    $0x4,%edx
{
  102729:	55                   	push   %ebp
  10272a:	89 e5                	mov    %esp,%ebp
  10272c:	57                   	push   %edi
  10272d:	56                   	push   %esi
  10272e:	89 cf                	mov    %ecx,%edi
  102730:	53                   	push   %ebx
  102731:	89 c3                	mov    %eax,%ebx
  102733:	83 ec 08             	sub    $0x8,%esp
	struct k_poll_signal *signal = &shell->ctx->signals[sig_idx];
  102736:	8b 40 08             	mov    0x8(%eax),%eax
  102739:	8d b4 10 64 02 00 00 	lea    0x264(%eax,%edx,1),%esi

K_SYSCALL_DECLARE1_VOID(K_SYSCALL_K_POLL_SIGNAL_INIT, k_poll_signal_init, struct k_poll_signal *, signal)

K_SYSCALL_DECLARE1_VOID(K_SYSCALL_K_POLL_SIGNAL_RESET, k_poll_signal_reset, struct k_poll_signal *, signal)

K_SYSCALL_DECLARE3_VOID(K_SYSCALL_K_POLL_SIGNAL_CHECK, k_poll_signal_check, struct k_poll_signal *, signal, unsigned int *, signaled, int *, result)
  102740:	8d 45 f0             	lea    -0x10(%ebp),%eax
  102743:	50                   	push   %eax
  102744:	8d 45 ec             	lea    -0x14(%ebp),%eax
  102747:	50                   	push   %eax
  102748:	56                   	push   %esi
  102749:	e8 ec 8f 00 00       	call   10b73a <z_impl_k_poll_signal_check>
  10274e:	83 c4 0c             	add    $0xc,%esp
	int set;
	int res;

	k_poll_signal_check(signal, &set, &res);

	if (set) {
  102751:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
  102755:	74 0b                	je     102762 <shell_signal_handle+0x3c>
 */
__syscall void k_poll_signal_reset(struct k_poll_signal *signal);

static inline void z_impl_k_poll_signal_reset(struct k_poll_signal *signal)
{
	signal->signaled = 0U;
  102757:	c7 46 08 00 00 00 00 	movl   $0x0,0x8(%esi)
		k_poll_signal_reset(signal);
		handler(shell);
  10275e:	53                   	push   %ebx
  10275f:	ff d7                	call   *%edi
  102761:	58                   	pop    %eax
	}
}
  102762:	8d 65 f4             	lea    -0xc(%ebp),%esp
  102765:	5b                   	pop    %ebx
  102766:	5e                   	pop    %esi
  102767:	5f                   	pop    %edi
  102768:	5d                   	pop    %ebp
  102769:	c3                   	ret    

0010276a <kill_handler>:

static void kill_handler(const struct shell *shell)
{
  10276a:	55                   	push   %ebp
  10276b:	89 e5                	mov    %esp,%ebp
  10276d:	53                   	push   %ebx
  10276e:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (flag_processing_get(shell)) {
  102771:	8b 43 08             	mov    0x8(%ebx),%eax
	shell->ctx->internal.flags.echo = val ? 1 : 0;
}

static inline bool flag_processing_get(const struct shell *shell)
{
	return shell->ctx->internal.flags.processing == 1 ? true : false;
  102774:	8b 80 60 02 00 00    	mov    0x260(%eax),%eax
  10277a:	a8 08                	test   $0x8,%al
  10277c:	75 2b                	jne    1027a9 <kill_handler+0x3f>
		shell_log_backend_disable(shell->log_backend);
  10277e:	ff 73 1c             	pushl  0x1c(%ebx)
  102781:	e8 a8 2d 00 00       	call   10552e <shell_log_backend_disable>
	err = shell->iface->api->uninit(shell->iface);
  102786:	8b 43 04             	mov    0x4(%ebx),%eax
  102789:	8b 10                	mov    (%eax),%edx
  10278b:	89 04 24             	mov    %eax,(%esp)
  10278e:	ff 52 04             	call   *0x4(%edx)
  102791:	5a                   	pop    %edx
	if (err != 0) {
  102792:	85 c0                	test   %eax,%eax
  102794:	75 13                	jne    1027a9 <kill_handler+0x3f>
	shell_history_purge(shell->history);
  102796:	ff 73 0c             	pushl  0xc(%ebx)
  102799:	e8 24 2b 00 00       	call   1052c2 <shell_history_purge>
  10279e:	58                   	pop    %eax
	shell->ctx->state = SHELL_STATE_UNINITIALIZED;
  10279f:	8b 43 08             	mov    0x8(%ebx),%eax
  1027a2:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
K_SYSCALL_DECLARE0(K_SYSCALL_K_CURRENT_GET, k_current_get, k_tid_t)
  1027a9:	e8 75 83 00 00       	call   10ab23 <z_impl_k_current_get>
	(void)instance_uninit(shell);
	k_thread_abort(k_current_get());
}
  1027ae:	8b 5d fc             	mov    -0x4(%ebp),%ebx
K_SYSCALL_DECLARE1_VOID(K_SYSCALL_K_THREAD_ABORT, k_thread_abort, k_tid_t, thread)
  1027b1:	89 45 08             	mov    %eax,0x8(%ebp)
  1027b4:	c9                   	leave  
  1027b5:	e9 9b 87 00 00       	jmp    10af55 <z_impl_k_thread_abort>

001027ba <shell_strlen>:
void shell_multiline_data_calc(struct shell_multiline_cons *cons,
				   u16_t buff_pos, u16_t buff_len);

static inline u16_t shell_strlen(const char *str)
{
	return str == NULL ? 0U : (u16_t)strlen(str);
  1027ba:	85 c0                	test   %eax,%eax
  1027bc:	74 0c                	je     1027ca <shell_strlen+0x10>
{
  1027be:	55                   	push   %ebp
  1027bf:	89 e5                	mov    %esp,%ebp
	return str == NULL ? 0U : (u16_t)strlen(str);
  1027c1:	50                   	push   %eax
  1027c2:	e8 af 45 00 00       	call   106d76 <strlen>
  1027c7:	5a                   	pop    %edx
}
  1027c8:	c9                   	leave  
  1027c9:	c3                   	ret    
	return str == NULL ? 0U : (u16_t)strlen(str);
  1027ca:	31 c0                	xor    %eax,%eax
}
  1027cc:	c3                   	ret    

001027cd <shell_raw_fprintf>:
{
  1027cd:	55                   	push   %ebp
  1027ce:	89 e5                	mov    %esp,%ebp
	va_start(args, fmt);
  1027d0:	8d 45 10             	lea    0x10(%ebp),%eax
	shell_fprintf_fmt(ctx, fmt, args);
  1027d3:	50                   	push   %eax
  1027d4:	ff 75 0c             	pushl  0xc(%ebp)
  1027d7:	ff 75 08             	pushl  0x8(%ebp)
  1027da:	e8 d7 11 00 00       	call   1039b6 <shell_fprintf_fmt>
  1027df:	83 c4 0c             	add    $0xc,%esp
}
  1027e2:	c9                   	leave  
  1027e3:	c3                   	ret    

001027e4 <shell_internal_help_print>:
{
  1027e4:	55                   	push   %ebp
  1027e5:	89 e5                	mov    %esp,%ebp
  1027e7:	53                   	push   %ebx
	shell_help_cmd_print(shell);
  1027e8:	50                   	push   %eax
{
  1027e9:	89 c3                	mov    %eax,%ebx
	shell_help_cmd_print(shell);
  1027eb:	e8 60 25 00 00       	call   104d50 <shell_help_cmd_print>
	shell_help_subcmd_print(shell);
  1027f0:	89 1c 24             	mov    %ebx,(%esp)
  1027f3:	e8 38 24 00 00       	call   104c30 <shell_help_subcmd_print>
  1027f8:	58                   	pop    %eax
}
  1027f9:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  1027fc:	c9                   	leave  
  1027fd:	c3                   	ret    

001027fe <state_set.constprop.23>:
static void state_set(const struct shell *shell, enum shell_state state)
  1027fe:	55                   	push   %ebp
	shell->ctx->state = state;
  1027ff:	8b 50 08             	mov    0x8(%eax),%edx
static void state_set(const struct shell *shell, enum shell_state state)
  102802:	89 e5                	mov    %esp,%ebp
	shell->ctx->state = state;
  102804:	c7 42 04 02 00 00 00 	movl   $0x2,0x4(%edx)
	shell->ctx->cmd_buff[0] = '\0'; /* clear command buffer */
  10280b:	c6 42 42 00          	movb   $0x0,0x42(%edx)
	shell->ctx->cmd_buff_len = 0;
  10280f:	c7 42 3c 00 00 00 00 	movl   $0x0,0x3c(%edx)
		shell_print_prompt_and_cmd(shell);
  102816:	50                   	push   %eax
  102817:	e8 a9 1f 00 00       	call   1047c5 <shell_print_prompt_and_cmd>
  10281c:	58                   	pop    %eax
}
  10281d:	c9                   	leave  
  10281e:	c3                   	ret    

0010281f <transport_evt_handler>:
{
  10281f:	55                   	push   %ebp
  102820:	89 e5                	mov    %esp,%ebp
	signal = (evt_type == SHELL_TRANSPORT_EVT_RX_RDY) ?
  102822:	8b 45 0c             	mov    0xc(%ebp),%eax
			&shell->ctx->signals[SHELL_SIGNAL_RXRDY] :
  102825:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  102829:	8b 50 08             	mov    0x8(%eax),%edx
  10282c:	8d 82 64 02 00 00    	lea    0x264(%edx),%eax
  102832:	74 06                	je     10283a <transport_evt_handler+0x1b>
  102834:	8d 82 94 02 00 00    	lea    0x294(%edx),%eax

K_SYSCALL_DECLARE2(K_SYSCALL_K_POLL_SIGNAL_RAISE, k_poll_signal_raise, int, struct k_poll_signal *, signal, int, result)
  10283a:	c7 45 0c 00 00 00 00 	movl   $0x0,0xc(%ebp)
  102841:	89 45 08             	mov    %eax,0x8(%ebp)
}
  102844:	5d                   	pop    %ebp
  102845:	e9 08 8f 00 00       	jmp    10b752 <z_impl_k_poll_signal_raise>

0010284a <shell_log_process>:
{
  10284a:	55                   	push   %ebp
  10284b:	89 e5                	mov    %esp,%ebp
  10284d:	57                   	push   %edi
  10284e:	56                   	push   %esi
  10284f:	53                   	push   %ebx
  102850:	83 ec 08             	sub    $0x8,%esp
	int signaled = 0;
  102853:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
{
  10285a:	8b 5d 08             	mov    0x8(%ebp),%ebx
			shell_cmd_line_erase(shell);
  10285d:	53                   	push   %ebx
  10285e:	e8 25 1a 00 00       	call   104288 <shell_cmd_line_erase>
  102863:	5a                   	pop    %edx
			processed = shell_log_backend_process(shell->log_backend);
  102864:	ff 73 1c             	pushl  0x1c(%ebx)
  102867:	e8 08 2d 00 00       	call   105574 <shell_log_backend_process>
  10286c:	89 c7                	mov    %eax,%edi
		struct k_poll_signal *signal =
  10286e:	8b 43 08             	mov    0x8(%ebx),%eax
		shell_print_prompt_and_cmd(shell);
  102871:	89 1c 24             	mov    %ebx,(%esp)
		struct k_poll_signal *signal =
  102874:	8d b0 64 02 00 00    	lea    0x264(%eax),%esi
		shell_print_prompt_and_cmd(shell);
  10287a:	e8 46 1f 00 00       	call   1047c5 <shell_print_prompt_and_cmd>
		if (shell->ctx->cmd_buff_len) {
  10287f:	8b 43 08             	mov    0x8(%ebx),%eax
		shell_print_prompt_and_cmd(shell);
  102882:	59                   	pop    %ecx
		if (shell->ctx->cmd_buff_len) {
  102883:	66 83 78 3c 00       	cmpw   $0x0,0x3c(%eax)
  102888:	74 08                	je     102892 <shell_log_process+0x48>
K_SYSCALL_DECLARE1(K_SYSCALL_K_SLEEP, k_sleep, s32_t, s32_t, duration)
  10288a:	6a 0f                	push   $0xf
  10288c:	e8 7d 81 00 00       	call   10aa0e <z_impl_k_sleep>
  102891:	58                   	pop    %eax
K_SYSCALL_DECLARE3_VOID(K_SYSCALL_K_POLL_SIGNAL_CHECK, k_poll_signal_check, struct k_poll_signal *, signal, unsigned int *, signaled, int *, result)
  102892:	8d 45 f0             	lea    -0x10(%ebp),%eax
  102895:	50                   	push   %eax
  102896:	8d 45 ec             	lea    -0x14(%ebp),%eax
  102899:	50                   	push   %eax
  10289a:	56                   	push   %esi
  10289b:	e8 9a 8e 00 00       	call   10b73a <z_impl_k_poll_signal_check>
	} while (processed && !signaled);
  1028a0:	89 f8                	mov    %edi,%eax
  1028a2:	83 c4 0c             	add    $0xc,%esp
  1028a5:	84 c0                	test   %al,%al
  1028a7:	74 06                	je     1028af <shell_log_process+0x65>
  1028a9:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
  1028ad:	74 ae                	je     10285d <shell_log_process+0x13>
}
  1028af:	8d 65 f4             	lea    -0xc(%ebp),%esp
  1028b2:	5b                   	pop    %ebx
  1028b3:	5e                   	pop    %esi
  1028b4:	5f                   	pop    %edi
  1028b5:	5d                   	pop    %ebp
  1028b6:	c3                   	ret    

001028b7 <history_handle>:
{
  1028b7:	55                   	push   %ebp
  1028b8:	89 e5                	mov    %esp,%ebp
  1028ba:	56                   	push   %esi
  1028bb:	53                   	push   %ebx
  1028bc:	89 d6                	mov    %edx,%esi
  1028be:	53                   	push   %ebx
  1028bf:	89 c3                	mov    %eax,%ebx
	if (flag_history_exit_get(shell)) {
  1028c1:	8b 40 08             	mov    0x8(%eax),%eax
	shell->ctx->internal.flags.mode_delete = val ? 1 : 0;
}

static inline bool flag_history_exit_get(const struct shell *shell)
{
	return shell->ctx->internal.flags.history_exit == 1 ? true : false;
  1028c4:	8b 90 60 02 00 00    	mov    0x260(%eax),%edx
  1028ca:	80 e2 40             	and    $0x40,%dl
  1028cd:	74 1b                	je     1028ea <history_handle+0x33>
}

static inline void flag_history_exit_set(const struct shell *shell, bool val)
{
	shell->ctx->internal.flags.history_exit = val ? 1 : 0;
  1028cf:	66 8b 90 60 02 00 00 	mov    0x260(%eax),%dx
  1028d6:	8b 4b 0c             	mov    0xc(%ebx),%ecx
  1028d9:	83 e2 bf             	and    $0xffffffbf,%edx
  1028dc:	66 89 90 60 02 00 00 	mov    %dx,0x260(%eax)
		shell_history_mode_exit(shell->history);
  1028e3:	51                   	push   %ecx
  1028e4:	e8 4f 29 00 00       	call   105238 <shell_history_mode_exit>
  1028e9:	59                   	pop    %ecx
	if (!shell_history_active(shell->history)) {
  1028ea:	8b 43 0c             	mov    0xc(%ebx),%eax
  1028ed:	83 78 0c 00          	cmpl   $0x0,0xc(%eax)
  1028f1:	75 37                	jne    10292a <history_handle+0x73>
		if (up) {
  1028f3:	89 f0                	mov    %esi,%eax
  1028f5:	84 c0                	test   %al,%al
  1028f7:	0f 84 ac 00 00 00    	je     1029a9 <history_handle+0xf2>
			u16_t cmd_len = shell_strlen(shell->ctx->cmd_buff);
  1028fd:	8b 43 08             	mov    0x8(%ebx),%eax
  102900:	83 c0 42             	add    $0x42,%eax
  102903:	e8 b2 fe ff ff       	call   1027ba <shell_strlen>
			if (cmd_len) {
  102908:	66 85 c0             	test   %ax,%ax
  10290b:	8b 43 08             	mov    0x8(%ebx),%eax
  10290e:	74 13                	je     102923 <history_handle+0x6c>
				       shell->ctx->cmd_buff);
  102910:	8d 50 42             	lea    0x42(%eax),%edx
				strcpy(shell->ctx->temp_buff,
  102913:	05 42 01 00 00       	add    $0x142,%eax
  102918:	52                   	push   %edx
  102919:	50                   	push   %eax
  10291a:	e8 d7 43 00 00       	call   106cf6 <strcpy>
  10291f:	58                   	pop    %eax
  102920:	5a                   	pop    %edx
  102921:	eb 07                	jmp    10292a <history_handle+0x73>
				shell->ctx->temp_buff[0] = '\0';
  102923:	c6 80 42 01 00 00 00 	movb   $0x0,0x142(%eax)
	history_mode = shell_history_get(shell->history, up,
  10292a:	8d 45 f6             	lea    -0xa(%ebp),%eax
  10292d:	50                   	push   %eax
					 shell->ctx->cmd_buff, &len);
  10292e:	8b 43 08             	mov    0x8(%ebx),%eax
  102931:	83 c0 42             	add    $0x42,%eax
	history_mode = shell_history_get(shell->history, up,
  102934:	50                   	push   %eax
  102935:	89 f0                	mov    %esi,%eax
  102937:	0f b6 f0             	movzbl %al,%esi
  10293a:	56                   	push   %esi
  10293b:	ff 73 0c             	pushl  0xc(%ebx)
  10293e:	e8 04 29 00 00       	call   105247 <shell_history_get>
  102943:	83 c4 10             	add    $0x10,%esp
	if (!history_mode) {
  102946:	84 c0                	test   %al,%al
  102948:	75 24                	jne    10296e <history_handle+0xb7>
		strcpy(shell->ctx->cmd_buff, shell->ctx->temp_buff);
  10294a:	8b 43 08             	mov    0x8(%ebx),%eax
  10294d:	8d 90 42 01 00 00    	lea    0x142(%eax),%edx
  102953:	83 c0 42             	add    $0x42,%eax
  102956:	52                   	push   %edx
  102957:	50                   	push   %eax
  102958:	e8 99 43 00 00       	call   106cf6 <strcpy>
		len = shell_strlen(shell->ctx->cmd_buff);
  10295d:	8b 43 08             	mov    0x8(%ebx),%eax
		strcpy(shell->ctx->cmd_buff, shell->ctx->temp_buff);
  102960:	5a                   	pop    %edx
		len = shell_strlen(shell->ctx->cmd_buff);
  102961:	83 c0 42             	add    $0x42,%eax
		strcpy(shell->ctx->cmd_buff, shell->ctx->temp_buff);
  102964:	59                   	pop    %ecx
		len = shell_strlen(shell->ctx->cmd_buff);
  102965:	e8 50 fe ff ff       	call   1027ba <shell_strlen>
  10296a:	66 89 45 f6          	mov    %ax,-0xa(%ebp)
	shell_op_cursor_home_move(shell);
  10296e:	53                   	push   %ebx
  10296f:	e8 84 18 00 00       	call   1041f8 <shell_op_cursor_home_move>
	SHELL_VT100_CMD(shell, SHELL_VT100_CLEAREOS);
  102974:	c7 04 24 6c db 10 00 	movl   $0x10db6c,(%esp)
  10297b:	68 7b e4 10 00       	push   $0x10e47b
  102980:	ff 73 14             	pushl  0x14(%ebx)
  102983:	e8 45 fe ff ff       	call   1027cd <shell_raw_fprintf>
  102988:	83 c4 0c             	add    $0xc,%esp
	shell_print_cmd(shell);
  10298b:	53                   	push   %ebx
  10298c:	e8 4b 19 00 00       	call   1042dc <shell_print_cmd>
	shell->ctx->cmd_buff_pos = len;
  102991:	8b 43 08             	mov    0x8(%ebx),%eax
  102994:	66 8b 55 f6          	mov    -0xa(%ebp),%dx
  102998:	66 89 50 3e          	mov    %dx,0x3e(%eax)
	shell->ctx->cmd_buff_len = len;
  10299c:	66 89 50 3c          	mov    %dx,0x3c(%eax)
	shell_op_cond_next_line(shell);
  1029a0:	89 1c 24             	mov    %ebx,(%esp)
  1029a3:	e8 52 16 00 00       	call   103ffa <shell_op_cond_next_line>
  1029a8:	58                   	pop    %eax
}
  1029a9:	8d 65 f8             	lea    -0x8(%ebp),%esp
  1029ac:	5b                   	pop    %ebx
  1029ad:	5e                   	pop    %esi
  1029ae:	5d                   	pop    %ebp
  1029af:	c3                   	ret    

001029b0 <execute>:
{
  1029b0:	55                   	push   %ebp
  1029b1:	89 e5                	mov    %esp,%ebp
  1029b3:	57                   	push   %edi
  1029b4:	56                   	push   %esi
  1029b5:	53                   	push   %ebx
  1029b6:	89 c3                	mov    %eax,%ebx
  1029b8:	83 ec 78             	sub    $0x78,%esp
	const struct shell_static_entry *p_static_entry = NULL;
  1029bb:	c7 45 90 00 00 00 00 	movl   $0x0,-0x70(%ebp)
	shell_op_cursor_end_move(shell);
  1029c2:	50                   	push   %eax
  1029c3:	e8 4b 18 00 00       	call   104213 <shell_op_cursor_end_move>
	if (!shell_cursor_in_empty_line(shell)) {
  1029c8:	89 1c 24             	mov    %ebx,(%esp)
  1029cb:	e8 f1 15 00 00       	call   103fc1 <shell_cursor_in_empty_line>
  1029d0:	5a                   	pop    %edx
  1029d1:	84 c0                	test   %al,%al
  1029d3:	75 0f                	jne    1029e4 <execute+0x34>
	shell_raw_fprintf(shell->fprintf_ctx, "\n");
  1029d5:	68 7f e4 10 00       	push   $0x10e47f
  1029da:	ff 73 14             	pushl  0x14(%ebx)
  1029dd:	e8 eb fd ff ff       	call   1027cd <shell_raw_fprintf>
  1029e2:	5e                   	pop    %esi
  1029e3:	5f                   	pop    %edi
	memset(&shell->ctx->active_cmd, 0, sizeof(shell->ctx->active_cmd));
  1029e4:	6a 14                	push   $0x14
  1029e6:	8b 43 08             	mov    0x8(%ebx),%eax
  1029e9:	6a 00                	push   $0x0
  1029eb:	83 c0 0c             	add    $0xc,%eax
  1029ee:	50                   	push   %eax
  1029ef:	e8 8d 44 00 00       	call   106e81 <memset>
  1029f4:	83 c4 0c             	add    $0xc,%esp
	shell_cmd_trim(shell);
  1029f7:	53                   	push   %ebx
  1029f8:	e8 5c 14 00 00       	call   103e59 <shell_cmd_trim>
		    shell->ctx->cmd_buff_len);
  1029fd:	8b 43 08             	mov    0x8(%ebx),%eax
	history_put(shell, shell->ctx->cmd_buff,
  102a00:	83 c0 42             	add    $0x42,%eax
  102a03:	0f b7 50 fa          	movzwl -0x6(%eax),%edx
	shell_history_put(shell->history, line, length);
  102a07:	89 14 24             	mov    %edx,(%esp)
  102a0a:	50                   	push   %eax
  102a0b:	ff 73 0c             	pushl  0xc(%ebx)
  102a0e:	e8 ca 28 00 00       	call   1052dd <shell_history_put>
  102a13:	83 c4 0c             	add    $0xc,%esp
		shell_wildcard_prepare(shell);
  102a16:	53                   	push   %ebx
  102a17:	e8 db 2c 00 00       	call   1056f7 <shell_wildcard_prepare>
	quote = shell_make_argv(&argc, &argv[0], shell->ctx->cmd_buff,
  102a1c:	8b 43 08             	mov    0x8(%ebx),%eax
  102a1f:	c7 04 24 0c 00 00 00 	movl   $0xc,(%esp)
  102a26:	83 c0 42             	add    $0x42,%eax
  102a29:	50                   	push   %eax
  102a2a:	8d 45 c0             	lea    -0x40(%ebp),%eax
  102a2d:	50                   	push   %eax
  102a2e:	8d 45 94             	lea    -0x6c(%ebp),%eax
  102a31:	50                   	push   %eax
  102a32:	e8 a6 10 00 00       	call   103add <shell_make_argv>
  102a37:	83 c4 10             	add    $0x10,%esp
	if (!argc) {
  102a3a:	83 7d 94 00          	cmpl   $0x0,-0x6c(%ebp)
  102a3e:	74 18                	je     102a58 <execute+0xa8>
	if (quote != 0) {
  102a40:	84 c0                	test   %al,%al
  102a42:	74 1e                	je     102a62 <execute+0xb2>
		shell_internal_fprintf(shell, SHELL_ERROR,
  102a44:	0f be c0             	movsbl %al,%eax
  102a47:	50                   	push   %eax
  102a48:	68 de e3 10 00       	push   $0x10e3de
  102a4d:	6a 02                	push   $0x2
  102a4f:	53                   	push   %ebx
  102a50:	e8 54 1a 00 00       	call   1044a9 <shell_internal_fprintf>
  102a55:	83 c4 10             	add    $0x10,%esp
		return -ENOEXEC;
  102a58:	be f8 ff ff ff       	mov    $0xfffffff8,%esi
  102a5d:	e9 92 02 00 00       	jmp    102cf4 <execute+0x344>
	help_entry.help = NULL;
  102a62:	c7 45 88 00 00 00 00 	movl   $0x0,-0x78(%ebp)
	size_t cmd_idx = 0;
  102a69:	31 f6                	xor    %esi,%esi
	bool wildcard_found = false;
  102a6b:	c6 45 87 00          	movb   $0x0,-0x79(%ebp)
	size_t cmd_with_handler_lvl = 0;
  102a6f:	c7 45 80 00 00 00 00 	movl   $0x0,-0x80(%ebp)
	size_t cmd_lvl = SHELL_CMD_ROOT_LVL;
  102a76:	c7 45 8c 00 00 00 00 	movl   $0x0,-0x74(%ebp)
	const struct shell_cmd_entry *p_cmd = NULL;
  102a7d:	31 ff                	xor    %edi,%edi
		if (cmd_lvl >= argc) {
  102a7f:	8b 45 8c             	mov    -0x74(%ebp),%eax
  102a82:	39 45 94             	cmp    %eax,-0x6c(%ebp)
  102a85:	0f 86 56 01 00 00    	jbe    102be1 <execute+0x231>
		if (IS_ENABLED(CONFIG_SHELL_HELP) && (cmd_lvl > 0) &&
  102a8b:	85 c0                	test   %eax,%eax
  102a8d:	74 52                	je     102ae1 <execute+0x131>
		    (!strcmp(argv[cmd_lvl], "-h") ||
  102a8f:	68 f2 e3 10 00       	push   $0x10e3f2
  102a94:	ff 74 85 c0          	pushl  -0x40(%ebp,%eax,4)
  102a98:	e8 ec 42 00 00       	call   106d89 <strcmp>
  102a9d:	5a                   	pop    %edx
		if (IS_ENABLED(CONFIG_SHELL_HELP) && (cmd_lvl > 0) &&
  102a9e:	85 c0                	test   %eax,%eax
		    (!strcmp(argv[cmd_lvl], "-h") ||
  102aa0:	59                   	pop    %ecx
		if (IS_ENABLED(CONFIG_SHELL_HELP) && (cmd_lvl > 0) &&
  102aa1:	75 17                	jne    102aba <execute+0x10a>
			if (help_entry.help) {
  102aa3:	83 7d 88 00          	cmpl   $0x0,-0x78(%ebp)
  102aa7:	74 2e                	je     102ad7 <execute+0x127>
				shell->ctx->active_cmd = help_entry;
  102aa9:	8b 45 88             	mov    -0x78(%ebp),%eax
  102aac:	89 45 b0             	mov    %eax,-0x50(%ebp)
  102aaf:	8b 43 08             	mov    0x8(%ebx),%eax
  102ab2:	8d 78 0c             	lea    0xc(%eax),%edi
  102ab5:	e9 72 01 00 00       	jmp    102c2c <execute+0x27c>
		     !strcmp(argv[cmd_lvl], "--help"))) {
  102aba:	8b 45 8c             	mov    -0x74(%ebp),%eax
  102abd:	68 f5 e3 10 00       	push   $0x10e3f5
  102ac2:	ff 74 85 c0          	pushl  -0x40(%ebp,%eax,4)
  102ac6:	e8 be 42 00 00       	call   106d89 <strcmp>
  102acb:	5a                   	pop    %edx
		    (!strcmp(argv[cmd_lvl], "-h") ||
  102acc:	85 c0                	test   %eax,%eax
		     !strcmp(argv[cmd_lvl], "--help"))) {
  102ace:	59                   	pop    %ecx
		    (!strcmp(argv[cmd_lvl], "-h") ||
  102acf:	0f 85 f2 00 00 00    	jne    102bc7 <execute+0x217>
  102ad5:	eb cc                	jmp    102aa3 <execute+0xf3>
			shell_internal_fprintf(shell, SHELL_ERROR,
  102ad7:	68 fc e3 10 00       	push   $0x10e3fc
  102adc:	e9 a1 00 00 00       	jmp    102b82 <execute+0x1d2>
		shell_cmd_get(p_cmd, cmd_lvl, cmd_idx++, &p_static_entry,
  102ae1:	8d 45 98             	lea    -0x68(%ebp),%eax
  102ae4:	8d 56 01             	lea    0x1(%esi),%edx
  102ae7:	50                   	push   %eax
  102ae8:	8d 45 90             	lea    -0x70(%ebp),%eax
  102aeb:	50                   	push   %eax
  102aec:	89 95 7c ff ff ff    	mov    %edx,-0x84(%ebp)
  102af2:	56                   	push   %esi
  102af3:	ff 75 8c             	pushl  -0x74(%ebp)
  102af6:	57                   	push   %edi
  102af7:	e8 51 12 00 00       	call   103d4d <shell_cmd_get>
		if ((cmd_idx == 0) || (p_static_entry == NULL)) {
  102afc:	8b 95 7c ff ff ff    	mov    -0x84(%ebp),%edx
		shell_cmd_get(p_cmd, cmd_lvl, cmd_idx++, &p_static_entry,
  102b02:	83 c4 14             	add    $0x14,%esp
		if ((cmd_idx == 0) || (p_static_entry == NULL)) {
  102b05:	85 d2                	test   %edx,%edx
  102b07:	74 07                	je     102b10 <execute+0x160>
  102b09:	8b 45 90             	mov    -0x70(%ebp),%eax
  102b0c:	85 c0                	test   %eax,%eax
  102b0e:	75 27                	jne    102b37 <execute+0x187>
			if (cmd_lvl == 0) {
  102b10:	83 7d 8c 00          	cmpl   $0x0,-0x74(%ebp)
  102b14:	0f 85 c7 00 00 00    	jne    102be1 <execute+0x231>
				shell_internal_fprintf(shell, SHELL_ERROR,
  102b1a:	68 1a e4 10 00       	push   $0x10e41a
  102b1f:	ff 75 c0             	pushl  -0x40(%ebp)
  102b22:	68 e5 e6 10 00       	push   $0x10e6e5
  102b27:	6a 02                	push   $0x2
  102b29:	53                   	push   %ebx
  102b2a:	e8 7a 19 00 00       	call   1044a9 <shell_internal_fprintf>
  102b2f:	83 c4 14             	add    $0x14,%esp
				return -ENOEXEC;
  102b32:	e9 21 ff ff ff       	jmp    102a58 <execute+0xa8>
		if (strcmp(argv[cmd_lvl], p_static_entry->syntax) == 0) {
  102b37:	ff 30                	pushl  (%eax)
  102b39:	8b 45 8c             	mov    -0x74(%ebp),%eax
  102b3c:	89 95 7c ff ff ff    	mov    %edx,-0x84(%ebp)
  102b42:	ff 74 85 c0          	pushl  -0x40(%ebp,%eax,4)
  102b46:	e8 3e 42 00 00       	call   106d89 <strcmp>
  102b4b:	8b 95 7c ff ff ff    	mov    -0x84(%ebp),%edx
  102b51:	59                   	pop    %ecx
  102b52:	85 c0                	test   %eax,%eax
  102b54:	5e                   	pop    %esi
  102b55:	74 07                	je     102b5e <execute+0x1ae>
				wildcard_found = true;
  102b57:	89 d6                	mov    %edx,%esi
  102b59:	e9 21 ff ff ff       	jmp    102a7f <execute+0xcf>
			if (p_static_entry->handler != NULL) {
  102b5e:	8b 45 90             	mov    -0x70(%ebp),%eax
  102b61:	83 78 0c 00          	cmpl   $0x0,0xc(%eax)
  102b65:	74 40                	je     102ba7 <execute+0x1f7>
				if (IS_ENABLED(CONFIG_SHELL_WILDCARD) &&
  102b67:	80 7d 87 00          	cmpb   $0x0,-0x79(%ebp)
  102b6b:	74 25                	je     102b92 <execute+0x1e2>
					shell_op_cursor_end_move(shell);
  102b6d:	53                   	push   %ebx
  102b6e:	e8 a0 16 00 00       	call   104213 <shell_op_cursor_end_move>
					shell_op_cond_next_line(shell);
  102b73:	89 1c 24             	mov    %ebx,(%esp)
  102b76:	e8 7f 14 00 00       	call   103ffa <shell_op_cond_next_line>
					shell_internal_fprintf(shell,
  102b7b:	c7 04 24 2e e4 10 00 	movl   $0x10e42e,(%esp)
  102b82:	6a 02                	push   $0x2
  102b84:	53                   	push   %ebx
  102b85:	e8 1f 19 00 00       	call   1044a9 <shell_internal_fprintf>
  102b8a:	83 c4 0c             	add    $0xc,%esp
					return -ENOEXEC;
  102b8d:	e9 c6 fe ff ff       	jmp    102a58 <execute+0xa8>
				shell->ctx->active_cmd = *p_static_entry;
  102b92:	8b 4b 08             	mov    0x8(%ebx),%ecx
  102b95:	89 c6                	mov    %eax,%esi
  102b97:	8d 79 0c             	lea    0xc(%ecx),%edi
  102b9a:	b9 05 00 00 00       	mov    $0x5,%ecx
  102b9f:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
  102ba1:	8b 4d 8c             	mov    -0x74(%ebp),%ecx
  102ba4:	89 4d 80             	mov    %ecx,-0x80(%ebp)
			if (p_static_entry->help != NULL) {
  102ba7:	8b 50 04             	mov    0x4(%eax),%edx
  102baa:	85 d2                	test   %edx,%edx
  102bac:	74 0f                	je     102bbd <execute+0x20d>
				help_entry = *p_static_entry;
  102bae:	8d 7d ac             	lea    -0x54(%ebp),%edi
  102bb1:	b9 05 00 00 00       	mov    $0x5,%ecx
  102bb6:	89 c6                	mov    %eax,%esi
  102bb8:	89 55 88             	mov    %edx,-0x78(%ebp)
  102bbb:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
			cmd_lvl++;
  102bbd:	ff 45 8c             	incl   -0x74(%ebp)
			p_cmd = p_static_entry->subcmd;
  102bc0:	8b 78 08             	mov    0x8(%eax),%edi
			cmd_idx = 0;
  102bc3:	31 d2                	xor    %edx,%edx
  102bc5:	eb 90                	jmp    102b57 <execute+0x1a7>
			status = shell_wildcard_process(shell, p_cmd,
  102bc7:	8b 45 8c             	mov    -0x74(%ebp),%eax
  102bca:	ff 74 85 c0          	pushl  -0x40(%ebp,%eax,4)
  102bce:	57                   	push   %edi
  102bcf:	53                   	push   %ebx
  102bd0:	e8 8d 2b 00 00       	call   105762 <shell_wildcard_process>
  102bd5:	83 c4 0c             	add    $0xc,%esp
			if (status == SHELL_WILDCARD_CMD_NO_MATCH_FOUND) {
  102bd8:	83 f8 02             	cmp    $0x2,%eax
  102bdb:	0f 85 fc 00 00 00    	jne    102cdd <execute+0x32d>
	if (IS_ENABLED(CONFIG_SHELL_WILDCARD) && wildcard_found) {
  102be1:	80 7d 87 00          	cmpb   $0x0,-0x79(%ebp)
  102be5:	74 24                	je     102c0b <execute+0x25b>
		shell_wildcard_finalize(shell);
  102be7:	53                   	push   %ebx
  102be8:	e8 e1 2c 00 00       	call   1058ce <shell_wildcard_finalize>
				      shell->ctx->cmd_buff,
  102bed:	8b 43 08             	mov    0x8(%ebx),%eax
		(void)shell_make_argv(&argc, &argv[0],
  102bf0:	c7 04 24 0c 00 00 00 	movl   $0xc,(%esp)
				      shell->ctx->cmd_buff,
  102bf7:	83 c0 42             	add    $0x42,%eax
		(void)shell_make_argv(&argc, &argv[0],
  102bfa:	50                   	push   %eax
  102bfb:	8d 45 c0             	lea    -0x40(%ebp),%eax
  102bfe:	50                   	push   %eax
  102bff:	8d 45 94             	lea    -0x6c(%ebp),%eax
  102c02:	50                   	push   %eax
  102c03:	e8 d5 0e 00 00       	call   103add <shell_make_argv>
  102c08:	83 c4 10             	add    $0x10,%esp
	if (shell->ctx->active_cmd.handler == NULL) {
  102c0b:	8b 7b 08             	mov    0x8(%ebx),%edi
  102c0e:	83 7f 18 00          	cmpl   $0x0,0x18(%edi)
  102c12:	75 33                	jne    102c47 <execute+0x297>
			if (help_entry->help == NULL) {
  102c14:	83 7d 88 00          	cmpl   $0x0,-0x78(%ebp)
  102c18:	0f 84 3a fe ff ff    	je     102a58 <execute+0xa8>
			if (help_entry->help != shell->ctx->active_cmd.help) {
  102c1e:	8b 45 88             	mov    -0x78(%ebp),%eax
  102c21:	3b 47 10             	cmp    0x10(%edi),%eax
  102c24:	74 10                	je     102c36 <execute+0x286>
				shell->ctx->active_cmd = *help_entry;
  102c26:	89 45 b0             	mov    %eax,-0x50(%ebp)
  102c29:	83 c7 0c             	add    $0xc,%edi
  102c2c:	8d 75 ac             	lea    -0x54(%ebp),%esi
  102c2f:	b9 05 00 00 00       	mov    $0x5,%ecx
  102c34:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
			shell_internal_help_print(shell);
  102c36:	89 d8                	mov    %ebx,%eax
			return SHELL_CMD_HELP_PRINTED;
  102c38:	be 01 00 00 00       	mov    $0x1,%esi
			shell_internal_help_print(shell);
  102c3d:	e8 a2 fb ff ff       	call   1027e4 <shell_internal_help_print>
			return SHELL_CMD_HELP_PRINTED;
  102c42:	e9 ad 00 00 00       	jmp    102cf4 <execute+0x344>
	if (shell->ctx->active_cmd.args.mandatory) {
  102c47:	0f b6 47 1c          	movzbl 0x1c(%edi),%eax
	return exec_cmd(shell, argc - cmd_with_handler_lvl,
  102c4b:	8b 75 94             	mov    -0x6c(%ebp),%esi
  102c4e:	2b 75 80             	sub    -0x80(%ebp),%esi
	if (shell->ctx->active_cmd.args.mandatory) {
  102c51:	84 c0                	test   %al,%al
  102c53:	74 2f                	je     102c84 <execute+0x2d4>
		u8_t opt = shell->ctx->active_cmd.args.optional;
  102c55:	0f b6 57 1d          	movzbl 0x1d(%edi),%edx
		bool in_range = (argc >= mand) && (argc <= (mand + opt));
  102c59:	39 c6                	cmp    %eax,%esi
  102c5b:	72 06                	jb     102c63 <execute+0x2b3>
  102c5d:	01 d0                	add    %edx,%eax
	if (!arg_cnt_ok) {
  102c5f:	39 c6                	cmp    %eax,%esi
  102c61:	76 21                	jbe    102c84 <execute+0x2d4>
		shell_internal_fprintf(shell, SHELL_ERROR,
  102c63:	ff 77 0c             	pushl  0xc(%edi)
		return -EINVAL;
  102c66:	be ea ff ff ff       	mov    $0xffffffea,%esi
		shell_internal_fprintf(shell, SHELL_ERROR,
  102c6b:	68 5d e4 10 00       	push   $0x10e45d
  102c70:	6a 02                	push   $0x2
  102c72:	53                   	push   %ebx
  102c73:	e8 31 18 00 00       	call   1044a9 <shell_internal_fprintf>
  102c78:	83 c4 10             	add    $0x10,%esp
			shell_internal_help_print(shell);
  102c7b:	89 d8                	mov    %ebx,%eax
  102c7d:	e8 62 fb ff ff       	call   1027e4 <shell_internal_help_print>
	if (!ret_val) {
  102c82:	eb 70                	jmp    102cf4 <execute+0x344>
		k_mutex_unlock(&shell->ctx->wr_mtx);
  102c84:	81 c7 f4 02 00 00    	add    $0x2f4,%edi
K_SYSCALL_DECLARE1_VOID(K_SYSCALL_K_MUTEX_UNLOCK, k_mutex_unlock, struct k_mutex *, mutex)
  102c8a:	57                   	push   %edi
  102c8b:	e8 44 76 00 00       	call   10a2d4 <z_impl_k_mutex_unlock>
	return shell->ctx->internal.flags.cmd_ctx == 1 ? true : false;
}

static inline void flag_cmd_ctx_set(const struct shell *shell, bool val)
{
	shell->ctx->internal.flags.cmd_ctx = val ? 1 : 0;
  102c90:	8b 43 08             	mov    0x8(%ebx),%eax
  102c93:	66 8b 90 60 02 00 00 	mov    0x260(%eax),%dx
  102c9a:	80 ca 80             	or     $0x80,%dl
  102c9d:	66 89 90 60 02 00 00 	mov    %dx,0x260(%eax)
	return exec_cmd(shell, argc - cmd_with_handler_lvl,
  102ca4:	8b 4d 80             	mov    -0x80(%ebp),%ecx
  102ca7:	8d 54 8d c0          	lea    -0x40(%ebp,%ecx,4),%edx
		ret_val = shell->ctx->active_cmd.handler(shell, argc, argv);
  102cab:	89 14 24             	mov    %edx,(%esp)
  102cae:	56                   	push   %esi
  102caf:	53                   	push   %ebx
  102cb0:	ff 50 18             	call   *0x18(%eax)
  102cb3:	89 c6                	mov    %eax,%esi
  102cb5:	8b 43 08             	mov    0x8(%ebx),%eax
  102cb8:	83 c4 0c             	add    $0xc,%esp
		k_mutex_lock(&shell->ctx->wr_mtx, K_FOREVER);
  102cbb:	05 f4 02 00 00       	add    $0x2f4,%eax
  102cc0:	66 8b 90 6c ff ff ff 	mov    -0x94(%eax),%dx
  102cc7:	80 e2 7f             	and    $0x7f,%dl
  102cca:	66 89 90 6c ff ff ff 	mov    %dx,-0x94(%eax)
K_SYSCALL_DECLARE2(K_SYSCALL_K_MUTEX_LOCK, k_mutex_lock, int, struct k_mutex *, mutex, s32_t, timeout)
  102cd1:	6a ff                	push   $0xffffffff
  102cd3:	50                   	push   %eax
  102cd4:	e8 08 75 00 00       	call   10a1e1 <z_impl_k_mutex_lock>
  102cd9:	58                   	pop    %eax
  102cda:	5a                   	pop    %edx
  102cdb:	eb 17                	jmp    102cf4 <execute+0x344>
			if (status != SHELL_WILDCARD_NOT_FOUND) {
  102cdd:	83 f8 03             	cmp    $0x3,%eax
  102ce0:	0f 84 fb fd ff ff    	je     102ae1 <execute+0x131>
				++cmd_lvl;
  102ce6:	ff 45 8c             	incl   -0x74(%ebp)
				continue;
  102ce9:	89 f2                	mov    %esi,%edx
				wildcard_found = true;
  102ceb:	c6 45 87 01          	movb   $0x1,-0x79(%ebp)
				continue;
  102cef:	e9 63 fe ff ff       	jmp    102b57 <execute+0x1a7>
}
  102cf4:	8d 65 f4             	lea    -0xc(%ebp),%esp
  102cf7:	89 f0                	mov    %esi,%eax
  102cf9:	5b                   	pop    %ebx
  102cfa:	5e                   	pop    %esi
  102cfb:	5f                   	pop    %edi
  102cfc:	5d                   	pop    %ebp
  102cfd:	c3                   	ret    

00102cfe <shell_process>:

	return 0;
}

void shell_process(const struct shell *shell)
{
  102cfe:	55                   	push   %ebp
  102cff:	89 e5                	mov    %esp,%ebp
  102d01:	57                   	push   %edi
  102d02:	56                   	push   %esi
  102d03:	53                   	push   %ebx
  102d04:	81 ec b4 00 00 00    	sub    $0xb4,%esp
  102d0a:	8b 5d 08             	mov    0x8(%ebp),%ebx
 * @return Previous value of @a target.
 */
#ifdef CONFIG_ATOMIC_OPERATIONS_BUILTIN
static inline atomic_val_t atomic_or(atomic_t *target, atomic_val_t value)
{
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
  102d0d:	8b 43 08             	mov    0x8(%ebx),%eax
  102d10:	f0 83 88 60 02 00 00 	lock orl $0x8,0x260(%eax)
  102d17:	08 
	internal.flags.processing = 1U;

	(void)atomic_or((atomic_t *)&shell->ctx->internal.value,
			internal.value);

	switch (shell->ctx->state) {
  102d18:	8b 43 08             	mov    0x8(%ebx),%eax
  102d1b:	83 78 04 02          	cmpl   $0x2,0x4(%eax)
  102d1f:	0f 85 01 05 00 00    	jne    103226 <shell_process+0x528>
	size_t count = 0;
  102d25:	c7 85 74 ff ff ff 00 	movl   $0x0,-0x8c(%ebp)
  102d2c:	00 00 00 
		(void)shell->iface->api->read(shell->iface, &data,
  102d2f:	8b 43 04             	mov    0x4(%ebx),%eax
  102d32:	8d 8d 74 ff ff ff    	lea    -0x8c(%ebp),%ecx
  102d38:	8b 10                	mov    (%eax),%edx
  102d3a:	51                   	push   %ecx
  102d3b:	6a 01                	push   $0x1
  102d3d:	8d 8d 73 ff ff ff    	lea    -0x8d(%ebp),%ecx
  102d43:	51                   	push   %ecx
  102d44:	50                   	push   %eax
  102d45:	ff 52 10             	call   *0x10(%edx)
  102d48:	83 c4 10             	add    $0x10,%esp
		if (count == 0) {
  102d4b:	83 bd 74 ff ff ff 00 	cmpl   $0x0,-0x8c(%ebp)
  102d52:	0f 84 ce 04 00 00    	je     103226 <shell_process+0x528>
		if (ascii_filter(data) != 0) {
  102d58:	8a 95 73 ff ff ff    	mov    -0x8d(%ebp),%dl
	return (u8_t) data > SHELL_ASCII_MAX_CHAR ? -EINVAL : 0;
  102d5e:	84 d2                	test   %dl,%dl
  102d60:	78 cd                	js     102d2f <shell_process+0x31>
		switch (shell->ctx->receive_state) {
  102d62:	8b 43 08             	mov    0x8(%ebx),%eax
  102d65:	8b 78 08             	mov    0x8(%eax),%edi
  102d68:	89 bd 6c ff ff ff    	mov    %edi,-0x94(%ebp)
  102d6e:	83 ff 01             	cmp    $0x1,%edi
  102d71:	0f 84 fc 03 00 00    	je     103173 <shell_process+0x475>
  102d77:	85 ff                	test   %edi,%edi
  102d79:	74 0e                	je     102d89 <shell_process+0x8b>
  102d7b:	83 ff 02             	cmp    $0x2,%edi
  102d7e:	0f 85 96 04 00 00    	jne    10321a <shell_process+0x51c>
  102d84:	e9 22 04 00 00       	jmp    1031ab <shell_process+0x4ad>
	if ((data != '\r') && (data != '\n')) {
  102d89:	80 fa 0d             	cmp    $0xd,%dl
  102d8c:	74 0e                	je     102d9c <shell_process+0x9e>
  102d8e:	80 fa 0a             	cmp    $0xa,%dl
  102d91:	74 09                	je     102d9c <shell_process+0x9e>
	return shell->ctx->internal.flags.last_nl;
}

static inline void flag_last_nl_set(const struct shell *shell, u8_t val)
{
	shell->ctx->internal.flags.last_nl = val;
  102d93:	c6 80 61 02 00 00 00 	movb   $0x0,0x261(%eax)
		return false;
  102d9a:	eb 5c                	jmp    102df8 <shell_process+0xfa>
	return shell->ctx->internal.flags.last_nl;
  102d9c:	8a 88 61 02 00 00    	mov    0x261(%eax),%cl
	if ((flag_last_nl_get(shell) == 0U) ||
  102da2:	84 c9                	test   %cl,%cl
  102da4:	74 0a                	je     102db0 <shell_process+0xb2>
  102da6:	8a 88 61 02 00 00    	mov    0x261(%eax),%cl
  102dac:	38 ca                	cmp    %cl,%dl
  102dae:	75 48                	jne    102df8 <shell_process+0xfa>
	shell->ctx->internal.flags.last_nl = val;
  102db0:	88 90 61 02 00 00    	mov    %dl,0x261(%eax)
				if (!shell->ctx->cmd_buff_len) {
  102db6:	66 83 78 3c 00       	cmpw   $0x0,0x3c(%eax)
  102dbb:	75 2f                	jne    102dec <shell_process+0xee>
	shell->ctx->internal.flags.history_exit = val ? 1 : 0;
  102dbd:	66 8b 90 60 02 00 00 	mov    0x260(%eax),%dx
  102dc4:	83 e2 bf             	and    $0xffffffbf,%edx
  102dc7:	66 89 90 60 02 00 00 	mov    %dx,0x260(%eax)
	shell_history_mode_exit(shell->history);
  102dce:	ff 73 0c             	pushl  0xc(%ebx)
  102dd1:	e8 62 24 00 00       	call   105238 <shell_history_mode_exit>
	shell_raw_fprintf(shell->fprintf_ctx, "\n");
  102dd6:	c7 04 24 7f e4 10 00 	movl   $0x10e47f,(%esp)
  102ddd:	ff 73 14             	pushl  0x14(%ebx)
  102de0:	e8 e8 f9 ff ff       	call   1027cd <shell_raw_fprintf>
  102de5:	5e                   	pop    %esi
  102de6:	5f                   	pop    %edi
  102de7:	e9 bd 02 00 00       	jmp    1030a9 <shell_process+0x3ab>
					(void)execute(shell);
  102dec:	89 d8                	mov    %ebx,%eax
  102dee:	e8 bd fb ff ff       	call   1029b0 <execute>
				state_set(shell, SHELL_STATE_ACTIVE);
  102df3:	e9 b1 02 00 00       	jmp    1030a9 <shell_process+0x3ab>
			switch (data) {
  102df8:	80 fa 09             	cmp    $0x9,%dl
  102dfb:	74 37                	je     102e34 <shell_process+0x136>
  102dfd:	7f 16                	jg     102e15 <shell_process+0x117>
  102dff:	84 d2                	test   %dl,%dl
  102e01:	0f 84 28 ff ff ff    	je     102d2f <shell_process+0x31>
  102e07:	80 fa 08             	cmp    $0x8,%dl
  102e0a:	0f 84 8b 01 00 00    	je     102f9b <shell_process+0x29d>
  102e10:	e9 fb 01 00 00       	jmp    103010 <shell_process+0x312>
  102e15:	80 fa 1b             	cmp    $0x1b,%dl
  102e18:	74 0e                	je     102e28 <shell_process+0x12a>
  102e1a:	80 fa 7f             	cmp    $0x7f,%dl
  102e1d:	0f 84 9a 01 00 00    	je     102fbd <shell_process+0x2bf>
  102e23:	e9 e8 01 00 00       	jmp    103010 <shell_process+0x312>
	shell->ctx->receive_state = state;
  102e28:	c7 40 08 01 00 00 00 	movl   $0x1,0x8(%eax)
  102e2f:	e9 fb fe ff ff       	jmp    102d2f <shell_process+0x31>
	return shell->ctx->internal.flags.echo == 1 ? true : false;
  102e34:	8b 90 60 02 00 00    	mov    0x260(%eax),%edx
  102e3a:	c1 ea 02             	shr    $0x2,%edx
				if (flag_echo_get(shell)) {
  102e3d:	88 d1                	mov    %dl,%cl
  102e3f:	80 e1 01             	and    $0x1,%cl
  102e42:	88 8d 50 ff ff ff    	mov    %cl,-0xb0(%ebp)
  102e48:	0f 84 e1 fe ff ff    	je     102d2f <shell_process+0x31>
	shell->ctx->internal.flags.history_exit = val ? 1 : 0;
  102e4e:	66 8b 90 60 02 00 00 	mov    0x260(%eax),%dx
  102e55:	83 ca 40             	or     $0x40,%edx
  102e58:	66 89 90 60 02 00 00 	mov    %dx,0x260(%eax)
	if (compl_space == 0U) {
  102e5f:	66 81 78 3c ff 00    	cmpw   $0xff,0x3c(%eax)
  102e65:	0f 84 c4 fe ff ff    	je     102d2f <shell_process+0x31>
	memcpy(shell->ctx->temp_buff, shell->ctx->cmd_buff,
  102e6b:	0f b7 50 3e          	movzwl 0x3e(%eax),%edx
  102e6f:	52                   	push   %edx
  102e70:	8d 50 42             	lea    0x42(%eax),%edx
  102e73:	52                   	push   %edx
  102e74:	05 42 01 00 00       	add    $0x142,%eax
  102e79:	50                   	push   %eax
  102e7a:	e8 93 3f 00 00       	call   106e12 <memcpy>
	shell->ctx->temp_buff[shell->ctx->cmd_buff_pos] = '\0';
  102e7f:	8b 43 08             	mov    0x8(%ebx),%eax
	memcpy(shell->ctx->temp_buff, shell->ctx->cmd_buff,
  102e82:	83 c4 0c             	add    $0xc,%esp
	(void)shell_make_argv(argc, argv, shell->ctx->temp_buff,
  102e85:	05 42 01 00 00       	add    $0x142,%eax
	shell->ctx->temp_buff[shell->ctx->cmd_buff_pos] = '\0';
  102e8a:	0f b7 90 fc fe ff ff 	movzwl -0x104(%eax),%edx
  102e91:	c6 04 10 00          	movb   $0x0,(%eax,%edx,1)
	(void)shell_make_argv(argc, argv, shell->ctx->temp_buff,
  102e95:	6a 0c                	push   $0xc
  102e97:	50                   	push   %eax
  102e98:	8d 45 c0             	lea    -0x40(%ebp),%eax
  102e9b:	50                   	push   %eax
  102e9c:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
  102ea2:	50                   	push   %eax
  102ea3:	e8 35 0c 00 00       	call   103add <shell_make_argv>
	if ((*argc == 0) || ((space == 0) && (*argc == 1))) {
  102ea8:	8b b5 78 ff ff ff    	mov    -0x88(%ebp),%esi
	(void)shell_make_argv(argc, argv, shell->ctx->temp_buff,
  102eae:	83 c4 10             	add    $0x10,%esp
	if ((*argc == 0) || ((space == 0) && (*argc == 1))) {
  102eb1:	85 f6                	test   %esi,%esi
  102eb3:	0f 84 82 03 00 00    	je     10323b <shell_process+0x53d>
	int space = isspace((int)shell->ctx->cmd_buff[
  102eb9:	8b 43 08             	mov    0x8(%ebx),%eax
						shell->ctx->cmd_buff_pos - 1]);
  102ebc:	0f b7 50 3e          	movzwl 0x3e(%eax),%edx
	int space = isspace((int)shell->ctx->cmd_buff[
  102ec0:	0f be 44 10 41       	movsbl 0x41(%eax,%edx,1),%eax
  102ec5:	89 c2                	mov    %eax,%edx
	return (int)(c == (int)' ' || ((unsigned)c-(unsigned)'\t') < 5U);
  102ec7:	83 e8 09             	sub    $0x9,%eax
	if ((*argc == 0) || ((space == 0) && (*argc == 1))) {
  102eca:	83 f8 04             	cmp    $0x4,%eax
  102ecd:	76 0f                	jbe    102ede <shell_process+0x1e0>
  102ecf:	80 fa 20             	cmp    $0x20,%dl
  102ed2:	74 0a                	je     102ede <shell_process+0x1e0>
  102ed4:	83 fe 01             	cmp    $0x1,%esi
  102ed7:	0f 84 5c 03 00 00    	je     103239 <shell_process+0x53b>
	search_argc = space ? *argc : *argc - 1;
  102edd:	4e                   	dec    %esi
{
  102ede:	31 d2                	xor    %edx,%edx
	const struct shell_static_entry *entry = NULL;
  102ee0:	31 ff                	xor    %edi,%edi
	const struct shell_cmd_entry *prev_cmd = NULL;
  102ee2:	c7 85 68 ff ff ff 00 	movl   $0x0,-0x98(%ebp)
  102ee9:	00 00 00 
			if (shell_wildcard_character_exist(argv[*match_arg])) {
  102eec:	ff 74 95 c0          	pushl  -0x40(%ebp,%edx,4)
  102ef0:	89 95 64 ff ff ff    	mov    %edx,-0x9c(%ebp)
  102ef6:	e8 bf 27 00 00       	call   1056ba <shell_wildcard_character_exist>
  102efb:	59                   	pop    %ecx
  102efc:	84 c0                	test   %al,%al
  102efe:	8b 95 64 ff ff ff    	mov    -0x9c(%ebp),%edx
  102f04:	75 7a                	jne    102f80 <shell_process+0x282>
		entry = find_cmd(prev_cmd, *match_arg, argv[*match_arg],
  102f06:	8b 7c 95 c0          	mov    -0x40(%ebp,%edx,4),%edi
	const struct shell_static_entry *entry = NULL;
  102f0a:	c7 45 ac 00 00 00 00 	movl   $0x0,-0x54(%ebp)
	size_t idx = 0;
  102f11:	31 c0                	xor    %eax,%eax
		shell_cmd_get(cmd, lvl, idx++, &entry, d_entry);
  102f13:	8d 48 01             	lea    0x1(%eax),%ecx
  102f16:	89 95 60 ff ff ff    	mov    %edx,-0xa0(%ebp)
  102f1c:	89 8d 64 ff ff ff    	mov    %ecx,-0x9c(%ebp)
  102f22:	8d 4d 84             	lea    -0x7c(%ebp),%ecx
  102f25:	51                   	push   %ecx
  102f26:	8d 4d ac             	lea    -0x54(%ebp),%ecx
  102f29:	51                   	push   %ecx
  102f2a:	50                   	push   %eax
  102f2b:	52                   	push   %edx
  102f2c:	ff b5 68 ff ff ff    	pushl  -0x98(%ebp)
  102f32:	e8 16 0e 00 00       	call   103d4d <shell_cmd_get>
		if (entry && (strcmp(cmd_str, entry->syntax) == 0)) {
  102f37:	8b 45 ac             	mov    -0x54(%ebp),%eax
		shell_cmd_get(cmd, lvl, idx++, &entry, d_entry);
  102f3a:	83 c4 14             	add    $0x14,%esp
		if (entry && (strcmp(cmd_str, entry->syntax) == 0)) {
  102f3d:	85 c0                	test   %eax,%eax
  102f3f:	0f 84 ea fd ff ff    	je     102d2f <shell_process+0x31>
  102f45:	ff 30                	pushl  (%eax)
  102f47:	57                   	push   %edi
  102f48:	e8 3c 3e 00 00       	call   106d89 <strcmp>
  102f4d:	59                   	pop    %ecx
  102f4e:	85 c0                	test   %eax,%eax
  102f50:	5a                   	pop    %edx
  102f51:	8b 95 60 ff ff ff    	mov    -0xa0(%ebp),%edx
  102f57:	75 16                	jne    102f6f <shell_process+0x271>
			return entry;
  102f59:	8b 7d ac             	mov    -0x54(%ebp),%edi
		if (entry) {
  102f5c:	85 ff                	test   %edi,%edi
  102f5e:	0f 84 cb fd ff ff    	je     102d2f <shell_process+0x31>
			prev_cmd = entry->subcmd;
  102f64:	8b 47 08             	mov    0x8(%edi),%eax
  102f67:	89 85 68 ff ff ff    	mov    %eax,-0x98(%ebp)
  102f6d:	eb 11                	jmp    102f80 <shell_process+0x282>
		shell_cmd_get(cmd, lvl, idx++, &entry, d_entry);
  102f6f:	8b 85 64 ff ff ff    	mov    -0x9c(%ebp),%eax
	} while (entry);
  102f75:	83 7d ac 00          	cmpl   $0x0,-0x54(%ebp)
  102f79:	75 98                	jne    102f13 <shell_process+0x215>
  102f7b:	e9 af fd ff ff       	jmp    102d2f <shell_process+0x31>
			(*match_arg)++;
  102f80:	8d 42 01             	lea    0x1(%edx),%eax
  102f83:	42                   	inc    %edx
	while (*match_arg < argc) {
  102f84:	39 c6                	cmp    %eax,%esi
  102f86:	0f 87 60 ff ff ff    	ja     102eec <shell_process+0x1ee>
	if ((*cmd == NULL) && (search_argc != 0)) {
  102f8c:	89 c6                	mov    %eax,%esi
  102f8e:	85 ff                	test   %edi,%edi
  102f90:	0f 85 a7 02 00 00    	jne    10323d <shell_process+0x53f>
  102f96:	e9 94 fd ff ff       	jmp    102d2f <shell_process+0x31>
	return shell->ctx->internal.flags.echo == 1 ? true : false;
  102f9b:	8b 90 60 02 00 00    	mov    0x260(%eax),%edx
				if (flag_echo_get(shell)) {
  102fa1:	80 e2 04             	and    $0x4,%dl
  102fa4:	0f 84 85 fd ff ff    	je     102d2f <shell_process+0x31>
	shell->ctx->internal.flags.history_exit = val ? 1 : 0;
  102faa:	66 8b 90 60 02 00 00 	mov    0x260(%eax),%dx
  102fb1:	83 ca 40             	or     $0x40,%edx
  102fb4:	66 89 90 60 02 00 00 	mov    %dx,0x260(%eax)
					shell_op_char_backspace(shell);
  102fbb:	eb 2a                	jmp    102fe7 <shell_process+0x2e9>
	return shell->ctx->internal.flags.echo == 1 ? true : false;
  102fbd:	8b 90 60 02 00 00    	mov    0x260(%eax),%edx
				if (flag_echo_get(shell)) {
  102fc3:	80 e2 04             	and    $0x4,%dl
  102fc6:	0f 84 63 fd ff ff    	je     102d2f <shell_process+0x31>
	shell->ctx->internal.flags.history_exit = val ? 1 : 0;
  102fcc:	66 8b 90 60 02 00 00 	mov    0x260(%eax),%dx
  102fd3:	83 ca 40             	or     $0x40,%edx
  102fd6:	66 89 90 60 02 00 00 	mov    %dx,0x260(%eax)
	return shell->ctx->internal.flags.mode_delete == 1 ? true : false;
  102fdd:	8b 80 60 02 00 00    	mov    0x260(%eax),%eax
					if (flag_mode_delete_get(shell)) {
  102fe3:	a8 20                	test   $0x20,%al
  102fe5:	74 1d                	je     103004 <shell_process+0x306>
						shell_op_char_backspace(shell);
  102fe7:	53                   	push   %ebx
  102fe8:	e8 a5 17 00 00       	call   104792 <shell_op_char_backspace>
  102fed:	eb 1b                	jmp    10300a <shell_process+0x30c>
	shell->ctx->receive_state = state;
  102fef:	c7 40 08 03 00 00 00 	movl   $0x3,0x8(%eax)
	return shell->ctx->internal.flags.echo == 1 ? true : false;
  102ff6:	8b 80 60 02 00 00    	mov    0x260(%eax),%eax
				if (flag_echo_get(shell)) {
  102ffc:	a8 04                	test   $0x4,%al
  102ffe:	0f 84 2b fd ff ff    	je     102d2f <shell_process+0x31>
						shell_op_char_delete(shell);
  103004:	53                   	push   %ebx
  103005:	e8 36 17 00 00       	call   104740 <shell_op_char_delete>
  10300a:	59                   	pop    %ecx
  10300b:	e9 1f fd ff ff       	jmp    102d2f <shell_process+0x31>
		if (ascii_filter(data) != 0) {
  103010:	0f be ca             	movsbl %dl,%ecx
	return (int)((((unsigned)c) >= ' ') &&
  103013:	8d 71 e0             	lea    -0x20(%ecx),%esi
				if (isprint((int) data)) {
  103016:	83 fe 5e             	cmp    $0x5e,%esi
  103019:	77 1f                	ja     10303a <shell_process+0x33c>
	shell->ctx->internal.flags.history_exit = val ? 1 : 0;
  10301b:	66 8b 90 60 02 00 00 	mov    0x260(%eax),%dx
  103022:	83 ca 40             	or     $0x40,%edx
  103025:	66 89 90 60 02 00 00 	mov    %dx,0x260(%eax)
					shell_op_char_insert(shell, data);
  10302c:	51                   	push   %ecx
  10302d:	53                   	push   %ebx
  10302e:	e8 74 16 00 00       	call   1046a7 <shell_op_char_insert>
		shell_op_cursor_move(shell, 1);
  103033:	59                   	pop    %ecx
  103034:	5e                   	pop    %esi
  103035:	e9 f5 fc ff ff       	jmp    102d2f <shell_process+0x31>
	return shell->ctx->internal.flags.echo == 1 ? true : false;
  10303a:	8b 80 60 02 00 00    	mov    0x260(%eax),%eax
				} else if (flag_echo_get(shell)) {
  103040:	a8 04                	test   $0x4,%al
  103042:	0f 84 e7 fc ff ff    	je     102d2f <shell_process+0x31>
	switch (data) {
  103048:	4a                   	dec    %edx
  103049:	80 fa 16             	cmp    $0x16,%dl
  10304c:	0f 87 dd fc ff ff    	ja     102d2f <shell_process+0x31>
  103052:	0f b6 d2             	movzbl %dl,%edx
  103055:	ff 24 95 a0 da 10 00 	jmp    *0x10daa0(,%edx,4)
	shell->ctx->receive_state = state;
  10305c:	c7 40 08 03 00 00 00 	movl   $0x3,0x8(%eax)
		shell_op_cursor_home_move(shell);
  103063:	53                   	push   %ebx
  103064:	e8 8f 11 00 00       	call   1041f8 <shell_op_cursor_home_move>
  103069:	eb 9f                	jmp    10300a <shell_process+0x30c>
		shell_op_left_arrow(shell);
  10306b:	53                   	push   %ebx
  10306c:	e8 be 11 00 00       	call   10422f <shell_op_left_arrow>
  103071:	eb 97                	jmp    10300a <shell_process+0x30c>
		shell_op_cursor_end_move(shell);
  103073:	53                   	push   %ebx
  103074:	e8 9a 11 00 00       	call   104213 <shell_op_cursor_end_move>
		if (!shell_cursor_in_empty_line(shell)) {
  103079:	89 1c 24             	mov    %ebx,(%esp)
  10307c:	e8 40 0f 00 00       	call   103fc1 <shell_cursor_in_empty_line>
  103081:	5a                   	pop    %edx
  103082:	84 c0                	test   %al,%al
  103084:	75 0f                	jne    103095 <shell_process+0x397>
	shell_raw_fprintf(shell->fprintf_ctx, "\n");
  103086:	68 7f e4 10 00       	push   $0x10e47f
  10308b:	ff 73 14             	pushl  0x14(%ebx)
  10308e:	e8 3a f7 ff ff       	call   1027cd <shell_raw_fprintf>
  103093:	5e                   	pop    %esi
  103094:	5f                   	pop    %edi
	shell->ctx->internal.flags.history_exit = val ? 1 : 0;
  103095:	8b 53 08             	mov    0x8(%ebx),%edx
  103098:	66 8b 82 60 02 00 00 	mov    0x260(%edx),%ax
  10309f:	83 c8 40             	or     $0x40,%eax
  1030a2:	66 89 82 60 02 00 00 	mov    %ax,0x260(%edx)
		state_set(shell, SHELL_STATE_ACTIVE);
  1030a9:	89 d8                	mov    %ebx,%eax
  1030ab:	e8 4e f7 ff ff       	call   1027fe <state_set.constprop.23>
		break;
  1030b0:	e9 7a fc ff ff       	jmp    102d2f <shell_process+0x31>
	shell->ctx->receive_state = state;
  1030b5:	c7 40 08 03 00 00 00 	movl   $0x3,0x8(%eax)
		shell_op_cursor_end_move(shell);
  1030bc:	53                   	push   %ebx
  1030bd:	e8 51 11 00 00       	call   104213 <shell_op_cursor_end_move>
  1030c2:	e9 43 ff ff ff       	jmp    10300a <shell_process+0x30c>
		shell_op_right_arrow(shell);
  1030c7:	53                   	push   %ebx
  1030c8:	e8 7e 11 00 00       	call   10424b <shell_op_right_arrow>
  1030cd:	e9 38 ff ff ff       	jmp    10300a <shell_process+0x30c>
		shell_op_delete_from_cursor(shell);
  1030d2:	53                   	push   %ebx
  1030d3:	e8 91 11 00 00       	call   104269 <shell_op_delete_from_cursor>
  1030d8:	e9 2d ff ff ff       	jmp    10300a <shell_process+0x30c>
		SHELL_VT100_CMD(shell, SHELL_VT100_CURSORHOME);
  1030dd:	68 78 db 10 00       	push   $0x10db78
  1030e2:	68 7b e4 10 00       	push   $0x10e47b
  1030e7:	ff 73 14             	pushl  0x14(%ebx)
  1030ea:	e8 de f6 ff ff       	call   1027cd <shell_raw_fprintf>
  1030ef:	83 c4 0c             	add    $0xc,%esp
		SHELL_VT100_CMD(shell, SHELL_VT100_CLEARSCREEN);
  1030f2:	68 70 db 10 00       	push   $0x10db70
  1030f7:	68 7b e4 10 00       	push   $0x10e47b
  1030fc:	ff 73 14             	pushl  0x14(%ebx)
  1030ff:	e8 c9 f6 ff ff       	call   1027cd <shell_raw_fprintf>
  103104:	83 c4 0c             	add    $0xc,%esp
		shell_print_prompt_and_cmd(shell);
  103107:	53                   	push   %ebx
  103108:	e8 b8 16 00 00       	call   1047c5 <shell_print_prompt_and_cmd>
  10310d:	e9 f8 fe ff ff       	jmp    10300a <shell_process+0x30c>
		shell_op_cursor_home_move(shell);
  103112:	53                   	push   %ebx
  103113:	e8 e0 10 00 00       	call   1041f8 <shell_op_cursor_home_move>
		cmd_buffer_clear(shell);
  103118:	8b 43 08             	mov    0x8(%ebx),%eax
  10311b:	66 8b 90 60 02 00 00 	mov    0x260(%eax),%dx
	shell->ctx->cmd_buff[0] = '\0'; /* clear command buffer */
  103122:	c6 40 42 00          	movb   $0x0,0x42(%eax)
  103126:	83 ca 40             	or     $0x40,%edx
	shell->ctx->cmd_buff_len = 0;
  103129:	c7 40 3c 00 00 00 00 	movl   $0x0,0x3c(%eax)
  103130:	66 89 90 60 02 00 00 	mov    %dx,0x260(%eax)
	SHELL_VT100_CMD(shell, SHELL_VT100_CLEAREOS);
  103137:	c7 04 24 6c db 10 00 	movl   $0x10db6c,(%esp)
  10313e:	68 7b e4 10 00       	push   $0x10e47b
  103143:	ff 73 14             	pushl  0x14(%ebx)
  103146:	e8 82 f6 ff ff       	call   1027cd <shell_raw_fprintf>
  10314b:	83 c4 0c             	add    $0xc,%esp
  10314e:	e9 dc fb ff ff       	jmp    102d2f <shell_process+0x31>
		shell_op_word_remove(shell);
  103153:	53                   	push   %ebx
  103154:	e8 6a 13 00 00       	call   1044c3 <shell_op_word_remove>
	shell->ctx->internal.flags.history_exit = val ? 1 : 0;
  103159:	8b 53 08             	mov    0x8(%ebx),%edx
  10315c:	59                   	pop    %ecx
  10315d:	66 8b 82 60 02 00 00 	mov    0x260(%edx),%ax
  103164:	83 c8 40             	or     $0x40,%eax
  103167:	66 89 82 60 02 00 00 	mov    %ax,0x260(%edx)
  10316e:	e9 bc fb ff ff       	jmp    102d2f <shell_process+0x31>
			if (data == '[') {
  103173:	80 fa 5b             	cmp    $0x5b,%dl
  103176:	75 0c                	jne    103184 <shell_process+0x486>
	shell->ctx->receive_state = state;
  103178:	c7 40 08 02 00 00 00 	movl   $0x2,0x8(%eax)
  10317f:	e9 ab fb ff ff       	jmp    102d2f <shell_process+0x31>
	return shell->ctx->internal.flags.echo == 1 ? true : false;
  103184:	8b 80 60 02 00 00    	mov    0x260(%eax),%eax
			} else if (flag_echo_get(shell)) {
  10318a:	a8 04                	test   $0x4,%al
  10318c:	74 18                	je     1031a6 <shell_process+0x4a8>
	if (data == SHELL_VT100_ASCII_ALT_B) {
  10318e:	80 fa 62             	cmp    $0x62,%dl
  103191:	75 04                	jne    103197 <shell_process+0x499>
		shell_op_cursor_word_move(shell, -1);
  103193:	6a ff                	push   $0xffffffff
  103195:	eb 07                	jmp    10319e <shell_process+0x4a0>
	} else if (data == SHELL_VT100_ASCII_ALT_F) {
  103197:	80 fa 66             	cmp    $0x66,%dl
  10319a:	75 0a                	jne    1031a6 <shell_process+0x4a8>
		shell_op_cursor_word_move(shell, 1);
  10319c:	6a 01                	push   $0x1
  10319e:	53                   	push   %ebx
  10319f:	e8 8e 0f 00 00       	call   104132 <shell_op_cursor_word_move>
  1031a4:	58                   	pop    %eax
  1031a5:	5a                   	pop    %edx
	shell->ctx->receive_state = state;
  1031a6:	8b 43 08             	mov    0x8(%ebx),%eax
  1031a9:	eb 6f                	jmp    10321a <shell_process+0x51c>
  1031ab:	8b 88 60 02 00 00    	mov    0x260(%eax),%ecx
  1031b1:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
			if (!flag_echo_get(shell)) {
  1031b8:	80 e1 04             	and    $0x4,%cl
  1031bb:	0f 84 6e fb ff ff    	je     102d2f <shell_process+0x31>
			switch (data) {
  1031c1:	83 ea 31             	sub    $0x31,%edx
  1031c4:	80 fa 1b             	cmp    $0x1b,%dl
  1031c7:	0f 87 62 fb ff ff    	ja     102d2f <shell_process+0x31>
  1031cd:	0f b6 d2             	movzbl %dl,%edx
  1031d0:	ff 24 95 fc da 10 00 	jmp    *0x10dafc(,%edx,4)
				history_handle(shell, true);
  1031d7:	ba 01 00 00 00       	mov    $0x1,%edx
  1031dc:	eb 02                	jmp    1031e0 <shell_process+0x4e2>
				history_handle(shell, false);
  1031de:	31 d2                	xor    %edx,%edx
  1031e0:	89 d8                	mov    %ebx,%eax
  1031e2:	e8 d0 f6 ff ff       	call   1028b7 <history_handle>
				break;
  1031e7:	e9 43 fb ff ff       	jmp    102d2f <shell_process+0x31>
	shell->ctx->receive_state = state;
  1031ec:	c7 40 08 03 00 00 00 	movl   $0x3,0x8(%eax)
	return ((shell->ctx->internal.flags.insert_mode == 1) ? true : false);
  1031f3:	8b 90 60 02 00 00    	mov    0x260(%eax),%edx
	shell->ctx->internal.flags.insert_mode = val ? 1 : 0;
  1031f9:	66 8b 88 60 02 00 00 	mov    0x260(%eax),%cx
	return ((shell->ctx->internal.flags.insert_mode == 1) ? true : false);
  103200:	83 e2 01             	and    $0x1,%edx
	shell->ctx->internal.flags.insert_mode = val ? 1 : 0;
  103203:	83 e1 fe             	and    $0xfffffffe,%ecx
				flag_insert_mode_set(shell, !status);
  103206:	83 f2 01             	xor    $0x1,%edx
  103209:	83 e2 01             	and    $0x1,%edx
  10320c:	09 ca                	or     %ecx,%edx
  10320e:	66 89 90 60 02 00 00 	mov    %dx,0x260(%eax)
  103215:	e9 15 fb ff ff       	jmp    102d2f <shell_process+0x31>
	shell->ctx->receive_state = state;
  10321a:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
  103221:	e9 09 fb ff ff       	jmp    102d2f <shell_process+0x31>
 * @return Previous value of @a target.
 */
#ifdef CONFIG_ATOMIC_OPERATIONS_BUILTIN
static inline atomic_val_t atomic_and(atomic_t *target, atomic_val_t value)
{
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
  103226:	8b 43 08             	mov    0x8(%ebx),%eax
  103229:	f0 83 a0 60 02 00 00 	lock andl $0xfffffff7,0x260(%eax)
  103230:	f7 

	internal.value = 0xFFFFFFFF;
	internal.flags.processing = 0U;
	(void)atomic_and((atomic_t *)&shell->ctx->internal.value,
			 internal.value);
}
  103231:	8d 65 f4             	lea    -0xc(%ebp),%esp
  103234:	5b                   	pop    %ebx
  103235:	5e                   	pop    %esi
  103236:	5f                   	pop    %edi
  103237:	5d                   	pop    %ebp
  103238:	c3                   	ret    
		*complete_arg_idx = SHELL_CMD_ROOT_LVL;
  103239:	31 f6                	xor    %esi,%esi
		*cmd = NULL;
  10323b:	31 ff                	xor    %edi,%edi
	find_completion_candidates(cmd, argv[arg_idx], &first, &cnt, &longest);
  10323d:	8b 44 b5 c0          	mov    -0x40(%ebp,%esi,4),%eax
  103241:	89 85 5c ff ff ff    	mov    %eax,-0xa4(%ebp)
	size_t incompl_cmd_len = shell_strlen(incompl_cmd);
  103247:	e8 6e f5 ff ff       	call   1027ba <shell_strlen>
  10324c:	0f b7 c0             	movzwl %ax,%eax
  10324f:	89 85 4c ff ff ff    	mov    %eax,-0xb4(%ebp)
	*cnt = 0;
  103255:	c7 85 68 ff ff ff 00 	movl   $0x0,-0x98(%ebp)
  10325c:	00 00 00 
	size_t first = 0;
  10325f:	c7 85 60 ff ff ff 00 	movl   $0x0,-0xa0(%ebp)
  103266:	00 00 00 
	*longest = 0U;
  103269:	66 c7 85 58 ff ff ff 	movw   $0x0,-0xa8(%ebp)
  103270:	00 00 
	bool found = false;
  103272:	c6 85 54 ff ff ff 00 	movb   $0x0,-0xac(%ebp)
		shell_cmd_get(cmd ? cmd->subcmd : NULL, cmd ? 1 : 0,
  103279:	31 c0                	xor    %eax,%eax
  10327b:	85 ff                	test   %edi,%edi
  10327d:	0f 95 c0             	setne  %al
  103280:	89 85 64 ff ff ff    	mov    %eax,-0x9c(%ebp)
  103286:	b8 00 00 00 00       	mov    $0x0,%eax
  10328b:	74 03                	je     103290 <shell_process+0x592>
  10328d:	8b 47 08             	mov    0x8(%edi),%eax
  103290:	8d 55 ac             	lea    -0x54(%ebp),%edx
  103293:	52                   	push   %edx
  103294:	8d 55 98             	lea    -0x68(%ebp),%edx
  103297:	52                   	push   %edx
  103298:	ff b5 6c ff ff ff    	pushl  -0x94(%ebp)
  10329e:	ff b5 64 ff ff ff    	pushl  -0x9c(%ebp)
  1032a4:	50                   	push   %eax
  1032a5:	e8 a3 0a 00 00       	call   103d4d <shell_cmd_get>
		if (!candidate) {
  1032aa:	8b 45 98             	mov    -0x68(%ebp),%eax
		shell_cmd_get(cmd ? cmd->subcmd : NULL, cmd ? 1 : 0,
  1032ad:	83 c4 14             	add    $0x14,%esp
		if (!candidate) {
  1032b0:	85 c0                	test   %eax,%eax
  1032b2:	74 6b                	je     10331f <shell_process+0x621>
	return (strncmp(candidate, str, len) == 0) ? true : false;
  1032b4:	ff b5 4c ff ff ff    	pushl  -0xb4(%ebp)
  1032ba:	ff b5 5c ff ff ff    	pushl  -0xa4(%ebp)
  1032c0:	ff 30                	pushl  (%eax)
  1032c2:	e8 e2 3a 00 00       	call   106da9 <strncmp>
  1032c7:	83 c4 0c             	add    $0xc,%esp
		if (is_completion_candidate(candidate->syntax, incompl_cmd,
  1032ca:	85 c0                	test   %eax,%eax
  1032cc:	75 46                	jne    103314 <shell_process+0x616>
			size_t slen = strlen(candidate->syntax);
  1032ce:	8b 45 98             	mov    -0x68(%ebp),%eax
  1032d1:	ff 30                	pushl  (%eax)
  1032d3:	e8 9e 3a 00 00       	call   106d76 <strlen>
  1032d8:	5a                   	pop    %edx
			*longest = (slen > *longest) ? slen : *longest;
  1032d9:	0f b7 95 58 ff ff ff 	movzwl -0xa8(%ebp),%edx
  1032e0:	39 c2                	cmp    %eax,%edx
  1032e2:	73 02                	jae    1032e6 <shell_process+0x5e8>
  1032e4:	89 c2                	mov    %eax,%edx
			(*cnt)++;
  1032e6:	ff 85 68 ff ff ff    	incl   -0x98(%ebp)
			*longest = (slen > *longest) ? slen : *longest;
  1032ec:	66 89 95 58 ff ff ff 	mov    %dx,-0xa8(%ebp)
			if (!found) {
  1032f3:	80 bd 54 ff ff ff 00 	cmpb   $0x0,-0xac(%ebp)
  1032fa:	75 18                	jne    103314 <shell_process+0x616>
				*first_idx = idx;
  1032fc:	8b 85 6c ff ff ff    	mov    -0x94(%ebp),%eax
  103302:	89 85 60 ff ff ff    	mov    %eax,-0xa0(%ebp)
			found = true;
  103308:	8a 85 50 ff ff ff    	mov    -0xb0(%ebp),%al
  10330e:	88 85 54 ff ff ff    	mov    %al,-0xac(%ebp)
		idx++;
  103314:	ff 85 6c ff ff ff    	incl   -0x94(%ebp)
  10331a:	e9 5a ff ff ff       	jmp    103279 <shell_process+0x57b>
	if (cnt == 1) {
  10331f:	83 bd 68 ff ff ff 01 	cmpl   $0x1,-0x98(%ebp)
  103326:	0f 85 be 00 00 00    	jne    1033ea <shell_process+0x6ec>
	u16_t arg_len = shell_strlen(arg);
  10332c:	8b 44 b5 c0          	mov    -0x40(%ebp,%esi,4),%eax
  103330:	e8 85 f4 ff ff       	call   1027ba <shell_strlen>
  103335:	0f b7 f0             	movzwl %ax,%esi
	shell_cmd_get(cmd ? cmd->subcmd : NULL, cmd ? 1 : 0,
  103338:	8b 43 08             	mov    0x8(%ebx),%eax
  10333b:	83 c0 0c             	add    $0xc,%eax
  10333e:	85 ff                	test   %edi,%edi
  103340:	74 03                	je     103345 <shell_process+0x647>
  103342:	8b 7f 08             	mov    0x8(%edi),%edi
  103345:	50                   	push   %eax
  103346:	8d 45 ac             	lea    -0x54(%ebp),%eax
  103349:	50                   	push   %eax
  10334a:	ff b5 60 ff ff ff    	pushl  -0xa0(%ebp)
  103350:	ff b5 64 ff ff ff    	pushl  -0x9c(%ebp)
  103356:	57                   	push   %edi
  103357:	e8 f1 09 00 00       	call   103d4d <shell_cmd_get>
	cmd_len = shell_strlen(match->syntax);
  10335c:	8b 45 ac             	mov    -0x54(%ebp),%eax
	shell_cmd_get(cmd ? cmd->subcmd : NULL, cmd ? 1 : 0,
  10335f:	83 c4 14             	add    $0x14,%esp
	cmd_len = shell_strlen(match->syntax);
  103362:	8b 00                	mov    (%eax),%eax
  103364:	e8 51 f4 ff ff       	call   1027ba <shell_strlen>
	if (cmd_len != arg_len) {
  103369:	66 39 c6             	cmp    %ax,%si
  10336c:	74 15                	je     103383 <shell_process+0x685>
					   cmd_len - arg_len);
  10336e:	29 f0                	sub    %esi,%eax
		shell_op_completion_insert(shell,
  103370:	0f b7 c0             	movzwl %ax,%eax
  103373:	50                   	push   %eax
  103374:	8b 45 ac             	mov    -0x54(%ebp),%eax
  103377:	03 30                	add    (%eax),%esi
  103379:	56                   	push   %esi
  10337a:	53                   	push   %ebx
  10337b:	e8 ad 13 00 00       	call   10472d <shell_op_completion_insert>
  103380:	83 c4 0c             	add    $0xc,%esp
	if (!isspace((int) shell->ctx->cmd_buff[
  103383:	8b 43 08             	mov    0x8(%ebx),%eax
					shell->ctx->cmd_buff_pos])) {
  103386:	0f b7 50 3e          	movzwl 0x3e(%eax),%edx
	if (!isspace((int) shell->ctx->cmd_buff[
  10338a:	0f be 54 10 42       	movsbl 0x42(%eax,%edx,1),%edx
  10338f:	89 d1                	mov    %edx,%ecx
	return (int)(c == (int)' ' || ((unsigned)c-(unsigned)'\t') < 5U);
  103391:	83 ea 09             	sub    $0x9,%edx
  103394:	83 fa 04             	cmp    $0x4,%edx
  103397:	76 44                	jbe    1033dd <shell_process+0x6df>
  103399:	80 f9 20             	cmp    $0x20,%cl
  10339c:	74 3f                	je     1033dd <shell_process+0x6df>
	return ((shell->ctx->internal.flags.insert_mode == 1) ? true : false);
  10339e:	8b 90 60 02 00 00    	mov    0x260(%eax),%edx
		if (flag_insert_mode_get(shell)) {
  1033a4:	80 e2 01             	and    $0x1,%dl
  1033a7:	74 2d                	je     1033d6 <shell_process+0x6d8>
	shell->ctx->internal.flags.insert_mode = val ? 1 : 0;
  1033a9:	66 8b 90 60 02 00 00 	mov    0x260(%eax),%dx
  1033b0:	83 e2 fe             	and    $0xfffffffe,%edx
  1033b3:	66 89 90 60 02 00 00 	mov    %dx,0x260(%eax)
			shell_op_char_insert(shell, ' ');
  1033ba:	6a 20                	push   $0x20
  1033bc:	53                   	push   %ebx
  1033bd:	e8 e5 12 00 00       	call   1046a7 <shell_op_char_insert>
  1033c2:	8b 53 08             	mov    0x8(%ebx),%edx
  1033c5:	5f                   	pop    %edi
  1033c6:	58                   	pop    %eax
  1033c7:	66 8b 82 60 02 00 00 	mov    0x260(%edx),%ax
  1033ce:	83 c8 01             	or     $0x1,%eax
  1033d1:	e9 91 fd ff ff       	jmp    103167 <shell_process+0x469>
			shell_op_char_insert(shell, ' ');
  1033d6:	6a 20                	push   $0x20
  1033d8:	e9 50 fc ff ff       	jmp    10302d <shell_process+0x32f>
		shell_op_cursor_move(shell, 1);
  1033dd:	6a 01                	push   $0x1
  1033df:	53                   	push   %ebx
  1033e0:	e8 c7 0c 00 00       	call   1040ac <shell_op_cursor_move>
  1033e5:	e9 49 fc ff ff       	jmp    103033 <shell_process+0x335>
	} else if (cnt > 1) {
  1033ea:	0f 86 3f f9 ff ff    	jbe    102d2f <shell_process+0x31>
		tab_options_print(shell, cmd, argv[arg_idx], first, cnt,
  1033f0:	8b 44 b5 c0          	mov    -0x40(%ebp,%esi,4),%eax
  1033f4:	89 85 5c ff ff ff    	mov    %eax,-0xa4(%ebp)
	size_t str_len = shell_strlen(str);
  1033fa:	e8 bb f3 ff ff       	call   1027ba <shell_strlen>
  1033ff:	0f b7 c0             	movzwl %ax,%eax
  103402:	89 85 4c ff ff ff    	mov    %eax,-0xb4(%ebp)
		shell->ctx->vt100_ctx.printed_cmd = 0;
  103408:	8b 43 08             	mov    0x8(%ebx),%eax
  10340b:	66 c7 40 38 00 00    	movw   $0x0,0x38(%eax)
  103411:	8b 85 68 ff ff ff    	mov    -0x98(%ebp),%eax
  103417:	89 85 40 ff ff ff    	mov    %eax,-0xc0(%ebp)
  10341d:	8b 85 60 ff ff ff    	mov    -0xa0(%ebp),%eax
  103423:	89 85 54 ff ff ff    	mov    %eax,-0xac(%ebp)
		shell_cmd_get(cmd ? cmd->subcmd : NULL, cmd ? 1 : 0,
  103429:	8b 43 08             	mov    0x8(%ebx),%eax
  10342c:	31 d2                	xor    %edx,%edx
  10342e:	83 c0 0c             	add    $0xc,%eax
  103431:	85 ff                	test   %edi,%edi
  103433:	74 03                	je     103438 <shell_process+0x73a>
  103435:	8b 57 08             	mov    0x8(%edi),%edx
  103438:	50                   	push   %eax
  103439:	8d 45 ac             	lea    -0x54(%ebp),%eax
  10343c:	50                   	push   %eax
  10343d:	ff b5 54 ff ff ff    	pushl  -0xac(%ebp)
  103443:	ff b5 64 ff ff ff    	pushl  -0x9c(%ebp)
  103449:	52                   	push   %edx
  10344a:	e8 fe 08 00 00       	call   103d4d <shell_cmd_get>
  10344f:	83 c4 14             	add    $0x14,%esp
		idx++;
  103452:	ff 85 54 ff ff ff    	incl   -0xac(%ebp)
		if (str && match->syntax &&
  103458:	83 bd 5c ff ff ff 00 	cmpl   $0x0,-0xa4(%ebp)
  10345f:	75 1d                	jne    10347e <shell_process+0x780>
		tab_item_print(shell, match->syntax, longest);
  103461:	8b 45 ac             	mov    -0x54(%ebp),%eax
  103464:	8b 00                	mov    (%eax),%eax
  103466:	89 85 6c ff ff ff    	mov    %eax,-0x94(%ebp)
	if (option == NULL) {
  10346c:	85 c0                	test   %eax,%eax
  10346e:	75 32                	jne    1034a2 <shell_process+0x7a4>
		shell->ctx->vt100_ctx.printed_cmd = 0;
  103470:	8b 43 08             	mov    0x8(%ebx),%eax
  103473:	66 c7 40 38 00 00    	movw   $0x0,0x38(%eax)
		return;
  103479:	e9 fe 00 00 00       	jmp    10357c <shell_process+0x87e>
		if (str && match->syntax &&
  10347e:	8b 45 ac             	mov    -0x54(%ebp),%eax
  103481:	8b 00                	mov    (%eax),%eax
  103483:	85 c0                	test   %eax,%eax
  103485:	74 da                	je     103461 <shell_process+0x763>
	return (strncmp(candidate, str, len) == 0) ? true : false;
  103487:	ff b5 4c ff ff ff    	pushl  -0xb4(%ebp)
  10348d:	ff b5 5c ff ff ff    	pushl  -0xa4(%ebp)
  103493:	50                   	push   %eax
  103494:	e8 10 39 00 00       	call   106da9 <strncmp>
  103499:	83 c4 0c             	add    $0xc,%esp
		if (str && match->syntax &&
  10349c:	85 c0                	test   %eax,%eax
  10349e:	74 c1                	je     103461 <shell_process+0x763>
  1034a0:	eb 87                	jmp    103429 <shell_process+0x72b>
	longest_option += shell_strlen(tab);
  1034a2:	b8 8e df 10 00       	mov    $0x10df8e,%eax
  1034a7:	e8 0e f3 ff ff       	call   1027ba <shell_strlen>
  1034ac:	03 85 58 ff ff ff    	add    -0xa8(%ebp),%eax
  1034b2:	66 89 85 50 ff ff ff 	mov    %ax,-0xb0(%ebp)
	columns = (shell->ctx->vt100_ctx.cons.terminal_wid
  1034b9:	8b 43 08             	mov    0x8(%ebx),%eax
  1034bc:	0f b7 40 2a          	movzwl 0x2a(%eax),%eax
  1034c0:	89 85 48 ff ff ff    	mov    %eax,-0xb8(%ebp)
			- shell_strlen(tab)) / longest_option;
  1034c6:	b8 8e df 10 00       	mov    $0x10df8e,%eax
  1034cb:	e8 ea f2 ff ff       	call   1027ba <shell_strlen>
  1034d0:	66 89 85 46 ff ff ff 	mov    %ax,-0xba(%ebp)
	diff = longest_option - shell_strlen(option);
  1034d7:	8b 85 6c ff ff ff    	mov    -0x94(%ebp),%eax
  1034dd:	e8 d8 f2 ff ff       	call   1027ba <shell_strlen>
  1034e2:	8b 8d 50 ff ff ff    	mov    -0xb0(%ebp),%ecx
  1034e8:	29 c1                	sub    %eax,%ecx
	if (shell->ctx->vt100_ctx.printed_cmd++ % columns == 0U) {
  1034ea:	8b 43 08             	mov    0x8(%ebx),%eax
	diff = longest_option - shell_strlen(option);
  1034ed:	66 89 8d 44 ff ff ff 	mov    %cx,-0xbc(%ebp)
	if (shell->ctx->vt100_ctx.printed_cmd++ % columns == 0U) {
  1034f4:	8b 48 38             	mov    0x38(%eax),%ecx
  1034f7:	8d 51 01             	lea    0x1(%ecx),%edx
  1034fa:	66 89 50 38          	mov    %dx,0x38(%eax)
			- shell_strlen(tab)) / longest_option;
  1034fe:	8b 95 48 ff ff ff    	mov    -0xb8(%ebp),%edx
  103504:	0f b7 85 46 ff ff ff 	movzwl -0xba(%ebp),%eax
  10350b:	29 c2                	sub    %eax,%edx
  10350d:	89 d0                	mov    %edx,%eax
  10350f:	0f b7 95 50 ff ff ff 	movzwl -0xb0(%ebp),%edx
  103516:	89 95 50 ff ff ff    	mov    %edx,-0xb0(%ebp)
  10351c:	99                   	cltd   
  10351d:	f7 bd 50 ff ff ff    	idivl  -0xb0(%ebp)
  103523:	89 85 50 ff ff ff    	mov    %eax,-0xb0(%ebp)
	if (shell->ctx->vt100_ctx.printed_cmd++ % columns == 0U) {
  103529:	31 d2                	xor    %edx,%edx
  10352b:	89 c8                	mov    %ecx,%eax
  10352d:	66 f7 b5 50 ff ff ff 	divw   -0xb0(%ebp)
  103534:	66 85 d2             	test   %dx,%dx
  103537:	75 1d                	jne    103556 <shell_process+0x858>
		shell_internal_fprintf(shell, SHELL_OPTION, "\n%s%s", tab,
  103539:	ff b5 6c ff ff ff    	pushl  -0x94(%ebp)
  10353f:	68 8e df 10 00       	push   $0x10df8e
  103544:	68 78 e4 10 00       	push   $0x10e478
  103549:	6a 07                	push   $0x7
  10354b:	53                   	push   %ebx
  10354c:	e8 58 0f 00 00       	call   1044a9 <shell_internal_fprintf>
  103551:	83 c4 14             	add    $0x14,%esp
  103554:	eb 16                	jmp    10356c <shell_process+0x86e>
		shell_internal_fprintf(shell, SHELL_OPTION, "%s", option);
  103556:	ff b5 6c ff ff ff    	pushl  -0x94(%ebp)
  10355c:	68 7b e4 10 00       	push   $0x10e47b
  103561:	6a 07                	push   $0x7
  103563:	53                   	push   %ebx
  103564:	e8 40 0f 00 00       	call   1044a9 <shell_internal_fprintf>
  103569:	83 c4 10             	add    $0x10,%esp
	shell_op_cursor_horiz_move(shell, diff);
  10356c:	0f b7 85 44 ff ff ff 	movzwl -0xbc(%ebp),%eax
  103573:	50                   	push   %eax
  103574:	53                   	push   %ebx
  103575:	e8 18 0a 00 00       	call   103f92 <shell_op_cursor_horiz_move>
  10357a:	58                   	pop    %eax
  10357b:	5a                   	pop    %edx
	while (cnt) {
  10357c:	ff 8d 40 ff ff ff    	decl   -0xc0(%ebp)
  103582:	0f 85 a1 fe ff ff    	jne    103429 <shell_process+0x72b>
	shell_raw_fprintf(shell->fprintf_ctx, "\n");
  103588:	68 7f e4 10 00       	push   $0x10e47f
  10358d:	ff 73 14             	pushl  0x14(%ebx)
  103590:	e8 38 f2 ff ff       	call   1027cd <shell_raw_fprintf>
  103595:	58                   	pop    %eax
  103596:	5a                   	pop    %edx
	shell_print_prompt_and_cmd(shell);
  103597:	53                   	push   %ebx
  103598:	e8 28 12 00 00       	call   1047c5 <shell_print_prompt_and_cmd>
	u16_t arg_len = shell_strlen(arg);
  10359d:	8b 44 b5 c0          	mov    -0x40(%ebp,%esi,4),%eax
	shell_print_prompt_and_cmd(shell);
  1035a1:	59                   	pop    %ecx
	u16_t arg_len = shell_strlen(arg);
  1035a2:	e8 13 f2 ff ff       	call   1027ba <shell_strlen>
  1035a7:	66 89 85 6c ff ff ff 	mov    %ax,-0x94(%ebp)
	u16_t common = common_beginning_find(cmd, &completion,
  1035ae:	0f b7 c0             	movzwl %ax,%eax
  1035b1:	89 85 5c ff ff ff    	mov    %eax,-0xa4(%ebp)
	size_t idx = first + 1;
  1035b7:	8b 85 60 ff ff ff    	mov    -0xa0(%ebp),%eax
  1035bd:	8d 48 01             	lea    0x1(%eax),%ecx
	shell_cmd_get(cmd ? cmd->subcmd : NULL, cmd ? 1 : 0,
  1035c0:	31 c0                	xor    %eax,%eax
  1035c2:	85 ff                	test   %edi,%edi
  1035c4:	74 03                	je     1035c9 <shell_process+0x8cb>
  1035c6:	8b 47 08             	mov    0x8(%edi),%eax
  1035c9:	8d 55 98             	lea    -0x68(%ebp),%edx
  1035cc:	89 8d 58 ff ff ff    	mov    %ecx,-0xa8(%ebp)
  1035d2:	52                   	push   %edx
  1035d3:	8d 95 7c ff ff ff    	lea    -0x84(%ebp),%edx
  1035d9:	52                   	push   %edx
	u16_t common = UINT16_MAX;
  1035da:	83 ce ff             	or     $0xffffffff,%esi
	shell_cmd_get(cmd ? cmd->subcmd : NULL, cmd ? 1 : 0,
  1035dd:	ff b5 60 ff ff ff    	pushl  -0xa0(%ebp)
  1035e3:	ff b5 64 ff ff ff    	pushl  -0x9c(%ebp)
  1035e9:	50                   	push   %eax
  1035ea:	e8 5e 07 00 00       	call   103d4d <shell_cmd_get>
	*str = match->syntax;
  1035ef:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
	shell_cmd_get(cmd ? cmd->subcmd : NULL, cmd ? 1 : 0,
  1035f5:	83 c4 14             	add    $0x14,%esp
	*str = match->syntax;
  1035f8:	8b 00                	mov    (%eax),%eax
  1035fa:	89 85 60 ff ff ff    	mov    %eax,-0xa0(%ebp)
	shell_cmd_get(cmd ? cmd->subcmd : NULL, cmd ? 1 : 0,
  103600:	8b 8d 58 ff ff ff    	mov    -0xa8(%ebp),%ecx
		shell_cmd_get(cmd ? cmd->subcmd : NULL, cmd ? 1 : 0,
  103606:	8d 41 01             	lea    0x1(%ecx),%eax
  103609:	89 85 58 ff ff ff    	mov    %eax,-0xa8(%ebp)
  10360f:	31 c0                	xor    %eax,%eax
  103611:	85 ff                	test   %edi,%edi
  103613:	74 03                	je     103618 <shell_process+0x91a>
  103615:	8b 47 08             	mov    0x8(%edi),%eax
  103618:	8d 55 ac             	lea    -0x54(%ebp),%edx
  10361b:	52                   	push   %edx
  10361c:	8d 55 80             	lea    -0x80(%ebp),%edx
  10361f:	52                   	push   %edx
  103620:	51                   	push   %ecx
  103621:	ff b5 64 ff ff ff    	pushl  -0x9c(%ebp)
  103627:	50                   	push   %eax
  103628:	e8 20 07 00 00       	call   103d4d <shell_cmd_get>
		if (match2 == NULL) {
  10362d:	8b 45 80             	mov    -0x80(%ebp),%eax
		shell_cmd_get(cmd ? cmd->subcmd : NULL, cmd ? 1 : 0,
  103630:	83 c4 14             	add    $0x14,%esp
		if (match2 == NULL) {
  103633:	85 c0                	test   %eax,%eax
  103635:	74 5a                	je     103691 <shell_process+0x993>
		curr_common = str_common(match->syntax, match2->syntax,
  103637:	8b 08                	mov    (%eax),%ecx
  103639:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
  10363f:	8b 00                	mov    (%eax),%eax
  103641:	89 85 54 ff ff ff    	mov    %eax,-0xac(%ebp)
	size_t common = 0;
  103647:	31 c0                	xor    %eax,%eax
	while ((n > 0) && (*s1 == *s2) && (*s1 != '\0')) {
  103649:	8b 95 54 ff ff ff    	mov    -0xac(%ebp),%edx
  10364f:	8a 14 02             	mov    (%edx,%eax,1),%dl
  103652:	38 14 01             	cmp    %dl,(%ecx,%eax,1)
  103655:	75 0c                	jne    103663 <shell_process+0x965>
  103657:	84 d2                	test   %dl,%dl
  103659:	74 08                	je     103663 <shell_process+0x965>
		common++;
  10365b:	40                   	inc    %eax
	while ((n > 0) && (*s1 == *s2) && (*s1 != '\0')) {
  10365c:	3d ff ff 00 00       	cmp    $0xffff,%eax
  103661:	75 e6                	jne    103649 <shell_process+0x94b>
		if ((arg_len == 0U) || (curr_common >= arg_len)) {
  103663:	66 83 bd 6c ff ff ff 	cmpw   $0x0,-0x94(%ebp)
  10366a:	00 
  10366b:	74 08                	je     103675 <shell_process+0x977>
  10366d:	39 85 5c ff ff ff    	cmp    %eax,-0xa4(%ebp)
  103673:	7f 8b                	jg     103600 <shell_process+0x902>
			common = (curr_common < common) ? curr_common : common;
  103675:	0f b7 f6             	movzwl %si,%esi
			--cnt;
  103678:	ff 8d 68 ff ff ff    	decl   -0x98(%ebp)
			common = (curr_common < common) ? curr_common : common;
  10367e:	39 c6                	cmp    %eax,%esi
  103680:	7e 02                	jle    103684 <shell_process+0x986>
  103682:	89 c6                	mov    %eax,%esi
	while (cnt > 1) {
  103684:	83 bd 68 ff ff ff 01 	cmpl   $0x1,-0x98(%ebp)
  10368b:	0f 85 6f ff ff ff    	jne    103600 <shell_process+0x902>
	if (common) {
  103691:	66 85 f6             	test   %si,%si
  103694:	0f 84 95 f6 ff ff    	je     102d2f <shell_process+0x31>
					   common - arg_len);
  10369a:	2b b5 6c ff ff ff    	sub    -0x94(%ebp),%esi
		shell_op_completion_insert(shell, &completion[arg_len],
  1036a0:	0f b7 85 6c ff ff ff 	movzwl -0x94(%ebp),%eax
  1036a7:	0f b7 f6             	movzwl %si,%esi
  1036aa:	03 85 60 ff ff ff    	add    -0xa0(%ebp),%eax
  1036b0:	56                   	push   %esi
  1036b1:	50                   	push   %eax
  1036b2:	53                   	push   %ebx
  1036b3:	e8 75 10 00 00       	call   10472d <shell_op_completion_insert>
  1036b8:	e9 8e fa ff ff       	jmp    10314b <shell_process+0x44d>

001036bd <shell_init>:
{
  1036bd:	55                   	push   %ebp
  1036be:	89 e5                	mov    %esp,%ebp
  1036c0:	57                   	push   %edi
  1036c1:	56                   	push   %esi
  1036c2:	53                   	push   %ebx
  1036c3:	8b 5d 08             	mov    0x8(%ebp),%ebx
  1036c6:	8b 75 14             	mov    0x14(%ebp),%esi
	int err = shell->iface->api->init(shell->iface, p_config,
  1036c9:	8b 43 04             	mov    0x4(%ebx),%eax
  1036cc:	8b 10                	mov    (%eax),%edx
  1036ce:	53                   	push   %ebx
  1036cf:	68 1f 28 10 00       	push   $0x10281f
  1036d4:	ff 75 0c             	pushl  0xc(%ebp)
  1036d7:	50                   	push   %eax
  1036d8:	ff 12                	call   *(%edx)
  1036da:	83 c4 10             	add    $0x10,%esp
  1036dd:	89 c7                	mov    %eax,%edi
	if (err != 0) {
  1036df:	85 c0                	test   %eax,%eax
  1036e1:	0f 85 d9 00 00 00    	jne    1037c0 <shell_init+0x103>
	memset(shell->ctx, 0, sizeof(*shell->ctx));
  1036e7:	68 0c 03 00 00       	push   $0x30c
  1036ec:	6a 00                	push   $0x0
  1036ee:	ff 73 08             	pushl  0x8(%ebx)
  1036f1:	e8 8b 37 00 00       	call   106e81 <memset>
	shell->ctx->prompt = shell->default_prompt;
  1036f6:	8b 43 08             	mov    0x8(%ebx),%eax
	memset(shell->ctx, 0, sizeof(*shell->ctx));
  1036f9:	83 c4 0c             	add    $0xc,%esp
	shell->ctx->prompt = shell->default_prompt;
  1036fc:	8b 13                	mov    (%ebx),%edx
  1036fe:	89 10                	mov    %edx,(%eax)
	shell_history_init(shell->history);
  103700:	ff 73 0c             	pushl  0xc(%ebx)
  103703:	e8 82 1c 00 00       	call   10538a <shell_history_init>
	k_mutex_init(&shell->ctx->wr_mtx);
  103708:	8b 43 08             	mov    0x8(%ebx),%eax
  10370b:	05 f4 02 00 00       	add    $0x2f4,%eax
K_SYSCALL_DECLARE1_VOID(K_SYSCALL_K_MUTEX_INIT, k_mutex_init, struct k_mutex *, mutex)
  103710:	89 04 24             	mov    %eax,(%esp)
  103713:	e8 ae 6a 00 00       	call   10a1c6 <z_impl_k_mutex_init>
  103718:	58                   	pop    %eax
		shell->stats->log_lost_cnt = 0;
  103719:	8b 43 18             	mov    0x18(%ebx),%eax
  10371c:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	shell->ctx->internal.flags.tx_rdy = val ? 1 : 0;
  103722:	8b 43 08             	mov    0x8(%ebx),%eax
  103725:	66 8b 90 60 02 00 00 	mov    0x260(%eax),%dx
	shell->ctx->state = SHELL_STATE_INITIALIZED;
  10372c:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
  103733:	83 ca 10             	or     $0x10,%edx
	shell->ctx->vt100_ctx.cons.terminal_hei = SHELL_DEFAULT_TERMINAL_HEIGHT;
  103736:	c7 40 28 18 00 50 00 	movl   $0x500018,0x28(%eax)
  10373d:	66 89 90 60 02 00 00 	mov    %dx,0x260(%eax)
	shell->ctx->internal.flags.echo = val ? 1 : 0;
  103744:	66 8b 90 60 02 00 00 	mov    0x260(%eax),%dx
  10374b:	83 ca 04             	or     $0x4,%edx
  10374e:	66 89 90 60 02 00 00 	mov    %dx,0x260(%eax)
	shell->ctx->internal.flags.mode_delete = val ? 1 : 0;
  103755:	66 8b 90 60 02 00 00 	mov    0x260(%eax),%dx
  10375c:	83 ca 20             	or     $0x20,%edx
  10375f:	66 89 90 60 02 00 00 	mov    %dx,0x260(%eax)
	shell->ctx->vt100_ctx.cons.name_len = shell_strlen(shell->ctx->prompt);
  103766:	8b 00                	mov    (%eax),%eax
  103768:	e8 4d f0 ff ff       	call   1027ba <shell_strlen>
  10376d:	8b 53 08             	mov    0x8(%ebx),%edx
  103770:	88 42 2c             	mov    %al,0x2c(%edx)
	shell->ctx->internal.flags.use_colors = val ? 1 : 0;
  103773:	66 8b 82 60 02 00 00 	mov    0x260(%edx),%ax
  10377a:	83 c8 02             	or     $0x2,%eax
  10377d:	66 89 82 60 02 00 00 	mov    %ax,0x260(%edx)
K_SYSCALL_DECLARE10(K_SYSCALL_K_THREAD_CREATE, k_thread_create, k_tid_t, struct k_thread *, new_thread, k_thread_stack_t *, stack, size_t, stack_size, k_thread_entry_t, entry, void *, p1, void *, p2, void *, p3, int, prio, u32_t, options, s32_t, delay)
  103784:	6a 00                	push   $0x0
  103786:	6a 00                	push   $0x0
	k_tid_t tid = k_thread_create(shell->thread,
  103788:	89 f0                	mov    %esi,%eax
  10378a:	6a 0e                	push   $0xe
  10378c:	ff 75 18             	pushl  0x18(%ebp)
  10378f:	0f b6 f0             	movzbl %al,%esi
  103792:	56                   	push   %esi
  103793:	53                   	push   %ebx
  103794:	68 06 38 10 00       	push   $0x103806
  103799:	68 00 08 00 00       	push   $0x800
  10379e:	ff 73 2c             	pushl  0x2c(%ebx)
  1037a1:	ff 73 28             	pushl  0x28(%ebx)
  1037a4:	e8 69 76 00 00       	call   10ae12 <z_impl_k_thread_create>
	shell->ctx->tid = tid;
  1037a9:	8b 53 08             	mov    0x8(%ebx),%edx
  1037ac:	83 c4 28             	add    $0x28,%esp
  1037af:	89 82 08 03 00 00    	mov    %eax,0x308(%edx)
K_SYSCALL_DECLARE2(K_SYSCALL_K_THREAD_NAME_SET, k_thread_name_set, int, k_tid_t, thread_id, const char *, value)
  1037b5:	ff 73 24             	pushl  0x24(%ebx)
  1037b8:	50                   	push   %eax
  1037b9:	e8 5e 75 00 00       	call   10ad1c <z_impl_k_thread_name_set>
  1037be:	5a                   	pop    %edx
  1037bf:	59                   	pop    %ecx
}
  1037c0:	8d 65 f4             	lea    -0xc(%ebp),%esp
  1037c3:	89 f8                	mov    %edi,%eax
  1037c5:	5b                   	pop    %ebx
  1037c6:	5e                   	pop    %esi
  1037c7:	5f                   	pop    %edi
  1037c8:	5d                   	pop    %ebp
  1037c9:	c3                   	ret    

001037ca <shell_start>:
{
  1037ca:	55                   	push   %ebp
  1037cb:	b8 dd ff ff ff       	mov    $0xffffffdd,%eax
  1037d0:	89 e5                	mov    %esp,%ebp
  1037d2:	53                   	push   %ebx
  1037d3:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (shell->ctx->state != SHELL_STATE_INITIALIZED) {
  1037d6:	8b 53 08             	mov    0x8(%ebx),%edx
  1037d9:	83 7a 04 01          	cmpl   $0x1,0x4(%edx)
  1037dd:	75 22                	jne    103801 <shell_start+0x37>
		shell_vt100_color_set(shell, SHELL_NORMAL);
  1037df:	6a 00                	push   $0x0
  1037e1:	53                   	push   %ebx
  1037e2:	e8 a5 0b 00 00       	call   10438c <shell_vt100_color_set>
  1037e7:	58                   	pop    %eax
  1037e8:	5a                   	pop    %edx
	shell_raw_fprintf(shell->fprintf_ctx, "\n\n");
  1037e9:	68 7e e4 10 00       	push   $0x10e47e
  1037ee:	ff 73 14             	pushl  0x14(%ebx)
  1037f1:	e8 d7 ef ff ff       	call   1027cd <shell_raw_fprintf>
  1037f6:	59                   	pop    %ecx
  1037f7:	58                   	pop    %eax
	state_set(shell, SHELL_STATE_ACTIVE);
  1037f8:	89 d8                	mov    %ebx,%eax
  1037fa:	e8 ff ef ff ff       	call   1027fe <state_set.constprop.23>
	return 0;
  1037ff:	31 c0                	xor    %eax,%eax
}
  103801:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  103804:	c9                   	leave  
  103805:	c3                   	ret    

00103806 <shell_thread>:
{
  103806:	55                   	push   %ebp
  103807:	89 e5                	mov    %esp,%ebp
  103809:	57                   	push   %edi
  10380a:	56                   	push   %esi
  10380b:	bf a4 02 00 00       	mov    $0x2a4,%edi
  103810:	53                   	push   %ebx
  103811:	be 64 02 00 00       	mov    $0x264,%esi
  103816:	8b 5d 08             	mov    0x8(%ebp),%ebx
		k_poll_signal_init(&shell->ctx->signals[i]);
  103819:	8b 43 08             	mov    0x8(%ebx),%eax
  10381c:	01 f0                	add    %esi,%eax
K_SYSCALL_DECLARE1_VOID(K_SYSCALL_K_POLL_SIGNAL_INIT, k_poll_signal_init, struct k_poll_signal *, signal)
  10381e:	50                   	push   %eax
  10381f:	e8 02 7f 00 00       	call   10b726 <z_impl_k_poll_signal_init>
				  &shell->ctx->signals[i]);
  103824:	8b 43 08             	mov    0x8(%ebx),%eax
  103827:	8d 14 30             	lea    (%eax,%esi,1),%edx
		k_poll_event_init(&shell->ctx->events[i],
  10382a:	01 f8                	add    %edi,%eax
  10382c:	89 14 24             	mov    %edx,(%esp)
  10382f:	6a 00                	push   $0x0
  103831:	6a 01                	push   $0x1
  103833:	83 c6 10             	add    $0x10,%esi
  103836:	50                   	push   %eax
  103837:	83 c7 14             	add    $0x14,%edi
  10383a:	e8 2d 7d 00 00       	call   10b56c <k_poll_event_init>
  10383f:	83 c4 10             	add    $0x10,%esp
	for (int i = 0; i < SHELL_SIGNALS; i++) {
  103842:	81 fe a4 02 00 00    	cmp    $0x2a4,%esi
  103848:	75 cf                	jne    103819 <shell_thread+0x13>
	err = shell->iface->api->enable(shell->iface, false);
  10384a:	8b 43 04             	mov    0x4(%ebx),%eax
  10384d:	8b 10                	mov    (%eax),%edx
  10384f:	6a 00                	push   $0x0
  103851:	50                   	push   %eax
  103852:	ff 52 08             	call   *0x8(%edx)
  103855:	59                   	pop    %ecx
  103856:	5e                   	pop    %esi
	if (err != 0) {
  103857:	85 c0                	test   %eax,%eax
  103859:	0f 85 b8 00 00 00    	jne    103917 <shell_thread+0x111>
	if (log_backend && IS_ENABLED(CONFIG_LOG)) {
  10385f:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  103863:	74 0f                	je     103874 <shell_thread+0x6e>
		shell_log_backend_enable(shell->log_backend, (void *)shell,
  103865:	ff 75 10             	pushl  0x10(%ebp)
  103868:	53                   	push   %ebx
  103869:	ff 73 1c             	pushl  0x1c(%ebx)
  10386c:	e8 84 1c 00 00       	call   1054f5 <shell_log_backend_enable>
  103871:	83 c4 0c             	add    $0xc,%esp
	err = shell_start(shell);
  103874:	53                   	push   %ebx
  103875:	e8 50 ff ff ff       	call   1037ca <shell_start>
  10387a:	5a                   	pop    %edx
	if (err != 0) {
  10387b:	85 c0                	test   %eax,%eax
  10387d:	0f 85 94 00 00 00    	jne    103917 <shell_thread+0x111>
K_SYSCALL_DECLARE3(K_SYSCALL_K_POLL, k_poll, int, struct k_poll_event *, events, int, num_events, s32_t, timeout)
  103883:	6a ff                	push   $0xffffffff
  103885:	6a 03                	push   $0x3
		err = k_poll(shell->ctx->events, SHELL_SIGNAL_TXDONE,
  103887:	8b 43 08             	mov    0x8(%ebx),%eax
  10388a:	05 a4 02 00 00       	add    $0x2a4,%eax
  10388f:	50                   	push   %eax
  103890:	e8 18 7d 00 00       	call   10b5ad <z_impl_k_poll>
  103895:	83 c4 0c             	add    $0xc,%esp
  103898:	89 c6                	mov    %eax,%esi
K_SYSCALL_DECLARE2(K_SYSCALL_K_MUTEX_LOCK, k_mutex_lock, int, struct k_mutex *, mutex, s32_t, timeout)
  10389a:	6a ff                	push   $0xffffffff
		k_mutex_lock(&shell->ctx->wr_mtx, K_FOREVER);
  10389c:	8b 43 08             	mov    0x8(%ebx),%eax
  10389f:	05 f4 02 00 00       	add    $0x2f4,%eax
  1038a4:	50                   	push   %eax
  1038a5:	e8 37 69 00 00       	call   10a1e1 <z_impl_k_mutex_lock>
  1038aa:	59                   	pop    %ecx
		if (err != 0) {
  1038ab:	85 f6                	test   %esi,%esi
  1038ad:	5f                   	pop    %edi
  1038ae:	74 13                	je     1038c3 <shell_thread+0xbd>
			shell_internal_fprintf(shell, SHELL_ERROR,
  1038b0:	56                   	push   %esi
  1038b1:	68 81 e4 10 00       	push   $0x10e481
  1038b6:	6a 02                	push   $0x2
  1038b8:	53                   	push   %ebx
  1038b9:	e8 eb 0b 00 00       	call   1044a9 <shell_internal_fprintf>
  1038be:	83 c4 10             	add    $0x10,%esp
			return;
  1038c1:	eb 54                	jmp    103917 <shell_thread+0x111>
		if (shell->iface->api->update) {
  1038c3:	8b 53 04             	mov    0x4(%ebx),%edx
  1038c6:	8b 02                	mov    (%edx),%eax
  1038c8:	8b 40 14             	mov    0x14(%eax),%eax
  1038cb:	85 c0                	test   %eax,%eax
  1038cd:	74 04                	je     1038d3 <shell_thread+0xcd>
			shell->iface->api->update(shell->iface);
  1038cf:	52                   	push   %edx
  1038d0:	ff d0                	call   *%eax
  1038d2:	5a                   	pop    %edx
		shell_signal_handle(shell, SHELL_SIGNAL_KILL, kill_handler);
  1038d3:	b9 6a 27 10 00       	mov    $0x10276a,%ecx
  1038d8:	ba 02 00 00 00       	mov    $0x2,%edx
  1038dd:	89 d8                	mov    %ebx,%eax
  1038df:	e8 42 ee ff ff       	call   102726 <shell_signal_handle>
		shell_signal_handle(shell, SHELL_SIGNAL_RXRDY, shell_process);
  1038e4:	b9 fe 2c 10 00       	mov    $0x102cfe,%ecx
  1038e9:	31 d2                	xor    %edx,%edx
  1038eb:	89 d8                	mov    %ebx,%eax
  1038ed:	e8 34 ee ff ff       	call   102726 <shell_signal_handle>
			shell_signal_handle(shell, SHELL_SIGNAL_LOG_MSG,
  1038f2:	b9 4a 28 10 00       	mov    $0x10284a,%ecx
  1038f7:	ba 01 00 00 00       	mov    $0x1,%edx
  1038fc:	89 d8                	mov    %ebx,%eax
  1038fe:	e8 23 ee ff ff       	call   102726 <shell_signal_handle>
		k_mutex_unlock(&shell->ctx->wr_mtx);
  103903:	8b 43 08             	mov    0x8(%ebx),%eax
  103906:	05 f4 02 00 00       	add    $0x2f4,%eax
K_SYSCALL_DECLARE1_VOID(K_SYSCALL_K_MUTEX_UNLOCK, k_mutex_unlock, struct k_mutex *, mutex)
  10390b:	50                   	push   %eax
  10390c:	e8 c3 69 00 00       	call   10a2d4 <z_impl_k_mutex_unlock>
  103911:	58                   	pop    %eax
  103912:	e9 6c ff ff ff       	jmp    103883 <shell_thread+0x7d>
}
  103917:	8d 65 f4             	lea    -0xc(%ebp),%esp
  10391a:	5b                   	pop    %ebx
  10391b:	5e                   	pop    %esi
  10391c:	5f                   	pop    %edi
  10391d:	5d                   	pop    %ebp
  10391e:	c3                   	ret    

0010391f <shell_fprintf>:
/* This function mustn't be used from shell context to avoid deadlock.
 * However it can be used in shell command handlers.
 */
void shell_fprintf(const struct shell *shell, enum shell_vt100_color color,
		   const char *fmt, ...)
{
  10391f:	55                   	push   %ebp
  103920:	89 e5                	mov    %esp,%ebp
  103922:	53                   	push   %ebx
K_SYSCALL_DECLARE2(K_SYSCALL_K_MUTEX_LOCK, k_mutex_lock, int, struct k_mutex *, mutex, s32_t, timeout)
  103923:	6a ff                	push   $0xffffffff
  103925:	8b 5d 08             	mov    0x8(%ebp),%ebx
	__ASSERT_NO_MSG(shell->fprintf_ctx);
	__ASSERT_NO_MSG(fmt);

	va_list args = { 0 };

	k_mutex_lock(&shell->ctx->wr_mtx, K_FOREVER);
  103928:	8b 43 08             	mov    0x8(%ebx),%eax
  10392b:	05 f4 02 00 00       	add    $0x2f4,%eax
  103930:	50                   	push   %eax
  103931:	e8 ab 68 00 00       	call   10a1e1 <z_impl_k_mutex_lock>
  103936:	58                   	pop    %eax
	if (!flag_cmd_ctx_get(shell)) {
  103937:	8b 43 08             	mov    0x8(%ebx),%eax
  10393a:	5a                   	pop    %edx
	return shell->ctx->internal.flags.cmd_ctx == 1 ? true : false;
  10393b:	8b 80 60 02 00 00    	mov    0x260(%eax),%eax
  103941:	84 c0                	test   %al,%al
  103943:	78 07                	js     10394c <shell_fprintf+0x2d>
		shell_cmd_line_erase(shell);
  103945:	53                   	push   %ebx
  103946:	e8 3d 09 00 00       	call   104288 <shell_cmd_line_erase>
  10394b:	59                   	pop    %ecx
	}

	va_start(args, fmt);
  10394c:	8d 45 14             	lea    0x14(%ebp),%eax
	shell_internal_vfprintf(shell, color, fmt, args);
  10394f:	50                   	push   %eax
  103950:	ff 75 10             	pushl  0x10(%ebp)
  103953:	ff 75 0c             	pushl  0xc(%ebp)
  103956:	53                   	push   %ebx
  103957:	e8 db 0a 00 00       	call   104437 <shell_internal_vfprintf>
	va_end(args);

	if (!flag_cmd_ctx_get(shell)) {
  10395c:	8b 43 08             	mov    0x8(%ebx),%eax
	shell_internal_vfprintf(shell, color, fmt, args);
  10395f:	83 c4 10             	add    $0x10,%esp
  103962:	8b 80 60 02 00 00    	mov    0x260(%eax),%eax
	if (!flag_cmd_ctx_get(shell)) {
  103968:	84 c0                	test   %al,%al
  10396a:	78 07                	js     103973 <shell_fprintf+0x54>
		shell_print_prompt_and_cmd(shell);
  10396c:	53                   	push   %ebx
  10396d:	e8 53 0e 00 00       	call   1047c5 <shell_print_prompt_and_cmd>
  103972:	5a                   	pop    %edx

void shell_spaces_trim(char *str);

static inline void transport_buffer_flush(const struct shell *shell)
{
	shell_fprintf_buffer_flush(shell->fprintf_ctx);
  103973:	ff 73 14             	pushl  0x14(%ebx)
  103976:	e8 16 00 00 00       	call   103991 <shell_fprintf_buffer_flush>
	}
	transport_buffer_flush(shell);
	k_mutex_unlock(&shell->ctx->wr_mtx);
  10397b:	8b 43 08             	mov    0x8(%ebx),%eax
  10397e:	05 f4 02 00 00       	add    $0x2f4,%eax
K_SYSCALL_DECLARE1_VOID(K_SYSCALL_K_MUTEX_UNLOCK, k_mutex_unlock, struct k_mutex *, mutex)
  103983:	89 04 24             	mov    %eax,(%esp)
  103986:	e8 49 69 00 00       	call   10a2d4 <z_impl_k_mutex_unlock>
  10398b:	58                   	pop    %eax
}
  10398c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  10398f:	c9                   	leave  
  103990:	c3                   	ret    

00103991 <shell_fprintf_buffer_flush>:
	}
}


void shell_fprintf_buffer_flush(const struct shell_fprintf *sh_fprintf)
{
  103991:	55                   	push   %ebp
  103992:	89 e5                	mov    %esp,%ebp
  103994:	53                   	push   %ebx
  103995:	8b 5d 08             	mov    0x8(%ebp),%ebx
	sh_fprintf->fwrite(sh_fprintf->user_ctx, sh_fprintf->buffer,
  103998:	8b 43 10             	mov    0x10(%ebx),%eax
  10399b:	ff 30                	pushl  (%eax)
  10399d:	ff 33                	pushl  (%ebx)
  10399f:	ff 73 0c             	pushl  0xc(%ebx)
  1039a2:	ff 53 08             	call   *0x8(%ebx)
			   sh_fprintf->ctrl_blk->buffer_cnt);
	sh_fprintf->ctrl_blk->buffer_cnt = 0;
  1039a5:	8b 43 10             	mov    0x10(%ebx),%eax
  1039a8:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	sh_fprintf->fwrite(sh_fprintf->user_ctx, sh_fprintf->buffer,
  1039ae:	83 c4 0c             	add    $0xc,%esp
}
  1039b1:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  1039b4:	c9                   	leave  
  1039b5:	c3                   	ret    

001039b6 <shell_fprintf_fmt>:
{
  1039b6:	55                   	push   %ebp
  1039b7:	89 e5                	mov    %esp,%ebp
  1039b9:	53                   	push   %ebx
	(void)z_prf(out_func, (void *)sh_fprintf, (char *)fmt, args);
  1039ba:	ff 75 10             	pushl  0x10(%ebp)
  1039bd:	ff 75 0c             	pushl  0xc(%ebp)
{
  1039c0:	8b 5d 08             	mov    0x8(%ebp),%ebx
	(void)z_prf(out_func, (void *)sh_fprintf, (char *)fmt, args);
  1039c3:	53                   	push   %ebx
  1039c4:	68 eb 39 10 00       	push   $0x1039eb
  1039c9:	e8 88 36 00 00       	call   107056 <z_prf>
	if (sh_fprintf->ctrl_blk->autoflush) {
  1039ce:	8b 43 10             	mov    0x10(%ebx),%eax
	(void)z_prf(out_func, (void *)sh_fprintf, (char *)fmt, args);
  1039d1:	83 c4 10             	add    $0x10,%esp
	if (sh_fprintf->ctrl_blk->autoflush) {
  1039d4:	80 78 04 00          	cmpb   $0x0,0x4(%eax)
  1039d8:	74 0c                	je     1039e6 <shell_fprintf_fmt+0x30>
		shell_fprintf_buffer_flush(sh_fprintf);
  1039da:	89 5d 08             	mov    %ebx,0x8(%ebp)
}
  1039dd:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  1039e0:	c9                   	leave  
		shell_fprintf_buffer_flush(sh_fprintf);
  1039e1:	e9 ab ff ff ff       	jmp    103991 <shell_fprintf_buffer_flush>
}
  1039e6:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  1039e9:	c9                   	leave  
  1039ea:	c3                   	ret    

001039eb <out_func>:
{
  1039eb:	55                   	push   %ebp
  1039ec:	89 e5                	mov    %esp,%ebp
  1039ee:	56                   	push   %esi
  1039ef:	53                   	push   %ebx
  1039f0:	8b 75 0c             	mov    0xc(%ebp),%esi
  1039f3:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if ((shell->shell_flag == SHELL_FLAG_OLF_CRLF) && (c == '\n')) {
  1039f6:	8b 46 0c             	mov    0xc(%esi),%eax
  1039f9:	83 78 10 02          	cmpl   $0x2,0x10(%eax)
  1039fd:	75 0f                	jne    103a0e <out_func+0x23>
  1039ff:	83 fb 0a             	cmp    $0xa,%ebx
  103a02:	75 0a                	jne    103a0e <out_func+0x23>
		(void)out_func('\r', ctx);
  103a04:	56                   	push   %esi
  103a05:	6a 0d                	push   $0xd
  103a07:	e8 df ff ff ff       	call   1039eb <out_func>
  103a0c:	5a                   	pop    %edx
  103a0d:	59                   	pop    %ecx
	sh_fprintf->buffer[sh_fprintf->ctrl_blk->buffer_cnt] = (u8_t)c;
  103a0e:	8b 46 10             	mov    0x10(%esi),%eax
  103a11:	8b 16                	mov    (%esi),%edx
  103a13:	8b 00                	mov    (%eax),%eax
  103a15:	88 1c 02             	mov    %bl,(%edx,%eax,1)
	sh_fprintf->ctrl_blk->buffer_cnt++;
  103a18:	8b 56 10             	mov    0x10(%esi),%edx
  103a1b:	8b 02                	mov    (%edx),%eax
  103a1d:	40                   	inc    %eax
  103a1e:	89 02                	mov    %eax,(%edx)
	if (sh_fprintf->ctrl_blk->buffer_cnt == sh_fprintf->buffer_size) {
  103a20:	3b 46 04             	cmp    0x4(%esi),%eax
  103a23:	75 07                	jne    103a2c <out_func+0x41>
		shell_fprintf_buffer_flush(sh_fprintf);
  103a25:	56                   	push   %esi
  103a26:	e8 66 ff ff ff       	call   103991 <shell_fprintf_buffer_flush>
  103a2b:	58                   	pop    %eax
}
  103a2c:	8d 65 f8             	lea    -0x8(%ebp),%esp
  103a2f:	31 c0                	xor    %eax,%eax
  103a31:	5b                   	pop    %ebx
  103a32:	5e                   	pop    %esi
  103a33:	5d                   	pop    %ebp
  103a34:	c3                   	ret    

00103a35 <shell_strlen>:
	return str == NULL ? 0U : (u16_t)strlen(str);
  103a35:	85 c0                	test   %eax,%eax
  103a37:	74 0c                	je     103a45 <shell_strlen+0x10>
{
  103a39:	55                   	push   %ebp
  103a3a:	89 e5                	mov    %esp,%ebp
	return str == NULL ? 0U : (u16_t)strlen(str);
  103a3c:	50                   	push   %eax
  103a3d:	e8 34 33 00 00       	call   106d76 <strlen>
  103a42:	5a                   	pop    %edx
}
  103a43:	c9                   	leave  
  103a44:	c3                   	ret    
	return str == NULL ? 0U : (u16_t)strlen(str);
  103a45:	31 c0                	xor    %eax,%eax
}
  103a47:	c3                   	ret    

00103a48 <column_span_with_buffer_offsets_get>:
}

s32_t column_span_with_buffer_offsets_get(struct shell_multiline_cons *cons,
					  u16_t offset1,
					  u16_t offset2)
{
  103a48:	55                   	push   %ebp
  103a49:	89 e5                	mov    %esp,%ebp
  103a4b:	56                   	push   %esi
  103a4c:	53                   	push   %ebx
  103a4d:	8b 45 08             	mov    0x8(%ebp),%eax
	return (1 + ((buffer_pos + cons->name_len) % cons->terminal_wid));
  103a50:	0f b6 70 0c          	movzbl 0xc(%eax),%esi
  103a54:	0f b7 58 0a          	movzwl 0xa(%eax),%ebx
	return col_num_with_buffer_offset_get(cons, offset2)
  103a58:	0f b7 45 10          	movzwl 0x10(%ebp),%eax
	return (1 + ((buffer_pos + cons->name_len) % cons->terminal_wid));
  103a5c:	01 f0                	add    %esi,%eax
  103a5e:	99                   	cltd   
  103a5f:	f7 fb                	idiv   %ebx
  103a61:	89 d1                	mov    %edx,%ecx
			- col_num_with_buffer_offset_get(cons, offset1);
  103a63:	0f b7 55 0c          	movzwl 0xc(%ebp),%edx
	return (1 + ((buffer_pos + cons->name_len) % cons->terminal_wid));
  103a67:	8d 04 32             	lea    (%edx,%esi,1),%eax
  103a6a:	99                   	cltd   
  103a6b:	f7 fb                	idiv   %ebx
}
  103a6d:	5b                   	pop    %ebx
			- col_num_with_buffer_offset_get(cons, offset1);
  103a6e:	89 c8                	mov    %ecx,%eax
}
  103a70:	5e                   	pop    %esi
			- col_num_with_buffer_offset_get(cons, offset1);
  103a71:	29 d0                	sub    %edx,%eax
}
  103a73:	5d                   	pop    %ebp
  103a74:	c3                   	ret    

00103a75 <row_span_with_buffer_offsets_get>:

s32_t row_span_with_buffer_offsets_get(struct shell_multiline_cons *cons,
				       u16_t offset1,
				       u16_t offset2)
{
  103a75:	55                   	push   %ebp
  103a76:	89 e5                	mov    %esp,%ebp
  103a78:	56                   	push   %esi
  103a79:	53                   	push   %ebx
  103a7a:	8b 45 08             	mov    0x8(%ebp),%eax
	return ((buffer_pos + cons->name_len) / cons->terminal_wid);
  103a7d:	0f b6 70 0c          	movzbl 0xc(%eax),%esi
  103a81:	0f b7 58 0a          	movzwl 0xa(%eax),%ebx
	return line_num_with_buffer_offset_get(cons, offset2)
  103a85:	0f b7 45 10          	movzwl 0x10(%ebp),%eax
	return ((buffer_pos + cons->name_len) / cons->terminal_wid);
  103a89:	01 f0                	add    %esi,%eax
  103a8b:	99                   	cltd   
  103a8c:	f7 fb                	idiv   %ebx
		- line_num_with_buffer_offset_get(cons, offset1);
  103a8e:	0f b7 55 0c          	movzwl 0xc(%ebp),%edx
	return ((buffer_pos + cons->name_len) / cons->terminal_wid);
  103a92:	89 c1                	mov    %eax,%ecx
  103a94:	8d 04 32             	lea    (%edx,%esi,1),%eax
  103a97:	99                   	cltd   
  103a98:	f7 fb                	idiv   %ebx
}
  103a9a:	5b                   	pop    %ebx
		- line_num_with_buffer_offset_get(cons, offset1);
  103a9b:	29 c1                	sub    %eax,%ecx
}
  103a9d:	5e                   	pop    %esi
		- line_num_with_buffer_offset_get(cons, offset1);
  103a9e:	89 c8                	mov    %ecx,%eax
}
  103aa0:	5d                   	pop    %ebp
  103aa1:	c3                   	ret    

00103aa2 <shell_multiline_data_calc>:

void shell_multiline_data_calc(struct shell_multiline_cons *cons,
			       u16_t buff_pos, u16_t buff_len)
{
  103aa2:	55                   	push   %ebp
  103aa3:	89 e5                	mov    %esp,%ebp
  103aa5:	56                   	push   %esi
  103aa6:	53                   	push   %ebx
  103aa7:	8b 4d 08             	mov    0x8(%ebp),%ecx
	/* Current cursor position in command.
	 * +1 -> because home position is (1, 1)
	 */
	cons->cur_x = (buff_pos + cons->name_len) % cons->terminal_wid + 1;
  103aaa:	0f b7 45 0c          	movzwl 0xc(%ebp),%eax
  103aae:	0f b6 71 0c          	movzbl 0xc(%ecx),%esi
  103ab2:	0f b7 59 0a          	movzwl 0xa(%ecx),%ebx
  103ab6:	01 f0                	add    %esi,%eax
  103ab8:	99                   	cltd   
  103ab9:	f7 fb                	idiv   %ebx
	cons->cur_y = (buff_pos + cons->name_len) / cons->terminal_wid + 1;
  103abb:	40                   	inc    %eax
	cons->cur_x = (buff_pos + cons->name_len) % cons->terminal_wid + 1;
  103abc:	42                   	inc    %edx
	cons->cur_y = (buff_pos + cons->name_len) / cons->terminal_wid + 1;
  103abd:	66 89 41 04          	mov    %ax,0x4(%ecx)
	cons->cur_x = (buff_pos + cons->name_len) % cons->terminal_wid + 1;
  103ac1:	66 89 11             	mov    %dx,(%ecx)

	/* Extreme position when cursor is at the end of command. */
	cons->cur_y_end = (buff_len + cons->name_len) / cons->terminal_wid + 1;
  103ac4:	0f b7 45 10          	movzwl 0x10(%ebp),%eax
  103ac8:	01 f0                	add    %esi,%eax
  103aca:	99                   	cltd   
  103acb:	f7 fb                	idiv   %ebx
  103acd:	40                   	inc    %eax
  103ace:	66 89 41 06          	mov    %ax,0x6(%ecx)
	cons->cur_x_end = (buff_len + cons->name_len) % cons->terminal_wid + 1;
  103ad2:	8d 42 01             	lea    0x1(%edx),%eax
  103ad5:	66 89 41 02          	mov    %ax,0x2(%ecx)
}
  103ad9:	5b                   	pop    %ebx
  103ada:	5e                   	pop    %esi
  103adb:	5d                   	pop    %ebp
  103adc:	c3                   	ret    

00103add <shell_make_argv>:
	return quote;
}


char shell_make_argv(size_t *argc, char **argv, char *cmd, u8_t max_argc)
{
  103add:	55                   	push   %ebp
  103ade:	89 e5                	mov    %esp,%ebp
  103ae0:	57                   	push   %edi
  103ae1:	56                   	push   %esi
  103ae2:	53                   	push   %ebx
  103ae3:	83 ec 08             	sub    $0x8,%esp
	char quote = 0;
  103ae6:	c6 45 f3 00          	movb   $0x0,-0xd(%ebp)
	char c;

	*argc = 0;
  103aea:	8b 45 08             	mov    0x8(%ebp),%eax
{
  103aed:	8b 5d 10             	mov    0x10(%ebp),%ebx
	*argc = 0;
  103af0:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
			continue;
		}

		argv[(*argc)++] = cmd;
		quote = make_argv(&cmd, c);
	} while (*argc < max_argc);
  103af6:	0f b6 45 14          	movzbl 0x14(%ebp),%eax
  103afa:	89 45 ec             	mov    %eax,-0x14(%ebp)
		c = *cmd;
  103afd:	8a 03                	mov    (%ebx),%al
		if (c == '\0') {
  103aff:	84 c0                	test   %al,%al
  103b01:	0f 84 c0 01 00 00    	je     103cc7 <shell_make_argv+0x1ea>
  103b07:	0f be d0             	movsbl %al,%edx
  103b0a:	83 ea 09             	sub    $0x9,%edx
		if (isspace((int) c)) {
  103b0d:	83 fa 04             	cmp    $0x4,%edx
  103b10:	76 04                	jbe    103b16 <shell_make_argv+0x39>
  103b12:	3c 20                	cmp    $0x20,%al
  103b14:	75 09                	jne    103b1f <shell_make_argv+0x42>
			*cmd++ = '\0';
  103b16:	c6 03 00             	movb   $0x0,(%ebx)
  103b19:	43                   	inc    %ebx
			continue;
  103b1a:	e9 9a 01 00 00       	jmp    103cb9 <shell_make_argv+0x1dc>
		argv[(*argc)++] = cmd;
  103b1f:	8b 45 08             	mov    0x8(%ebp),%eax
  103b22:	8b 7d 08             	mov    0x8(%ebp),%edi
	char quote = 0;
  103b25:	c6 45 f3 00          	movb   $0x0,-0xd(%ebp)
		argv[(*argc)++] = cmd;
  103b29:	8b 00                	mov    (%eax),%eax
  103b2b:	8d 50 01             	lea    0x1(%eax),%edx
  103b2e:	89 17                	mov    %edx,(%edi)
  103b30:	8b 7d 0c             	mov    0xc(%ebp),%edi
  103b33:	89 1c 87             	mov    %ebx,(%edi,%eax,4)
		c = *cmd;
  103b36:	8a 13                	mov    (%ebx),%dl
		if (c == '\0') {
  103b38:	84 d2                	test   %dl,%dl
  103b3a:	0f 84 79 01 00 00    	je     103cb9 <shell_make_argv+0x1dc>
		if (!quote) {
  103b40:	80 7d f3 00          	cmpb   $0x0,-0xd(%ebp)
  103b44:	75 3e                	jne    103b84 <shell_make_argv+0xa7>
			switch (c) {
  103b46:	80 fa 27             	cmp    $0x27,%dl
  103b49:	74 18                	je     103b63 <shell_make_argv+0x86>
  103b4b:	80 fa 5c             	cmp    $0x5c,%dl
  103b4e:	74 07                	je     103b57 <shell_make_argv+0x7a>
  103b50:	80 fa 22             	cmp    $0x22,%dl
  103b53:	75 2f                	jne    103b84 <shell_make_argv+0xa7>
  103b55:	eb 0c                	jmp    103b63 <shell_make_argv+0x86>
						shell_strlen(cmd));
  103b57:	89 d8                	mov    %ebx,%eax
				memmove(cmd, cmd + 1,
  103b59:	8d 7b 01             	lea    0x1(%ebx),%edi
						shell_strlen(cmd));
  103b5c:	e8 d4 fe ff ff       	call   103a35 <shell_strlen>
  103b61:	eb 71                	jmp    103bd4 <shell_make_argv+0xf7>
						shell_strlen(cmd));
  103b63:	89 d8                	mov    %ebx,%eax
  103b65:	88 55 f3             	mov    %dl,-0xd(%ebp)
  103b68:	e8 c8 fe ff ff       	call   103a35 <shell_strlen>
				memmove(cmd, cmd + 1,
  103b6d:	89 df                	mov    %ebx,%edi
  103b6f:	0f b7 c0             	movzwl %ax,%eax
  103b72:	50                   	push   %eax
  103b73:	8d 43 01             	lea    0x1(%ebx),%eax
  103b76:	50                   	push   %eax
  103b77:	53                   	push   %ebx
  103b78:	e8 5c 32 00 00       	call   106dd9 <memmove>
  103b7d:	83 c4 0c             	add    $0xc,%esp
				memmove(cmd, cmd + 1,
  103b80:	89 fb                	mov    %edi,%ebx
  103b82:	eb b2                	jmp    103b36 <shell_make_argv+0x59>
		if (quote == c) {
  103b84:	0f be 4d f3          	movsbl -0xd(%ebp),%ecx
  103b88:	0f b6 c2             	movzbl %dl,%eax
  103b8b:	39 c1                	cmp    %eax,%ecx
  103b8d:	75 20                	jne    103baf <shell_make_argv+0xd2>
			memmove(cmd, cmd + 1, shell_strlen(cmd));
  103b8f:	89 d8                	mov    %ebx,%eax
  103b91:	89 df                	mov    %ebx,%edi
  103b93:	e8 9d fe ff ff       	call   103a35 <shell_strlen>
  103b98:	0f b7 c0             	movzwl %ax,%eax
  103b9b:	50                   	push   %eax
  103b9c:	8d 43 01             	lea    0x1(%ebx),%eax
  103b9f:	50                   	push   %eax
  103ba0:	53                   	push   %ebx
  103ba1:	e8 33 32 00 00       	call   106dd9 <memmove>
  103ba6:	83 c4 0c             	add    $0xc,%esp
			quote = 0;
  103ba9:	c6 45 f3 00          	movb   $0x0,-0xd(%ebp)
  103bad:	eb d1                	jmp    103b80 <shell_make_argv+0xa3>
		if (quote && c == '\\') {
  103baf:	80 7d f3 00          	cmpb   $0x0,-0xd(%ebp)
  103bb3:	0f 84 e5 00 00 00    	je     103c9e <shell_make_argv+0x1c1>
  103bb9:	80 fa 5c             	cmp    $0x5c,%dl
  103bbc:	0f 85 dc 00 00 00    	jne    103c9e <shell_make_argv+0x1c1>
			char t = *(cmd + 1);
  103bc2:	8a 43 01             	mov    0x1(%ebx),%al
			if (t == quote) {
  103bc5:	8d 7b 01             	lea    0x1(%ebx),%edi
  103bc8:	38 45 f3             	cmp    %al,-0xd(%ebp)
  103bcb:	75 17                	jne    103be4 <shell_make_argv+0x107>
						shell_strlen(cmd));
  103bcd:	89 d8                	mov    %ebx,%eax
  103bcf:	e8 61 fe ff ff       	call   103a35 <shell_strlen>
				memmove(cmd, cmd + 1,
  103bd4:	0f b7 c0             	movzwl %ax,%eax
  103bd7:	50                   	push   %eax
  103bd8:	57                   	push   %edi
  103bd9:	53                   	push   %ebx
  103bda:	e8 fa 31 00 00       	call   106dd9 <memmove>
  103bdf:	83 c4 0c             	add    $0xc,%esp
				continue;
  103be2:	eb 9c                	jmp    103b80 <shell_make_argv+0xa3>
			if (t == '0') {
  103be4:	3c 30                	cmp    $0x30,%al
  103be6:	75 2c                	jne    103c14 <shell_make_argv+0x137>
  103be8:	b9 02 00 00 00       	mov    $0x2,%ecx
				u8_t v = 0U;
  103bed:	31 f6                	xor    %esi,%esi
					t = *(cmd + i);
  103bef:	8a 04 0b             	mov    (%ebx,%ecx,1),%al
  103bf2:	88 4d f2             	mov    %cl,-0xe(%ebp)
					if (t >= '0' && t <= '7') {
  103bf5:	8d 50 d0             	lea    -0x30(%eax),%edx
  103bf8:	80 fa 07             	cmp    $0x7,%dl
  103bfb:	77 11                	ja     103c0e <shell_make_argv+0x131>
						v = (v << 3) | (t - '0');
  103bfd:	c1 e6 03             	shl    $0x3,%esi
  103c00:	41                   	inc    %ecx
  103c01:	09 d6                	or     %edx,%esi
				for (i = 2U; i < (2 + 3); i++) {
  103c03:	83 f9 05             	cmp    $0x5,%ecx
  103c06:	75 e7                	jne    103bef <shell_make_argv+0x112>
  103c08:	c6 45 f2 05          	movb   $0x5,-0xe(%ebp)
  103c0c:	eb 65                	jmp    103c73 <shell_make_argv+0x196>
				if (i > 2) {
  103c0e:	80 7d f2 02          	cmpb   $0x2,-0xe(%ebp)
  103c12:	75 5f                	jne    103c73 <shell_make_argv+0x196>
			if (t == 'x') {
  103c14:	3c 78                	cmp    $0x78,%al
  103c16:	0f 85 95 00 00 00    	jne    103cb1 <shell_make_argv+0x1d4>
  103c1c:	ba 02 00 00 00       	mov    $0x2,%edx
				u8_t v = 0U;
  103c21:	31 f6                	xor    %esi,%esi
					t = *(cmd + i);
  103c23:	8a 04 13             	mov    (%ebx,%edx,1),%al
  103c26:	88 55 f2             	mov    %dl,-0xe(%ebp)
					if (t >= '0' && t <= '9') {
  103c29:	8d 48 d0             	lea    -0x30(%eax),%ecx
  103c2c:	80 f9 09             	cmp    $0x9,%cl
  103c2f:	77 07                	ja     103c38 <shell_make_argv+0x15b>
						v = (v << 4) | (t - '0');
  103c31:	c1 e6 04             	shl    $0x4,%esi
  103c34:	09 ce                	or     %ecx,%esi
  103c36:	eb 20                	jmp    103c58 <shell_make_argv+0x17b>
					} else if ((t >= 'a') &&
  103c38:	8d 48 9f             	lea    -0x61(%eax),%ecx
  103c3b:	80 f9 05             	cmp    $0x5,%cl
  103c3e:	77 08                	ja     103c48 <shell_make_argv+0x16b>
						v = (v << 4) | (t - 'a' + 10);
  103c40:	c1 e6 04             	shl    $0x4,%esi
  103c43:	83 e8 57             	sub    $0x57,%eax
  103c46:	eb 0e                	jmp    103c56 <shell_make_argv+0x179>
					} else if ((t >= 'A') && (t <= 'F')) {
  103c48:	8d 48 bf             	lea    -0x41(%eax),%ecx
  103c4b:	80 f9 05             	cmp    $0x5,%cl
  103c4e:	77 18                	ja     103c68 <shell_make_argv+0x18b>
						v = (v << 4) | (t - 'A' + 10);
  103c50:	c1 e6 04             	shl    $0x4,%esi
  103c53:	83 e8 37             	sub    $0x37,%eax
  103c56:	09 c6                	or     %eax,%esi
				for (i = 2U; i < (2 + 2); i++) {
  103c58:	83 fa 03             	cmp    $0x3,%edx
  103c5b:	74 07                	je     103c64 <shell_make_argv+0x187>
  103c5d:	ba 03 00 00 00       	mov    $0x3,%edx
  103c62:	eb bf                	jmp    103c23 <shell_make_argv+0x146>
  103c64:	b2 04                	mov    $0x4,%dl
  103c66:	eb 08                	jmp    103c70 <shell_make_argv+0x193>
				if (i > 2) {
  103c68:	80 7d f2 02          	cmpb   $0x2,-0xe(%ebp)
  103c6c:	74 43                	je     103cb1 <shell_make_argv+0x1d4>
  103c6e:	b2 03                	mov    $0x3,%dl
  103c70:	88 55 f2             	mov    %dl,-0xe(%ebp)
						shell_strlen(cmd) - (i - 2));
  103c73:	89 d8                	mov    %ebx,%eax
  103c75:	e8 bb fd ff ff       	call   103a35 <shell_strlen>
  103c7a:	0f b6 55 f2          	movzbl -0xe(%ebp),%edx
  103c7e:	0f b7 c0             	movzwl %ax,%eax
  103c81:	83 c0 02             	add    $0x2,%eax
  103c84:	29 d0                	sub    %edx,%eax
					memmove(cmd, cmd + (i - 1),
  103c86:	50                   	push   %eax
  103c87:	8d 44 13 ff          	lea    -0x1(%ebx,%edx,1),%eax
  103c8b:	50                   	push   %eax
  103c8c:	53                   	push   %ebx
  103c8d:	e8 47 31 00 00       	call   106dd9 <memmove>
					*cmd++ = v;
  103c92:	89 f0                	mov    %esi,%eax
					memmove(cmd, cmd + (i - 1),
  103c94:	83 c4 0c             	add    $0xc,%esp
					*cmd++ = v;
  103c97:	88 03                	mov    %al,(%ebx)
					continue;
  103c99:	e9 e2 fe ff ff       	jmp    103b80 <shell_make_argv+0xa3>
		if (!quote && isspace((int) c)) {
  103c9e:	80 7d f3 00          	cmpb   $0x0,-0xd(%ebp)
  103ca2:	75 0d                	jne    103cb1 <shell_make_argv+0x1d4>
  103ca4:	8d 50 f7             	lea    -0x9(%eax),%edx
  103ca7:	83 fa 04             	cmp    $0x4,%edx
  103caa:	76 0d                	jbe    103cb9 <shell_make_argv+0x1dc>
  103cac:	83 f8 20             	cmp    $0x20,%eax
  103caf:	74 08                	je     103cb9 <shell_make_argv+0x1dc>
		cmd += 1;
  103cb1:	8d 7b 01             	lea    0x1(%ebx),%edi
  103cb4:	e9 c7 fe ff ff       	jmp    103b80 <shell_make_argv+0xa3>
	} while (*argc < max_argc);
  103cb9:	8b 45 08             	mov    0x8(%ebp),%eax
  103cbc:	8b 7d ec             	mov    -0x14(%ebp),%edi
  103cbf:	39 38                	cmp    %edi,(%eax)
  103cc1:	0f 82 36 fe ff ff    	jb     103afd <shell_make_argv+0x20>

	argv[*argc] = 0;
  103cc7:	8b 45 08             	mov    0x8(%ebp),%eax
  103cca:	8b 7d 0c             	mov    0xc(%ebp),%edi
  103ccd:	8b 00                	mov    (%eax),%eax
  103ccf:	c7 04 87 00 00 00 00 	movl   $0x0,(%edi,%eax,4)

	return quote;
}
  103cd6:	8a 45 f3             	mov    -0xd(%ebp),%al
  103cd9:	8d 65 f4             	lea    -0xc(%ebp),%esp
  103cdc:	5b                   	pop    %ebx
  103cdd:	5e                   	pop    %esi
  103cde:	5f                   	pop    %edi
  103cdf:	5d                   	pop    %ebp
  103ce0:	c3                   	ret    

00103ce1 <shell_pattern_remove>:

void shell_pattern_remove(char *buff, u16_t *buff_len, const char *pattern)
{
  103ce1:	55                   	push   %ebp
  103ce2:	89 e5                	mov    %esp,%ebp
  103ce4:	57                   	push   %edi
  103ce5:	56                   	push   %esi
  103ce6:	53                   	push   %ebx
  103ce7:	50                   	push   %eax
  103ce8:	8b 5d 10             	mov    0x10(%ebp),%ebx
  103ceb:	8b 55 08             	mov    0x8(%ebp),%edx
	char *pattern_addr = strstr(buff, pattern);
  103cee:	53                   	push   %ebx
  103cef:	89 55 f0             	mov    %edx,-0x10(%ebp)
  103cf2:	52                   	push   %edx
{
  103cf3:	8b 7d 0c             	mov    0xc(%ebp),%edi
	char *pattern_addr = strstr(buff, pattern);
  103cf6:	e8 a1 2f 00 00       	call   106c9c <strstr>
  103cfb:	5a                   	pop    %edx
  103cfc:	89 c6                	mov    %eax,%esi
	u16_t shift;
	u16_t pattern_len = shell_strlen(pattern);
  103cfe:	89 d8                	mov    %ebx,%eax
	char *pattern_addr = strstr(buff, pattern);
  103d00:	59                   	pop    %ecx
	u16_t pattern_len = shell_strlen(pattern);
  103d01:	e8 2f fd ff ff       	call   103a35 <shell_strlen>

	if (!pattern_addr) {
  103d06:	85 f6                	test   %esi,%esi
  103d08:	74 3b                	je     103d45 <shell_pattern_remove+0x64>
		return;
	}

	if (pattern_addr > buff) {
  103d0a:	8b 55 f0             	mov    -0x10(%ebp),%edx
  103d0d:	89 c3                	mov    %eax,%ebx
  103d0f:	39 f2                	cmp    %esi,%edx
  103d11:	73 08                	jae    103d1b <shell_pattern_remove+0x3a>
		if (*(pattern_addr - 1) == ' ') {
  103d13:	80 7e ff 20          	cmpb   $0x20,-0x1(%esi)
  103d17:	75 02                	jne    103d1b <shell_pattern_remove+0x3a>
			pattern_len++; /* space needs to be removed as well */
  103d19:	43                   	inc    %ebx
			pattern_addr--; /* set pointer to space */
  103d1a:	4e                   	dec    %esi
		}
	}

	shift = shell_strlen(pattern_addr) - pattern_len + 1; /* +1 for EOS */
  103d1b:	89 f0                	mov    %esi,%eax
  103d1d:	e8 13 fd ff ff       	call   103a35 <shell_strlen>
	*buff_len -= pattern_len;
  103d22:	66 29 1f             	sub    %bx,(%edi)
	shift = shell_strlen(pattern_addr) - pattern_len + 1; /* +1 for EOS */
  103d25:	29 d8                	sub    %ebx,%eax
  103d27:	40                   	inc    %eax

	memmove(pattern_addr, pattern_addr + pattern_len, shift);
  103d28:	89 75 08             	mov    %esi,0x8(%ebp)
  103d2b:	0f b7 db             	movzwl %bx,%ebx
  103d2e:	01 f3                	add    %esi,%ebx
  103d30:	0f b7 c0             	movzwl %ax,%eax
  103d33:	89 5d 0c             	mov    %ebx,0xc(%ebp)
  103d36:	89 45 10             	mov    %eax,0x10(%ebp)
}
  103d39:	8d 65 f4             	lea    -0xc(%ebp),%esp
  103d3c:	5b                   	pop    %ebx
  103d3d:	5e                   	pop    %esi
  103d3e:	5f                   	pop    %edi
  103d3f:	5d                   	pop    %ebp
	memmove(pattern_addr, pattern_addr + pattern_len, shift);
  103d40:	e9 94 30 00 00       	jmp    106dd9 <memmove>
}
  103d45:	8d 65 f4             	lea    -0xc(%ebp),%esp
  103d48:	5b                   	pop    %ebx
  103d49:	5e                   	pop    %esi
  103d4a:	5f                   	pop    %edi
  103d4b:	5d                   	pop    %ebp
  103d4c:	c3                   	ret    

00103d4d <shell_cmd_get>:
}

void shell_cmd_get(const struct shell_cmd_entry *command, size_t lvl,
		   size_t idx, const struct shell_static_entry **entry,
		   struct shell_static_entry *d_entry)
{
  103d4d:	55                   	push   %ebp
  103d4e:	89 e5                	mov    %esp,%ebp
  103d50:	56                   	push   %esi
  103d51:	53                   	push   %ebx
  103d52:	8b 4d 08             	mov    0x8(%ebp),%ecx
  103d55:	8b 45 10             	mov    0x10(%ebp),%eax
  103d58:	8b 5d 14             	mov    0x14(%ebp),%ebx
  103d5b:	8b 75 18             	mov    0x18(%ebp),%esi
	__ASSERT_NO_MSG(entry != NULL);
	__ASSERT_NO_MSG(d_entry != NULL);

	if (lvl == SHELL_CMD_ROOT_LVL) {
  103d5e:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  103d62:	75 1d                	jne    103d81 <shell_cmd_get+0x34>
	return ((u8_t *)__shell_root_cmds_end -
  103d64:	ba 70 ba 10 00       	mov    $0x10ba70,%edx
  103d69:	81 ea 28 ba 10 00    	sub    $0x10ba28,%edx
			(u8_t *)__shell_root_cmds_start)/
  103d6f:	c1 ea 03             	shr    $0x3,%edx
		if (idx < shell_root_cmd_count()) {
  103d72:	39 d0                	cmp    %edx,%eax
  103d74:	73 0f                	jae    103d85 <shell_cmd_get+0x38>
			const struct shell_cmd_entry *cmd;

			cmd = shell_root_cmd_get(idx);
			*entry = cmd->u.entry;
  103d76:	8b 04 c5 2c ba 10 00 	mov    0x10ba2c(,%eax,8),%eax
  103d7d:	89 03                	mov    %eax,(%ebx)
  103d7f:	eb 34                	jmp    103db5 <shell_cmd_get+0x68>
			*entry = NULL;
		}
		return;
	}

	if (command == NULL) {
  103d81:	85 c9                	test   %ecx,%ecx
  103d83:	75 08                	jne    103d8d <shell_cmd_get+0x40>
			*entry = NULL;
  103d85:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
  103d8b:	eb 28                	jmp    103db5 <shell_cmd_get+0x68>
		*entry = NULL;
		return;
	}

	if (command->is_dynamic) {
  103d8d:	8b 51 04             	mov    0x4(%ecx),%edx
  103d90:	80 39 00             	cmpb   $0x0,(%ecx)
  103d93:	74 11                	je     103da6 <shell_cmd_get+0x59>
		command->u.dynamic_get(idx, d_entry);
  103d95:	56                   	push   %esi
  103d96:	50                   	push   %eax
  103d97:	ff d2                	call   *%edx
  103d99:	58                   	pop    %eax
		*entry = (d_entry->syntax != NULL) ? d_entry : NULL;
  103d9a:	83 3e 00             	cmpl   $0x0,(%esi)
		command->u.dynamic_get(idx, d_entry);
  103d9d:	5a                   	pop    %edx
		*entry = (d_entry->syntax != NULL) ? d_entry : NULL;
  103d9e:	75 02                	jne    103da2 <shell_cmd_get+0x55>
  103da0:	31 f6                	xor    %esi,%esi
  103da2:	89 33                	mov    %esi,(%ebx)
  103da4:	eb 0f                	jmp    103db5 <shell_cmd_get+0x68>
	} else {
		*entry = (command->u.entry[idx].syntax != NULL) ?
  103da6:	6b c0 14             	imul   $0x14,%eax,%eax
  103da9:	01 d0                	add    %edx,%eax
  103dab:	8b 10                	mov    (%eax),%edx
				&command->u.entry[idx] : NULL;
  103dad:	85 d2                	test   %edx,%edx
  103daf:	74 02                	je     103db3 <shell_cmd_get+0x66>
  103db1:	89 c2                	mov    %eax,%edx
		*entry = (command->u.entry[idx].syntax != NULL) ?
  103db3:	89 13                	mov    %edx,(%ebx)
	}
}
  103db5:	8d 65 f8             	lea    -0x8(%ebp),%esp
  103db8:	5b                   	pop    %ebx
  103db9:	5e                   	pop    %esi
  103dba:	5d                   	pop    %ebp
  103dbb:	c3                   	ret    

00103dbc <shell_spaces_trim>:

	return 0;
}

void shell_spaces_trim(char *str)
{
  103dbc:	55                   	push   %ebp
  103dbd:	89 e5                	mov    %esp,%ebp
  103dbf:	57                   	push   %edi
  103dc0:	56                   	push   %esi
  103dc1:	53                   	push   %ebx
  103dc2:	83 ec 0c             	sub    $0xc,%esp
  103dc5:	8b 75 08             	mov    0x8(%ebp),%esi
	u16_t len = shell_strlen(str);
  103dc8:	89 f0                	mov    %esi,%eax
  103dca:	e8 66 fc ff ff       	call   103a35 <shell_strlen>
	u16_t shift = 0U;

	if (!str) {
  103dcf:	85 f6                	test   %esi,%esi
	u16_t len = shell_strlen(str);
  103dd1:	66 89 45 f0          	mov    %ax,-0x10(%ebp)
	if (!str) {
  103dd5:	74 7a                	je     103e51 <shell_spaces_trim+0x95>
		return;
	}

	for (u16_t i = 0; i < len - 1; i++) {
  103dd7:	66 c7 45 f2 00 00    	movw   $0x0,-0xe(%ebp)
	u16_t shift = 0U;
  103ddd:	31 db                	xor    %ebx,%ebx
	for (u16_t i = 0; i < len - 1; i++) {
  103ddf:	0f b7 45 f0          	movzwl -0x10(%ebp),%eax
  103de3:	0f b7 7d f2          	movzwl -0xe(%ebp),%edi
  103de7:	89 45 ec             	mov    %eax,-0x14(%ebp)
  103dea:	48                   	dec    %eax
  103deb:	39 c7                	cmp    %eax,%edi
  103ded:	7d 62                	jge    103e51 <shell_spaces_trim+0x95>
		if (isspace((int)str[i])) {
  103def:	0f be 14 3e          	movsbl (%esi,%edi,1),%edx
  103df3:	66 ff 45 f2          	incw   -0xe(%ebp)
  103df7:	89 d0                	mov    %edx,%eax
  103df9:	83 ea 09             	sub    $0x9,%edx
  103dfc:	83 fa 04             	cmp    $0x4,%edx
  103dff:	76 04                	jbe    103e05 <shell_spaces_trim+0x49>
  103e01:	3c 20                	cmp    $0x20,%al
  103e03:	75 da                	jne    103ddf <shell_spaces_trim+0x23>
			for (u16_t j = i + 1; j < len; j++) {
  103e05:	0f b7 45 f2          	movzwl -0xe(%ebp),%eax
  103e09:	66 39 45 f0          	cmp    %ax,-0x10(%ebp)
  103e0d:	76 d0                	jbe    103ddf <shell_spaces_trim+0x23>
				if (isspace((int)str[j])) {
  103e0f:	8d 0c 06             	lea    (%esi,%eax,1),%ecx
  103e12:	89 4d e8             	mov    %ecx,-0x18(%ebp)
  103e15:	0f be 0c 06          	movsbl (%esi,%eax,1),%ecx
  103e19:	89 ca                	mov    %ecx,%edx
  103e1b:	83 e9 09             	sub    $0x9,%ecx
  103e1e:	40                   	inc    %eax
  103e1f:	83 f9 04             	cmp    $0x4,%ecx
  103e22:	76 05                	jbe    103e29 <shell_spaces_trim+0x6d>
  103e24:	80 fa 20             	cmp    $0x20,%dl
  103e27:	75 03                	jne    103e2c <shell_spaces_trim+0x70>
					shift++;
  103e29:	43                   	inc    %ebx
					continue;
  103e2a:	eb dd                	jmp    103e09 <shell_spaces_trim+0x4d>
				}

				if (shift > 0) {
  103e2c:	66 85 db             	test   %bx,%bx
  103e2f:	74 ae                	je     103ddf <shell_spaces_trim+0x23>
					/* +1 for EOS */
					memmove(&str[i + 1],
						&str[j],
						len - shift + 1);
  103e31:	8b 45 ec             	mov    -0x14(%ebp),%eax
  103e34:	0f b7 d3             	movzwl %bx,%edx
  103e37:	40                   	inc    %eax
  103e38:	29 d0                	sub    %edx,%eax
					memmove(&str[i + 1],
  103e3a:	50                   	push   %eax
  103e3b:	8d 44 3e 01          	lea    0x1(%esi,%edi,1),%eax
  103e3f:	ff 75 e8             	pushl  -0x18(%ebp)
  103e42:	50                   	push   %eax
  103e43:	e8 91 2f 00 00       	call   106dd9 <memmove>
					len -= shift;
  103e48:	66 29 5d f0          	sub    %bx,-0x10(%ebp)
					memmove(&str[i + 1],
  103e4c:	83 c4 0c             	add    $0xc,%esp
					len -= shift;
  103e4f:	eb 8c                	jmp    103ddd <shell_spaces_trim+0x21>

				break;
			}
		}
	}
}
  103e51:	8d 65 f4             	lea    -0xc(%ebp),%esp
  103e54:	5b                   	pop    %ebx
  103e55:	5e                   	pop    %esi
  103e56:	5f                   	pop    %edi
  103e57:	5d                   	pop    %ebp
  103e58:	c3                   	ret    

00103e59 <shell_cmd_trim>:
		*buff_len = *buff_len - i;
	}
}

void shell_cmd_trim(const struct shell *shell)
{
  103e59:	55                   	push   %ebp
  103e5a:	89 e5                	mov    %esp,%ebp
  103e5c:	57                   	push   %edi
  103e5d:	56                   	push   %esi
  103e5e:	53                   	push   %ebx
  103e5f:	83 ec 08             	sub    $0x8,%esp
	buffer_trim(shell->ctx->cmd_buff, &shell->ctx->cmd_buff_len);
  103e62:	8b 45 08             	mov    0x8(%ebp),%eax
  103e65:	8b 58 08             	mov    0x8(%eax),%ebx
	if (buff[0] == '\0') {
  103e68:	8d 43 42             	lea    0x42(%ebx),%eax
  103e6b:	80 7b 42 00          	cmpb   $0x0,0x42(%ebx)
  103e6f:	74 76                	je     103ee7 <shell_cmd_trim+0x8e>
	while (isspace((int) buff[*buff_len - 1U])) {
  103e71:	0f b7 7b 3c          	movzwl 0x3c(%ebx),%edi
  103e75:	89 fa                	mov    %edi,%edx
  103e77:	0f be 74 38 ff       	movsbl -0x1(%eax,%edi,1),%esi
  103e7c:	89 f1                	mov    %esi,%ecx
  103e7e:	83 ee 09             	sub    $0x9,%esi
  103e81:	83 fe 04             	cmp    $0x4,%esi
  103e84:	77 10                	ja     103e96 <shell_cmd_trim+0x3d>
		*buff_len -= 1U;
  103e86:	4a                   	dec    %edx
		if (*buff_len == 0U) {
  103e87:	66 85 d2             	test   %dx,%dx
		*buff_len -= 1U;
  103e8a:	66 89 53 3c          	mov    %dx,0x3c(%ebx)
		if (*buff_len == 0U) {
  103e8e:	75 e1                	jne    103e71 <shell_cmd_trim+0x18>
			buff[0] = '\0';
  103e90:	c6 43 42 00          	movb   $0x0,0x42(%ebx)
			return;
  103e94:	eb 51                	jmp    103ee7 <shell_cmd_trim+0x8e>
	while (isspace((int) buff[*buff_len - 1U])) {
  103e96:	80 f9 20             	cmp    $0x20,%cl
  103e99:	74 eb                	je     103e86 <shell_cmd_trim+0x2d>
	buff[*buff_len] = '\0';
  103e9b:	c6 44 3b 42 00       	movb   $0x0,0x42(%ebx,%edi,1)
	u16_t i = 0U;
  103ea0:	31 f6                	xor    %esi,%esi
	while (isspace((int) buff[i++]))
  103ea2:	0f b7 ce             	movzwl %si,%ecx
  103ea5:	8d 7e 01             	lea    0x1(%esi),%edi
  103ea8:	89 4d ec             	mov    %ecx,-0x14(%ebp)
  103eab:	66 89 7d f2          	mov    %di,-0xe(%ebp)
  103eaf:	89 cf                	mov    %ecx,%edi
  103eb1:	01 c7                	add    %eax,%edi
  103eb3:	0f be 0f             	movsbl (%edi),%ecx
  103eb6:	89 ca                	mov    %ecx,%edx
  103eb8:	83 e9 09             	sub    $0x9,%ecx
  103ebb:	83 f9 04             	cmp    $0x4,%ecx
  103ebe:	77 06                	ja     103ec6 <shell_cmd_trim+0x6d>
  103ec0:	66 8b 75 f2          	mov    -0xe(%ebp),%si
  103ec4:	eb dc                	jmp    103ea2 <shell_cmd_trim+0x49>
  103ec6:	80 fa 20             	cmp    $0x20,%dl
  103ec9:	74 f5                	je     103ec0 <shell_cmd_trim+0x67>
	if (--i > 0) {
  103ecb:	66 85 f6             	test   %si,%si
  103ece:	74 17                	je     103ee7 <shell_cmd_trim+0x8e>
		memmove(buff, buff + i, (*buff_len + 1U) - i); /* +1 for '\0' */
  103ed0:	0f b7 53 3c          	movzwl 0x3c(%ebx),%edx
  103ed4:	42                   	inc    %edx
  103ed5:	2b 55 ec             	sub    -0x14(%ebp),%edx
  103ed8:	52                   	push   %edx
  103ed9:	57                   	push   %edi
  103eda:	50                   	push   %eax
  103edb:	e8 f9 2e 00 00       	call   106dd9 <memmove>
		*buff_len = *buff_len - i;
  103ee0:	66 29 73 3c          	sub    %si,0x3c(%ebx)
		memmove(buff, buff + i, (*buff_len + 1U) - i); /* +1 for '\0' */
  103ee4:	83 c4 0c             	add    $0xc,%esp
	shell->ctx->cmd_buff_pos = shell->ctx->cmd_buff_len;
  103ee7:	8b 45 08             	mov    0x8(%ebp),%eax
  103eea:	8b 40 08             	mov    0x8(%eax),%eax
  103eed:	8b 50 3c             	mov    0x3c(%eax),%edx
  103ef0:	66 89 50 3e          	mov    %dx,0x3e(%eax)
}
  103ef4:	8d 65 f4             	lea    -0xc(%ebp),%esp
  103ef7:	5b                   	pop    %ebx
  103ef8:	5e                   	pop    %esi
  103ef9:	5f                   	pop    %edi
  103efa:	5d                   	pop    %ebp
  103efb:	c3                   	ret    

00103efc <shell_raw_fprintf>:
{
  103efc:	55                   	push   %ebp
  103efd:	89 e5                	mov    %esp,%ebp
	va_start(args, fmt);
  103eff:	8d 45 10             	lea    0x10(%ebp),%eax
	shell_fprintf_fmt(ctx, fmt, args);
  103f02:	50                   	push   %eax
  103f03:	ff 75 0c             	pushl  0xc(%ebp)
  103f06:	ff 75 08             	pushl  0x8(%ebp)
  103f09:	e8 a8 fa ff ff       	call   1039b6 <shell_fprintf_fmt>
  103f0e:	83 c4 0c             	add    $0xc,%esp
}
  103f11:	c9                   	leave  
  103f12:	c3                   	ret    

00103f13 <clear_eos.isra.5>:
static inline void clear_eos(const struct shell *shell)
  103f13:	55                   	push   %ebp
  103f14:	89 e5                	mov    %esp,%ebp
	SHELL_VT100_CMD(shell, SHELL_VT100_CLEAREOS);
  103f16:	68 80 db 10 00       	push   $0x10db80
  103f1b:	68 7b e4 10 00       	push   $0x10e47b
  103f20:	50                   	push   %eax
  103f21:	e8 d6 ff ff ff       	call   103efc <shell_raw_fprintf>
  103f26:	83 c4 0c             	add    $0xc,%esp
}
  103f29:	c9                   	leave  
  103f2a:	c3                   	ret    

00103f2b <full_line_cmd.isra.7>:
}

/* Function returns true if command length is equal to multiplicity of terminal
 * width.
 */
static inline bool full_line_cmd(const struct shell *shell)
  103f2b:	55                   	push   %ebp
  103f2c:	89 e5                	mov    %esp,%ebp
  103f2e:	56                   	push   %esi
  103f2f:	53                   	push   %ebx
  103f30:	89 c6                	mov    %eax,%esi
{
	return ((shell->ctx->cmd_buff_len + shell_strlen(shell->ctx->prompt))
  103f32:	8b 00                	mov    (%eax),%eax
  103f34:	0f b7 58 3c          	movzwl 0x3c(%eax),%ebx
  103f38:	8b 00                	mov    (%eax),%eax
	return str == NULL ? 0U : (u16_t)strlen(str);
  103f3a:	85 c0                	test   %eax,%eax
  103f3c:	74 09                	je     103f47 <full_line_cmd.isra.7+0x1c>
  103f3e:	50                   	push   %eax
  103f3f:	e8 32 2e 00 00       	call   106d76 <strlen>
  103f44:	5a                   	pop    %edx
  103f45:	eb 02                	jmp    103f49 <full_line_cmd.isra.7+0x1e>
  103f47:	31 c0                	xor    %eax,%eax
			% shell->ctx->vt100_ctx.cons.terminal_wid == 0U);
  103f49:	8b 16                	mov    (%esi),%edx
	return ((shell->ctx->cmd_buff_len + shell_strlen(shell->ctx->prompt))
  103f4b:	0f b7 c0             	movzwl %ax,%eax
  103f4e:	01 d8                	add    %ebx,%eax
			% shell->ctx->vt100_ctx.cons.terminal_wid == 0U);
  103f50:	0f b7 4a 2a          	movzwl 0x2a(%edx),%ecx
  103f54:	99                   	cltd   
  103f55:	f7 f9                	idiv   %ecx
  103f57:	85 d2                	test   %edx,%edx
  103f59:	0f 94 c0             	sete   %al
}
  103f5c:	8d 65 f8             	lea    -0x8(%ebp),%esp
  103f5f:	5b                   	pop    %ebx
  103f60:	5e                   	pop    %esi
  103f61:	5d                   	pop    %ebp
  103f62:	c3                   	ret    

00103f63 <shell_op_cursor_vert_move>:
{
  103f63:	55                   	push   %ebp
  103f64:	89 e5                	mov    %esp,%ebp
  103f66:	8b 45 0c             	mov    0xc(%ebp),%eax
	if (delta != 0) {
  103f69:	85 c0                	test   %eax,%eax
  103f6b:	74 23                	je     103f90 <shell_op_cursor_vert_move+0x2d>
		shell_raw_fprintf(shell->fprintf_ctx, "\033[%d%c",
  103f6d:	0f 9e c2             	setle  %dl
  103f70:	0f b6 d2             	movzbl %dl,%edx
  103f73:	83 c2 41             	add    $0x41,%edx
  103f76:	52                   	push   %edx
  103f77:	99                   	cltd   
  103f78:	31 d0                	xor    %edx,%eax
  103f7a:	29 d0                	sub    %edx,%eax
  103f7c:	50                   	push   %eax
  103f7d:	8b 45 08             	mov    0x8(%ebp),%eax
  103f80:	68 98 e4 10 00       	push   $0x10e498
  103f85:	ff 70 14             	pushl  0x14(%eax)
  103f88:	e8 6f ff ff ff       	call   103efc <shell_raw_fprintf>
  103f8d:	83 c4 10             	add    $0x10,%esp
}
  103f90:	c9                   	leave  
  103f91:	c3                   	ret    

00103f92 <shell_op_cursor_horiz_move>:
{
  103f92:	55                   	push   %ebp
  103f93:	89 e5                	mov    %esp,%ebp
  103f95:	8b 45 0c             	mov    0xc(%ebp),%eax
	if (delta != 0) {
  103f98:	85 c0                	test   %eax,%eax
  103f9a:	74 23                	je     103fbf <shell_op_cursor_horiz_move+0x2d>
		shell_raw_fprintf(shell->fprintf_ctx, "\033[%d%c",
  103f9c:	0f 9e c2             	setle  %dl
  103f9f:	0f b6 d2             	movzbl %dl,%edx
  103fa2:	83 c2 43             	add    $0x43,%edx
  103fa5:	52                   	push   %edx
  103fa6:	99                   	cltd   
  103fa7:	31 d0                	xor    %edx,%eax
  103fa9:	29 d0                	sub    %edx,%eax
  103fab:	50                   	push   %eax
  103fac:	8b 45 08             	mov    0x8(%ebp),%eax
  103faf:	68 98 e4 10 00       	push   $0x10e498
  103fb4:	ff 70 14             	pushl  0x14(%eax)
  103fb7:	e8 40 ff ff ff       	call   103efc <shell_raw_fprintf>
  103fbc:	83 c4 10             	add    $0x10,%esp
}
  103fbf:	c9                   	leave  
  103fc0:	c3                   	ret    

00103fc1 <shell_cursor_in_empty_line>:

/* Function returns true if cursor is at beginning of an empty line. */
bool shell_cursor_in_empty_line(const struct shell *shell)
{
  103fc1:	55                   	push   %ebp
  103fc2:	89 e5                	mov    %esp,%ebp
  103fc4:	56                   	push   %esi
  103fc5:	53                   	push   %ebx
  103fc6:	8b 75 08             	mov    0x8(%ebp),%esi
	return ((shell->ctx->cmd_buff_pos + shell_strlen(shell->ctx->prompt))
  103fc9:	8b 46 08             	mov    0x8(%esi),%eax
  103fcc:	8b 10                	mov    (%eax),%edx
  103fce:	0f b7 58 3e          	movzwl 0x3e(%eax),%ebx
  103fd2:	31 c0                	xor    %eax,%eax
  103fd4:	85 d2                	test   %edx,%edx
  103fd6:	74 07                	je     103fdf <shell_cursor_in_empty_line+0x1e>
  103fd8:	52                   	push   %edx
  103fd9:	e8 98 2d 00 00       	call   106d76 <strlen>
  103fde:	5a                   	pop    %edx
			% shell->ctx->vt100_ctx.cons.terminal_wid == 0U);
  103fdf:	8b 56 08             	mov    0x8(%esi),%edx
	return ((shell->ctx->cmd_buff_pos + shell_strlen(shell->ctx->prompt))
  103fe2:	0f b7 c0             	movzwl %ax,%eax
  103fe5:	01 d8                	add    %ebx,%eax
			% shell->ctx->vt100_ctx.cons.terminal_wid == 0U);
  103fe7:	0f b7 4a 2a          	movzwl 0x2a(%edx),%ecx
  103feb:	99                   	cltd   
  103fec:	f7 f9                	idiv   %ecx
  103fee:	85 d2                	test   %edx,%edx
  103ff0:	0f 94 c0             	sete   %al
}
  103ff3:	8d 65 f8             	lea    -0x8(%ebp),%esp
  103ff6:	5b                   	pop    %ebx
  103ff7:	5e                   	pop    %esi
  103ff8:	5d                   	pop    %ebp
  103ff9:	c3                   	ret    

00103ffa <shell_op_cond_next_line>:

void shell_op_cond_next_line(const struct shell *shell)
{
  103ffa:	55                   	push   %ebp
  103ffb:	89 e5                	mov    %esp,%ebp
  103ffd:	53                   	push   %ebx
  103ffe:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (shell_cursor_in_empty_line(shell) || full_line_cmd(shell)) {
  104001:	53                   	push   %ebx
  104002:	e8 ba ff ff ff       	call   103fc1 <shell_cursor_in_empty_line>
  104007:	59                   	pop    %ecx
  104008:	84 c0                	test   %al,%al
  10400a:	74 11                	je     10401d <shell_op_cond_next_line+0x23>
	shell_raw_fprintf(shell->fprintf_ctx, "\n");
  10400c:	68 7f e4 10 00       	push   $0x10e47f
  104011:	ff 73 14             	pushl  0x14(%ebx)
  104014:	e8 e3 fe ff ff       	call   103efc <shell_raw_fprintf>
  104019:	58                   	pop    %eax
  10401a:	5a                   	pop    %edx
  10401b:	eb 0c                	jmp    104029 <shell_op_cond_next_line+0x2f>
  10401d:	8d 43 08             	lea    0x8(%ebx),%eax
  104020:	e8 06 ff ff ff       	call   103f2b <full_line_cmd.isra.7>
  104025:	84 c0                	test   %al,%al
  104027:	75 e3                	jne    10400c <shell_op_cond_next_line+0x12>
		cursor_next_line_move(shell);
	}
}
  104029:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  10402c:	c9                   	leave  
  10402d:	c3                   	ret    

0010402e <shell_op_cursor_position_synchronize>:

void shell_op_cursor_position_synchronize(const struct shell *shell)
{
  10402e:	55                   	push   %ebp
  10402f:	89 e5                	mov    %esp,%ebp
  104031:	57                   	push   %edi
  104032:	56                   	push   %esi
  104033:	53                   	push   %ebx
  104034:	51                   	push   %ecx
  104035:	8b 5d 08             	mov    0x8(%ebp),%ebx
	struct shell_multiline_cons *cons = &shell->ctx->vt100_ctx.cons;
  104038:	8b 73 08             	mov    0x8(%ebx),%esi
	bool last_line;

	shell_multiline_data_calc(cons, shell->ctx->cmd_buff_pos,
  10403b:	0f b7 46 3c          	movzwl 0x3c(%esi),%eax
  10403f:	50                   	push   %eax
  104040:	0f b7 46 3e          	movzwl 0x3e(%esi),%eax
  104044:	50                   	push   %eax
	struct shell_multiline_cons *cons = &shell->ctx->vt100_ctx.cons;
  104045:	8d 46 20             	lea    0x20(%esi),%eax
	shell_multiline_data_calc(cons, shell->ctx->cmd_buff_pos,
  104048:	50                   	push   %eax
  104049:	e8 54 fa ff ff       	call   103aa2 <shell_multiline_data_calc>
				  shell->ctx->cmd_buff_len);
	last_line = (cons->cur_y == cons->cur_y_end);
  10404e:	66 8b 46 26          	mov    0x26(%esi),%ax
	shell_multiline_data_calc(cons, shell->ctx->cmd_buff_pos,
  104052:	83 c4 0c             	add    $0xc,%esp
	last_line = (cons->cur_y == cons->cur_y_end);
  104055:	66 89 45 f2          	mov    %ax,-0xe(%ebp)

	/* In case cursor reaches the bottom line of a terminal, it will
	 * be moved to the next line.
	 */
	if (full_line_cmd(shell)) {
  104059:	8d 43 08             	lea    0x8(%ebx),%eax
	last_line = (cons->cur_y == cons->cur_y_end);
  10405c:	66 8b 7e 24          	mov    0x24(%esi),%di
	if (full_line_cmd(shell)) {
  104060:	e8 c6 fe ff ff       	call   103f2b <full_line_cmd.isra.7>
  104065:	84 c0                	test   %al,%al
  104067:	74 0f                	je     104078 <shell_op_cursor_position_synchronize+0x4a>
  104069:	68 7f e4 10 00       	push   $0x10e47f
  10406e:	ff 73 14             	pushl  0x14(%ebx)
  104071:	e8 86 fe ff ff       	call   103efc <shell_raw_fprintf>
  104076:	58                   	pop    %eax
  104077:	5a                   	pop    %edx
		cursor_next_line_move(shell);
	}

	if (last_line) {
  104078:	66 3b 7d f2          	cmp    -0xe(%ebp),%di
  10407c:	74 13                	je     104091 <shell_op_cursor_position_synchronize+0x63>
		shell_op_cursor_horiz_move(shell, cons->cur_x -
							       cons->cur_x_end);
	} else {
		shell_op_cursor_vert_move(shell, cons->cur_y_end - cons->cur_y);
  10407e:	0f b7 4e 24          	movzwl 0x24(%esi),%ecx
  104082:	0f b7 46 26          	movzwl 0x26(%esi),%eax
  104086:	29 c8                	sub    %ecx,%eax
  104088:	50                   	push   %eax
  104089:	53                   	push   %ebx
  10408a:	e8 d4 fe ff ff       	call   103f63 <shell_op_cursor_vert_move>
  10408f:	59                   	pop    %ecx
  104090:	5f                   	pop    %edi
		shell_op_cursor_horiz_move(shell, cons->cur_x -
							       cons->cur_x_end);
  104091:	0f b7 56 22          	movzwl 0x22(%esi),%edx
		shell_op_cursor_horiz_move(shell, cons->cur_x -
  104095:	0f b7 46 20          	movzwl 0x20(%esi),%eax
  104099:	29 d0                	sub    %edx,%eax
  10409b:	50                   	push   %eax
  10409c:	53                   	push   %ebx
  10409d:	e8 f0 fe ff ff       	call   103f92 <shell_op_cursor_horiz_move>
  1040a2:	58                   	pop    %eax
  1040a3:	5a                   	pop    %edx
	}
}
  1040a4:	8d 65 f4             	lea    -0xc(%ebp),%esp
  1040a7:	5b                   	pop    %ebx
  1040a8:	5e                   	pop    %esi
  1040a9:	5f                   	pop    %edi
  1040aa:	5d                   	pop    %ebp
  1040ab:	c3                   	ret    

001040ac <shell_op_cursor_move>:

void shell_op_cursor_move(const struct shell *shell, s16_t val)
{
  1040ac:	55                   	push   %ebp
  1040ad:	89 e5                	mov    %esp,%ebp
  1040af:	57                   	push   %edi
  1040b0:	56                   	push   %esi
  1040b1:	53                   	push   %ebx
  1040b2:	50                   	push   %eax
  1040b3:	8b 5d 08             	mov    0x8(%ebp),%ebx
	struct shell_multiline_cons *cons = &shell->ctx->vt100_ctx.cons;
  1040b6:	8b 43 08             	mov    0x8(%ebx),%eax
  1040b9:	83 c0 20             	add    $0x20,%eax
	u16_t new_pos = shell->ctx->cmd_buff_pos + val;
	s32_t row_span;
	s32_t col_span;

	shell_multiline_data_calc(cons, shell->ctx->cmd_buff_pos,
  1040bc:	0f b7 48 1c          	movzwl 0x1c(%eax),%ecx
	u16_t new_pos = shell->ctx->cmd_buff_pos + val;
  1040c0:	0f b7 50 1e          	movzwl 0x1e(%eax),%edx
	shell_multiline_data_calc(cons, shell->ctx->cmd_buff_pos,
  1040c4:	51                   	push   %ecx
	u16_t new_pos = shell->ctx->cmd_buff_pos + val;
  1040c5:	89 d6                	mov    %edx,%esi
	shell_multiline_data_calc(cons, shell->ctx->cmd_buff_pos,
  1040c7:	52                   	push   %edx
	u16_t new_pos = shell->ctx->cmd_buff_pos + val;
  1040c8:	03 75 0c             	add    0xc(%ebp),%esi
	shell_multiline_data_calc(cons, shell->ctx->cmd_buff_pos,
  1040cb:	50                   	push   %eax
  1040cc:	e8 d1 f9 ff ff       	call   103aa2 <shell_multiline_data_calc>
				  shell->ctx->cmd_buff_len);

	/* Calculate the new cursor. */
	row_span = row_span_with_buffer_offsets_get(&shell->ctx->vt100_ctx.cons,
						    shell->ctx->cmd_buff_pos,
  1040d1:	8b 43 08             	mov    0x8(%ebx),%eax
	shell_multiline_data_calc(cons, shell->ctx->cmd_buff_pos,
  1040d4:	83 c4 0c             	add    $0xc,%esp
	row_span = row_span_with_buffer_offsets_get(&shell->ctx->vt100_ctx.cons,
  1040d7:	0f b7 d6             	movzwl %si,%edx
  1040da:	0f b7 48 3e          	movzwl 0x3e(%eax),%ecx
  1040de:	52                   	push   %edx
  1040df:	83 c0 20             	add    $0x20,%eax
  1040e2:	51                   	push   %ecx
  1040e3:	89 55 f0             	mov    %edx,-0x10(%ebp)
  1040e6:	50                   	push   %eax
  1040e7:	e8 89 f9 ff ff       	call   103a75 <row_span_with_buffer_offsets_get>
  1040ec:	83 c4 0c             	add    $0xc,%esp
  1040ef:	89 c7                	mov    %eax,%edi
						    new_pos);
	col_span = column_span_with_buffer_offsets_get(
						    &shell->ctx->vt100_ctx.cons,
						    shell->ctx->cmd_buff_pos,
  1040f1:	8b 43 08             	mov    0x8(%ebx),%eax
	col_span = column_span_with_buffer_offsets_get(
  1040f4:	8b 55 f0             	mov    -0x10(%ebp),%edx
  1040f7:	52                   	push   %edx
  1040f8:	83 c0 20             	add    $0x20,%eax
  1040fb:	0f b7 50 1e          	movzwl 0x1e(%eax),%edx
  1040ff:	52                   	push   %edx
  104100:	50                   	push   %eax
  104101:	e8 42 f9 ff ff       	call   103a48 <column_span_with_buffer_offsets_get>
  104106:	83 c4 0c             	add    $0xc,%esp
  104109:	89 45 f0             	mov    %eax,-0x10(%ebp)
						    new_pos);

	shell_op_cursor_vert_move(shell, -row_span);
  10410c:	f7 df                	neg    %edi
  10410e:	57                   	push   %edi
  10410f:	53                   	push   %ebx
  104110:	e8 4e fe ff ff       	call   103f63 <shell_op_cursor_vert_move>
  104115:	5a                   	pop    %edx
	shell_op_cursor_horiz_move(shell, col_span);
  104116:	8b 45 f0             	mov    -0x10(%ebp),%eax
	shell_op_cursor_vert_move(shell, -row_span);
  104119:	59                   	pop    %ecx
	shell_op_cursor_horiz_move(shell, col_span);
  10411a:	50                   	push   %eax
  10411b:	53                   	push   %ebx
  10411c:	e8 71 fe ff ff       	call   103f92 <shell_op_cursor_horiz_move>
  104121:	5f                   	pop    %edi
  104122:	58                   	pop    %eax
	shell->ctx->cmd_buff_pos = new_pos;
  104123:	8b 43 08             	mov    0x8(%ebx),%eax
  104126:	66 89 70 3e          	mov    %si,0x3e(%eax)
}
  10412a:	8d 65 f4             	lea    -0xc(%ebp),%esp
  10412d:	5b                   	pop    %ebx
  10412e:	5e                   	pop    %esi
  10412f:	5f                   	pop    %edi
  104130:	5d                   	pop    %ebp
  104131:	c3                   	ret    

00104132 <shell_op_cursor_word_move>:

	return ret;
}

void shell_op_cursor_word_move(const struct shell *shell, s16_t val)
{
  104132:	55                   	push   %ebp
  104133:	89 e5                	mov    %esp,%ebp
  104135:	57                   	push   %edi
  104136:	56                   	push   %esi
  104137:	be 01 00 00 00       	mov    $0x1,%esi
  10413c:	53                   	push   %ebx
  10413d:	83 ec 10             	sub    $0x10,%esp
  104140:	8b 45 0c             	mov    0xc(%ebp),%eax
	s16_t shift;
	s16_t sign;

	if (val < 0) {
  104143:	66 85 c0             	test   %ax,%ax
{
  104146:	89 c3                	mov    %eax,%ebx
	if (val < 0) {
  104148:	79 05                	jns    10414f <shell_op_cursor_word_move+0x1d>
		val = -val;
  10414a:	f7 db                	neg    %ebx
		sign = -1;
  10414c:	83 ce ff             	or     $0xffffffff,%esi
		if (((idx == 0U) && (sign < 0)) ||
  10414f:	89 f0                	mov    %esi,%eax
  104151:	66 c1 e8 0f          	shr    $0xf,%ax
  104155:	66 89 45 e6          	mov    %ax,-0x1a(%ebp)
	} else {
		sign = 1;
	}

	while (val--) {
  104159:	4b                   	dec    %ebx
  10415a:	66 83 fb ff          	cmp    $0xffff,%bx
  10415e:	0f 84 8c 00 00 00    	je     1041f0 <shell_op_cursor_word_move+0xbe>
		shift = shift_calc(shell->ctx->cmd_buff,
				   shell->ctx->cmd_buff_pos,
				   shell->ctx->cmd_buff_len, sign);
  104164:	8b 45 08             	mov    0x8(%ebp),%eax
		if (((idx == 0U) && (sign < 0)) ||
  104167:	8a 55 e6             	mov    -0x1a(%ebp),%dl
  10416a:	88 55 e9             	mov    %dl,-0x17(%ebp)
				   shell->ctx->cmd_buff_len, sign);
  10416d:	8b 40 08             	mov    0x8(%eax),%eax
		shift = shift_calc(shell->ctx->cmd_buff,
  104170:	83 c0 42             	add    $0x42,%eax
				   shell->ctx->cmd_buff_len, sign);
  104173:	8b 78 fa             	mov    -0x6(%eax),%edi
  104176:	66 89 7d f0          	mov    %di,-0x10(%ebp)
				   shell->ctx->cmd_buff_pos,
  10417a:	66 8b 78 fc          	mov    -0x4(%eax),%di
  10417e:	66 89 7d f2          	mov    %di,-0xe(%ebp)
		shift = shift_calc(shell->ctx->cmd_buff,
  104182:	89 45 ec             	mov    %eax,-0x14(%ebp)
  104185:	89 f8                	mov    %edi,%eax
	bool found = false;
  104187:	31 ff                	xor    %edi,%edi
		idx = pos + ret * sign;
  104189:	89 c1                	mov    %eax,%ecx
  10418b:	66 2b 4d f2          	sub    -0xe(%ebp),%cx
		if (((idx == 0U) && (sign < 0)) ||
  10418f:	66 85 c0             	test   %ax,%ax
  104192:	66 89 4d ea          	mov    %cx,-0x16(%ebp)
  104196:	75 06                	jne    10419e <shell_op_cursor_word_move+0x6c>
  104198:	80 7d e9 00          	cmpb   $0x0,-0x17(%ebp)
  10419c:	75 3e                	jne    1041dc <shell_op_cursor_word_move+0xaa>
  10419e:	66 39 45 f0          	cmp    %ax,-0x10(%ebp)
  1041a2:	75 05                	jne    1041a9 <shell_op_cursor_word_move+0x77>
  1041a4:	66 85 f6             	test   %si,%si
  1041a7:	7f 33                	jg     1041dc <shell_op_cursor_word_move+0xaa>
		if (isalnum((int)str[idx]) != 0) {
  1041a9:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  1041ac:	0f b7 d0             	movzwl %ax,%edx
  1041af:	0f be 14 11          	movsbl (%ecx,%edx,1),%edx
	return (int)((((unsigned)c|32u)-(unsigned)'a') < 26U);
  1041b3:	88 d1                	mov    %dl,%cl
  1041b5:	83 c9 20             	or     $0x20,%ecx
  1041b8:	0f be c9             	movsbl %cl,%ecx
  1041bb:	83 e9 61             	sub    $0x61,%ecx
				(int)'z') ? (chr - 32) : (chr));
}

static inline int isalnum(int chr)
{
	return (int)(isalpha(chr) || isdigit(chr));
  1041be:	83 f9 19             	cmp    $0x19,%ecx
  1041c1:	76 10                	jbe    1041d3 <shell_op_cursor_word_move+0xa1>
	return (int)(((unsigned)(a)-(unsigned)'0') < 10U);
  1041c3:	83 ea 30             	sub    $0x30,%edx
	return (int)(isalpha(chr) || isdigit(chr));
  1041c6:	83 fa 09             	cmp    $0x9,%edx
  1041c9:	76 08                	jbe    1041d3 <shell_op_cursor_word_move+0xa1>
			if (found) {
  1041cb:	89 fa                	mov    %edi,%edx
  1041cd:	84 d2                	test   %dl,%dl
  1041cf:	74 07                	je     1041d8 <shell_op_cursor_word_move+0xa6>
  1041d1:	eb 09                	jmp    1041dc <shell_op_cursor_word_move+0xaa>
			found = true;
  1041d3:	bf 01 00 00 00       	mov    $0x1,%edi
		ret++;
  1041d8:	01 f0                	add    %esi,%eax
  1041da:	eb ad                	jmp    104189 <shell_op_cursor_word_move+0x57>
		shell_op_cursor_move(shell, sign * shift);
  1041dc:	0f bf 45 ea          	movswl -0x16(%ebp),%eax
  1041e0:	50                   	push   %eax
  1041e1:	ff 75 08             	pushl  0x8(%ebp)
  1041e4:	e8 c3 fe ff ff       	call   1040ac <shell_op_cursor_move>
  1041e9:	58                   	pop    %eax
  1041ea:	5a                   	pop    %edx
  1041eb:	e9 69 ff ff ff       	jmp    104159 <shell_op_cursor_word_move+0x27>
	}
}
  1041f0:	8d 65 f4             	lea    -0xc(%ebp),%esp
  1041f3:	5b                   	pop    %ebx
  1041f4:	5e                   	pop    %esi
  1041f5:	5f                   	pop    %edi
  1041f6:	5d                   	pop    %ebp
  1041f7:	c3                   	ret    

001041f8 <shell_op_cursor_home_move>:
	clear_eos(shell);
	cursor_restore(shell);
}

void shell_op_cursor_home_move(const struct shell *shell)
{
  1041f8:	55                   	push   %ebp
  1041f9:	89 e5                	mov    %esp,%ebp
  1041fb:	8b 55 08             	mov    0x8(%ebp),%edx
	shell_op_cursor_move(shell, -shell->ctx->cmd_buff_pos);
  1041fe:	8b 42 08             	mov    0x8(%edx),%eax
  104201:	66 8b 40 3e          	mov    0x3e(%eax),%ax
  104205:	f7 d8                	neg    %eax
  104207:	98                   	cwtl   
  104208:	50                   	push   %eax
  104209:	52                   	push   %edx
  10420a:	e8 9d fe ff ff       	call   1040ac <shell_op_cursor_move>
  10420f:	58                   	pop    %eax
  104210:	5a                   	pop    %edx
}
  104211:	c9                   	leave  
  104212:	c3                   	ret    

00104213 <shell_op_cursor_end_move>:

void shell_op_cursor_end_move(const struct shell *shell)
{
  104213:	55                   	push   %ebp
  104214:	89 e5                	mov    %esp,%ebp
  104216:	8b 55 08             	mov    0x8(%ebp),%edx
	shell_op_cursor_move(shell, shell->ctx->cmd_buff_len -
  104219:	8b 4a 08             	mov    0x8(%edx),%ecx
  10421c:	8b 41 3c             	mov    0x3c(%ecx),%eax
  10421f:	66 2b 41 3e          	sub    0x3e(%ecx),%ax
  104223:	98                   	cwtl   
  104224:	50                   	push   %eax
  104225:	52                   	push   %edx
  104226:	e8 81 fe ff ff       	call   1040ac <shell_op_cursor_move>
  10422b:	58                   	pop    %eax
  10422c:	5a                   	pop    %edx
						shell->ctx->cmd_buff_pos);
}
  10422d:	c9                   	leave  
  10422e:	c3                   	ret    

0010422f <shell_op_left_arrow>:


void shell_op_left_arrow(const struct shell *shell)
{
  10422f:	55                   	push   %ebp
  104230:	89 e5                	mov    %esp,%ebp
  104232:	8b 45 08             	mov    0x8(%ebp),%eax
	if (shell->ctx->cmd_buff_pos > 0) {
  104235:	8b 50 08             	mov    0x8(%eax),%edx
  104238:	66 83 7a 3e 00       	cmpw   $0x0,0x3e(%edx)
  10423d:	74 0a                	je     104249 <shell_op_left_arrow+0x1a>
		shell_op_cursor_move(shell, -1);
  10423f:	6a ff                	push   $0xffffffff
  104241:	50                   	push   %eax
  104242:	e8 65 fe ff ff       	call   1040ac <shell_op_cursor_move>
  104247:	58                   	pop    %eax
  104248:	5a                   	pop    %edx
	}
}
  104249:	c9                   	leave  
  10424a:	c3                   	ret    

0010424b <shell_op_right_arrow>:

void shell_op_right_arrow(const struct shell *shell)
{
  10424b:	55                   	push   %ebp
  10424c:	89 e5                	mov    %esp,%ebp
  10424e:	8b 45 08             	mov    0x8(%ebp),%eax
	if (shell->ctx->cmd_buff_pos < shell->ctx->cmd_buff_len) {
  104251:	8b 50 08             	mov    0x8(%eax),%edx
  104254:	8b 4a 3c             	mov    0x3c(%edx),%ecx
  104257:	66 39 4a 3e          	cmp    %cx,0x3e(%edx)
  10425b:	73 0a                	jae    104267 <shell_op_right_arrow+0x1c>
		shell_op_cursor_move(shell, 1);
  10425d:	6a 01                	push   $0x1
  10425f:	50                   	push   %eax
  104260:	e8 47 fe ff ff       	call   1040ac <shell_op_cursor_move>
  104265:	58                   	pop    %eax
  104266:	5a                   	pop    %edx
	}
}
  104267:	c9                   	leave  
  104268:	c3                   	ret    

00104269 <shell_op_delete_from_cursor>:
	--shell->ctx->cmd_buff_len;
	reprint_from_cursor(shell, --diff, true);
}

void shell_op_delete_from_cursor(const struct shell *shell)
{
  104269:	55                   	push   %ebp
  10426a:	89 e5                	mov    %esp,%ebp
  10426c:	8b 4d 08             	mov    0x8(%ebp),%ecx
	shell->ctx->cmd_buff_len = shell->ctx->cmd_buff_pos;
  10426f:	8b 51 08             	mov    0x8(%ecx),%edx
  104272:	0f b7 42 3e          	movzwl 0x3e(%edx),%eax
  104276:	66 89 42 3c          	mov    %ax,0x3c(%edx)
	shell->ctx->cmd_buff[shell->ctx->cmd_buff_pos] = '\0';
  10427a:	c6 44 02 42 00       	movb   $0x0,0x42(%edx,%eax,1)

	clear_eos(shell);
  10427f:	8b 41 14             	mov    0x14(%ecx),%eax
}
  104282:	5d                   	pop    %ebp
	clear_eos(shell);
  104283:	e9 8b fc ff ff       	jmp    103f13 <clear_eos.isra.5>

00104288 <shell_cmd_line_erase>:
{
	data_insert(shell, compl, compl_len);
}

void shell_cmd_line_erase(const struct shell *shell)
{
  104288:	55                   	push   %ebp
  104289:	89 e5                	mov    %esp,%ebp
  10428b:	53                   	push   %ebx
  10428c:	8b 5d 08             	mov    0x8(%ebp),%ebx
	shell_multiline_data_calc(&shell->ctx->vt100_ctx.cons,
				  shell->ctx->cmd_buff_pos,
				  shell->ctx->cmd_buff_len);
  10428f:	8b 43 08             	mov    0x8(%ebx),%eax
	shell_multiline_data_calc(&shell->ctx->vt100_ctx.cons,
  104292:	83 c0 20             	add    $0x20,%eax
  104295:	0f b7 50 1c          	movzwl 0x1c(%eax),%edx
  104299:	52                   	push   %edx
  10429a:	0f b7 50 1e          	movzwl 0x1e(%eax),%edx
  10429e:	52                   	push   %edx
  10429f:	50                   	push   %eax
  1042a0:	e8 fd f7 ff ff       	call   103aa2 <shell_multiline_data_calc>
	shell_op_cursor_horiz_move(shell,
				   -(shell->ctx->vt100_ctx.cons.cur_x - 1));
  1042a5:	8b 43 08             	mov    0x8(%ebx),%eax
	shell_multiline_data_calc(&shell->ctx->vt100_ctx.cons,
  1042a8:	83 c4 0c             	add    $0xc,%esp
				   -(shell->ctx->vt100_ctx.cons.cur_x - 1));
  1042ab:	0f b7 50 20          	movzwl 0x20(%eax),%edx
	shell_op_cursor_horiz_move(shell,
  1042af:	b8 01 00 00 00       	mov    $0x1,%eax
  1042b4:	29 d0                	sub    %edx,%eax
  1042b6:	50                   	push   %eax
  1042b7:	53                   	push   %ebx
  1042b8:	e8 d5 fc ff ff       	call   103f92 <shell_op_cursor_horiz_move>
  1042bd:	58                   	pop    %eax
	shell_op_cursor_vert_move(shell, shell->ctx->vt100_ctx.cons.cur_y - 1);
  1042be:	8b 43 08             	mov    0x8(%ebx),%eax
	shell_op_cursor_horiz_move(shell,
  1042c1:	5a                   	pop    %edx
	shell_op_cursor_vert_move(shell, shell->ctx->vt100_ctx.cons.cur_y - 1);
  1042c2:	0f b7 40 24          	movzwl 0x24(%eax),%eax
  1042c6:	48                   	dec    %eax
  1042c7:	50                   	push   %eax
  1042c8:	53                   	push   %ebx
  1042c9:	e8 95 fc ff ff       	call   103f63 <shell_op_cursor_vert_move>
  1042ce:	59                   	pop    %ecx
  1042cf:	58                   	pop    %eax

	clear_eos(shell);
  1042d0:	8b 43 14             	mov    0x14(%ebx),%eax
}
  1042d3:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  1042d6:	c9                   	leave  
	clear_eos(shell);
  1042d7:	e9 37 fc ff ff       	jmp    103f13 <clear_eos.isra.5>

001042dc <shell_print_cmd>:
{
	shell_internal_fprintf(shell, SHELL_INFO, "%s", shell->ctx->prompt);
}

void shell_print_cmd(const struct shell *shell)
{
  1042dc:	55                   	push   %ebp
  1042dd:	89 e5                	mov    %esp,%ebp
  1042df:	8b 55 08             	mov    0x8(%ebp),%edx
	shell_raw_fprintf(shell->fprintf_ctx, "%s", shell->ctx->cmd_buff);
  1042e2:	8b 42 08             	mov    0x8(%edx),%eax
  1042e5:	83 c0 42             	add    $0x42,%eax
  1042e8:	50                   	push   %eax
  1042e9:	68 7b e4 10 00       	push   $0x10e47b
  1042ee:	ff 72 14             	pushl  0x14(%edx)
  1042f1:	e8 06 fc ff ff       	call   103efc <shell_raw_fprintf>
  1042f6:	83 c4 0c             	add    $0xc,%esp
}
  1042f9:	c9                   	leave  
  1042fa:	c3                   	ret    

001042fb <shell_write>:
	}
}

void shell_write(const struct shell *shell, const void *data,
		 size_t length)
{
  1042fb:	55                   	push   %ebp
  1042fc:	89 e5                	mov    %esp,%ebp
  1042fe:	57                   	push   %edi
  1042ff:	56                   	push   %esi
	__ASSERT_NO_MSG(shell && data);

	size_t offset = 0;
  104300:	31 f6                	xor    %esi,%esi
{
  104302:	53                   	push   %ebx
  104303:	50                   	push   %eax
  104304:	8b 7d 08             	mov    0x8(%ebp),%edi
  104307:	8b 5d 10             	mov    0x10(%ebp),%ebx
	size_t tmp_cnt;

	while (length) {
  10430a:	85 db                	test   %ebx,%ebx
  10430c:	74 71                	je     10437f <shell_write+0x84>
		int err = shell->iface->api->write(shell->iface,
  10430e:	8b 47 04             	mov    0x4(%edi),%eax
  104311:	8d 4d f0             	lea    -0x10(%ebp),%ecx
  104314:	8b 10                	mov    (%eax),%edx
  104316:	51                   	push   %ecx
  104317:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  10431a:	53                   	push   %ebx
  10431b:	01 f1                	add    %esi,%ecx
  10431d:	51                   	push   %ecx
  10431e:	50                   	push   %eax
  10431f:	ff 52 0c             	call   *0xc(%edx)
				&((const u8_t *) data)[offset], length,
				&tmp_cnt);
		(void)err;
		__ASSERT_NO_MSG(err == 0);
		__ASSERT_NO_MSG(length >= tmp_cnt);
		offset += tmp_cnt;
  104322:	8b 45 f0             	mov    -0x10(%ebp),%eax
		int err = shell->iface->api->write(shell->iface,
  104325:	83 c4 10             	add    $0x10,%esp
		offset += tmp_cnt;
  104328:	01 c6                	add    %eax,%esi
		length -= tmp_cnt;
  10432a:	29 c3                	sub    %eax,%ebx
		if (tmp_cnt == 0 &&
  10432c:	85 c0                	test   %eax,%eax
  10432e:	75 da                	jne    10430a <shell_write+0xf>
		    (shell->ctx->state != SHELL_STATE_PANIC_MODE_ACTIVE)) {
  104330:	8b 47 08             	mov    0x8(%edi),%eax
  104333:	8b 50 04             	mov    0x4(%eax),%edx
		if (tmp_cnt == 0 &&
  104336:	83 fa 03             	cmp    $0x3,%edx
  104339:	74 cf                	je     10430a <shell_write+0xf>
	if (IS_ENABLED(CONFIG_MULTITHREADING) &&
  10433b:	83 fa 02             	cmp    $0x2,%edx
  10433e:	77 21                	ja     104361 <shell_write+0x66>
K_SYSCALL_DECLARE3(K_SYSCALL_K_POLL, k_poll, int, struct k_poll_event *, events, int, num_events, s32_t, timeout)
  104340:	6a ff                	push   $0xffffffff
		k_poll(&shell->ctx->events[SHELL_SIGNAL_TXDONE], 1, K_FOREVER);
  104342:	05 e0 02 00 00       	add    $0x2e0,%eax
  104347:	6a 01                	push   $0x1
  104349:	50                   	push   %eax
  10434a:	e8 5e 72 00 00       	call   10b5ad <z_impl_k_poll>
  10434f:	8b 47 08             	mov    0x8(%edi),%eax
  104352:	83 c4 0c             	add    $0xc,%esp
  104355:	c7 80 9c 02 00 00 00 	movl   $0x0,0x29c(%eax)
  10435c:	00 00 00 
  10435f:	eb a9                	jmp    10430a <shell_write+0xf>
	return shell->ctx->internal.flags.tx_rdy == 1 ? true : false;
  104361:	8b 90 60 02 00 00    	mov    0x260(%eax),%edx
		while (!flag_tx_rdy_get(shell)) {
  104367:	80 e2 10             	and    $0x10,%dl
  10436a:	74 f5                	je     104361 <shell_write+0x66>
	shell->ctx->internal.flags.tx_rdy = val ? 1 : 0;
  10436c:	66 8b 90 60 02 00 00 	mov    0x260(%eax),%dx
  104373:	83 e2 ef             	and    $0xffffffef,%edx
  104376:	66 89 90 60 02 00 00 	mov    %dx,0x260(%eax)
  10437d:	eb 8b                	jmp    10430a <shell_write+0xf>
			shell_pend_on_txdone(shell);
		}
	}
}
  10437f:	8d 65 f4             	lea    -0xc(%ebp),%esp
  104382:	5b                   	pop    %ebx
  104383:	5e                   	pop    %esi
  104384:	5f                   	pop    %edi
  104385:	5d                   	pop    %ebp
  104386:	c3                   	ret    

00104387 <shell_print_stream>:

/* Function shall be only used by the fprintf module. */
void shell_print_stream(const void *user_ctx, const char *data,
			size_t data_len)
{
	shell_write((const struct shell *) user_ctx, data, data_len);
  104387:	e9 6f ff ff ff       	jmp    1042fb <shell_write>

0010438c <shell_vt100_color_set>:

}

void shell_vt100_color_set(const struct shell *shell,
			   enum shell_vt100_color color)
{
  10438c:	55                   	push   %ebp
  10438d:	89 e5                	mov    %esp,%ebp
  10438f:	83 ec 08             	sub    $0x8,%esp
  104392:	8b 55 08             	mov    0x8(%ebp),%edx
  104395:	8b 45 0c             	mov    0xc(%ebp),%eax

	if (shell->ctx->vt100_ctx.col.col == color) {
  104398:	8b 4a 08             	mov    0x8(%edx),%ecx
  10439b:	39 41 30             	cmp    %eax,0x30(%ecx)
  10439e:	74 3a                	je     1043da <shell_vt100_color_set+0x4e>
		return;
	}

	shell->ctx->vt100_ctx.col.col = color;
  1043a0:	89 41 30             	mov    %eax,0x30(%ecx)

	if (color != SHELL_NORMAL) {
  1043a3:	8b 52 14             	mov    0x14(%edx),%edx
  1043a6:	85 c0                	test   %eax,%eax
  1043a8:	74 1d                	je     1043c7 <shell_vt100_color_set+0x3b>

		u8_t cmd[] = SHELL_VT100_COLOR(color - 1);
  1043aa:	83 c0 2f             	add    $0x2f,%eax
  1043ad:	c7 45 f8 1b 5b 31 3b 	movl   $0x3b315b1b,-0x8(%ebp)
  1043b4:	88 45 fd             	mov    %al,-0x3(%ebp)

		shell_raw_fprintf(shell->fprintf_ctx, "%s", cmd);
  1043b7:	8d 45 f8             	lea    -0x8(%ebp),%eax
		u8_t cmd[] = SHELL_VT100_COLOR(color - 1);
  1043ba:	c6 45 fc 33          	movb   $0x33,-0x4(%ebp)
  1043be:	66 c7 45 fe 6d 00    	movw   $0x6d,-0x2(%ebp)
		shell_raw_fprintf(shell->fprintf_ctx, "%s", cmd);
  1043c4:	50                   	push   %eax
  1043c5:	eb 05                	jmp    1043cc <shell_vt100_color_set+0x40>
	} else {
		static const u8_t cmd[] = SHELL_VT100_MODESOFF;

		shell_raw_fprintf(shell->fprintf_ctx, "%s", cmd);
  1043c7:	68 7c db 10 00       	push   $0x10db7c
  1043cc:	68 7b e4 10 00       	push   $0x10e47b
  1043d1:	52                   	push   %edx
  1043d2:	e8 25 fb ff ff       	call   103efc <shell_raw_fprintf>
  1043d7:	83 c4 0c             	add    $0xc,%esp
	}
}
  1043da:	c9                   	leave  
  1043db:	c3                   	ret    

001043dc <shell_vt100_colors_restore>:

void shell_vt100_colors_restore(const struct shell *shell,
				       const struct shell_vt100_colors *color)
{
  1043dc:	55                   	push   %ebp
  1043dd:	89 e5                	mov    %esp,%ebp
  1043df:	56                   	push   %esi
  1043e0:	53                   	push   %ebx
  1043e1:	83 ec 08             	sub    $0x8,%esp
  1043e4:	8b 75 0c             	mov    0xc(%ebp),%esi
  1043e7:	8b 5d 08             	mov    0x8(%ebp),%ebx
	shell_vt100_color_set(shell, color->col);
  1043ea:	ff 36                	pushl  (%esi)
  1043ec:	53                   	push   %ebx
  1043ed:	e8 9a ff ff ff       	call   10438c <shell_vt100_color_set>
  1043f2:	5a                   	pop    %edx
	vt100_bgcolor_set(shell, color->bgcol);
  1043f3:	8b 46 04             	mov    0x4(%esi),%eax
	shell_vt100_color_set(shell, color->col);
  1043f6:	59                   	pop    %ecx
	if ((bgcolor == SHELL_NORMAL) ||
  1043f7:	85 c0                	test   %eax,%eax
  1043f9:	74 35                	je     104430 <shell_vt100_colors_restore+0x54>
	    (shell->ctx->vt100_ctx.col.bgcol == bgcolor)) {
  1043fb:	8b 53 08             	mov    0x8(%ebx),%edx
	if ((bgcolor == SHELL_NORMAL) ||
  1043fe:	3b 42 34             	cmp    0x34(%edx),%eax
  104401:	74 2d                	je     104430 <shell_vt100_colors_restore+0x54>
	shell->ctx->vt100_ctx.col.bgcol = bgcolor;
  104403:	89 42 34             	mov    %eax,0x34(%edx)
	u8_t cmd[] = SHELL_VT100_BGCOLOR(bgcolor - 1);
  104406:	8d 48 2f             	lea    0x2f(%eax),%ecx
	shell_raw_fprintf(shell->fprintf_ctx, "%s", cmd);
  104409:	8d 45 f2             	lea    -0xe(%ebp),%eax
	u8_t cmd[] = SHELL_VT100_BGCOLOR(bgcolor - 1);
  10440c:	66 c7 45 f2 1b 5b    	movw   $0x5b1b,-0xe(%ebp)
	shell_raw_fprintf(shell->fprintf_ctx, "%s", cmd);
  104412:	50                   	push   %eax
	u8_t cmd[] = SHELL_VT100_BGCOLOR(bgcolor - 1);
  104413:	c6 45 f4 34          	movb   $0x34,-0xc(%ebp)
	shell_raw_fprintf(shell->fprintf_ctx, "%s", cmd);
  104417:	68 7b e4 10 00       	push   $0x10e47b
	u8_t cmd[] = SHELL_VT100_BGCOLOR(bgcolor - 1);
  10441c:	88 4d f5             	mov    %cl,-0xb(%ebp)
	shell_raw_fprintf(shell->fprintf_ctx, "%s", cmd);
  10441f:	ff 73 14             	pushl  0x14(%ebx)
	u8_t cmd[] = SHELL_VT100_BGCOLOR(bgcolor - 1);
  104422:	66 c7 45 f6 6d 00    	movw   $0x6d,-0xa(%ebp)
	shell_raw_fprintf(shell->fprintf_ctx, "%s", cmd);
  104428:	e8 cf fa ff ff       	call   103efc <shell_raw_fprintf>
  10442d:	83 c4 0c             	add    $0xc,%esp
}
  104430:	8d 65 f8             	lea    -0x8(%ebp),%esp
  104433:	5b                   	pop    %ebx
  104434:	5e                   	pop    %esi
  104435:	5d                   	pop    %ebp
  104436:	c3                   	ret    

00104437 <shell_internal_vfprintf>:

void shell_internal_vfprintf(const struct shell *shell,
			     enum shell_vt100_color color, const char *fmt,
			     va_list args)
{
  104437:	55                   	push   %ebp
  104438:	89 e5                	mov    %esp,%ebp
  10443a:	57                   	push   %edi
  10443b:	56                   	push   %esi
  10443c:	53                   	push   %ebx
  10443d:	83 ec 08             	sub    $0x8,%esp
  104440:	8b 5d 08             	mov    0x8(%ebp),%ebx
  104443:	8b 7d 0c             	mov    0xc(%ebp),%edi
	if (IS_ENABLED(CONFIG_SHELL_VT100_COLORS) &&
	    shell->ctx->internal.flags.use_colors &&
  104446:	8b 43 08             	mov    0x8(%ebx),%eax
  104449:	8b 90 60 02 00 00    	mov    0x260(%eax),%edx
	if (IS_ENABLED(CONFIG_SHELL_VT100_COLORS) &&
  10444f:	80 e2 02             	and    $0x2,%dl
  104452:	74 3c                	je     104490 <shell_internal_vfprintf+0x59>
	    shell->ctx->internal.flags.use_colors &&
  104454:	39 78 30             	cmp    %edi,0x30(%eax)
  104457:	74 37                	je     104490 <shell_internal_vfprintf+0x59>
			   enum shell_vt100_color color);

static inline void shell_vt100_colors_store(const struct shell *shell,
					    struct shell_vt100_colors *color)
{
	memcpy(color, &shell->ctx->vt100_ctx.col, sizeof(*color));
  104459:	6a 08                	push   $0x8
  10445b:	83 c0 30             	add    $0x30,%eax
  10445e:	50                   	push   %eax
  10445f:	8d 75 ec             	lea    -0x14(%ebp),%esi
  104462:	56                   	push   %esi
  104463:	e8 aa 29 00 00       	call   106e12 <memcpy>
  104468:	83 c4 0c             	add    $0xc,%esp
	    (color != shell->ctx->vt100_ctx.col.col)) {
		struct shell_vt100_colors col;

		shell_vt100_colors_store(shell, &col);
		shell_vt100_color_set(shell, color);
  10446b:	57                   	push   %edi
  10446c:	53                   	push   %ebx
  10446d:	e8 1a ff ff ff       	call   10438c <shell_vt100_color_set>
  104472:	58                   	pop    %eax
  104473:	5a                   	pop    %edx

		shell_fprintf_fmt(shell->fprintf_ctx, fmt, args);
  104474:	ff 75 14             	pushl  0x14(%ebp)
  104477:	ff 75 10             	pushl  0x10(%ebp)
  10447a:	ff 73 14             	pushl  0x14(%ebx)
  10447d:	e8 34 f5 ff ff       	call   1039b6 <shell_fprintf_fmt>
  104482:	83 c4 0c             	add    $0xc,%esp

		shell_vt100_colors_restore(shell, &col);
  104485:	56                   	push   %esi
  104486:	53                   	push   %ebx
  104487:	e8 50 ff ff ff       	call   1043dc <shell_vt100_colors_restore>
  10448c:	59                   	pop    %ecx
  10448d:	5b                   	pop    %ebx
	    (color != shell->ctx->vt100_ctx.col.col)) {
  10448e:	eb 11                	jmp    1044a1 <shell_internal_vfprintf+0x6a>
	} else {
		shell_fprintf_fmt(shell->fprintf_ctx, fmt, args);
  104490:	ff 75 14             	pushl  0x14(%ebp)
  104493:	ff 75 10             	pushl  0x10(%ebp)
  104496:	ff 73 14             	pushl  0x14(%ebx)
  104499:	e8 18 f5 ff ff       	call   1039b6 <shell_fprintf_fmt>
  10449e:	83 c4 0c             	add    $0xc,%esp
	}
}
  1044a1:	8d 65 f4             	lea    -0xc(%ebp),%esp
  1044a4:	5b                   	pop    %ebx
  1044a5:	5e                   	pop    %esi
  1044a6:	5f                   	pop    %edi
  1044a7:	5d                   	pop    %ebp
  1044a8:	c3                   	ret    

001044a9 <shell_internal_fprintf>:

void shell_internal_fprintf(const struct shell *shell,
			    enum shell_vt100_color color,
			    const char *fmt, ...)
{
  1044a9:	55                   	push   %ebp
  1044aa:	89 e5                	mov    %esp,%ebp
	__ASSERT_NO_MSG(shell->fprintf_ctx);
	__ASSERT_NO_MSG(fmt);

	va_list args = { 0 };

	va_start(args, fmt);
  1044ac:	8d 45 14             	lea    0x14(%ebp),%eax
	shell_internal_vfprintf(shell, color, fmt, args);
  1044af:	50                   	push   %eax
  1044b0:	ff 75 10             	pushl  0x10(%ebp)
  1044b3:	ff 75 0c             	pushl  0xc(%ebp)
  1044b6:	ff 75 08             	pushl  0x8(%ebp)
  1044b9:	e8 79 ff ff ff       	call   104437 <shell_internal_vfprintf>
  1044be:	83 c4 10             	add    $0x10,%esp
	va_end(args);
}
  1044c1:	c9                   	leave  
  1044c2:	c3                   	ret    

001044c3 <shell_op_word_remove>:
{
  1044c3:	55                   	push   %ebp
  1044c4:	89 e5                	mov    %esp,%ebp
  1044c6:	57                   	push   %edi
  1044c7:	56                   	push   %esi
  1044c8:	8b 75 08             	mov    0x8(%ebp),%esi
  1044cb:	53                   	push   %ebx
	char *str = &shell->ctx->cmd_buff[shell->ctx->cmd_buff_pos - 1];
  1044cc:	8b 46 08             	mov    0x8(%esi),%eax
  1044cf:	0f b7 48 3e          	movzwl 0x3e(%eax),%ecx
	if ((shell->ctx->cmd_buff_len == 0) ||
  1044d3:	0f b7 50 3c          	movzwl 0x3c(%eax),%edx
  1044d7:	66 85 c9             	test   %cx,%cx
  1044da:	0f 84 a9 00 00 00    	je     104589 <shell_op_word_remove+0xc6>
  1044e0:	66 85 d2             	test   %dx,%dx
  1044e3:	0f 84 a0 00 00 00    	je     104589 <shell_op_word_remove+0xc6>
	char *str = &shell->ctx->cmd_buff[shell->ctx->cmd_buff_pos - 1];
  1044e9:	8d 4c 08 41          	lea    0x41(%eax,%ecx,1),%ecx
	char *str_start = &shell->ctx->cmd_buff[0];
  1044ed:	8d 78 42             	lea    0x42(%eax),%edi
	char *str = &shell->ctx->cmd_buff[shell->ctx->cmd_buff_pos - 1];
  1044f0:	89 c8                	mov    %ecx,%eax
  1044f2:	89 cb                	mov    %ecx,%ebx
  1044f4:	29 c3                	sub    %eax,%ebx
	while ((str >= str_start) && (*str == ' ')) {
  1044f6:	39 f8                	cmp    %edi,%eax
  1044f8:	72 13                	jb     10450d <shell_op_word_remove+0x4a>
  1044fa:	80 38 20             	cmpb   $0x20,(%eax)
  1044fd:	75 09                	jne    104508 <shell_op_word_remove+0x45>
		--str;
  1044ff:	48                   	dec    %eax
  104500:	eb f0                	jmp    1044f2 <shell_op_word_remove+0x2f>
		--str;
  104502:	48                   	dec    %eax
		++chars_to_delete;
  104503:	43                   	inc    %ebx
	while ((str >= str_start) && (*str != ' ')) {
  104504:	39 c7                	cmp    %eax,%edi
  104506:	77 05                	ja     10450d <shell_op_word_remove+0x4a>
  104508:	80 38 20             	cmpb   $0x20,(%eax)
  10450b:	75 f5                	jne    104502 <shell_op_word_remove+0x3f>
		shell->ctx->cmd_buff_len - chars_to_delete);
  10450d:	0f b7 cb             	movzwl %bx,%ecx
  104510:	29 ca                	sub    %ecx,%edx
	memmove(str + 1, str + 1 + chars_to_delete,
  104512:	8d 78 01             	lea    0x1(%eax),%edi
  104515:	52                   	push   %edx
  104516:	8d 44 08 01          	lea    0x1(%eax,%ecx,1),%eax
  10451a:	50                   	push   %eax
  10451b:	57                   	push   %edi
  10451c:	e8 b8 28 00 00       	call   106dd9 <memmove>
	shell->ctx->cmd_buff_len -= chars_to_delete;
  104521:	8b 56 08             	mov    0x8(%esi),%edx
	memmove(str + 1, str + 1 + chars_to_delete,
  104524:	83 c4 0c             	add    $0xc,%esp
	shell->ctx->cmd_buff_len -= chars_to_delete;
  104527:	8b 42 3c             	mov    0x3c(%edx),%eax
  10452a:	29 d8                	sub    %ebx,%eax
  10452c:	66 89 42 3c          	mov    %ax,0x3c(%edx)
	shell_op_cursor_move(shell, -chars_to_delete);
  104530:	f7 db                	neg    %ebx
	shell->ctx->cmd_buff[shell->ctx->cmd_buff_len] = '\0';
  104532:	0f b7 c0             	movzwl %ax,%eax
	shell_op_cursor_move(shell, -chars_to_delete);
  104535:	0f bf db             	movswl %bx,%ebx
	shell->ctx->cmd_buff[shell->ctx->cmd_buff_len] = '\0';
  104538:	c6 44 02 42 00       	movb   $0x0,0x42(%edx,%eax,1)
	shell_op_cursor_move(shell, -chars_to_delete);
  10453d:	53                   	push   %ebx
  10453e:	56                   	push   %esi
  10453f:	e8 68 fb ff ff       	call   1040ac <shell_op_cursor_move>
  104544:	58                   	pop    %eax
  104545:	5a                   	pop    %edx
	SHELL_VT100_CMD(shell, SHELL_VT100_SAVECURSOR);
  104546:	68 a2 e4 10 00       	push   $0x10e4a2
  10454b:	68 7b e4 10 00       	push   $0x10e47b
  104550:	ff 76 14             	pushl  0x14(%esi)
  104553:	e8 a4 f9 ff ff       	call   103efc <shell_raw_fprintf>
  104558:	83 c4 0c             	add    $0xc,%esp
	shell_internal_fprintf(shell, SHELL_NORMAL, "%s", str + 1);
  10455b:	57                   	push   %edi
  10455c:	68 7b e4 10 00       	push   $0x10e47b
  104561:	6a 00                	push   $0x0
  104563:	56                   	push   %esi
  104564:	e8 40 ff ff ff       	call   1044a9 <shell_internal_fprintf>
  104569:	83 c4 10             	add    $0x10,%esp
	clear_eos(shell);
  10456c:	8b 46 14             	mov    0x14(%esi),%eax
  10456f:	e8 9f f9 ff ff       	call   103f13 <clear_eos.isra.5>
	SHELL_VT100_CMD(shell, SHELL_VT100_RESTORECURSOR);
  104574:	68 9f e4 10 00       	push   $0x10e49f
  104579:	68 7b e4 10 00       	push   $0x10e47b
  10457e:	ff 76 14             	pushl  0x14(%esi)
  104581:	e8 76 f9 ff ff       	call   103efc <shell_raw_fprintf>
  104586:	83 c4 0c             	add    $0xc,%esp
}
  104589:	8d 65 f4             	lea    -0xc(%ebp),%esp
  10458c:	5b                   	pop    %ebx
  10458d:	5e                   	pop    %esi
  10458e:	5f                   	pop    %edi
  10458f:	5d                   	pop    %ebp
  104590:	c3                   	ret    

00104591 <reprint_from_cursor>:
{
  104591:	55                   	push   %ebp
	if (data_removed) {
  104592:	84 c9                	test   %cl,%cl
{
  104594:	89 e5                	mov    %esp,%ebp
  104596:	57                   	push   %edi
  104597:	56                   	push   %esi
  104598:	89 cf                	mov    %ecx,%edi
  10459a:	53                   	push   %ebx
  10459b:	89 d6                	mov    %edx,%esi
  10459d:	89 c3                	mov    %eax,%ebx
	if (data_removed) {
  10459f:	74 08                	je     1045a9 <reprint_from_cursor+0x18>
		clear_eos(shell);
  1045a1:	8b 40 14             	mov    0x14(%eax),%eax
  1045a4:	e8 6a f9 ff ff       	call   103f13 <clear_eos.isra.5>
		      &shell->ctx->cmd_buff[shell->ctx->cmd_buff_pos]);
  1045a9:	8b 43 08             	mov    0x8(%ebx),%eax
	shell_internal_fprintf(shell, SHELL_NORMAL, "%s",
  1045ac:	0f b7 50 3e          	movzwl 0x3e(%eax),%edx
  1045b0:	8d 44 10 42          	lea    0x42(%eax,%edx,1),%eax
  1045b4:	50                   	push   %eax
  1045b5:	68 7b e4 10 00       	push   $0x10e47b
  1045ba:	6a 00                	push   $0x0
  1045bc:	53                   	push   %ebx
  1045bd:	e8 e7 fe ff ff       	call   1044a9 <shell_internal_fprintf>
	shell->ctx->cmd_buff_pos = shell->ctx->cmd_buff_len;
  1045c2:	8b 43 08             	mov    0x8(%ebx),%eax
	shell_internal_fprintf(shell, SHELL_NORMAL, "%s",
  1045c5:	83 c4 10             	add    $0x10,%esp
	shell->ctx->cmd_buff_pos = shell->ctx->cmd_buff_len;
  1045c8:	8b 50 3c             	mov    0x3c(%eax),%edx
  1045cb:	66 89 50 3e          	mov    %dx,0x3e(%eax)
	if (full_line_cmd(shell)) {
  1045cf:	8d 43 08             	lea    0x8(%ebx),%eax
  1045d2:	e8 54 f9 ff ff       	call   103f2b <full_line_cmd.isra.7>
  1045d7:	84 c0                	test   %al,%al
  1045d9:	74 1a                	je     1045f5 <reprint_from_cursor+0x64>
		if (((data_removed) && (diff > 0)) || (!data_removed)) {
  1045db:	66 85 f6             	test   %si,%si
  1045de:	75 06                	jne    1045e6 <reprint_from_cursor+0x55>
  1045e0:	89 f8                	mov    %edi,%eax
  1045e2:	84 c0                	test   %al,%al
  1045e4:	75 0f                	jne    1045f5 <reprint_from_cursor+0x64>
	shell_raw_fprintf(shell->fprintf_ctx, "\n");
  1045e6:	68 7f e4 10 00       	push   $0x10e47f
  1045eb:	ff 73 14             	pushl  0x14(%ebx)
  1045ee:	e8 09 f9 ff ff       	call   103efc <shell_raw_fprintf>
  1045f3:	59                   	pop    %ecx
  1045f4:	5f                   	pop    %edi
	shell_op_cursor_move(shell, -diff);
  1045f5:	f7 de                	neg    %esi
  1045f7:	0f bf f6             	movswl %si,%esi
  1045fa:	56                   	push   %esi
  1045fb:	53                   	push   %ebx
  1045fc:	e8 ab fa ff ff       	call   1040ac <shell_op_cursor_move>
  104601:	58                   	pop    %eax
  104602:	5a                   	pop    %edx
}
  104603:	8d 65 f4             	lea    -0xc(%ebp),%esp
  104606:	5b                   	pop    %ebx
  104607:	5e                   	pop    %esi
  104608:	5f                   	pop    %edi
  104609:	5d                   	pop    %ebp
  10460a:	c3                   	ret    

0010460b <data_insert>:
{
  10460b:	55                   	push   %ebp
  10460c:	89 e5                	mov    %esp,%ebp
  10460e:	57                   	push   %edi
  10460f:	56                   	push   %esi
  104610:	53                   	push   %ebx
  104611:	83 ec 0c             	sub    $0xc,%esp
  104614:	89 55 ec             	mov    %edx,-0x14(%ebp)
	u16_t after = shell->ctx->cmd_buff_len - shell->ctx->cmd_buff_pos;
  104617:	8b 70 08             	mov    0x8(%eax),%esi
	if ((shell->ctx->cmd_buff_len + len) >= CONFIG_SHELL_CMD_BUFF_SIZE) {
  10461a:	0f b7 d1             	movzwl %cx,%edx
	u16_t after = shell->ctx->cmd_buff_len - shell->ctx->cmd_buff_pos;
  10461d:	0f b7 5e 3c          	movzwl 0x3c(%esi),%ebx
  104621:	89 df                	mov    %ebx,%edi
	if ((shell->ctx->cmd_buff_len + len) >= CONFIG_SHELL_CMD_BUFF_SIZE) {
  104623:	01 d3                	add    %edx,%ebx
  104625:	89 55 f0             	mov    %edx,-0x10(%ebp)
  104628:	81 fb ff 00 00 00    	cmp    $0xff,%ebx
  10462e:	7f 6f                	jg     10469f <data_insert+0x94>
  104630:	89 c3                	mov    %eax,%ebx
  104632:	89 4d e8             	mov    %ecx,-0x18(%ebp)
	u16_t after = shell->ctx->cmd_buff_len - shell->ctx->cmd_buff_pos;
  104635:	0f b7 46 3e          	movzwl 0x3e(%esi),%eax
  104639:	29 c7                	sub    %eax,%edi
	memmove(curr_pos + len, curr_pos, after);
  10463b:	0f b7 ff             	movzwl %di,%edi
	char *curr_pos = &shell->ctx->cmd_buff[shell->ctx->cmd_buff_pos];
  10463e:	8d 74 06 42          	lea    0x42(%esi,%eax,1),%esi
	memmove(curr_pos + len, curr_pos, after);
  104642:	57                   	push   %edi
  104643:	8b 45 f0             	mov    -0x10(%ebp),%eax
  104646:	56                   	push   %esi
  104647:	01 f0                	add    %esi,%eax
  104649:	50                   	push   %eax
  10464a:	e8 8a 27 00 00       	call   106dd9 <memmove>
  10464f:	83 c4 0c             	add    $0xc,%esp
	memcpy(curr_pos, data, len);
  104652:	8b 55 ec             	mov    -0x14(%ebp),%edx
  104655:	ff 75 f0             	pushl  -0x10(%ebp)
  104658:	52                   	push   %edx
  104659:	56                   	push   %esi
  10465a:	e8 b3 27 00 00       	call   106e12 <memcpy>
	shell->ctx->cmd_buff_len += len;
  10465f:	8b 53 08             	mov    0x8(%ebx),%edx
  104662:	8b 4d e8             	mov    -0x18(%ebp),%ecx
  104665:	89 c8                	mov    %ecx,%eax
	memcpy(curr_pos, data, len);
  104667:	83 c4 0c             	add    $0xc,%esp
	shell->ctx->cmd_buff_len += len;
  10466a:	03 42 3c             	add    0x3c(%edx),%eax
  10466d:	66 89 42 3c          	mov    %ax,0x3c(%edx)
	shell->ctx->cmd_buff[shell->ctx->cmd_buff_len] = '\0';
  104671:	0f b7 c0             	movzwl %ax,%eax
  104674:	c6 44 02 42 00       	movb   $0x0,0x42(%edx,%eax,1)
	if (!flag_echo_get(shell)) {
  104679:	8b 43 08             	mov    0x8(%ebx),%eax
	return shell->ctx->internal.flags.echo == 1 ? true : false;
  10467c:	8b 90 60 02 00 00    	mov    0x260(%eax),%edx
  104682:	80 e2 04             	and    $0x4,%dl
  104685:	75 06                	jne    10468d <data_insert+0x82>
		shell->ctx->cmd_buff_pos += len;
  104687:	66 01 48 3e          	add    %cx,0x3e(%eax)
		return;
  10468b:	eb 12                	jmp    10469f <data_insert+0x94>
}
  10468d:	8d 65 f4             	lea    -0xc(%ebp),%esp
	reprint_from_cursor(shell, after, false);
  104690:	89 d8                	mov    %ebx,%eax
  104692:	89 fa                	mov    %edi,%edx
  104694:	31 c9                	xor    %ecx,%ecx
}
  104696:	5b                   	pop    %ebx
  104697:	5e                   	pop    %esi
  104698:	5f                   	pop    %edi
  104699:	5d                   	pop    %ebp
	reprint_from_cursor(shell, after, false);
  10469a:	e9 f2 fe ff ff       	jmp    104591 <reprint_from_cursor>
}
  10469f:	8d 65 f4             	lea    -0xc(%ebp),%esp
  1046a2:	5b                   	pop    %ebx
  1046a3:	5e                   	pop    %esi
  1046a4:	5f                   	pop    %edi
  1046a5:	5d                   	pop    %ebp
  1046a6:	c3                   	ret    

001046a7 <shell_op_char_insert>:
{
  1046a7:	55                   	push   %ebp
  1046a8:	89 e5                	mov    %esp,%ebp
  1046aa:	56                   	push   %esi
  1046ab:	53                   	push   %ebx
  1046ac:	53                   	push   %ebx
  1046ad:	8b 5d 08             	mov    0x8(%ebp),%ebx
  1046b0:	8b 45 0c             	mov    0xc(%ebp),%eax
  1046b3:	88 45 f4             	mov    %al,-0xc(%ebp)
	if (shell->ctx->internal.flags.insert_mode &&
  1046b6:	8b 4b 08             	mov    0x8(%ebx),%ecx
  1046b9:	8b 91 60 02 00 00    	mov    0x260(%ecx),%edx
  1046bf:	80 e2 01             	and    $0x1,%dl
  1046c2:	74 53                	je     104717 <shell_op_char_insert+0x70>
		(shell->ctx->cmd_buff_len != shell->ctx->cmd_buff_pos)) {
  1046c4:	0f b7 51 3e          	movzwl 0x3e(%ecx),%edx
	if (shell->ctx->internal.flags.insert_mode &&
  1046c8:	66 39 51 3c          	cmp    %dx,0x3c(%ecx)
  1046cc:	74 49                	je     104717 <shell_op_char_insert+0x70>
	shell->ctx->cmd_buff[shell->ctx->cmd_buff_pos++] = data;
  1046ce:	8d 72 01             	lea    0x1(%edx),%esi
  1046d1:	66 89 71 3e          	mov    %si,0x3e(%ecx)
  1046d5:	88 44 11 42          	mov    %al,0x42(%ecx,%edx,1)
	if (!flag_echo_get(shell)) {
  1046d9:	8b 53 08             	mov    0x8(%ebx),%edx
  1046dc:	8b 92 60 02 00 00    	mov    0x260(%edx),%edx
  1046e2:	80 e2 04             	and    $0x4,%dl
  1046e5:	74 3f                	je     104726 <shell_op_char_insert+0x7f>
		char_replace(shell, data);
  1046e7:	0f be c0             	movsbl %al,%eax
	shell_raw_fprintf(shell->fprintf_ctx, "%c", data);
  1046ea:	50                   	push   %eax
  1046eb:	68 9c e4 10 00       	push   $0x10e49c
  1046f0:	ff 73 14             	pushl  0x14(%ebx)
  1046f3:	e8 04 f8 ff ff       	call   103efc <shell_raw_fprintf>
  1046f8:	83 c4 0c             	add    $0xc,%esp
	if (shell_cursor_in_empty_line(shell)) {
  1046fb:	53                   	push   %ebx
  1046fc:	e8 c0 f8 ff ff       	call   103fc1 <shell_cursor_in_empty_line>
  104701:	59                   	pop    %ecx
  104702:	84 c0                	test   %al,%al
  104704:	74 20                	je     104726 <shell_op_char_insert+0x7f>
	shell_raw_fprintf(shell->fprintf_ctx, "\n");
  104706:	68 7f e4 10 00       	push   $0x10e47f
  10470b:	ff 73 14             	pushl  0x14(%ebx)
  10470e:	e8 e9 f7 ff ff       	call   103efc <shell_raw_fprintf>
  104713:	58                   	pop    %eax
  104714:	5a                   	pop    %edx
  104715:	eb 0f                	jmp    104726 <shell_op_char_insert+0x7f>
		data_insert(shell, &data, 1);
  104717:	b9 01 00 00 00       	mov    $0x1,%ecx
  10471c:	8d 55 f4             	lea    -0xc(%ebp),%edx
  10471f:	89 d8                	mov    %ebx,%eax
  104721:	e8 e5 fe ff ff       	call   10460b <data_insert>
}
  104726:	8d 65 f8             	lea    -0x8(%ebp),%esp
  104729:	5b                   	pop    %ebx
  10472a:	5e                   	pop    %esi
  10472b:	5d                   	pop    %ebp
  10472c:	c3                   	ret    

0010472d <shell_op_completion_insert>:
{
  10472d:	55                   	push   %ebp
  10472e:	89 e5                	mov    %esp,%ebp
	data_insert(shell, compl, compl_len);
  104730:	0f b7 4d 10          	movzwl 0x10(%ebp),%ecx
  104734:	8b 55 0c             	mov    0xc(%ebp),%edx
  104737:	8b 45 08             	mov    0x8(%ebp),%eax
}
  10473a:	5d                   	pop    %ebp
	data_insert(shell, compl, compl_len);
  10473b:	e9 cb fe ff ff       	jmp    10460b <data_insert>

00104740 <shell_op_char_delete>:
{
  104740:	55                   	push   %ebp
  104741:	89 e5                	mov    %esp,%ebp
  104743:	56                   	push   %esi
  104744:	53                   	push   %ebx
  104745:	8b 75 08             	mov    0x8(%ebp),%esi
	u16_t diff = shell->ctx->cmd_buff_len - shell->ctx->cmd_buff_pos;
  104748:	8b 56 08             	mov    0x8(%esi),%edx
  10474b:	0f b7 42 3e          	movzwl 0x3e(%edx),%eax
	if (diff == 0U) {
  10474f:	8b 5a 3c             	mov    0x3c(%edx),%ebx
  104752:	66 29 c3             	sub    %ax,%bx
  104755:	74 34                	je     10478b <shell_op_char_delete+0x4b>
	char *str = &shell->ctx->cmd_buff[shell->ctx->cmd_buff_pos];
  104757:	8d 44 02 42          	lea    0x42(%edx,%eax,1),%eax
	memmove(str, str + 1, diff);
  10475b:	0f b7 d3             	movzwl %bx,%edx
  10475e:	52                   	push   %edx
  10475f:	8d 50 01             	lea    0x1(%eax),%edx
  104762:	52                   	push   %edx
  104763:	50                   	push   %eax
  104764:	e8 70 26 00 00       	call   106dd9 <memmove>
	--shell->ctx->cmd_buff_len;
  104769:	8b 46 08             	mov    0x8(%esi),%eax
	memmove(str, str + 1, diff);
  10476c:	83 c4 0c             	add    $0xc,%esp
	reprint_from_cursor(shell, --diff, true);
  10476f:	8d 53 ff             	lea    -0x1(%ebx),%edx
  104772:	b9 01 00 00 00       	mov    $0x1,%ecx
	--shell->ctx->cmd_buff_len;
  104777:	66 ff 48 3c          	decw   0x3c(%eax)
}
  10477b:	8d 65 f8             	lea    -0x8(%ebp),%esp
  10477e:	5b                   	pop    %ebx
	reprint_from_cursor(shell, --diff, true);
  10477f:	89 f0                	mov    %esi,%eax
  104781:	0f b7 d2             	movzwl %dx,%edx
}
  104784:	5e                   	pop    %esi
  104785:	5d                   	pop    %ebp
	reprint_from_cursor(shell, --diff, true);
  104786:	e9 06 fe ff ff       	jmp    104591 <reprint_from_cursor>
}
  10478b:	8d 65 f8             	lea    -0x8(%ebp),%esp
  10478e:	5b                   	pop    %ebx
  10478f:	5e                   	pop    %esi
  104790:	5d                   	pop    %ebp
  104791:	c3                   	ret    

00104792 <shell_op_char_backspace>:
{
  104792:	55                   	push   %ebp
  104793:	89 e5                	mov    %esp,%ebp
  104795:	53                   	push   %ebx
  104796:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if ((shell->ctx->cmd_buff_len == 0) ||
  104799:	8b 43 08             	mov    0x8(%ebx),%eax
  10479c:	66 83 78 3c 00       	cmpw   $0x0,0x3c(%eax)
  1047a1:	74 1d                	je     1047c0 <shell_op_char_backspace+0x2e>
  1047a3:	66 83 78 3e 00       	cmpw   $0x0,0x3e(%eax)
  1047a8:	74 16                	je     1047c0 <shell_op_char_backspace+0x2e>
	shell_op_cursor_move(shell, -1);
  1047aa:	6a ff                	push   $0xffffffff
  1047ac:	53                   	push   %ebx
  1047ad:	e8 fa f8 ff ff       	call   1040ac <shell_op_cursor_move>
  1047b2:	58                   	pop    %eax
	shell_op_char_delete(shell);
  1047b3:	89 5d 08             	mov    %ebx,0x8(%ebp)
}
  1047b6:	8b 5d fc             	mov    -0x4(%ebp),%ebx
	shell_op_cursor_move(shell, -1);
  1047b9:	5a                   	pop    %edx
}
  1047ba:	c9                   	leave  
	shell_op_char_delete(shell);
  1047bb:	e9 80 ff ff ff       	jmp    104740 <shell_op_char_delete>
}
  1047c0:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  1047c3:	c9                   	leave  
  1047c4:	c3                   	ret    

001047c5 <shell_print_prompt_and_cmd>:
{
  1047c5:	55                   	push   %ebp
  1047c6:	89 e5                	mov    %esp,%ebp
  1047c8:	53                   	push   %ebx
  1047c9:	8b 5d 08             	mov    0x8(%ebp),%ebx
	shell_internal_fprintf(shell, SHELL_INFO, "%s", shell->ctx->prompt);
  1047cc:	8b 43 08             	mov    0x8(%ebx),%eax
  1047cf:	ff 30                	pushl  (%eax)
  1047d1:	68 7b e4 10 00       	push   $0x10e47b
  1047d6:	6a 03                	push   $0x3
  1047d8:	53                   	push   %ebx
  1047d9:	e8 cb fc ff ff       	call   1044a9 <shell_internal_fprintf>
	if (flag_echo_get(shell)) {
  1047de:	8b 43 08             	mov    0x8(%ebx),%eax
	shell_internal_fprintf(shell, SHELL_INFO, "%s", shell->ctx->prompt);
  1047e1:	83 c4 10             	add    $0x10,%esp
	return shell->ctx->internal.flags.echo == 1 ? true : false;
  1047e4:	8b 80 60 02 00 00    	mov    0x260(%eax),%eax
	if (flag_echo_get(shell)) {
  1047ea:	a8 04                	test   $0x4,%al
  1047ec:	74 13                	je     104801 <shell_print_prompt_and_cmd+0x3c>
		shell_print_cmd(shell);
  1047ee:	53                   	push   %ebx
  1047ef:	e8 e8 fa ff ff       	call   1042dc <shell_print_cmd>
		shell_op_cursor_position_synchronize(shell);
  1047f4:	89 5d 08             	mov    %ebx,0x8(%ebp)
}
  1047f7:	8b 5d fc             	mov    -0x4(%ebp),%ebx
		shell_print_cmd(shell);
  1047fa:	58                   	pop    %eax
}
  1047fb:	c9                   	leave  
		shell_op_cursor_position_synchronize(shell);
  1047fc:	e9 2d f8 ff ff       	jmp    10402e <shell_op_cursor_position_synchronize>
}
  104801:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  104804:	c9                   	leave  
  104805:	c3                   	ret    

00104806 <z_impl_uart_irq_tx_disable>:
static inline void z_impl_uart_irq_tx_disable(struct device *dev)
{
	const struct uart_driver_api *api =
		(const struct uart_driver_api *)dev->driver_api;

	if (api->irq_tx_disable) {
  104806:	8b 50 04             	mov    0x4(%eax),%edx
  104809:	8b 52 20             	mov    0x20(%edx),%edx
  10480c:	85 d2                	test   %edx,%edx
  10480e:	74 09                	je     104819 <z_impl_uart_irq_tx_disable+0x13>
{
  104810:	55                   	push   %ebp
  104811:	89 e5                	mov    %esp,%ebp
		api->irq_tx_disable(dev);
  104813:	50                   	push   %eax
  104814:	ff d2                	call   *%edx
  104816:	58                   	pop    %eax
	}
}
  104817:	c9                   	leave  
  104818:	c3                   	ret    
  104819:	c3                   	ret    

0010481a <uninit>:
}

static int uninit(const struct shell_transport *transport)
{
	return 0;
}
  10481a:	31 c0                	xor    %eax,%eax
  10481c:	c3                   	ret    

0010481d <enable>:

static int enable(const struct shell_transport *transport, bool blocking_tx)
{
  10481d:	55                   	push   %ebp
  10481e:	89 e5                	mov    %esp,%ebp
	const struct shell_uart *sh_uart = (struct shell_uart *)transport->ctx;

	sh_uart->ctrl_blk->blocking_tx = blocking_tx;
  104820:	8b 45 08             	mov    0x8(%ebp),%eax
{
  104823:	8b 55 0c             	mov    0xc(%ebp),%edx

	if (blocking_tx) {
  104826:	84 d2                	test   %dl,%dl
	sh_uart->ctrl_blk->blocking_tx = blocking_tx;
  104828:	8b 40 04             	mov    0x4(%eax),%eax
  10482b:	8b 00                	mov    (%eax),%eax
  10482d:	88 50 10             	mov    %dl,0x10(%eax)
	if (blocking_tx) {
  104830:	74 07                	je     104839 <enable+0x1c>

K_SYSCALL_DECLARE2(K_SYSCALL_UART_CONFIG_GET, uart_config_get, int, struct device *, dev, struct uart_config *, cfg)

K_SYSCALL_DECLARE1_VOID(K_SYSCALL_UART_IRQ_TX_ENABLE, uart_irq_tx_enable, struct device *, dev)

K_SYSCALL_DECLARE1_VOID(K_SYSCALL_UART_IRQ_TX_DISABLE, uart_irq_tx_disable, struct device *, dev)
  104832:	8b 00                	mov    (%eax),%eax
  104834:	e8 cd ff ff ff       	call   104806 <z_impl_uart_irq_tx_disable>
		uart_irq_tx_disable(sh_uart->ctrl_blk->dev);
#endif
	}

	return 0;
}
  104839:	31 c0                	xor    %eax,%eax
  10483b:	5d                   	pop    %ebp
  10483c:	c3                   	ret    

0010483d <read>:
	return 0;
}

static int read(const struct shell_transport *transport,
		void *data, size_t length, size_t *cnt)
{
  10483d:	55                   	push   %ebp
  10483e:	89 e5                	mov    %esp,%ebp
	struct shell_uart *sh_uart = (struct shell_uart *)transport->ctx;

	*cnt = ring_buf_get(sh_uart->rx_ringbuf, data, length);
  104840:	ff 75 10             	pushl  0x10(%ebp)
  104843:	ff 75 0c             	pushl  0xc(%ebp)
  104846:	8b 45 08             	mov    0x8(%ebp),%eax
  104849:	8b 40 04             	mov    0x4(%eax),%eax
  10484c:	ff 70 0c             	pushl  0xc(%eax)
  10484f:	e8 40 c2 ff ff       	call   100a94 <ring_buf_get>
  104854:	8b 55 14             	mov    0x14(%ebp),%edx
  104857:	83 c4 0c             	add    $0xc,%esp
  10485a:	89 02                	mov    %eax,(%edx)

	return 0;
}
  10485c:	31 c0                	xor    %eax,%eax
  10485e:	c9                   	leave  
  10485f:	c3                   	ret    

00104860 <enable_shell_uart>:
	.update = update,
#endif /* CONFIG_MCUMGR_SMP_SHELL */
};

static int enable_shell_uart(struct device *arg)
{
  104860:	55                   	push   %ebp
  104861:	89 e5                	mov    %esp,%ebp

#ifdef __cplusplus
extern "C" {
#endif

K_SYSCALL_DECLARE1(K_SYSCALL_DEVICE_GET_BINDING, device_get_binding, struct device *, const char *, name)
  104863:	68 a5 e4 10 00       	push   $0x10e4a5
  104868:	e8 91 54 00 00       	call   109cfe <z_impl_device_get_binding>
	bool log_backend = CONFIG_SHELL_BACKEND_SERIAL_LOG_LEVEL > 0;
	u32_t level =
		(CONFIG_SHELL_BACKEND_SERIAL_LOG_LEVEL > LOG_LEVEL_DBG) ?
		CONFIG_LOG_MAX_LEVEL : CONFIG_SHELL_BACKEND_SERIAL_LOG_LEVEL;

	shell_init(&shell_uart, dev, true, log_backend, level);
  10486d:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
  104874:	6a 01                	push   $0x1
  104876:	6a 01                	push   $0x1
  104878:	50                   	push   %eax
  104879:	68 c0 bc 10 00       	push   $0x10bcc0
  10487e:	e8 3a ee ff ff       	call   1036bd <shell_init>
  104883:	83 c4 14             	add    $0x14,%esp

	return 0;
}
  104886:	31 c0                	xor    %eax,%eax
  104888:	c9                   	leave  
  104889:	c3                   	ret    

0010488a <init>:
{
  10488a:	55                   	push   %ebp
  10488b:	89 e5                	mov    %esp,%ebp
  10488d:	53                   	push   %ebx
	const struct shell_uart *sh_uart = (struct shell_uart *)transport->ctx;
  10488e:	8b 45 08             	mov    0x8(%ebp),%eax
{
  104891:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	sh_uart->ctrl_blk->handler = evt_handler;
  104894:	8b 4d 10             	mov    0x10(%ebp),%ecx
	const struct shell_uart *sh_uart = (struct shell_uart *)transport->ctx;
  104897:	8b 50 04             	mov    0x4(%eax),%edx
	sh_uart->ctrl_blk->dev = (struct device *)config;
  10489a:	8b 02                	mov    (%edx),%eax
	sh_uart->ctrl_blk->handler = evt_handler;
  10489c:	89 48 04             	mov    %ecx,0x4(%eax)
	sh_uart->ctrl_blk->context = context;
  10489f:	8b 4d 14             	mov    0x14(%ebp),%ecx
	sh_uart->ctrl_blk->dev = (struct device *)config;
  1048a2:	89 18                	mov    %ebx,(%eax)
	sh_uart->ctrl_blk->context = context;
  1048a4:	89 48 08             	mov    %ecx,0x8(%eax)
static inline void uart_irq_callback_user_data_set(
					struct device *dev,
					uart_irq_callback_user_data_t cb,
					void *user_data)
{
	const struct uart_driver_api *api =
  1048a7:	8b 43 04             	mov    0x4(%ebx),%eax
		(const struct uart_driver_api *)dev->driver_api;

	if ((api != NULL) && (api->irq_callback_set != NULL)) {
  1048aa:	85 c0                	test   %eax,%eax
  1048ac:	74 13                	je     1048c1 <init+0x37>
  1048ae:	8b 40 48             	mov    0x48(%eax),%eax
  1048b1:	85 c0                	test   %eax,%eax
  1048b3:	74 0c                	je     1048c1 <init+0x37>
		api->irq_callback_set(dev, cb, user_data);
  1048b5:	52                   	push   %edx
  1048b6:	68 60 49 10 00       	push   $0x104960
  1048bb:	53                   	push   %ebx
  1048bc:	ff d0                	call   *%eax
  1048be:	83 c4 0c             	add    $0xc,%esp
	if (api->irq_rx_enable) {
  1048c1:	8b 43 04             	mov    0x4(%ebx),%eax
  1048c4:	8b 40 28             	mov    0x28(%eax),%eax
  1048c7:	85 c0                	test   %eax,%eax
  1048c9:	74 04                	je     1048cf <init+0x45>
		api->irq_rx_enable(dev);
  1048cb:	53                   	push   %ebx
  1048cc:	ff d0                	call   *%eax
  1048ce:	58                   	pop    %eax
}
  1048cf:	31 c0                	xor    %eax,%eax
  1048d1:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  1048d4:	c9                   	leave  
  1048d5:	c3                   	ret    

001048d6 <write>:
{
  1048d6:	55                   	push   %ebp
  1048d7:	89 e5                	mov    %esp,%ebp
  1048d9:	57                   	push   %edi
  1048da:	56                   	push   %esi
  1048db:	53                   	push   %ebx
  1048dc:	50                   	push   %eax
	const struct shell_uart *sh_uart = (struct shell_uart *)transport->ctx;
  1048dd:	8b 45 08             	mov    0x8(%ebp),%eax
{
  1048e0:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  1048e3:	8b 7d 10             	mov    0x10(%ebp),%edi
	const struct shell_uart *sh_uart = (struct shell_uart *)transport->ctx;
  1048e6:	8b 70 04             	mov    0x4(%eax),%esi
		!sh_uart->ctrl_blk->blocking_tx) {
  1048e9:	8b 06                	mov    (%esi),%eax
	if (IS_ENABLED(CONFIG_SHELL_BACKEND_SERIAL_INTERRUPT_DRIVEN) &&
  1048eb:	80 78 10 00          	cmpb   $0x0,0x10(%eax)
  1048ef:	74 08                	je     1048f9 <write+0x23>
  1048f1:	8d 04 3b             	lea    (%ebx,%edi,1),%eax
  1048f4:	89 45 f0             	mov    %eax,-0x10(%ebp)
  1048f7:	eb 34                	jmp    10492d <write+0x57>
	*cnt = ring_buf_put(sh_uart->tx_ringbuf, data, length);
  1048f9:	57                   	push   %edi
  1048fa:	53                   	push   %ebx
  1048fb:	ff 76 08             	pushl  0x8(%esi)
  1048fe:	e8 b8 c0 ff ff       	call   1009bb <ring_buf_put>
  104903:	8b 4d 14             	mov    0x14(%ebp),%ecx
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
  104906:	8b 16                	mov    (%esi),%edx
  104908:	83 c4 0c             	add    $0xc,%esp
  10490b:	89 01                	mov    %eax,(%ecx)
  10490d:	b8 01 00 00 00       	mov    $0x1,%eax
  104912:	87 42 0c             	xchg   %eax,0xc(%edx)
	if (atomic_set(&sh_uart->ctrl_blk->tx_busy, 1) == 0) {
  104915:	85 c0                	test   %eax,%eax
  104917:	75 3d                	jne    104956 <write+0x80>
		uart_irq_tx_enable(sh_uart->ctrl_blk->dev);
  104919:	8b 06                	mov    (%esi),%eax
  10491b:	8b 10                	mov    (%eax),%edx
	if (api->irq_tx_enable) {
  10491d:	8b 42 04             	mov    0x4(%edx),%eax
  104920:	8b 40 1c             	mov    0x1c(%eax),%eax
  104923:	85 c0                	test   %eax,%eax
  104925:	74 2f                	je     104956 <write+0x80>
		api->irq_tx_enable(dev);
  104927:	52                   	push   %edx
  104928:	ff d0                	call   *%eax
  10492a:	58                   	pop    %eax
  10492b:	eb 29                	jmp    104956 <write+0x80>
  10492d:	8b 06                	mov    (%esi),%eax
		for (size_t i = 0; i < length; i++) {
  10492f:	3b 5d f0             	cmp    -0x10(%ebp),%ebx
  104932:	74 13                	je     104947 <write+0x71>
			uart_poll_out(sh_uart->ctrl_blk->dev, data8[i]);
  104934:	8b 00                	mov    (%eax),%eax
	api->poll_out(dev, out_char);
  104936:	43                   	inc    %ebx
  104937:	0f b6 4b ff          	movzbl -0x1(%ebx),%ecx
  10493b:	8b 50 04             	mov    0x4(%eax),%edx
  10493e:	51                   	push   %ecx
  10493f:	50                   	push   %eax
  104940:	ff 52 04             	call   *0x4(%edx)
  104943:	59                   	pop    %ecx
  104944:	58                   	pop    %eax
  104945:	eb e6                	jmp    10492d <write+0x57>
		*cnt = length;
  104947:	8b 4d 14             	mov    0x14(%ebp),%ecx
  10494a:	89 39                	mov    %edi,(%ecx)
		sh_uart->ctrl_blk->handler(SHELL_TRANSPORT_EVT_TX_RDY,
  10494c:	ff 70 08             	pushl  0x8(%eax)
  10494f:	6a 01                	push   $0x1
  104951:	ff 50 04             	call   *0x4(%eax)
  104954:	58                   	pop    %eax
  104955:	5a                   	pop    %edx
}
  104956:	8d 65 f4             	lea    -0xc(%ebp),%esp
  104959:	31 c0                	xor    %eax,%eax
  10495b:	5b                   	pop    %ebx
  10495c:	5e                   	pop    %esi
  10495d:	5f                   	pop    %edi
  10495e:	5d                   	pop    %ebp
  10495f:	c3                   	ret    

00104960 <uart_callback>:
{
  104960:	55                   	push   %ebp
  104961:	89 e5                	mov    %esp,%ebp
  104963:	57                   	push   %edi
  104964:	56                   	push   %esi
  104965:	53                   	push   %ebx
  104966:	83 ec 10             	sub    $0x10,%esp
  104969:	8b 5d 08             	mov    0x8(%ebp),%ebx
	struct device *dev = sh_uart->ctrl_blk->dev;
  10496c:	8b 03                	mov    (%ebx),%eax
  10496e:	8b 30                	mov    (%eax),%esi
	if (api->irq_update) {
  104970:	8b 46 04             	mov    0x4(%esi),%eax
  104973:	8b 40 44             	mov    0x44(%eax),%eax
  104976:	85 c0                	test   %eax,%eax
  104978:	74 04                	je     10497e <uart_callback+0x1e>
		return api->irq_update(dev);
  10497a:	56                   	push   %esi
  10497b:	ff d0                	call   *%eax
  10497d:	5f                   	pop    %edi
	if (api->irq_rx_ready) {
  10497e:	8b 46 04             	mov    0x4(%esi),%eax
  104981:	8b 40 34             	mov    0x34(%eax),%eax
  104984:	85 c0                	test   %eax,%eax
  104986:	0f 84 bd 00 00 00    	je     104a49 <uart_callback+0xe9>
		return api->irq_rx_ready(dev);
  10498c:	56                   	push   %esi
  10498d:	ff d0                	call   *%eax
  10498f:	59                   	pop    %ecx
	if (uart_irq_rx_ready(dev)) {
  104990:	85 c0                	test   %eax,%eax
  104992:	0f 84 b1 00 00 00    	je     104a49 <uart_callback+0xe9>
	bool new_data = false;
  104998:	c6 45 eb 00          	movb   $0x0,-0x15(%ebp)
					 sh_uart->rx_ringbuf->size);
  10499c:	8b 43 0c             	mov    0xc(%ebx),%eax
		len = ring_buf_put_claim(sh_uart->rx_ringbuf, &data,
  10499f:	8d 55 f0             	lea    -0x10(%ebp),%edx
  1049a2:	ff 70 10             	pushl  0x10(%eax)
  1049a5:	52                   	push   %edx
  1049a6:	50                   	push   %eax
  1049a7:	e8 8e bf ff ff       	call   10093a <ring_buf_put_claim>
  1049ac:	83 c4 0c             	add    $0xc,%esp
  1049af:	89 c7                	mov    %eax,%edi
		if (len > 0) {
  1049b1:	85 c0                	test   %eax,%eax
  1049b3:	74 3f                	je     1049f4 <uart_callback+0x94>
			rd_len = uart_fifo_read(sh_uart->ctrl_blk->dev,
  1049b5:	8b 03                	mov    (%ebx),%eax
	return 0;
  1049b7:	31 d2                	xor    %edx,%edx
  1049b9:	8b 08                	mov    (%eax),%ecx
	if (api->fifo_read) {
  1049bb:	8b 41 04             	mov    0x4(%ecx),%eax
  1049be:	8b 40 18             	mov    0x18(%eax),%eax
  1049c1:	85 c0                	test   %eax,%eax
  1049c3:	74 14                	je     1049d9 <uart_callback+0x79>
		return api->fifo_read(dev, rx_data, size);
  1049c5:	57                   	push   %edi
  1049c6:	ff 75 f0             	pushl  -0x10(%ebp)
  1049c9:	51                   	push   %ecx
  1049ca:	ff d0                	call   *%eax
  1049cc:	83 c4 0c             	add    $0xc,%esp
  1049cf:	89 c2                	mov    %eax,%edx
			if (rd_len > 0) {
  1049d1:	85 c0                	test   %eax,%eax
  1049d3:	74 04                	je     1049d9 <uart_callback+0x79>
				new_data = true;
  1049d5:	c6 45 eb 01          	movb   $0x1,-0x15(%ebp)
			int err = ring_buf_put_finish(sh_uart->rx_ringbuf,
  1049d9:	52                   	push   %edx
  1049da:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  1049dd:	ff 73 0c             	pushl  0xc(%ebx)
  1049e0:	e8 9f bf ff ff       	call   100984 <ring_buf_put_finish>
  1049e5:	58                   	pop    %eax
  1049e6:	5a                   	pop    %edx
	} while (rd_len && (rd_len == len));
  1049e7:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  1049ea:	85 d2                	test   %edx,%edx
  1049ec:	74 49                	je     104a37 <uart_callback+0xd7>
  1049ee:	39 d7                	cmp    %edx,%edi
  1049f0:	74 aa                	je     10499c <uart_callback+0x3c>
  1049f2:	eb 43                	jmp    104a37 <uart_callback+0xd7>
			LOG_WRN("RX ring buffer full.");
  1049f4:	f6 05 18 34 11 00 06 	testb  $0x6,0x113418
  1049fb:	74 20                	je     104a1d <uart_callback+0xbd>
  1049fd:	b8 08 ba 10 00       	mov    $0x10ba08,%eax
  104a02:	2d e0 b9 10 00       	sub    $0x10b9e0,%eax
  104a07:	c1 e8 03             	shr    $0x3,%eax
  104a0a:	c1 e0 06             	shl    $0x6,%eax
  104a0d:	83 c8 02             	or     $0x2,%eax
  104a10:	50                   	push   %eax
  104a11:	68 ac e4 10 00       	push   $0x10e4ac
  104a16:	e8 eb c7 ff ff       	call   101206 <log_0>
  104a1b:	59                   	pop    %ecx
  104a1c:	5f                   	pop    %edi
			rd_len = uart_fifo_read(sh_uart->ctrl_blk->dev,
  104a1d:	8b 03                	mov    (%ebx),%eax
  104a1f:	8b 10                	mov    (%eax),%edx
	if (api->fifo_read) {
  104a21:	8b 42 04             	mov    0x4(%edx),%eax
  104a24:	8b 40 18             	mov    0x18(%eax),%eax
  104a27:	85 c0                	test   %eax,%eax
  104a29:	74 0c                	je     104a37 <uart_callback+0xd7>
		return api->fifo_read(dev, rx_data, size);
  104a2b:	6a 01                	push   $0x1
  104a2d:	8d 4d ef             	lea    -0x11(%ebp),%ecx
  104a30:	51                   	push   %ecx
  104a31:	52                   	push   %edx
  104a32:	ff d0                	call   *%eax
  104a34:	83 c4 0c             	add    $0xc,%esp
	if (new_data) {
  104a37:	80 7d eb 00          	cmpb   $0x0,-0x15(%ebp)
  104a3b:	74 0c                	je     104a49 <uart_callback+0xe9>
		sh_uart->ctrl_blk->handler(SHELL_TRANSPORT_EVT_RX_RDY,
  104a3d:	8b 03                	mov    (%ebx),%eax
  104a3f:	ff 70 08             	pushl  0x8(%eax)
  104a42:	6a 00                	push   $0x0
  104a44:	ff 50 04             	call   *0x4(%eax)
  104a47:	58                   	pop    %eax
  104a48:	5a                   	pop    %edx
	if (api->irq_tx_ready) {
  104a49:	8b 46 04             	mov    0x4(%esi),%eax
  104a4c:	8b 40 24             	mov    0x24(%eax),%eax
  104a4f:	85 c0                	test   %eax,%eax
  104a51:	74 64                	je     104ab7 <uart_callback+0x157>
		return api->irq_tx_ready(dev);
  104a53:	56                   	push   %esi
  104a54:	ff d0                	call   *%eax
  104a56:	5f                   	pop    %edi
	if (uart_irq_tx_ready(dev)) {
  104a57:	85 c0                	test   %eax,%eax
  104a59:	74 5c                	je     104ab7 <uart_callback+0x157>
	struct device *dev = sh_uart->ctrl_blk->dev;
  104a5b:	8b 03                	mov    (%ebx),%eax
	len = ring_buf_get_claim(sh_uart->tx_ringbuf, (u8_t **)&data,
  104a5d:	8d 55 f0             	lea    -0x10(%ebp),%edx
	struct device *dev = sh_uart->ctrl_blk->dev;
  104a60:	8b 30                	mov    (%eax),%esi
				 sh_uart->tx_ringbuf->size);
  104a62:	8b 43 08             	mov    0x8(%ebx),%eax
	len = ring_buf_get_claim(sh_uart->tx_ringbuf, (u8_t **)&data,
  104a65:	ff 70 10             	pushl  0x10(%eax)
  104a68:	52                   	push   %edx
  104a69:	50                   	push   %eax
  104a6a:	e8 9b bf ff ff       	call   100a0a <ring_buf_get_claim>
  104a6f:	83 c4 0c             	add    $0xc,%esp
	if (len) {
  104a72:	85 c0                	test   %eax,%eax
  104a74:	74 25                	je     104a9b <uart_callback+0x13b>
	if (api->fifo_fill) {
  104a76:	8b 56 04             	mov    0x4(%esi),%edx
  104a79:	8b 4a 14             	mov    0x14(%edx),%ecx
	return 0;
  104a7c:	31 d2                	xor    %edx,%edx
	if (api->fifo_fill) {
  104a7e:	85 c9                	test   %ecx,%ecx
  104a80:	74 0c                	je     104a8e <uart_callback+0x12e>
		return api->fifo_fill(dev, tx_data, size);
  104a82:	50                   	push   %eax
  104a83:	ff 75 f0             	pushl  -0x10(%ebp)
  104a86:	56                   	push   %esi
  104a87:	ff d1                	call   *%ecx
  104a89:	83 c4 0c             	add    $0xc,%esp
  104a8c:	89 c2                	mov    %eax,%edx
		err = ring_buf_get_finish(sh_uart->tx_ringbuf, len);
  104a8e:	52                   	push   %edx
  104a8f:	ff 73 08             	pushl  0x8(%ebx)
  104a92:	e8 c3 bf ff ff       	call   100a5a <ring_buf_get_finish>
  104a97:	59                   	pop    %ecx
  104a98:	5e                   	pop    %esi
		__ASSERT_NO_MSG(err == 0);
  104a99:	eb 10                	jmp    104aab <uart_callback+0x14b>
  104a9b:	89 f0                	mov    %esi,%eax
  104a9d:	e8 64 fd ff ff       	call   104806 <z_impl_uart_irq_tx_disable>
		sh_uart->ctrl_blk->tx_busy = 0;
  104aa2:	8b 03                	mov    (%ebx),%eax
  104aa4:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
	sh_uart->ctrl_blk->handler(SHELL_TRANSPORT_EVT_TX_RDY,
  104aab:	8b 03                	mov    (%ebx),%eax
  104aad:	ff 70 08             	pushl  0x8(%eax)
  104ab0:	6a 01                	push   $0x1
  104ab2:	ff 50 04             	call   *0x4(%eax)
  104ab5:	58                   	pop    %eax
  104ab6:	5a                   	pop    %edx
}
  104ab7:	8d 65 f4             	lea    -0xc(%ebp),%esp
  104aba:	5b                   	pop    %ebx
  104abb:	5e                   	pop    %esi
  104abc:	5f                   	pop    %edi
  104abd:	5d                   	pop    %ebp
  104abe:	c3                   	ret    

00104abf <shell_raw_fprintf>:
{
  104abf:	55                   	push   %ebp
  104ac0:	89 e5                	mov    %esp,%ebp
	va_start(args, fmt);
  104ac2:	8d 45 10             	lea    0x10(%ebp),%eax
	shell_fprintf_fmt(ctx, fmt, args);
  104ac5:	50                   	push   %eax
  104ac6:	ff 75 0c             	pushl  0xc(%ebp)
  104ac9:	ff 75 08             	pushl  0x8(%ebp)
  104acc:	e8 e5 ee ff ff       	call   1039b6 <shell_fprintf_fmt>
  104ad1:	83 c4 0c             	add    $0xc,%esp
}
  104ad4:	c9                   	leave  
  104ad5:	c3                   	ret    

00104ad6 <formatted_text_print.constprop.2>:
				 size_t terminal_offset, bool offset_first_line)
{
	size_t offset = 0;
	size_t length;

	if (str == NULL) {
  104ad6:	85 d2                	test   %edx,%edx
  104ad8:	0f 84 51 01 00 00    	je     104c2f <formatted_text_print.constprop.2+0x159>
static void formatted_text_print(const struct shell *shell, const char *str,
  104ade:	55                   	push   %ebp
  104adf:	89 e5                	mov    %esp,%ebp
  104ae1:	57                   	push   %edi
  104ae2:	56                   	push   %esi
	if (str == NULL) {
  104ae3:	31 f6                	xor    %esi,%esi
static void formatted_text_print(const struct shell *shell, const char *str,
  104ae5:	53                   	push   %ebx
  104ae6:	89 c3                	mov    %eax,%ebx
  104ae8:	83 ec 10             	sub    $0x10,%esp
  104aeb:	89 4d ec             	mov    %ecx,-0x14(%ebp)
  104aee:	89 55 f0             	mov    %edx,-0x10(%ebp)
		shell_op_cursor_horiz_move(shell, terminal_offset);
	}


	/* Skipping whitespace. */
	while (isspace((int) *(str + offset))) {
  104af1:	8b 45 f0             	mov    -0x10(%ebp),%eax
  104af4:	0f be 04 30          	movsbl (%eax,%esi,1),%eax
  104af8:	89 c1                	mov    %eax,%ecx
	return (int)(c == (int)' ' || ((unsigned)c-(unsigned)'\t') < 5U);
  104afa:	83 e8 09             	sub    $0x9,%eax
  104afd:	83 f8 04             	cmp    $0x4,%eax
  104b00:	77 03                	ja     104b05 <formatted_text_print.constprop.2+0x2f>
		++offset;
  104b02:	46                   	inc    %esi
  104b03:	eb ec                	jmp    104af1 <formatted_text_print.constprop.2+0x1b>
	while (isspace((int) *(str + offset))) {
  104b05:	80 f9 20             	cmp    $0x20,%cl
  104b08:	74 f8                	je     104b02 <formatted_text_print.constprop.2+0x2c>
  104b0a:	ff 75 f0             	pushl  -0x10(%ebp)
  104b0d:	e8 64 22 00 00       	call   106d76 <strlen>
		size_t idx = 0;

		length = shell_strlen(str) - offset;

		if (length <=
		    shell->ctx->vt100_ctx.cons.terminal_wid - terminal_offset) {
  104b12:	8b 53 08             	mov    0x8(%ebx),%edx
  104b15:	0f b7 7a 2a          	movzwl 0x2a(%edx),%edi
  104b19:	89 fa                	mov    %edi,%edx
  104b1b:	89 7d e8             	mov    %edi,-0x18(%ebp)
		length = shell_strlen(str) - offset;
  104b1e:	0f b7 c0             	movzwl %ax,%eax
		    shell->ctx->vt100_ctx.cons.terminal_wid - terminal_offset) {
  104b21:	2b 55 ec             	sub    -0x14(%ebp),%edx
		length = shell_strlen(str) - offset;
  104b24:	29 f0                	sub    %esi,%eax
			for (idx = 0; idx < length; idx++) {
  104b26:	31 ff                	xor    %edi,%edi
  104b28:	59                   	pop    %ecx
		if (length <=
  104b29:	39 d0                	cmp    %edx,%eax
  104b2b:	76 0d                	jbe    104b3a <formatted_text_print.constprop.2+0x64>
  104b2d:	8b 45 f0             	mov    -0x10(%ebp),%eax
  104b30:	01 f0                	add    %esi,%eax
  104b32:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  104b35:	e9 89 00 00 00       	jmp    104bc3 <formatted_text_print.constprop.2+0xed>
  104b3a:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  104b3d:	01 f1                	add    %esi,%ecx
			for (idx = 0; idx < length; idx++) {
  104b3f:	39 f8                	cmp    %edi,%eax
  104b41:	74 4a                	je     104b8d <formatted_text_print.constprop.2+0xb7>
				if (*(str + offset + idx) == '\n') {
  104b43:	8d 14 3e             	lea    (%esi,%edi,1),%edx
  104b46:	80 3c 39 0a          	cmpb   $0xa,(%ecx,%edi,1)
  104b4a:	89 55 e8             	mov    %edx,-0x18(%ebp)
  104b4d:	75 3b                	jne    104b8a <formatted_text_print.constprop.2+0xb4>
	shell_fprintf_buffer_flush(shell->fprintf_ctx);
  104b4f:	ff 73 14             	pushl  0x14(%ebx)
  104b52:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
  104b55:	e8 37 ee ff ff       	call   103991 <shell_fprintf_buffer_flush>
					transport_buffer_flush(shell);
					shell_write(shell, str + offset, idx);
  104b5a:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  104b5d:	89 3c 24             	mov    %edi,(%esp)
  104b60:	51                   	push   %ecx
  104b61:	53                   	push   %ebx
  104b62:	e8 94 f7 ff ff       	call   1042fb <shell_write>
  104b67:	83 c4 0c             	add    $0xc,%esp
					offset += idx + 1;
  104b6a:	8b 75 e8             	mov    -0x18(%ebp),%esi
  104b6d:	46                   	inc    %esi
	shell_raw_fprintf(shell->fprintf_ctx, "\n");
  104b6e:	68 7f e4 10 00       	push   $0x10e47f
  104b73:	ff 73 14             	pushl  0x14(%ebx)
  104b76:	e8 44 ff ff ff       	call   104abf <shell_raw_fprintf>
  104b7b:	5f                   	pop    %edi
  104b7c:	58                   	pop    %eax
					cursor_next_line_move(shell);
					shell_op_cursor_horiz_move(shell,
  104b7d:	ff 75 ec             	pushl  -0x14(%ebp)
  104b80:	53                   	push   %ebx
  104b81:	e8 0c f4 ff ff       	call   103f92 <shell_op_cursor_horiz_move>
  104b86:	58                   	pop    %eax
  104b87:	5a                   	pop    %edx
							terminal_offset);
					break;
  104b88:	eb 03                	jmp    104b8d <formatted_text_print.constprop.2+0xb7>
			for (idx = 0; idx < length; idx++) {
  104b8a:	47                   	inc    %edi
  104b8b:	eb b2                	jmp    104b3f <formatted_text_print.constprop.2+0x69>
				}
			}

			/* String will fit in one line. */
			shell_raw_fprintf(shell->fprintf_ctx, str + offset);
  104b8d:	8b 55 f0             	mov    -0x10(%ebp),%edx
  104b90:	01 f2                	add    %esi,%edx
  104b92:	52                   	push   %edx
  104b93:	ff 73 14             	pushl  0x14(%ebx)
  104b96:	e8 24 ff ff ff       	call   104abf <shell_raw_fprintf>
  104b9b:	58                   	pop    %eax
  104b9c:	5a                   	pop    %edx
  104b9d:	68 7f e4 10 00       	push   $0x10e47f
  104ba2:	ff 73 14             	pushl  0x14(%ebx)
  104ba5:	e8 15 ff ff ff       	call   104abf <shell_raw_fprintf>
  104baa:	59                   	pop    %ecx
  104bab:	5b                   	pop    %ebx
		cursor_next_line_move(shell);
		shell_op_cursor_horiz_move(shell, terminal_offset);

	}
	cursor_next_line_move(shell);
}
  104bac:	8d 65 f4             	lea    -0xc(%ebp),%esp
  104baf:	5b                   	pop    %ebx
  104bb0:	5e                   	pop    %esi
  104bb1:	5f                   	pop    %edi
  104bb2:	5d                   	pop    %ebp
  104bb3:	c3                   	ret    
			if (isspace((int) (*(str + offset + idx)))) {
  104bb4:	3c 20                	cmp    $0x20,%al
  104bb6:	74 1c                	je     104bd4 <formatted_text_print.constprop.2+0xfe>
			if ((idx + terminal_offset) >=
  104bb8:	8b 45 ec             	mov    -0x14(%ebp),%eax
  104bbb:	01 f8                	add    %edi,%eax
  104bbd:	39 45 e8             	cmp    %eax,-0x18(%ebp)
  104bc0:	76 1a                	jbe    104bdc <formatted_text_print.constprop.2+0x106>
			++idx;
  104bc2:	47                   	inc    %edi
			if (isspace((int) (*(str + offset + idx)))) {
  104bc3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  104bc6:	0f be 0c 38          	movsbl (%eax,%edi,1),%ecx
  104bca:	89 c8                	mov    %ecx,%eax
  104bcc:	83 e9 09             	sub    $0x9,%ecx
  104bcf:	83 f9 04             	cmp    $0x4,%ecx
  104bd2:	77 e0                	ja     104bb4 <formatted_text_print.constprop.2+0xde>
				if (*(str + offset + idx) == '\n') {
  104bd4:	3c 0a                	cmp    $0xa,%al
  104bd6:	74 06                	je     104bde <formatted_text_print.constprop.2+0x108>
  104bd8:	89 fa                	mov    %edi,%edx
  104bda:	eb dc                	jmp    104bb8 <formatted_text_print.constprop.2+0xe2>
			if ((idx + terminal_offset) >=
  104bdc:	89 d7                	mov    %edx,%edi
  104bde:	ff 73 14             	pushl  0x14(%ebx)
  104be1:	e8 ab ed ff ff       	call   103991 <shell_fprintf_buffer_flush>
		shell_write(shell, str + offset, length);
  104be6:	89 3c 24             	mov    %edi,(%esp)
  104be9:	ff 75 e4             	pushl  -0x1c(%ebp)
		offset += length;
  104bec:	01 fe                	add    %edi,%esi
		shell_write(shell, str + offset, length);
  104bee:	53                   	push   %ebx
  104bef:	e8 07 f7 ff ff       	call   1042fb <shell_write>
  104bf4:	83 c4 0c             	add    $0xc,%esp
		while (isspace((int) (*(str + offset)))) {
  104bf7:	8b 45 f0             	mov    -0x10(%ebp),%eax
  104bfa:	0f be 04 30          	movsbl (%eax,%esi,1),%eax
  104bfe:	89 c1                	mov    %eax,%ecx
  104c00:	83 e8 09             	sub    $0x9,%eax
  104c03:	83 f8 04             	cmp    $0x4,%eax
  104c06:	77 03                	ja     104c0b <formatted_text_print.constprop.2+0x135>
			++offset;
  104c08:	46                   	inc    %esi
  104c09:	eb ec                	jmp    104bf7 <formatted_text_print.constprop.2+0x121>
		while (isspace((int) (*(str + offset)))) {
  104c0b:	80 f9 20             	cmp    $0x20,%cl
  104c0e:	74 f8                	je     104c08 <formatted_text_print.constprop.2+0x132>
  104c10:	68 7f e4 10 00       	push   $0x10e47f
  104c15:	ff 73 14             	pushl  0x14(%ebx)
  104c18:	e8 a2 fe ff ff       	call   104abf <shell_raw_fprintf>
  104c1d:	58                   	pop    %eax
  104c1e:	5a                   	pop    %edx
		shell_op_cursor_horiz_move(shell, terminal_offset);
  104c1f:	ff 75 ec             	pushl  -0x14(%ebp)
  104c22:	53                   	push   %ebx
  104c23:	e8 6a f3 ff ff       	call   103f92 <shell_op_cursor_horiz_move>
  104c28:	59                   	pop    %ecx
  104c29:	5f                   	pop    %edi
  104c2a:	e9 db fe ff ff       	jmp    104b0a <formatted_text_print.constprop.2+0x34>
  104c2f:	c3                   	ret    

00104c30 <shell_help_subcmd_print>:

/* Function is printing command help, its subcommands name and subcommands
 * help string.
 */
void shell_help_subcmd_print(const struct shell *shell)
{
  104c30:	55                   	push   %ebp
  104c31:	89 e5                	mov    %esp,%ebp
  104c33:	57                   	push   %edi
  104c34:	56                   	push   %esi
  104c35:	53                   	push   %ebx
  104c36:	83 ec 28             	sub    $0x28,%esp
	const struct shell_static_entry *entry = NULL;
  104c39:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
{
  104c40:	8b 5d 08             	mov    0x8(%ebp),%ebx
	struct shell_static_entry static_entry;
	u16_t longest_syntax = 0U;
	size_t cmd_idx = 0;

	/* Checking if there are any subcommands available. */
	if (!shell->ctx->active_cmd.subcmd) {
  104c43:	8b 43 08             	mov    0x8(%ebx),%eax
  104c46:	83 78 14 00          	cmpl   $0x0,0x14(%eax)
  104c4a:	0f 84 f8 00 00 00    	je     104d48 <shell_help_subcmd_print+0x118>
	size_t cmd_idx = 0;
  104c50:	31 ff                	xor    %edi,%edi
	u16_t longest_syntax = 0U;
  104c52:	31 f6                	xor    %esi,%esi
		return;
	}

	/* Searching for the longest subcommand to print. */
	do {
		shell_cmd_get(shell->ctx->active_cmd.subcmd,
  104c54:	8d 47 01             	lea    0x1(%edi),%eax
  104c57:	89 45 d8             	mov    %eax,-0x28(%ebp)
  104c5a:	8d 45 e0             	lea    -0x20(%ebp),%eax
  104c5d:	50                   	push   %eax
  104c5e:	8d 45 dc             	lea    -0x24(%ebp),%eax
  104c61:	50                   	push   %eax
  104c62:	8b 43 08             	mov    0x8(%ebx),%eax
  104c65:	57                   	push   %edi
  104c66:	6a 01                	push   $0x1
  104c68:	ff 70 14             	pushl  0x14(%eax)
  104c6b:	e8 dd f0 ff ff       	call   103d4d <shell_cmd_get>
			      !SHELL_CMD_ROOT_LVL,
			      cmd_idx++, &entry, &static_entry);

		if (!entry) {
  104c70:	8b 45 dc             	mov    -0x24(%ebp),%eax
		shell_cmd_get(shell->ctx->active_cmd.subcmd,
  104c73:	83 c4 14             	add    $0x14,%esp
		if (!entry) {
  104c76:	85 c0                	test   %eax,%eax
  104c78:	74 1c                	je     104c96 <shell_help_subcmd_print+0x66>
			break;
		}

		u16_t len = shell_strlen(entry->syntax);
  104c7a:	8b 00                	mov    (%eax),%eax
	return str == NULL ? 0U : (u16_t)strlen(str);
  104c7c:	85 c0                	test   %eax,%eax
  104c7e:	74 0e                	je     104c8e <shell_help_subcmd_print+0x5e>
  104c80:	50                   	push   %eax
  104c81:	e8 f0 20 00 00       	call   106d76 <strlen>

		longest_syntax = longest_syntax > len ? longest_syntax : len;
  104c86:	66 39 c6             	cmp    %ax,%si
  104c89:	5a                   	pop    %edx
  104c8a:	73 02                	jae    104c8e <shell_help_subcmd_print+0x5e>
  104c8c:	89 c6                	mov    %eax,%esi
	} while (cmd_idx != 0); /* too many commands */
  104c8e:	47                   	inc    %edi
  104c8f:	74 0f                	je     104ca0 <shell_help_subcmd_print+0x70>
		shell_cmd_get(shell->ctx->active_cmd.subcmd,
  104c91:	8b 7d d8             	mov    -0x28(%ebp),%edi
  104c94:	eb be                	jmp    104c54 <shell_help_subcmd_print+0x24>

	if (cmd_idx == 1) {
  104c96:	83 7d d8 01          	cmpl   $0x1,-0x28(%ebp)
  104c9a:	0f 84 a8 00 00 00    	je     104d48 <shell_help_subcmd_print+0x118>
		return;
	}

	shell_internal_fprintf(shell, SHELL_NORMAL, "Subcommands:\n");
  104ca0:	68 ee e4 10 00       	push   $0x10e4ee
  104ca5:	6a 00                	push   $0x0
  104ca7:	53                   	push   %ebx
  104ca8:	e8 fc f7 ff ff       	call   1044a9 <shell_internal_fprintf>

		if (entry == NULL) {
			break;
		}

		help_item_print(shell, entry->syntax, longest_syntax,
  104cad:	0f b7 d6             	movzwl %si,%edx
	shell_internal_fprintf(shell, SHELL_NORMAL, "Subcommands:\n");
  104cb0:	83 c4 0c             	add    $0xc,%esp
	cmd_idx = 0;
  104cb3:	31 c0                	xor    %eax,%eax
		help_item_print(shell, entry->syntax, longest_syntax,
  104cb5:	89 55 d4             	mov    %edx,-0x2c(%ebp)
		shell_cmd_get(shell->ctx->active_cmd.subcmd,
  104cb8:	8d 50 01             	lea    0x1(%eax),%edx
  104cbb:	89 55 d8             	mov    %edx,-0x28(%ebp)
  104cbe:	8d 55 e0             	lea    -0x20(%ebp),%edx
  104cc1:	52                   	push   %edx
  104cc2:	8d 55 dc             	lea    -0x24(%ebp),%edx
  104cc5:	52                   	push   %edx
  104cc6:	50                   	push   %eax
  104cc7:	8b 43 08             	mov    0x8(%ebx),%eax
  104cca:	6a 01                	push   $0x1
  104ccc:	ff 70 14             	pushl  0x14(%eax)
  104ccf:	e8 79 f0 ff ff       	call   103d4d <shell_cmd_get>
		if (entry == NULL) {
  104cd4:	8b 45 dc             	mov    -0x24(%ebp),%eax
		shell_cmd_get(shell->ctx->active_cmd.subcmd,
  104cd7:	83 c4 14             	add    $0x14,%esp
		if (entry == NULL) {
  104cda:	85 c0                	test   %eax,%eax
  104cdc:	74 6a                	je     104d48 <shell_help_subcmd_print+0x118>
		help_item_print(shell, entry->syntax, longest_syntax,
  104cde:	8b 08                	mov    (%eax),%ecx
  104ce0:	8b 78 04             	mov    0x4(%eax),%edi
  104ce3:	89 4d cc             	mov    %ecx,-0x34(%ebp)
	const u16_t offset = 2 * strlen(tabulator) + item_name_width + 1;
  104ce6:	68 06 e5 10 00       	push   $0x10e506
  104ceb:	e8 86 20 00 00       	call   106d76 <strlen>
  104cf0:	59                   	pop    %ecx
	if (item_name == NULL) {
  104cf1:	8b 4d cc             	mov    -0x34(%ebp),%ecx
	const u16_t offset = 2 * strlen(tabulator) + item_name_width + 1;
  104cf4:	89 45 d0             	mov    %eax,-0x30(%ebp)
	if (item_name == NULL) {
  104cf7:	85 c9                	test   %ecx,%ecx
  104cf9:	75 05                	jne    104d00 <shell_help_subcmd_print+0xd0>
  104cfb:	8b 45 d8             	mov    -0x28(%ebp),%eax
  104cfe:	eb b8                	jmp    104cb8 <shell_help_subcmd_print+0x88>
		shell_internal_fprintf(shell, SHELL_NORMAL, "%s%-*s%s:",
  104d00:	68 06 e5 10 00       	push   $0x10e506
  104d05:	51                   	push   %ecx
  104d06:	ff 75 d4             	pushl  -0x2c(%ebp)
  104d09:	68 06 e5 10 00       	push   $0x10e506
  104d0e:	68 fc e4 10 00       	push   $0x10e4fc
  104d13:	6a 00                	push   $0x0
  104d15:	53                   	push   %ebx
  104d16:	e8 8e f7 ff ff       	call   1044a9 <shell_internal_fprintf>
  104d1b:	83 c4 1c             	add    $0x1c,%esp
	if (item_help == NULL) {
  104d1e:	8b 45 d0             	mov    -0x30(%ebp),%eax
  104d21:	85 ff                	test   %edi,%edi
  104d23:	75 11                	jne    104d36 <shell_help_subcmd_print+0x106>
  104d25:	68 7f e4 10 00       	push   $0x10e47f
  104d2a:	ff 73 14             	pushl  0x14(%ebx)
  104d2d:	e8 8d fd ff ff       	call   104abf <shell_raw_fprintf>
  104d32:	58                   	pop    %eax
  104d33:	5a                   	pop    %edx
  104d34:	eb c5                	jmp    104cfb <shell_help_subcmd_print+0xcb>
	const u16_t offset = 2 * strlen(tabulator) + item_name_width + 1;
  104d36:	8d 4c 46 01          	lea    0x1(%esi,%eax,2),%ecx
	formatted_text_print(shell, item_help, offset, false);
  104d3a:	89 fa                	mov    %edi,%edx
  104d3c:	0f b7 c9             	movzwl %cx,%ecx
  104d3f:	89 d8                	mov    %ebx,%eax
  104d41:	e8 90 fd ff ff       	call   104ad6 <formatted_text_print.constprop.2>
  104d46:	eb b3                	jmp    104cfb <shell_help_subcmd_print+0xcb>
				entry->help);
	}
}
  104d48:	8d 65 f4             	lea    -0xc(%ebp),%esp
  104d4b:	5b                   	pop    %ebx
  104d4c:	5e                   	pop    %esi
  104d4d:	5f                   	pop    %edi
  104d4e:	5d                   	pop    %ebp
  104d4f:	c3                   	ret    

00104d50 <shell_help_cmd_print>:

void shell_help_cmd_print(const struct shell *shell)
{
  104d50:	55                   	push   %ebp
  104d51:	89 e5                	mov    %esp,%ebp
  104d53:	56                   	push   %esi
  104d54:	53                   	push   %ebx
  104d55:	31 db                	xor    %ebx,%ebx
  104d57:	8b 75 08             	mov    0x8(%ebp),%esi
	static const char cmd_sep[] = " - ";	/* commands separator */

	u16_t field_width = shell_strlen(shell->ctx->active_cmd.syntax) +
  104d5a:	8b 46 08             	mov    0x8(%esi),%eax
  104d5d:	8b 40 0c             	mov    0xc(%eax),%eax
  104d60:	85 c0                	test   %eax,%eax
  104d62:	74 09                	je     104d6d <shell_help_cmd_print+0x1d>
  104d64:	50                   	push   %eax
  104d65:	e8 0c 20 00 00       	call   106d76 <strlen>
  104d6a:	5a                   	pop    %edx
  104d6b:	89 c3                	mov    %eax,%ebx
  104d6d:	68 e4 db 10 00       	push   $0x10dbe4
  104d72:	e8 ff 1f 00 00       	call   106d76 <strlen>
							  shell_strlen(cmd_sep);

	shell_internal_fprintf(shell, SHELL_NORMAL, "%s%s",
  104d77:	c7 04 24 e4 db 10 00 	movl   $0x10dbe4,(%esp)
	u16_t field_width = shell_strlen(shell->ctx->active_cmd.syntax) +
  104d7e:	01 c3                	add    %eax,%ebx
	shell_internal_fprintf(shell, SHELL_NORMAL, "%s%s",
  104d80:	8b 46 08             	mov    0x8(%esi),%eax
  104d83:	ff 70 0c             	pushl  0xc(%eax)
  104d86:	68 79 e4 10 00       	push   $0x10e479
  104d8b:	6a 00                	push   $0x0
  104d8d:	56                   	push   %esi
  104d8e:	e8 16 f7 ff ff       	call   1044a9 <shell_internal_fprintf>
			       shell->ctx->active_cmd.syntax, cmd_sep);

	formatted_text_print(shell, shell->ctx->active_cmd.help,
  104d93:	8b 46 08             	mov    0x8(%esi),%eax
	shell_internal_fprintf(shell, SHELL_NORMAL, "%s%s",
  104d96:	83 c4 14             	add    $0x14,%esp
	formatted_text_print(shell, shell->ctx->active_cmd.help,
  104d99:	0f b7 cb             	movzwl %bx,%ecx
  104d9c:	8b 50 10             	mov    0x10(%eax),%edx
			     field_width, false);
}
  104d9f:	8d 65 f8             	lea    -0x8(%ebp),%esp
	formatted_text_print(shell, shell->ctx->active_cmd.help,
  104da2:	89 f0                	mov    %esi,%eax
}
  104da4:	5b                   	pop    %ebx
  104da5:	5e                   	pop    %esi
  104da6:	5d                   	pop    %ebp
	formatted_text_print(shell, shell->ctx->active_cmd.help,
  104da7:	e9 2a fd ff ff       	jmp    104ad6 <formatted_text_print.constprop.2>

00104dac <cmd_bacskpace_mode_backspace>:
	return 0;
}

static int cmd_bacskpace_mode_backspace(const struct shell *shell, size_t argc,
					char **argv)
{
  104dac:	55                   	push   %ebp
  104dad:	89 e5                	mov    %esp,%ebp
	shell->ctx->internal.flags.mode_delete = val ? 1 : 0;
  104daf:	8b 45 08             	mov    0x8(%ebp),%eax
  104db2:	8b 50 08             	mov    0x8(%eax),%edx
  104db5:	66 8b 82 60 02 00 00 	mov    0x260(%edx),%ax
  104dbc:	83 e0 df             	and    $0xffffffdf,%eax
  104dbf:	66 89 82 60 02 00 00 	mov    %ax,0x260(%edx)
	ARG_UNUSED(argv);

	flag_mode_delete_set(shell, false);

	return 0;
}
  104dc6:	31 c0                	xor    %eax,%eax
  104dc8:	5d                   	pop    %ebp
  104dc9:	c3                   	ret    

00104dca <cmd_bacskpace_mode_delete>:

static int cmd_bacskpace_mode_delete(const struct shell *shell, size_t argc,
				      char **argv)
{
  104dca:	55                   	push   %ebp
  104dcb:	89 e5                	mov    %esp,%ebp
  104dcd:	8b 45 08             	mov    0x8(%ebp),%eax
  104dd0:	8b 50 08             	mov    0x8(%eax),%edx
  104dd3:	66 8b 82 60 02 00 00 	mov    0x260(%edx),%ax
  104dda:	83 c8 20             	or     $0x20,%eax
  104ddd:	66 89 82 60 02 00 00 	mov    %ax,0x260(%edx)
	ARG_UNUSED(argv);

	flag_mode_delete_set(shell, true);

	return 0;
}
  104de4:	31 c0                	xor    %eax,%eax
  104de6:	5d                   	pop    %ebp
  104de7:	c3                   	ret    

00104de8 <cmd_colors_off>:

static int cmd_colors_off(const struct shell *shell, size_t argc, char **argv)
{
  104de8:	55                   	push   %ebp
  104de9:	89 e5                	mov    %esp,%ebp
	shell->ctx->internal.flags.use_colors = val ? 1 : 0;
  104deb:	8b 45 08             	mov    0x8(%ebp),%eax
  104dee:	8b 50 08             	mov    0x8(%eax),%edx
  104df1:	66 8b 82 60 02 00 00 	mov    0x260(%edx),%ax
  104df8:	83 e0 fd             	and    $0xfffffffd,%eax
  104dfb:	66 89 82 60 02 00 00 	mov    %ax,0x260(%edx)
	ARG_UNUSED(argv);

	flag_use_colors_set(shell, false);

	return 0;
}
  104e02:	31 c0                	xor    %eax,%eax
  104e04:	5d                   	pop    %ebp
  104e05:	c3                   	ret    

00104e06 <cmd_colors_on>:

static int cmd_colors_on(const struct shell *shell, size_t argc, char **argv)
{
  104e06:	55                   	push   %ebp
  104e07:	89 e5                	mov    %esp,%ebp
  104e09:	8b 45 08             	mov    0x8(%ebp),%eax
  104e0c:	8b 50 08             	mov    0x8(%eax),%edx
  104e0f:	66 8b 82 60 02 00 00 	mov    0x260(%edx),%ax
  104e16:	83 c8 02             	or     $0x2,%eax
  104e19:	66 89 82 60 02 00 00 	mov    %ax,0x260(%edx)
	ARG_UNUSED(argv);

	flag_use_colors_set(shell, true);

	return 0;
}
  104e20:	31 c0                	xor    %eax,%eax
  104e22:	5d                   	pop    %ebp
  104e23:	c3                   	ret    

00104e24 <cmd_echo_off>:

static int cmd_echo_off(const struct shell *shell, size_t argc, char **argv)
{
  104e24:	55                   	push   %ebp
  104e25:	89 e5                	mov    %esp,%ebp
	shell->ctx->internal.flags.echo = val ? 1 : 0;
  104e27:	8b 45 08             	mov    0x8(%ebp),%eax
  104e2a:	8b 50 08             	mov    0x8(%eax),%edx
  104e2d:	66 8b 82 60 02 00 00 	mov    0x260(%edx),%ax
  104e34:	83 e0 fb             	and    $0xfffffffb,%eax
  104e37:	66 89 82 60 02 00 00 	mov    %ax,0x260(%edx)
	ARG_UNUSED(argv);

	flag_echo_set(shell, false);

	return 0;
}
  104e3e:	31 c0                	xor    %eax,%eax
  104e40:	5d                   	pop    %ebp
  104e41:	c3                   	ret    

00104e42 <cmd_echo_on>:

static int cmd_echo_on(const struct shell *shell, size_t argc, char **argv)
{
  104e42:	55                   	push   %ebp
  104e43:	89 e5                	mov    %esp,%ebp
  104e45:	8b 45 08             	mov    0x8(%ebp),%eax
  104e48:	8b 50 08             	mov    0x8(%eax),%edx
  104e4b:	66 8b 82 60 02 00 00 	mov    0x260(%edx),%ax
  104e52:	83 c8 04             	or     $0x4,%eax
  104e55:	66 89 82 60 02 00 00 	mov    %ax,0x260(%edx)
	ARG_UNUSED(argv);

	flag_echo_set(shell, true);

	return 0;
}
  104e5c:	31 c0                	xor    %eax,%eax
  104e5e:	5d                   	pop    %ebp
  104e5f:	c3                   	ret    

00104e60 <cmd_shell_stats_reset>:
	return 0;
}

static int cmd_shell_stats_reset(const struct shell *shell,
				 size_t argc, char **argv)
{
  104e60:	55                   	push   %ebp
  104e61:	89 e5                	mov    %esp,%ebp
	if (!IS_ENABLED(CONFIG_SHELL_STATS)) {
		shell_error(shell, "Command not supported.");
		return -ENOEXEC;
	}

	shell->stats->log_lost_cnt = 0;
  104e63:	8b 45 08             	mov    0x8(%ebp),%eax
  104e66:	8b 40 18             	mov    0x18(%eax),%eax
  104e69:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

	return 0;
}
  104e6f:	31 c0                	xor    %eax,%eax
  104e71:	5d                   	pop    %ebp
  104e72:	c3                   	ret    

00104e73 <shell_raw_fprintf>:
{
  104e73:	55                   	push   %ebp
  104e74:	89 e5                	mov    %esp,%ebp
	va_start(args, fmt);
  104e76:	8d 45 10             	lea    0x10(%ebp),%eax
	shell_fprintf_fmt(ctx, fmt, args);
  104e79:	50                   	push   %eax
  104e7a:	ff 75 0c             	pushl  0xc(%ebp)
  104e7d:	ff 75 08             	pushl  0x8(%ebp)
  104e80:	e8 31 eb ff ff       	call   1039b6 <shell_fprintf_fmt>
  104e85:	83 c4 0c             	add    $0xc,%esp
}
  104e88:	c9                   	leave  
  104e89:	c3                   	ret    

00104e8a <cmd_clear>:
{
  104e8a:	55                   	push   %ebp
  104e8b:	89 e5                	mov    %esp,%ebp
  104e8d:	53                   	push   %ebx
	SHELL_VT100_CMD(shell, SHELL_VT100_CURSORHOME);
  104e8e:	68 00 dc 10 00       	push   $0x10dc00
{
  104e93:	8b 5d 08             	mov    0x8(%ebp),%ebx
	SHELL_VT100_CMD(shell, SHELL_VT100_CURSORHOME);
  104e96:	68 7b e4 10 00       	push   $0x10e47b
  104e9b:	ff 73 14             	pushl  0x14(%ebx)
  104e9e:	e8 d0 ff ff ff       	call   104e73 <shell_raw_fprintf>
  104ea3:	83 c4 0c             	add    $0xc,%esp
	SHELL_VT100_CMD(shell, SHELL_VT100_CLEARSCREEN);
  104ea6:	68 f8 db 10 00       	push   $0x10dbf8
  104eab:	68 7b e4 10 00       	push   $0x10e47b
  104eb0:	ff 73 14             	pushl  0x14(%ebx)
  104eb3:	e8 bb ff ff ff       	call   104e73 <shell_raw_fprintf>
  104eb8:	83 c4 0c             	add    $0xc,%esp
}
  104ebb:	31 c0                	xor    %eax,%eax
  104ebd:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  104ec0:	c9                   	leave  
  104ec1:	c3                   	ret    

00104ec2 <cmd_resize_default>:

static int cmd_resize_default(const struct shell *shell,
			      size_t argc, char **argv)
{
  104ec2:	55                   	push   %ebp
  104ec3:	89 e5                	mov    %esp,%ebp
  104ec5:	53                   	push   %ebx
	ARG_UNUSED(argc);
	ARG_UNUSED(argv);

	SHELL_VT100_CMD(shell, SHELL_VT100_SETCOL_80);
  104ec6:	68 e8 db 10 00       	push   $0x10dbe8
{
  104ecb:	8b 5d 08             	mov    0x8(%ebp),%ebx
	SHELL_VT100_CMD(shell, SHELL_VT100_SETCOL_80);
  104ece:	68 7b e4 10 00       	push   $0x10e47b
  104ed3:	ff 73 14             	pushl  0x14(%ebx)
  104ed6:	e8 98 ff ff ff       	call   104e73 <shell_raw_fprintf>
	shell->ctx->vt100_ctx.cons.terminal_wid =  SHELL_DEFAULT_TERMINAL_WIDTH;
	shell->ctx->vt100_ctx.cons.terminal_hei = SHELL_DEFAULT_TERMINAL_HEIGHT;
  104edb:	8b 43 08             	mov    0x8(%ebx),%eax
  104ede:	c7 40 28 18 00 50 00 	movl   $0x500018,0x28(%eax)
	SHELL_VT100_CMD(shell, SHELL_VT100_SETCOL_80);
  104ee5:	83 c4 0c             	add    $0xc,%esp

	return 0;
}
  104ee8:	31 c0                	xor    %eax,%eax
  104eea:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  104eed:	c9                   	leave  
  104eee:	c3                   	ret    

00104eef <cmd_shell_stats_show>:
{
  104eef:	55                   	push   %ebp
  104ef0:	89 e5                	mov    %esp,%ebp
  104ef2:	8b 45 08             	mov    0x8(%ebp),%eax
	shell_print(shell, "Lost logs: %u", shell->stats->log_lost_cnt);
  104ef5:	8b 50 18             	mov    0x18(%eax),%edx
  104ef8:	ff 32                	pushl  (%edx)
  104efa:	68 09 e5 10 00       	push   $0x10e509
  104eff:	6a 00                	push   $0x0
  104f01:	50                   	push   %eax
  104f02:	e8 18 ea ff ff       	call   10391f <shell_fprintf>
  104f07:	83 c4 10             	add    $0x10,%esp
}
  104f0a:	31 c0                	xor    %eax,%eax
  104f0c:	c9                   	leave  
  104f0d:	c3                   	ret    

00104f0e <cmd_help>:
{
  104f0e:	55                   	push   %ebp
  104f0f:	89 e5                	mov    %esp,%ebp
  104f11:	53                   	push   %ebx
	shell_print(shell,
  104f12:	68 18 e5 10 00       	push   $0x10e518
{
  104f17:	8b 5d 08             	mov    0x8(%ebp),%ebx
	shell_print(shell,
  104f1a:	6a 00                	push   $0x0
  104f1c:	53                   	push   %ebx
  104f1d:	e8 fd e9 ff ff       	call   10391f <shell_fprintf>
  104f22:	83 c4 0c             	add    $0xc,%esp
	shell_print(shell,
  104f25:	68 07 e6 10 00       	push   $0x10e607
  104f2a:	6a 00                	push   $0x0
  104f2c:	53                   	push   %ebx
  104f2d:	e8 ed e9 ff ff       	call   10391f <shell_fprintf>
  104f32:	83 c4 0c             	add    $0xc,%esp
}
  104f35:	31 c0                	xor    %eax,%eax
  104f37:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  104f3a:	c9                   	leave  
  104f3b:	c3                   	ret    

00104f3c <cmd_history>:
{
  104f3c:	55                   	push   %ebp
  104f3d:	89 e5                	mov    %esp,%ebp
  104f3f:	57                   	push   %edi
  104f40:	56                   	push   %esi
	size_t i = 0;
  104f41:	31 ff                	xor    %edi,%edi
{
  104f43:	53                   	push   %ebx
  104f44:	50                   	push   %eax
  104f45:	8b 75 08             	mov    0x8(%ebp),%esi
		shell_history_get(shell->history, true,
  104f48:	8d 45 f2             	lea    -0xe(%ebp),%eax
  104f4b:	50                   	push   %eax
				  shell->ctx->temp_buff, &len);
  104f4c:	8b 46 08             	mov    0x8(%esi),%eax
  104f4f:	05 42 01 00 00       	add    $0x142,%eax
		shell_history_get(shell->history, true,
  104f54:	50                   	push   %eax
  104f55:	6a 01                	push   $0x1
  104f57:	ff 76 0c             	pushl  0xc(%esi)
  104f5a:	e8 e8 02 00 00       	call   105247 <shell_history_get>
  104f5f:	83 c4 10             	add    $0x10,%esp
		if (len) {
  104f62:	8b 46 08             	mov    0x8(%esi),%eax
  104f65:	66 83 7d f2 00       	cmpw   $0x0,-0xe(%ebp)
  104f6a:	74 1e                	je     104f8a <cmd_history+0x4e>
			shell_print(shell, "[%3d] %s",
  104f6c:	05 42 01 00 00       	add    $0x142,%eax
  104f71:	8d 5f 01             	lea    0x1(%edi),%ebx
  104f74:	50                   	push   %eax
  104f75:	57                   	push   %edi
  104f76:	89 df                	mov    %ebx,%edi
  104f78:	68 bf e6 10 00       	push   $0x10e6bf
  104f7d:	6a 00                	push   $0x0
  104f7f:	56                   	push   %esi
  104f80:	e8 9a e9 ff ff       	call   10391f <shell_fprintf>
  104f85:	83 c4 14             	add    $0x14,%esp
		shell_history_get(shell->history, true,
  104f88:	eb be                	jmp    104f48 <cmd_history+0xc>
	shell->ctx->temp_buff[0] = '\0';
  104f8a:	c6 80 42 01 00 00 00 	movb   $0x0,0x142(%eax)
}
  104f91:	8d 65 f4             	lea    -0xc(%ebp),%esp
  104f94:	31 c0                	xor    %eax,%eax
  104f96:	5b                   	pop    %ebx
  104f97:	5e                   	pop    %esi
  104f98:	5f                   	pop    %edi
  104f99:	5d                   	pop    %ebp
  104f9a:	c3                   	ret    

00104f9b <cmd_echo>:
{
  104f9b:	55                   	push   %ebp
  104f9c:	89 e5                	mov    %esp,%ebp
  104f9e:	8b 45 08             	mov    0x8(%ebp),%eax
  104fa1:	8b 55 10             	mov    0x10(%ebp),%edx
	if (argc == 2) {
  104fa4:	83 7d 0c 02          	cmpl   $0x2,0xc(%ebp)
  104fa8:	75 21                	jne    104fcb <cmd_echo+0x30>
		shell_error(shell, "%s:%s%s", argv[0],
  104faa:	ff 72 04             	pushl  0x4(%edx)
  104fad:	68 cd e6 10 00       	push   $0x10e6cd
  104fb2:	ff 32                	pushl  (%edx)
  104fb4:	68 e2 e6 10 00       	push   $0x10e6e2
  104fb9:	6a 02                	push   $0x2
  104fbb:	50                   	push   %eax
  104fbc:	e8 5e e9 ff ff       	call   10391f <shell_fprintf>
  104fc1:	83 c4 18             	add    $0x18,%esp
  104fc4:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
  104fc9:	eb 2b                	jmp    104ff6 <cmd_echo+0x5b>
	shell_print(shell, "Echo status: %s",
  104fcb:	8b 50 08             	mov    0x8(%eax),%edx
	return shell->ctx->internal.flags.echo == 1 ? true : false;
  104fce:	8b 8a 60 02 00 00    	mov    0x260(%edx),%ecx
  104fd4:	ba 23 e3 10 00       	mov    $0x10e323,%edx
  104fd9:	80 e1 04             	and    $0x4,%cl
  104fdc:	75 05                	jne    104fe3 <cmd_echo+0x48>
  104fde:	ba c9 e6 10 00       	mov    $0x10e6c9,%edx
  104fe3:	52                   	push   %edx
  104fe4:	68 eb e6 10 00       	push   $0x10e6eb
  104fe9:	6a 00                	push   $0x0
  104feb:	50                   	push   %eax
  104fec:	e8 2e e9 ff ff       	call   10391f <shell_fprintf>
  104ff1:	83 c4 10             	add    $0x10,%esp
	return 0;
  104ff4:	31 c0                	xor    %eax,%eax
}
  104ff6:	c9                   	leave  
  104ff7:	c3                   	ret    

00104ff8 <cmd_resize>:

static int cmd_resize(const struct shell *shell, size_t argc, char **argv)
{
  104ff8:	55                   	push   %ebp
  104ff9:	89 e5                	mov    %esp,%ebp
  104ffb:	57                   	push   %edi
  104ffc:	56                   	push   %esi
  104ffd:	53                   	push   %ebx
  104ffe:	83 ec 0c             	sub    $0xc,%esp
  105001:	8b 5d 08             	mov    0x8(%ebp),%ebx
  105004:	8b 45 10             	mov    0x10(%ebp),%eax
	if (!IS_ENABLED(CONFIG_SHELL_CMDS_RESIZE)) {
		shell_error(shell, "Command not supported.");
		return -ENOEXEC;
	}

	if (argc != 1) {
  105007:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
  10500b:	74 24                	je     105031 <cmd_resize+0x39>
		shell_error(shell, "%s:%s%s", argv[0],
  10500d:	ff 70 04             	pushl  0x4(%eax)
			    SHELL_MSG_UNKNOWN_PARAMETER, argv[1]);
		return -EINVAL;
  105010:	be ea ff ff ff       	mov    $0xffffffea,%esi
		shell_error(shell, "%s:%s%s", argv[0],
  105015:	68 cd e6 10 00       	push   $0x10e6cd
  10501a:	ff 30                	pushl  (%eax)
  10501c:	68 e2 e6 10 00       	push   $0x10e6e2
  105021:	6a 02                	push   $0x2
  105023:	53                   	push   %ebx
  105024:	e8 f6 e8 ff ff       	call   10391f <shell_fprintf>
  105029:	83 c4 18             	add    $0x18,%esp
		return -EINVAL;
  10502c:	e9 b3 01 00 00       	jmp    1051e4 <cmd_resize+0x1ec>
	SHELL_VT100_CMD(shell, SHELL_VT100_SAVECURSOR);
  105031:	68 39 e7 10 00       	push   $0x10e739
  105036:	68 7b e4 10 00       	push   $0x10e47b
  10503b:	ff 73 14             	pushl  0x14(%ebx)
  10503e:	e8 30 fe ff ff       	call   104e73 <shell_raw_fprintf>
  105043:	83 c4 0c             	add    $0xc,%esp
	shell_op_cursor_vert_move(shell, -SHELL_MAX_TERMINAL_SIZE);
  105046:	68 06 ff ff ff       	push   $0xffffff06
  10504b:	53                   	push   %ebx
  10504c:	e8 12 ef ff ff       	call   103f63 <shell_op_cursor_vert_move>
  105051:	5a                   	pop    %edx
  105052:	59                   	pop    %ecx
	shell_op_cursor_horiz_move(shell, SHELL_MAX_TERMINAL_SIZE);
  105053:	68 fa 00 00 00       	push   $0xfa
  105058:	53                   	push   %ebx
  105059:	e8 34 ef ff ff       	call   103f92 <shell_op_cursor_horiz_move>
  10505e:	5e                   	pop    %esi
	memset(shell->ctx->temp_buff, 0, sizeof(shell->ctx->temp_buff));
  10505f:	8b 43 08             	mov    0x8(%ebx),%eax
	shell_op_cursor_horiz_move(shell, SHELL_MAX_TERMINAL_SIZE);
  105062:	5f                   	pop    %edi
	memset(shell->ctx->temp_buff, 0, sizeof(shell->ctx->temp_buff));
  105063:	05 42 01 00 00       	add    $0x142,%eax
  105068:	68 00 01 00 00       	push   $0x100
	char c = 0;
  10506d:	c6 45 ef 00          	movb   $0x0,-0x11(%ebp)
	memset(shell->ctx->temp_buff, 0, sizeof(shell->ctx->temp_buff));
  105071:	6a 00                	push   $0x0
	shell_fprintf_buffer_flush(shell->fprintf_ctx);
  105073:	bf e8 03 00 00       	mov    $0x3e8,%edi
  105078:	50                   	push   %eax
  105079:	e8 03 1e 00 00       	call   106e81 <memset>
  10507e:	83 c4 0c             	add    $0xc,%esp
	u16_t buff_idx = 0U;
  105081:	31 f6                	xor    %esi,%esi
	shell_raw_fprintf(shell->fprintf_ctx, cmd_get_terminal_size);
  105083:	68 f0 db 10 00       	push   $0x10dbf0
  105088:	ff 73 14             	pushl  0x14(%ebx)
  10508b:	e8 e3 fd ff ff       	call   104e73 <shell_raw_fprintf>
  105090:	58                   	pop    %eax
  105091:	5a                   	pop    %edx
  105092:	ff 73 14             	pushl  0x14(%ebx)
  105095:	e8 f7 e8 ff ff       	call   103991 <shell_fprintf_buffer_flush>
  10509a:	59                   	pop    %ecx
			(void)shell->iface->api->read(shell->iface, &c,
  10509b:	8b 43 04             	mov    0x4(%ebx),%eax
  10509e:	8d 4d f0             	lea    -0x10(%ebp),%ecx
  1050a1:	8b 10                	mov    (%eax),%edx
  1050a3:	51                   	push   %ecx
  1050a4:	6a 01                	push   $0x1
  1050a6:	8d 4d ef             	lea    -0x11(%ebp),%ecx
  1050a9:	51                   	push   %ecx
  1050aa:	50                   	push   %eax
  1050ab:	ff 52 10             	call   *0x10(%edx)
  1050ae:	83 c4 10             	add    $0x10,%esp
			if (cnt == 0) {
  1050b1:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
  1050b5:	75 14                	jne    1050cb <cmd_resize+0xd3>
K_SYSCALL_DECLARE1_VOID(K_SYSCALL_K_BUSY_WAIT, k_busy_wait, u32_t, usec_to_wait)
  1050b7:	68 e8 03 00 00       	push   $0x3e8
  1050bc:	e8 d8 5b 00 00       	call   10ac99 <z_impl_k_busy_wait>
	for (u16_t i = 0; i < 1000; i++) {
  1050c1:	66 4f                	dec    %di
  1050c3:	58                   	pop    %eax
  1050c4:	75 d5                	jne    10509b <cmd_resize+0xa3>
  1050c6:	e9 dc 00 00 00       	jmp    1051a7 <cmd_resize+0x1af>
			if ((c != SHELL_VT100_ASCII_ESC) &&
  1050cb:	8a 55 ef             	mov    -0x11(%ebp),%dl
  1050ce:	8b 43 08             	mov    0x8(%ebx),%eax
  1050d1:	80 fa 1b             	cmp    $0x1b,%dl
  1050d4:	0f 84 b1 00 00 00    	je     10518b <cmd_resize+0x193>
  1050da:	80 b8 42 01 00 00 1b 	cmpb   $0x1b,0x142(%eax)
  1050e1:	75 b8                	jne    10509b <cmd_resize+0xa3>
			if (c == 'R') { /* End of response from the terminal. */
  1050e3:	80 fa 52             	cmp    $0x52,%dl
  1050e6:	0f 85 9f 00 00 00    	jne    10518b <cmd_resize+0x193>
				shell->ctx->temp_buff[buff_idx] = '\0';
  1050ec:	0f b7 f6             	movzwl %si,%esi
				if (shell->ctx->temp_buff[1] != '[') {
  1050ef:	31 ff                	xor    %edi,%edi
	*y = 0U;
  1050f1:	31 d2                	xor    %edx,%edx
				shell->ctx->temp_buff[buff_idx] = '\0';
  1050f3:	c6 84 30 42 01 00 00 	movb   $0x0,0x142(%eax,%esi,1)
  1050fa:	00 
				if (shell->ctx->temp_buff[1] != '[') {
  1050fb:	80 b8 43 01 00 00 5b 	cmpb   $0x5b,0x143(%eax)
  105102:	0f 85 98 00 00 00    	jne    1051a0 <cmd_resize+0x1a8>
				while (shell->ctx->temp_buff[buff_idx] != ';') {
  105108:	66 0f be 8c 38 44 01 	movsbw 0x144(%eax,%edi,1),%cx
  10510f:	00 00 
  105111:	8d 77 03             	lea    0x3(%edi),%esi
  105114:	80 f9 3b             	cmp    $0x3b,%cl
  105117:	74 12                	je     10512b <cmd_resize+0x133>
					*y = *y * 10U +
  105119:	6b d2 0a             	imul   $0xa,%edx,%edx
  10511c:	47                   	inc    %edi
  10511d:	8d 54 0a d0          	lea    -0x30(%edx,%ecx,1),%edx
					if (buff_idx >=
  105121:	81 ff fe 00 00 00    	cmp    $0xfe,%edi
  105127:	75 df                	jne    105108 <cmd_resize+0x110>
  105129:	eb 7c                	jmp    1051a7 <cmd_resize+0x1af>
				if (++buff_idx >= CONFIG_SHELL_CMD_BUFF_SIZE) {
  10512b:	66 81 fe 00 01       	cmp    $0x100,%si
  105130:	74 75                	je     1051a7 <cmd_resize+0x1af>
  105132:	0f b7 ce             	movzwl %si,%ecx
  105135:	8d 3c 08             	lea    (%eax,%ecx,1),%edi
  105138:	89 7d e8             	mov    %edi,-0x18(%ebp)
	*x = 0U;
  10513b:	31 ff                	xor    %edi,%edi
				while (shell->ctx->temp_buff[buff_idx]
  10513d:	8b 4d e8             	mov    -0x18(%ebp),%ecx
  105140:	66 0f be 89 42 01 00 	movsbw 0x142(%ecx),%cx
  105147:	00 
  105148:	84 c9                	test   %cl,%cl
  10514a:	74 14                	je     105160 <cmd_resize+0x168>
					*x = *x * 10U +
  10514c:	6b ff 0a             	imul   $0xa,%edi,%edi
					(shell->ctx->temp_buff[buff_idx++] -
  10514f:	46                   	inc    %esi
  105150:	ff 45 e8             	incl   -0x18(%ebp)
					if (buff_idx >=
  105153:	66 81 fe ff 00       	cmp    $0xff,%si
					*x = *x * 10U +
  105158:	8d 7c 0f d0          	lea    -0x30(%edi,%ecx,1),%edi
					if (buff_idx >=
  10515c:	76 df                	jbe    10513d <cmd_resize+0x145>
  10515e:	eb 47                	jmp    1051a7 <cmd_resize+0x1af>
		shell->ctx->vt100_ctx.cons.terminal_wid = x;
  105160:	66 81 ff fa 00       	cmp    $0xfa,%di
				shell->ctx->temp_buff[0] = 0;
  105165:	c6 80 42 01 00 00 00 	movb   $0x0,0x142(%eax)
		shell->ctx->vt100_ctx.cons.terminal_wid = x;
  10516c:	76 05                	jbe    105173 <cmd_resize+0x17b>
  10516e:	bf fa 00 00 00       	mov    $0xfa,%edi
		shell->ctx->vt100_ctx.cons.terminal_hei = y;
  105173:	66 81 fa fa 00       	cmp    $0xfa,%dx
		shell->ctx->vt100_ctx.cons.terminal_wid = x;
  105178:	66 89 78 2a          	mov    %di,0x2a(%eax)
		shell->ctx->vt100_ctx.cons.terminal_hei = y;
  10517c:	76 05                	jbe    105183 <cmd_resize+0x18b>
  10517e:	ba fa 00 00 00       	mov    $0xfa,%edx
  105183:	66 89 50 28          	mov    %dx,0x28(%eax)
	int ret_val = 0;
  105187:	31 f6                	xor    %esi,%esi
  105189:	eb 21                	jmp    1051ac <cmd_resize+0x1b4>
			shell->ctx->temp_buff[buff_idx] = c;
  10518b:	0f b7 ce             	movzwl %si,%ecx
			if (++buff_idx > SHELL_CURSOR_POSITION_BUFFER - 1) {
  10518e:	46                   	inc    %esi
  10518f:	66 83 fe 09          	cmp    $0x9,%si
			shell->ctx->temp_buff[buff_idx] = c;
  105193:	88 94 08 42 01 00 00 	mov    %dl,0x142(%eax,%ecx,1)
			if (++buff_idx > SHELL_CURSOR_POSITION_BUFFER - 1) {
  10519a:	0f 86 fb fe ff ff    	jbe    10509b <cmd_resize+0xa3>
				shell->ctx->temp_buff[0] = 0;
  1051a0:	c6 80 42 01 00 00 00 	movb   $0x0,0x142(%eax)
		ret_val = -ENOTSUP;
  1051a7:	be dd ff ff ff       	mov    $0xffffffdd,%esi
	SHELL_VT100_CMD(shell, SHELL_VT100_RESTORECURSOR);
  1051ac:	68 36 e7 10 00       	push   $0x10e736
  1051b1:	68 7b e4 10 00       	push   $0x10e47b
  1051b6:	ff 73 14             	pushl  0x14(%ebx)
  1051b9:	e8 b5 fc ff ff       	call   104e73 <shell_raw_fprintf>
  1051be:	83 c4 0c             	add    $0xc,%esp
	}

	err = terminal_size_get(shell);
	if (err != 0) {
  1051c1:	85 f6                	test   %esi,%esi
  1051c3:	74 1f                	je     1051e4 <cmd_resize+0x1ec>
		shell->ctx->vt100_ctx.cons.terminal_wid =
				SHELL_DEFAULT_TERMINAL_WIDTH;
		shell->ctx->vt100_ctx.cons.terminal_hei =
  1051c5:	8b 43 08             	mov    0x8(%ebx),%eax
				SHELL_DEFAULT_TERMINAL_HEIGHT;
		shell_warn(shell, "No response from the terminal, assumed 80x24"
  1051c8:	be f8 ff ff ff       	mov    $0xfffffff8,%esi
		shell->ctx->vt100_ctx.cons.terminal_hei =
  1051cd:	c7 40 28 18 00 50 00 	movl   $0x500018,0x28(%eax)
		shell_warn(shell, "No response from the terminal, assumed 80x24"
  1051d4:	68 fc e6 10 00       	push   $0x10e6fc
  1051d9:	6a 04                	push   $0x4
  1051db:	53                   	push   %ebx
  1051dc:	e8 3e e7 ff ff       	call   10391f <shell_fprintf>
  1051e1:	83 c4 0c             	add    $0xc,%esp
			   " screen size");
		return -ENOEXEC;
	}

	return 0;
}
  1051e4:	8d 65 f4             	lea    -0xc(%ebp),%esp
  1051e7:	89 f0                	mov    %esi,%eax
  1051e9:	5b                   	pop    %ebx
  1051ea:	5e                   	pop    %esi
  1051eb:	5f                   	pop    %edi
  1051ec:	5d                   	pop    %ebp
  1051ed:	c3                   	ret    

001051ee <remove_from_tail>:
	item->data[len] = '\0';
	sys_dlist_prepend(&history->list, &item->dnode);
}

static void remove_from_tail(struct shell_history *history)
{
  1051ee:	55                   	push   %ebp
	sys_dnode_t *l_item; /* list item */
	struct shell_history_item *h_item;

	l_item = sys_dlist_peek_tail(&history->list);
  1051ef:	8d 50 04             	lea    0x4(%eax),%edx
{
  1051f2:	89 e5                	mov    %esp,%ebp
  1051f4:	53                   	push   %ebx
  1051f5:	51                   	push   %ecx
	return sys_dlist_is_empty(list) ? NULL : list->tail;
  1051f6:	39 50 04             	cmp    %edx,0x4(%eax)
  1051f9:	74 2f                	je     10522a <remove_from_tail+0x3c>
  1051fb:	8b 50 08             	mov    0x8(%eax),%edx
	l_item = sys_dlist_peek_tail(&history->list);
  1051fe:	89 55 f8             	mov    %edx,-0x8(%ebp)
 * @return N/A
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	node->prev->next = node->next;
  105201:	8b 5a 04             	mov    0x4(%edx),%ebx
  105204:	8b 0a                	mov    (%edx),%ecx
  105206:	89 0b                	mov    %ecx,(%ebx)
	node->next->prev = node->prev;
  105208:	89 59 04             	mov    %ebx,0x4(%ecx)
	node->next = NULL;
  10520b:	c7 02 00 00 00 00    	movl   $0x0,(%edx)
	node->prev = NULL;
  105211:	c7 42 04 00 00 00 00 	movl   $0x0,0x4(%edx)
	sys_dlist_remove(l_item);

	h_item = CONTAINER_OF(l_item, struct shell_history_item, dnode);
	k_mem_slab_free(history->mem_slab, (void **)&l_item);
  105218:	8d 55 f8             	lea    -0x8(%ebp),%edx
  10521b:	52                   	push   %edx
  10521c:	ff 30                	pushl  (%eax)
  10521e:	e8 61 4d 00 00       	call   109f84 <k_mem_slab_free>
}
  105223:	8b 5d fc             	mov    -0x4(%ebp),%ebx
	k_mem_slab_free(history->mem_slab, (void **)&l_item);
  105226:	58                   	pop    %eax
  105227:	5a                   	pop    %edx
}
  105228:	c9                   	leave  
  105229:	c3                   	ret    
	l_item = sys_dlist_peek_tail(&history->list);
  10522a:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
	node->prev->next = node->next;
  105231:	a1 04 00 00 00       	mov    0x4,%eax
  105236:	0f 0b                	ud2    

00105238 <shell_history_mode_exit>:
{
  105238:	55                   	push   %ebp
  105239:	89 e5                	mov    %esp,%ebp
	history->current = NULL;
  10523b:	8b 45 08             	mov    0x8(%ebp),%eax
  10523e:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
}
  105245:	5d                   	pop    %ebp
  105246:	c3                   	ret    

00105247 <shell_history_get>:
{
  105247:	55                   	push   %ebp
  105248:	89 e5                	mov    %esp,%ebp
  10524a:	57                   	push   %edi
  10524b:	56                   	push   %esi
  10524c:	8b 45 08             	mov    0x8(%ebp),%eax
  10524f:	53                   	push   %ebx
  105250:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  105253:	8b 75 10             	mov    0x10(%ebp),%esi
	return list->head == list;
  105256:	8b 58 04             	mov    0x4(%eax),%ebx
	if (sys_dlist_is_empty(&history->list)) {
  105259:	8d 50 04             	lea    0x4(%eax),%edx
{
  10525c:	8b 7d 14             	mov    0x14(%ebp),%edi
	if (sys_dlist_is_empty(&history->list)) {
  10525f:	39 d3                	cmp    %edx,%ebx
  105261:	75 09                	jne    10526c <shell_history_get+0x25>
		*len = 0U;
  105263:	66 c7 07 00 00       	movw   $0x0,(%edi)
		return false;
  105268:	31 c0                	xor    %eax,%eax
  10526a:	eb 4e                	jmp    1052ba <shell_history_get+0x73>
	if (!up) { /* button down */
  10526c:	8b 50 0c             	mov    0xc(%eax),%edx
  10526f:	84 c9                	test   %cl,%cl
  105271:	75 16                	jne    105289 <shell_history_get+0x42>
		if (history->current == NULL) {
  105273:	85 d2                	test   %edx,%edx
  105275:	74 ec                	je     105263 <shell_history_get+0x1c>
	return (node == list->head) ? NULL : node->prev;
  105277:	39 d3                	cmp    %edx,%ebx
  105279:	75 09                	jne    105284 <shell_history_get+0x3d>
	history->current = l_item;
  10527b:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
	if (h_item) {
  105282:	eb df                	jmp    105263 <shell_history_get+0x1c>
  105284:	8b 5a 04             	mov    0x4(%edx),%ebx
  105287:	eb 0b                	jmp    105294 <shell_history_get+0x4d>
		sys_dlist_peek_head_not_empty(&history->list) :
  105289:	85 d2                	test   %edx,%edx
  10528b:	74 07                	je     105294 <shell_history_get+0x4d>
	return (node == list->tail) ? NULL : node->next;
  10528d:	39 50 08             	cmp    %edx,0x8(%eax)
  105290:	74 e9                	je     10527b <shell_history_get+0x34>
  105292:	8b 1a                	mov    (%edx),%ebx
	history->current = l_item;
  105294:	89 58 0c             	mov    %ebx,0xc(%eax)
	if (h_item) {
  105297:	85 db                	test   %ebx,%ebx
  105299:	74 c8                	je     105263 <shell_history_get+0x1c>
		memcpy(dst, h_item->data, h_item->len);
  10529b:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  10529f:	50                   	push   %eax
  1052a0:	8d 43 0a             	lea    0xa(%ebx),%eax
  1052a3:	50                   	push   %eax
  1052a4:	56                   	push   %esi
  1052a5:	e8 68 1b 00 00       	call   106e12 <memcpy>
		*len = h_item->len;
  1052aa:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
		memcpy(dst, h_item->data, h_item->len);
  1052ae:	83 c4 0c             	add    $0xc,%esp
		*len = h_item->len;
  1052b1:	66 89 07             	mov    %ax,(%edi)
		dst[*len] = '\0';
  1052b4:	c6 04 06 00          	movb   $0x0,(%esi,%eax,1)
		return true;
  1052b8:	b0 01                	mov    $0x1,%al
}
  1052ba:	8d 65 f4             	lea    -0xc(%ebp),%esp
  1052bd:	5b                   	pop    %ebx
  1052be:	5e                   	pop    %esi
  1052bf:	5f                   	pop    %edi
  1052c0:	5d                   	pop    %ebp
  1052c1:	c3                   	ret    

001052c2 <shell_history_purge>:

void shell_history_purge(struct shell_history *history)
{
  1052c2:	55                   	push   %ebp
  1052c3:	89 e5                	mov    %esp,%ebp
  1052c5:	53                   	push   %ebx
  1052c6:	8b 5d 08             	mov    0x8(%ebp),%ebx
	while (!sys_dlist_is_empty(&history->list)) {
  1052c9:	8d 43 04             	lea    0x4(%ebx),%eax
  1052cc:	39 43 04             	cmp    %eax,0x4(%ebx)
  1052cf:	74 09                	je     1052da <shell_history_purge+0x18>
		remove_from_tail(history);
  1052d1:	89 d8                	mov    %ebx,%eax
  1052d3:	e8 16 ff ff ff       	call   1051ee <remove_from_tail>
  1052d8:	eb ef                	jmp    1052c9 <shell_history_purge+0x7>
	}
}
  1052da:	5b                   	pop    %ebx
  1052db:	5d                   	pop    %ebp
  1052dc:	c3                   	ret    

001052dd <shell_history_put>:

void shell_history_put(struct shell_history *history, u8_t *line, size_t len)
{
  1052dd:	55                   	push   %ebp
  1052de:	89 e5                	mov    %esp,%ebp
  1052e0:	57                   	push   %edi
  1052e1:	56                   	push   %esi
  1052e2:	53                   	push   %ebx
  1052e3:	83 ec 08             	sub    $0x8,%esp
  1052e6:	8b 5d 08             	mov    0x8(%ebp),%ebx
  1052e9:	8b 75 10             	mov    0x10(%ebp),%esi
	sys_dnode_t *l_item; /* list item */
	struct shell_history_item *h_item;

	shell_history_mode_exit(history);

	if (len == 0) {
  1052ec:	85 f6                	test   %esi,%esi
	history->current = NULL;
  1052ee:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
	if (len == 0) {
  1052f5:	0f 84 87 00 00 00    	je     105382 <shell_history_put+0xa5>
		return;
	}

	l_item = sys_dlist_peek_head(&history->list);
  1052fb:	8d 7b 04             	lea    0x4(%ebx),%edi
	return list->head == list;
  1052fe:	8b 43 04             	mov    0x4(%ebx),%eax
	return sys_dlist_is_empty(list) ? NULL : list->head;
  105301:	39 c7                	cmp    %eax,%edi
  105303:	75 09                	jne    10530e <shell_history_put+0x31>
	h_item = CONTAINER_OF(l_item, struct shell_history_item, dnode);
  105305:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

	if (h_item &&
  10530c:	eb 27                	jmp    105335 <shell_history_put+0x58>
	h_item = CONTAINER_OF(l_item, struct shell_history_item, dnode);
  10530e:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (h_item &&
  105311:	85 c0                	test   %eax,%eax
  105313:	74 20                	je     105335 <shell_history_put+0x58>
	   (h_item->len == len) &&
  105315:	0f b7 50 08          	movzwl 0x8(%eax),%edx
	if (h_item &&
  105319:	39 f2                	cmp    %esi,%edx
  10531b:	75 18                	jne    105335 <shell_history_put+0x58>
	   (strncmp(h_item->data, line, CONFIG_SHELL_CMD_BUFF_SIZE) == 0)) {
  10531d:	68 00 01 00 00       	push   $0x100
  105322:	83 c0 0a             	add    $0xa,%eax
  105325:	ff 75 0c             	pushl  0xc(%ebp)
  105328:	50                   	push   %eax
  105329:	e8 7b 1a 00 00       	call   106da9 <strncmp>
  10532e:	83 c4 0c             	add    $0xc,%esp
	   (h_item->len == len) &&
  105331:	85 c0                	test   %eax,%eax
  105333:	74 4d                	je     105382 <shell_history_put+0xa5>
		/* Same command as before, do not store */
		return;
	}

	while (k_mem_slab_alloc(history->mem_slab, (void **)&h_item, K_NO_WAIT)
  105335:	6a 00                	push   $0x0
  105337:	8d 45 f0             	lea    -0x10(%ebp),%eax
  10533a:	50                   	push   %eax
  10533b:	ff 33                	pushl  (%ebx)
  10533d:	e8 dc 4b 00 00       	call   109f1e <k_mem_slab_alloc>
  105342:	83 c4 0c             	add    $0xc,%esp
  105345:	85 c0                	test   %eax,%eax
  105347:	74 09                	je     105352 <shell_history_put+0x75>
			!= 0) {
		/* if no space remove the oldest entry. */
		remove_from_tail(history);
  105349:	89 d8                	mov    %ebx,%eax
  10534b:	e8 9e fe ff ff       	call   1051ee <remove_from_tail>
  105350:	eb e3                	jmp    105335 <shell_history_put+0x58>
	}

	add_to_head(history, h_item, line, len);
  105352:	8b 55 f0             	mov    -0x10(%ebp),%edx
	memcpy(item->data, src, len);
  105355:	89 55 ec             	mov    %edx,-0x14(%ebp)
	item->len = len;
  105358:	66 89 72 08          	mov    %si,0x8(%edx)
	memcpy(item->data, src, len);
  10535c:	56                   	push   %esi
  10535d:	ff 75 0c             	pushl  0xc(%ebp)
  105360:	8d 42 0a             	lea    0xa(%edx),%eax
  105363:	50                   	push   %eax
  105364:	e8 a9 1a 00 00       	call   106e12 <memcpy>
	item->data[len] = '\0';
  105369:	8b 55 ec             	mov    -0x14(%ebp),%edx
	memcpy(item->data, src, len);
  10536c:	83 c4 0c             	add    $0xc,%esp
	item->data[len] = '\0';
  10536f:	c6 44 32 0a 00       	movb   $0x0,0xa(%edx,%esi,1)
	node->next = list->head;
  105374:	8b 43 04             	mov    0x4(%ebx),%eax
	node->prev = list;
  105377:	89 7a 04             	mov    %edi,0x4(%edx)
	node->next = list->head;
  10537a:	89 02                	mov    %eax,(%edx)
	list->head->prev = node;
  10537c:	89 50 04             	mov    %edx,0x4(%eax)
	list->head = node;
  10537f:	89 53 04             	mov    %edx,0x4(%ebx)
}
  105382:	8d 65 f4             	lea    -0xc(%ebp),%esp
  105385:	5b                   	pop    %ebx
  105386:	5e                   	pop    %esi
  105387:	5f                   	pop    %edi
  105388:	5d                   	pop    %ebp
  105389:	c3                   	ret    

0010538a <shell_history_init>:

void shell_history_init(struct shell_history *history)
{
  10538a:	55                   	push   %ebp
  10538b:	89 e5                	mov    %esp,%ebp
  10538d:	8b 45 08             	mov    0x8(%ebp),%eax
	sys_dlist_init(&history->list);
  105390:	8d 50 04             	lea    0x4(%eax),%edx
	history->current = NULL;
  105393:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
	list->head = (sys_dnode_t *)list;
  10539a:	89 50 04             	mov    %edx,0x4(%eax)
	list->tail = (sys_dnode_t *)list;
  10539d:	89 50 08             	mov    %edx,0x8(%eax)
}
  1053a0:	5d                   	pop    %ebp
  1053a1:	c3                   	ret    

001053a2 <dropped>:
		shell_log_backend_disable(shell->log_backend);
	}
}

static void dropped(const struct log_backend *const backend, u32_t cnt)
{
  1053a2:	55                   	push   %ebp
  1053a3:	89 e5                	mov    %esp,%ebp
	const struct shell *shell = (const struct shell *)backend->cb->ctx;
  1053a5:	8b 45 08             	mov    0x8(%ebp),%eax
{
  1053a8:	8b 55 0c             	mov    0xc(%ebp),%edx
	const struct shell *shell = (const struct shell *)backend->cb->ctx;
  1053ab:	8b 40 04             	mov    0x4(%eax),%eax
  1053ae:	8b 00                	mov    (%eax),%eax
	const struct shell_log_backend *log_backend = shell->log_backend;
  1053b0:	8b 48 1c             	mov    0x1c(%eax),%ecx
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
  1053b3:	8b 40 18             	mov    0x18(%eax),%eax
  1053b6:	f0 01 10             	lock add %edx,(%eax)
  1053b9:	8b 41 0c             	mov    0xc(%ecx),%eax
  1053bc:	f0 01 10             	lock add %edx,(%eax)

	atomic_add(&shell->stats->log_lost_cnt, cnt);
	atomic_add(&log_backend->control_block->dropped_cnt, cnt);
}
  1053bf:	5d                   	pop    %ebp
  1053c0:	c3                   	ret    

001053c1 <put>:
{
  1053c1:	55                   	push   %ebp
  1053c2:	89 e5                	mov    %esp,%ebp
  1053c4:	57                   	push   %edi
  1053c5:	56                   	push   %esi
  1053c6:	53                   	push   %ebx
  1053c7:	83 ec 18             	sub    $0x18,%esp
	const struct shell *shell = (const struct shell *)backend->cb->ctx;
  1053ca:	8b 45 08             	mov    0x8(%ebp),%eax
{
  1053cd:	8b 75 0c             	mov    0xc(%ebp),%esi
	const struct shell *shell = (const struct shell *)backend->cb->ctx;
  1053d0:	8b 40 04             	mov    0x4(%eax),%eax
  1053d3:	8b 18                	mov    (%eax),%ebx
			shell->ctx->internal.flags.use_colors;
  1053d5:	8b 43 08             	mov    0x8(%ebx),%eax
  1053d8:	8b b8 60 02 00 00    	mov    0x260(%eax),%edi
	log_msg_get(msg);
  1053de:	56                   	push   %esi
			shell->ctx->internal.flags.use_colors;
  1053df:	d1 ef                	shr    %edi
	log_msg_get(msg);
  1053e1:	e8 d8 c2 ff ff       	call   1016be <log_msg_get>
  1053e6:	58                   	pop    %eax
	switch (shell->log_backend->control_block->state) {
  1053e7:	8b 43 1c             	mov    0x1c(%ebx),%eax
			shell->ctx->internal.flags.use_colors;
  1053ea:	83 e7 01             	and    $0x1,%edi
	switch (shell->log_backend->control_block->state) {
  1053ed:	8b 40 0c             	mov    0xc(%eax),%eax
  1053f0:	8b 40 04             	mov    0x4(%eax),%eax
  1053f3:	83 f8 01             	cmp    $0x1,%eax
  1053f6:	74 30                	je     105428 <put+0x67>
  1053f8:	83 f8 03             	cmp    $0x3,%eax
  1053fb:	0f 85 c8 00 00 00    	jne    1054c9 <put+0x108>
		shell_cmd_line_erase(shell);
  105401:	53                   	push   %ebx
  105402:	e8 81 ee ff ff       	call   104288 <shell_cmd_line_erase>
		msg_process(shell->log_backend->log_output, msg, colors);
  105407:	8b 43 1c             	mov    0x1c(%ebx),%eax
  10540a:	8b 50 08             	mov    0x8(%eax),%edx
		flags |= LOG_OUTPUT_FLAG_COLORS;
  10540d:	89 f8                	mov    %edi,%eax
  10540f:	3c 01                	cmp    $0x1,%al
  105411:	19 c0                	sbb    %eax,%eax
  105413:	83 c0 0f             	add    $0xf,%eax
	log_output_msg_process(log_output, msg, flags);
  105416:	89 04 24             	mov    %eax,(%esp)
  105419:	56                   	push   %esi
  10541a:	52                   	push   %edx
  10541b:	e8 c3 c9 ff ff       	call   101de3 <log_output_msg_process>
  105420:	83 c4 0c             	add    $0xc,%esp
	log_msg_put(msg);
  105423:	e9 a1 00 00 00       	jmp    1054c9 <put+0x108>
		msg_to_fifo(shell, msg);
  105428:	89 75 e0             	mov    %esi,-0x20(%ebp)
	struct shell_log_backend_msg t_msg = {
  10542b:	89 75 e4             	mov    %esi,-0x1c(%ebp)
K_SYSCALL_DECLARE0_RET64(K_SYSCALL_K_UPTIME_GET, k_uptime_get, s64_t)
  10542e:	e8 29 5e 00 00       	call   10b25c <z_impl_k_uptime_get>
K_SYSCALL_DECLARE3(K_SYSCALL_K_MSGQ_PUT, k_msgq_put, int, struct k_msgq *, q, void *, data, s32_t, timeout)
  105433:	8d 55 e4             	lea    -0x1c(%ebp),%edx
	return (u32_t)k_uptime_get();
  105436:	89 45 e8             	mov    %eax,-0x18(%ebp)
			 shell->log_backend->timeout);
  105439:	8b 43 1c             	mov    0x1c(%ebx),%eax
  10543c:	ff 70 10             	pushl  0x10(%eax)
  10543f:	52                   	push   %edx
  105440:	ff 70 04             	pushl  0x4(%eax)
  105443:	e8 ab 4b 00 00       	call   109ff3 <z_impl_k_msgq_put>
  105448:	83 c4 0c             	add    $0xc,%esp
	switch (err) {
  10544b:	83 f8 b0             	cmp    $0xffffffb0,%eax
  10544e:	74 05                	je     105455 <put+0x94>
  105450:	83 f8 f5             	cmp    $0xfffffff5,%eax
  105453:	75 60                	jne    1054b5 <put+0xf4>
	struct k_msgq *msgq = shell->log_backend->msgq;
  105455:	8b 43 1c             	mov    0x1c(%ebx),%eax
  105458:	8b 70 04             	mov    0x4(%eax),%esi
	u32_t timeout = shell->log_backend->timeout;
  10545b:	8b 40 10             	mov    0x10(%eax),%eax
  10545e:	89 45 dc             	mov    %eax,-0x24(%ebp)
K_SYSCALL_DECLARE0_RET64(K_SYSCALL_K_UPTIME_GET, k_uptime_get, s64_t)
  105461:	e8 f6 5d 00 00       	call   10b25c <z_impl_k_uptime_get>
  105466:	89 c7                	mov    %eax,%edi
K_SYSCALL_DECLARE2(K_SYSCALL_K_MSGQ_PEEK, k_msgq_peek, int, struct k_msgq *, q, void *, data)
  105468:	8d 55 ec             	lea    -0x14(%ebp),%edx
  10546b:	52                   	push   %edx
  10546c:	56                   	push   %esi
  10546d:	e8 20 4d 00 00       	call   10a192 <z_impl_k_msgq_peek>
  105472:	5a                   	pop    %edx
		if (err == 0 && ((now - msg.timestamp) > timeout)) {
  105473:	85 c0                	test   %eax,%eax
  105475:	59                   	pop    %ecx
  105476:	75 29                	jne    1054a1 <put+0xe0>
  105478:	89 f8                	mov    %edi,%eax
  10547a:	2b 45 f0             	sub    -0x10(%ebp),%eax
  10547d:	39 45 dc             	cmp    %eax,-0x24(%ebp)
  105480:	73 1f                	jae    1054a1 <put+0xe0>
K_SYSCALL_DECLARE3(K_SYSCALL_K_MSGQ_GET, k_msgq_get, int, struct k_msgq *, q, void *, data, s32_t, timeout)
  105482:	6a 00                	push   $0x0
  105484:	8d 55 ec             	lea    -0x14(%ebp),%edx
  105487:	52                   	push   %edx
  105488:	56                   	push   %esi
  105489:	e8 2a 4c 00 00       	call   10a0b8 <z_impl_k_msgq_get>
  10548e:	83 c4 0c             	add    $0xc,%esp
			log_msg_put(msg.msg);
  105491:	ff 75 ec             	pushl  -0x14(%ebp)
  105494:	e8 59 c3 ff ff       	call   1017f2 <log_msg_put>
  105499:	58                   	pop    %eax
				shell->stats->log_lost_cnt++;
  10549a:	8b 43 18             	mov    0x18(%ebx),%eax
  10549d:	ff 00                	incl   (%eax)
  10549f:	eb c7                	jmp    105468 <put+0xa7>
K_SYSCALL_DECLARE3(K_SYSCALL_K_MSGQ_PUT, k_msgq_put, int, struct k_msgq *, q, void *, data, s32_t, timeout)
  1054a1:	6a 00                	push   $0x0
  1054a3:	8d 45 e0             	lea    -0x20(%ebp),%eax
  1054a6:	50                   	push   %eax
		err = k_msgq_put(shell->log_backend->msgq, &msg, K_NO_WAIT);
  1054a7:	8b 43 1c             	mov    0x1c(%ebx),%eax
  1054aa:	ff 70 04             	pushl  0x4(%eax)
  1054ad:	e8 41 4b 00 00       	call   109ff3 <z_impl_k_msgq_put>
  1054b2:	83 c4 0c             	add    $0xc,%esp
			signal = &shell->ctx->signals[SHELL_SIGNAL_LOG_MSG];
  1054b5:	8b 43 08             	mov    0x8(%ebx),%eax
K_SYSCALL_DECLARE2(K_SYSCALL_K_POLL_SIGNAL_RAISE, k_poll_signal_raise, int, struct k_poll_signal *, signal, int, result)
  1054b8:	6a 00                	push   $0x0
  1054ba:	05 74 02 00 00       	add    $0x274,%eax
  1054bf:	50                   	push   %eax
  1054c0:	e8 8d 62 00 00       	call   10b752 <z_impl_k_poll_signal_raise>
  1054c5:	5a                   	pop    %edx
  1054c6:	59                   	pop    %ecx
  1054c7:	eb 07                	jmp    1054d0 <put+0x10f>
		log_msg_put(msg);
  1054c9:	56                   	push   %esi
  1054ca:	e8 23 c3 ff ff       	call   1017f2 <log_msg_put>
  1054cf:	58                   	pop    %eax
}
  1054d0:	8d 65 f4             	lea    -0xc(%ebp),%esp
  1054d3:	5b                   	pop    %ebx
  1054d4:	5e                   	pop    %esi
  1054d5:	5f                   	pop    %edi
  1054d6:	5d                   	pop    %ebp
  1054d7:	c3                   	ret    

001054d8 <shell_log_backend_output_func>:
{
  1054d8:	55                   	push   %ebp
  1054d9:	89 e5                	mov    %esp,%ebp
  1054db:	53                   	push   %ebx
  1054dc:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	shell_print_stream(ctx, data, length);
  1054df:	53                   	push   %ebx
  1054e0:	ff 75 08             	pushl  0x8(%ebp)
  1054e3:	ff 75 10             	pushl  0x10(%ebp)
  1054e6:	e8 9c ee ff ff       	call   104387 <shell_print_stream>
}
  1054eb:	89 d8                	mov    %ebx,%eax
	shell_print_stream(ctx, data, length);
  1054ed:	83 c4 0c             	add    $0xc,%esp
}
  1054f0:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  1054f3:	c9                   	leave  
  1054f4:	c3                   	ret    

001054f5 <shell_log_backend_enable>:
{
  1054f5:	55                   	push   %ebp
  1054f6:	89 e5                	mov    %esp,%ebp
  1054f8:	56                   	push   %esi
  1054f9:	53                   	push   %ebx
		log_backend_enable(backend->backend, ctx, init_log_level);
  1054fa:	ff 75 10             	pushl  0x10(%ebp)
{
  1054fd:	8b 5d 08             	mov    0x8(%ebp),%ebx
  105500:	8b 75 0c             	mov    0xc(%ebp),%esi
		log_backend_enable(backend->backend, ctx, init_log_level);
  105503:	56                   	push   %esi
  105504:	ff 33                	pushl  (%ebx)
  105506:	e8 a3 be ff ff       	call   1013ae <log_backend_enable>
		log_output_ctx_set(backend->log_output, ctx);
  10550b:	8b 43 08             	mov    0x8(%ebx),%eax
  10550e:	8b 40 04             	mov    0x4(%eax),%eax
		log_backend_enable(backend->backend, ctx, init_log_level);
  105511:	83 c4 0c             	add    $0xc,%esp
 * @param ctx		User context.
 */
static inline void log_output_ctx_set(const struct log_output *log_output,
				      void *ctx)
{
	log_output->control_block->ctx = ctx;
  105514:	89 70 04             	mov    %esi,0x4(%eax)
	backend->control_block->dropped_cnt = 0;
  105517:	8b 43 0c             	mov    0xc(%ebx),%eax
  10551a:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		backend->control_block->state = SHELL_LOG_BACKEND_ENABLED;
  105520:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
}
  105527:	8d 65 f8             	lea    -0x8(%ebp),%esp
  10552a:	5b                   	pop    %ebx
  10552b:	5e                   	pop    %esi
  10552c:	5d                   	pop    %ebp
  10552d:	c3                   	ret    

0010552e <shell_log_backend_disable>:
{
  10552e:	55                   	push   %ebp
  10552f:	89 e5                	mov    %esp,%ebp
  105531:	53                   	push   %ebx
  105532:	83 ec 08             	sub    $0x8,%esp
  105535:	8b 5d 08             	mov    0x8(%ebp),%ebx
K_SYSCALL_DECLARE3(K_SYSCALL_K_MSGQ_GET, k_msgq_get, int, struct k_msgq *, q, void *, data, s32_t, timeout)
  105538:	6a 00                	push   $0x0
  10553a:	8d 45 f4             	lea    -0xc(%ebp),%eax
  10553d:	50                   	push   %eax
  10553e:	ff 73 04             	pushl  0x4(%ebx)
  105541:	e8 72 4b 00 00       	call   10a0b8 <z_impl_k_msgq_get>
  105546:	83 c4 0c             	add    $0xc,%esp
	return (err == 0) ? msg.msg : NULL;
  105549:	85 c0                	test   %eax,%eax
  10554b:	75 10                	jne    10555d <shell_log_backend_disable+0x2f>
  10554d:	8b 45 f4             	mov    -0xc(%ebp),%eax
	while ((msg = msg_from_fifo(backend)) != NULL) {
  105550:	85 c0                	test   %eax,%eax
  105552:	74 09                	je     10555d <shell_log_backend_disable+0x2f>
		log_msg_put(msg);
  105554:	50                   	push   %eax
  105555:	e8 98 c2 ff ff       	call   1017f2 <log_msg_put>
  10555a:	5a                   	pop    %edx
  10555b:	eb db                	jmp    105538 <shell_log_backend_disable+0xa>
	log_backend_disable(backend->backend);
  10555d:	ff 33                	pushl  (%ebx)
  10555f:	e8 9f bf ff ff       	call   101503 <log_backend_disable>
  105564:	58                   	pop    %eax
	backend->control_block->state = SHELL_LOG_BACKEND_DISABLED;
  105565:	8b 43 0c             	mov    0xc(%ebx),%eax
}
  105568:	8b 5d fc             	mov    -0x4(%ebp),%ebx
	backend->control_block->state = SHELL_LOG_BACKEND_DISABLED;
  10556b:	c7 40 04 02 00 00 00 	movl   $0x2,0x4(%eax)
}
  105572:	c9                   	leave  
  105573:	c3                   	ret    

00105574 <shell_log_backend_process>:
{
  105574:	55                   	push   %ebp
  105575:	89 e5                	mov    %esp,%ebp
  105577:	57                   	push   %edi
  105578:	56                   	push   %esi
  105579:	53                   	push   %ebx
  10557a:	8d 4d ec             	lea    -0x14(%ebp),%ecx
  10557d:	83 ec 0c             	sub    $0xc,%esp
  105580:	8b 55 08             	mov    0x8(%ebp),%edx
			(const struct shell *)backend->backend->cb->ctx;
  105583:	8b 02                	mov    (%edx),%eax
	const struct shell *shell =
  105585:	8b 40 04             	mov    0x4(%eax),%eax
  105588:	8b 18                	mov    (%eax),%ebx
			shell->ctx->internal.flags.use_colors;
  10558a:	8b 43 08             	mov    0x8(%ebx),%eax
  10558d:	8b 80 60 02 00 00    	mov    0x260(%eax),%eax
  105593:	6a 00                	push   $0x0
  105595:	d1 e8                	shr    %eax
  105597:	51                   	push   %ecx
  105598:	ff 72 04             	pushl  0x4(%edx)
  10559b:	83 e0 01             	and    $0x1,%eax
  10559e:	88 45 eb             	mov    %al,-0x15(%ebp)
  1055a1:	e8 12 4b 00 00       	call   10a0b8 <z_impl_k_msgq_get>
  1055a6:	83 c4 0c             	add    $0xc,%esp
	return (err == 0) ? msg.msg : NULL;
  1055a9:	8b 55 08             	mov    0x8(%ebp),%edx
  1055ac:	85 c0                	test   %eax,%eax
  1055ae:	74 04                	je     1055b4 <shell_log_backend_process+0x40>
		return false;
  1055b0:	31 c0                	xor    %eax,%eax
  1055b2:	eb 7f                	jmp    105633 <shell_log_backend_process+0xbf>
	return (err == 0) ? msg.msg : NULL;
  1055b4:	8b 7d ec             	mov    -0x14(%ebp),%edi
	if (!msg) {
  1055b7:	89 c6                	mov    %eax,%esi
		return false;
  1055b9:	31 c0                	xor    %eax,%eax
	if (!msg) {
  1055bb:	85 ff                	test   %edi,%edi
  1055bd:	74 74                	je     105633 <shell_log_backend_process+0xbf>
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
  1055bf:	8b 42 0c             	mov    0xc(%edx),%eax
  1055c2:	87 30                	xchg   %esi,(%eax)
	if (dropped) {
  1055c4:	85 f6                	test   %esi,%esi
  1055c6:	74 48                	je     105610 <shell_log_backend_process+0x9c>
		if (colors) {
  1055c8:	80 7d eb 00          	cmpb   $0x0,-0x15(%ebp)
  1055cc:	74 25                	je     1055f3 <shell_log_backend_process+0x7f>
	memcpy(color, &shell->ctx->vt100_ctx.col, sizeof(*color));
  1055ce:	8b 43 08             	mov    0x8(%ebx),%eax
  1055d1:	6a 08                	push   $0x8
  1055d3:	83 c0 30             	add    $0x30,%eax
  1055d6:	8d 4d ec             	lea    -0x14(%ebp),%ecx
  1055d9:	50                   	push   %eax
  1055da:	89 55 08             	mov    %edx,0x8(%ebp)
  1055dd:	51                   	push   %ecx
  1055de:	e8 2f 18 00 00       	call   106e12 <memcpy>
  1055e3:	83 c4 0c             	add    $0xc,%esp
			shell_vt100_color_set(shell, SHELL_VT100_COLOR_RED);
  1055e6:	6a 02                	push   $0x2
  1055e8:	53                   	push   %ebx
  1055e9:	e8 9e ed ff ff       	call   10438c <shell_vt100_color_set>
  1055ee:	58                   	pop    %eax
  1055ef:	5a                   	pop    %edx
  1055f0:	8b 55 08             	mov    0x8(%ebp),%edx
		log_output_dropped_process(backend->log_output, dropped);
  1055f3:	56                   	push   %esi
  1055f4:	ff 72 08             	pushl  0x8(%edx)
  1055f7:	e8 29 c9 ff ff       	call   101f25 <log_output_dropped_process>
  1055fc:	5e                   	pop    %esi
  1055fd:	58                   	pop    %eax
		if (colors) {
  1055fe:	80 7d eb 00          	cmpb   $0x0,-0x15(%ebp)
  105602:	74 0c                	je     105610 <shell_log_backend_process+0x9c>
			shell_vt100_colors_restore(shell, &col);
  105604:	8d 45 ec             	lea    -0x14(%ebp),%eax
  105607:	50                   	push   %eax
  105608:	53                   	push   %ebx
  105609:	e8 ce ed ff ff       	call   1043dc <shell_vt100_colors_restore>
  10560e:	5a                   	pop    %edx
  10560f:	59                   	pop    %ecx
	msg_process(shell->log_backend->log_output, msg, colors);
  105610:	8b 43 1c             	mov    0x1c(%ebx),%eax
		flags |= LOG_OUTPUT_FLAG_COLORS;
  105613:	80 7d eb 01          	cmpb   $0x1,-0x15(%ebp)
	msg_process(shell->log_backend->log_output, msg, colors);
  105617:	8b 50 08             	mov    0x8(%eax),%edx
		flags |= LOG_OUTPUT_FLAG_COLORS;
  10561a:	19 c0                	sbb    %eax,%eax
  10561c:	83 c0 0f             	add    $0xf,%eax
	log_output_msg_process(log_output, msg, flags);
  10561f:	50                   	push   %eax
  105620:	57                   	push   %edi
  105621:	52                   	push   %edx
  105622:	e8 bc c7 ff ff       	call   101de3 <log_output_msg_process>
  105627:	83 c4 0c             	add    $0xc,%esp
	log_msg_put(msg);
  10562a:	57                   	push   %edi
  10562b:	e8 c2 c1 ff ff       	call   1017f2 <log_msg_put>
  105630:	58                   	pop    %eax
	return true;
  105631:	b0 01                	mov    $0x1,%al
}
  105633:	8d 65 f4             	lea    -0xc(%ebp),%esp
  105636:	5b                   	pop    %ebx
  105637:	5e                   	pop    %esi
  105638:	5f                   	pop    %edi
  105639:	5d                   	pop    %ebp
  10563a:	c3                   	ret    

0010563b <panic>:
{
  10563b:	55                   	push   %ebp
  10563c:	89 e5                	mov    %esp,%ebp
  10563e:	53                   	push   %ebx
	const struct shell *shell = (const struct shell *)backend->cb->ctx;
  10563f:	8b 45 08             	mov    0x8(%ebp),%eax
  105642:	8b 40 04             	mov    0x4(%eax),%eax
  105645:	8b 18                	mov    (%eax),%ebx
	err = shell->iface->api->enable(shell->iface, true);
  105647:	8b 43 04             	mov    0x4(%ebx),%eax
  10564a:	8b 10                	mov    (%eax),%edx
  10564c:	6a 01                	push   $0x1
  10564e:	50                   	push   %eax
  10564f:	ff 52 08             	call   *0x8(%edx)
  105652:	59                   	pop    %ecx
	if (err == 0) {
  105653:	85 c0                	test   %eax,%eax
	err = shell->iface->api->enable(shell->iface, true);
  105655:	5a                   	pop    %edx
	if (err == 0) {
  105656:	8b 43 1c             	mov    0x1c(%ebx),%eax
  105659:	75 4e                	jne    1056a9 <panic+0x6e>
		shell->log_backend->control_block->state =
  10565b:	8b 40 0c             	mov    0xc(%eax),%eax
  10565e:	c7 40 04 03 00 00 00 	movl   $0x3,0x4(%eax)
						  shell->ctx->cmd_buff_len);
  105665:	8b 43 08             	mov    0x8(%ebx),%eax
		shell_multiline_data_calc(&shell->ctx->vt100_ctx.cons,
  105668:	83 c0 20             	add    $0x20,%eax
  10566b:	0f b7 50 1c          	movzwl 0x1c(%eax),%edx
  10566f:	52                   	push   %edx
  105670:	0f b7 50 1e          	movzwl 0x1e(%eax),%edx
  105674:	52                   	push   %edx
  105675:	50                   	push   %eax
  105676:	e8 27 e4 ff ff       	call   103aa2 <shell_multiline_data_calc>
  10567b:	83 c4 0c             	add    $0xc,%esp
		shell_op_cursor_vert_move(shell, -1);
  10567e:	6a ff                	push   $0xffffffff
  105680:	53                   	push   %ebx
  105681:	e8 dd e8 ff ff       	call   103f63 <shell_op_cursor_vert_move>
  105686:	59                   	pop    %ecx
  105687:	58                   	pop    %eax
					   -shell->ctx->vt100_ctx.cons.cur_x);
  105688:	8b 43 08             	mov    0x8(%ebx),%eax
  10568b:	0f b7 40 20          	movzwl 0x20(%eax),%eax
		shell_op_cursor_horiz_move(shell,
  10568f:	f7 d8                	neg    %eax
  105691:	50                   	push   %eax
  105692:	53                   	push   %ebx
  105693:	e8 fa e8 ff ff       	call   103f92 <shell_op_cursor_horiz_move>
  105698:	58                   	pop    %eax
  105699:	5a                   	pop    %edx
		while (shell_log_backend_process(shell->log_backend)) {
  10569a:	ff 73 1c             	pushl  0x1c(%ebx)
  10569d:	e8 d2 fe ff ff       	call   105574 <shell_log_backend_process>
  1056a2:	5a                   	pop    %edx
  1056a3:	84 c0                	test   %al,%al
  1056a5:	75 f3                	jne    10569a <panic+0x5f>
  1056a7:	eb 0c                	jmp    1056b5 <panic+0x7a>
}
  1056a9:	8b 5d fc             	mov    -0x4(%ebp),%ebx
		shell_log_backend_disable(shell->log_backend);
  1056ac:	89 45 08             	mov    %eax,0x8(%ebp)
}
  1056af:	c9                   	leave  
		shell_log_backend_disable(shell->log_backend);
  1056b0:	e9 79 fe ff ff       	jmp    10552e <shell_log_backend_disable>
}
  1056b5:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  1056b8:	c9                   	leave  
  1056b9:	c3                   	ret    

001056ba <shell_wildcard_character_exist>:

	return ret_val;
}

bool shell_wildcard_character_exist(const char *str)
{
  1056ba:	55                   	push   %ebp
  1056bb:	89 e5                	mov    %esp,%ebp
  1056bd:	56                   	push   %esi
  1056be:	53                   	push   %ebx
  1056bf:	8b 5d 08             	mov    0x8(%ebp),%ebx
	return str == NULL ? 0U : (u16_t)strlen(str);
  1056c2:	85 db                	test   %ebx,%ebx
  1056c4:	75 04                	jne    1056ca <shell_wildcard_character_exist+0x10>
		if ((str[i] == '?') || (str[i] == '*')) {
			return true;
		}
	}

	return false;
  1056c6:	31 c0                	xor    %eax,%eax
  1056c8:	eb 26                	jmp    1056f0 <shell_wildcard_character_exist+0x36>
  1056ca:	53                   	push   %ebx
  1056cb:	e8 a6 16 00 00       	call   106d76 <strlen>
  1056d0:	5a                   	pop    %edx
	for (size_t i = 0; i < str_len; i++) {
  1056d1:	31 d2                	xor    %edx,%edx
  1056d3:	0f b7 f0             	movzwl %ax,%esi
  1056d6:	39 f2                	cmp    %esi,%edx
  1056d8:	73 ec                	jae    1056c6 <shell_wildcard_character_exist+0xc>
		if ((str[i] == '?') || (str[i] == '*')) {
  1056da:	8a 0c 13             	mov    (%ebx,%edx,1),%cl
  1056dd:	80 f9 3f             	cmp    $0x3f,%cl
  1056e0:	0f 94 c0             	sete   %al
  1056e3:	80 f9 2a             	cmp    $0x2a,%cl
  1056e6:	0f 94 c1             	sete   %cl
  1056e9:	08 c8                	or     %cl,%al
  1056eb:	75 03                	jne    1056f0 <shell_wildcard_character_exist+0x36>
	for (size_t i = 0; i < str_len; i++) {
  1056ed:	42                   	inc    %edx
  1056ee:	eb e6                	jmp    1056d6 <shell_wildcard_character_exist+0x1c>
}
  1056f0:	8d 65 f8             	lea    -0x8(%ebp),%esp
  1056f3:	5b                   	pop    %ebx
  1056f4:	5e                   	pop    %esi
  1056f5:	5d                   	pop    %ebp
  1056f6:	c3                   	ret    

001056f7 <shell_wildcard_prepare>:

void shell_wildcard_prepare(const struct shell *shell)
{
  1056f7:	55                   	push   %ebp
  1056f8:	89 e5                	mov    %esp,%ebp
  1056fa:	53                   	push   %ebx
	 *    buffer with all expanded commands is copied to Command buffer.
	 * 7. Deepest found handler is executed and all lower level commands,
	 *    including expanded commands, are passed as arguments.
	 */

	memset(shell->ctx->temp_buff, 0, sizeof(shell->ctx->temp_buff));
  1056fb:	68 00 01 00 00       	push   $0x100
{
  105700:	8b 5d 08             	mov    0x8(%ebp),%ebx
	memset(shell->ctx->temp_buff, 0, sizeof(shell->ctx->temp_buff));
  105703:	6a 00                	push   $0x0
  105705:	8b 43 08             	mov    0x8(%ebx),%eax
  105708:	05 42 01 00 00       	add    $0x142,%eax
  10570d:	50                   	push   %eax
  10570e:	e8 6e 17 00 00       	call   106e81 <memset>
	memcpy(shell->ctx->temp_buff,
			shell->ctx->cmd_buff,
			shell->ctx->cmd_buff_len);
  105713:	8b 43 08             	mov    0x8(%ebx),%eax
	memset(shell->ctx->temp_buff, 0, sizeof(shell->ctx->temp_buff));
  105716:	83 c4 0c             	add    $0xc,%esp
	memcpy(shell->ctx->temp_buff,
  105719:	0f b7 50 3c          	movzwl 0x3c(%eax),%edx
  10571d:	52                   	push   %edx
			shell->ctx->cmd_buff,
  10571e:	8d 50 42             	lea    0x42(%eax),%edx
	memcpy(shell->ctx->temp_buff,
  105721:	52                   	push   %edx
  105722:	05 42 01 00 00       	add    $0x142,%eax
  105727:	50                   	push   %eax
  105728:	e8 e5 16 00 00       	call   106e12 <memcpy>
  10572d:	83 c4 0c             	add    $0xc,%esp

	/* Function shell_spaces_trim must be used instead of shell_make_argv.
	 * At this point it is important to keep temp_buff as one string.
	 * It will allow to find wildcard commands easily with strstr function.
	 */
	shell_spaces_trim(shell->ctx->temp_buff);
  105730:	8b 43 08             	mov    0x8(%ebx),%eax
  105733:	05 42 01 00 00       	add    $0x142,%eax
  105738:	50                   	push   %eax
  105739:	e8 7e e6 ff ff       	call   103dbc <shell_spaces_trim>
  10573e:	8b 53 08             	mov    0x8(%ebx),%edx
  105741:	59                   	pop    %ecx
  105742:	81 c2 42 01 00 00    	add    $0x142,%edx
  105748:	74 09                	je     105753 <shell_wildcard_prepare+0x5c>
  10574a:	52                   	push   %edx
  10574b:	e8 26 16 00 00       	call   106d76 <strlen>
  105750:	5a                   	pop    %edx
  105751:	eb 02                	jmp    105755 <shell_wildcard_prepare+0x5e>
  105753:	31 c0                	xor    %eax,%eax

	/* +1 for EOS*/
	shell->ctx->cmd_tmp_buff_len = shell_strlen(shell->ctx->temp_buff) + 1;
  105755:	8b 53 08             	mov    0x8(%ebx),%edx
  105758:	40                   	inc    %eax
}
  105759:	8b 5d fc             	mov    -0x4(%ebp),%ebx
	shell->ctx->cmd_tmp_buff_len = shell_strlen(shell->ctx->temp_buff) + 1;
  10575c:	66 89 42 40          	mov    %ax,0x40(%edx)
}
  105760:	c9                   	leave  
  105761:	c3                   	ret    

00105762 <shell_wildcard_process>:


enum shell_wildcard_status shell_wildcard_process(const struct shell *shell,
					      const struct shell_cmd_entry *cmd,
					      const char *pattern)
{
  105762:	55                   	push   %ebp
  105763:	89 e5                	mov    %esp,%ebp
  105765:	57                   	push   %edi
  105766:	56                   	push   %esi
  105767:	53                   	push   %ebx
  105768:	83 ec 24             	sub    $0x24,%esp
	enum shell_wildcard_status ret_val = SHELL_WILDCARD_NOT_FOUND;

	if (cmd == NULL) {
  10576b:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  10576f:	75 0a                	jne    10577b <shell_wildcard_process+0x19>
		return ret_val;
  105771:	bb 03 00 00 00       	mov    $0x3,%ebx
  105776:	e9 49 01 00 00       	jmp    1058c4 <shell_wildcard_process+0x162>
	}

	if (!shell_wildcard_character_exist(pattern)) {
  10577b:	ff 75 10             	pushl  0x10(%ebp)
  10577e:	e8 37 ff ff ff       	call   1056ba <shell_wildcard_character_exist>
  105783:	5a                   	pop    %edx
  105784:	84 c0                	test   %al,%al
  105786:	74 e9                	je     105771 <shell_wildcard_process+0xf>
  105788:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
	size_t cnt = 0;
  10578f:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
	enum shell_wildcard_status ret_val = SHELL_WILDCARD_CMD_NO_MATCH_FOUND;
  105796:	bb 02 00 00 00       	mov    $0x2,%ebx
  10579b:	8b 45 0c             	mov    0xc(%ebp),%eax
	if (cmd->is_dynamic) {
  10579e:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  1057a1:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  1057a4:	f7 da                	neg    %edx
  1057a6:	8b 40 04             	mov    0x4(%eax),%eax
  1057a9:	80 39 00             	cmpb   $0x0,(%ecx)
  1057ac:	74 0f                	je     1057bd <shell_wildcard_process+0x5b>
		cmd->u.dynamic_get(idx, d_entry);
  1057ae:	8d 75 e0             	lea    -0x20(%ebp),%esi
  1057b1:	56                   	push   %esi
  1057b2:	52                   	push   %edx
  1057b3:	ff d0                	call   *%eax
  1057b5:	5f                   	pop    %edi
  1057b6:	58                   	pop    %eax
		*entry = (d_entry->syntax != NULL) ? d_entry : NULL;
  1057b7:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
  1057bb:	eb 09                	jmp    1057c6 <shell_wildcard_process+0x64>
		*entry = (cmd->u.entry[idx].syntax != NULL) ?
  1057bd:	6b 75 d4 ec          	imul   $0xffffffec,-0x2c(%ebp),%esi
  1057c1:	01 c6                	add    %eax,%esi
				&cmd->u.entry[idx] : NULL;
  1057c3:	83 3e 00             	cmpl   $0x0,(%esi)
  1057c6:	74 68                	je     105830 <shell_wildcard_process+0xce>
		if (fnmatch(pattern, p_static_entry->syntax, 0) == 0) {
  1057c8:	6a 00                	push   $0x0
  1057ca:	ff 36                	pushl  (%esi)
  1057cc:	ff 75 10             	pushl  0x10(%ebp)
  1057cf:	e8 24 b7 ff ff       	call   100ef8 <fnmatch>
  1057d4:	83 c4 0c             	add    $0xc,%esp
  1057d7:	85 c0                	test   %eax,%eax
  1057d9:	0f 85 cd 00 00 00    	jne    1058ac <shell_wildcard_process+0x14a>
			ret_val = command_add(shell->ctx->temp_buff,
  1057df:	8b 06                	mov    (%esi),%eax
  1057e1:	66 c7 45 da 00 00    	movw   $0x0,-0x26(%ebp)
  1057e7:	89 45 dc             	mov    %eax,-0x24(%ebp)
					      &shell->ctx->cmd_tmp_buff_len,
  1057ea:	8b 45 08             	mov    0x8(%ebp),%eax
  1057ed:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
  1057f1:	8b 58 08             	mov    0x8(%eax),%ebx
  1057f4:	74 0d                	je     105803 <shell_wildcard_process+0xa1>
  1057f6:	ff 75 dc             	pushl  -0x24(%ebp)
  1057f9:	e8 78 15 00 00       	call   106d76 <strlen>
  1057fe:	5e                   	pop    %esi
  1057ff:	66 89 45 da          	mov    %ax,-0x26(%ebp)
	if ((*buff_len + cmd_len + 1) > CONFIG_SHELL_CMD_BUFF_SIZE) {
  105803:	0f b7 43 40          	movzwl 0x40(%ebx),%eax
  105807:	0f b7 75 da          	movzwl -0x26(%ebp),%esi
  10580b:	8d 44 30 01          	lea    0x1(%eax,%esi,1),%eax
  10580f:	3d 00 01 00 00       	cmp    $0x100,%eax
  105814:	7e 41                	jle    105857 <shell_wildcard_process+0xf5>
				shell_internal_fprintf(shell,
  105816:	ff 75 10             	pushl  0x10(%ebp)
			ret_val = command_add(shell->ctx->temp_buff,
  105819:	bb 01 00 00 00       	mov    $0x1,%ebx
				shell_internal_fprintf(shell,
  10581e:	68 0a eb 10 00       	push   $0x10eb0a
  105823:	6a 04                	push   $0x4
  105825:	ff 75 08             	pushl  0x8(%ebp)
  105828:	e8 7c ec ff ff       	call   1044a9 <shell_internal_fprintf>
  10582d:	83 c4 10             	add    $0x10,%esp
	if (cnt > 0) {
  105830:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
  105834:	0f 84 8a 00 00 00    	je     1058c4 <shell_wildcard_process+0x162>
				     &shell->ctx->cmd_tmp_buff_len, pattern);
  10583a:	8b 45 08             	mov    0x8(%ebp),%eax
  10583d:	8b 40 08             	mov    0x8(%eax),%eax
		shell_pattern_remove(shell->ctx->temp_buff,
  105840:	ff 75 10             	pushl  0x10(%ebp)
  105843:	8d 50 40             	lea    0x40(%eax),%edx
  105846:	05 42 01 00 00       	add    $0x142,%eax
  10584b:	52                   	push   %edx
  10584c:	50                   	push   %eax
  10584d:	e8 8f e4 ff ff       	call   103ce1 <shell_pattern_remove>
  105852:	83 c4 0c             	add    $0xc,%esp
	 * possible. Next it will continue to search for next wildcard pattern
	 * and it will try to add matching commands.
	 */
	ret_val = commands_expand(shell, cmd, pattern);

	return ret_val;
  105855:	eb 6d                	jmp    1058c4 <shell_wildcard_process+0x162>
	completion_addr = strstr(buff, pattern);
  105857:	ff 75 10             	pushl  0x10(%ebp)
			ret_val = command_add(shell->ctx->temp_buff,
  10585a:	8d 83 42 01 00 00    	lea    0x142(%ebx),%eax
	completion_addr = strstr(buff, pattern);
  105860:	50                   	push   %eax
  105861:	e8 36 14 00 00       	call   106c9c <strstr>
  105866:	5a                   	pop    %edx
  105867:	89 c7                	mov    %eax,%edi
  105869:	59                   	pop    %ecx
	if (!completion_addr) {
  10586a:	85 c0                	test   %eax,%eax
  10586c:	74 4c                	je     1058ba <shell_wildcard_process+0x158>
  10586e:	50                   	push   %eax
  10586f:	e8 02 15 00 00       	call   106d76 <strlen>
	memmove(completion_addr + cmd_len + 1, completion_addr, shift + 1);
  105874:	0f b7 c0             	movzwl %ax,%eax
  105877:	40                   	inc    %eax
  105878:	89 04 24             	mov    %eax,(%esp)
  10587b:	57                   	push   %edi
  10587c:	8d 44 37 01          	lea    0x1(%edi,%esi,1),%eax
  105880:	50                   	push   %eax
  105881:	e8 53 15 00 00       	call   106dd9 <memmove>
  105886:	83 c4 0c             	add    $0xc,%esp
	memcpy(completion_addr, cmd, cmd_len);
  105889:	56                   	push   %esi
  10588a:	ff 75 dc             	pushl  -0x24(%ebp)
  10588d:	57                   	push   %edi
  10588e:	e8 7f 15 00 00       	call   106e12 <memcpy>
	completion_addr[cmd_len] = ' ';
  105893:	c6 04 37 20          	movb   $0x20,(%edi,%esi,1)
	*buff_len += cmd_len + 1; /* + 1 for space */
  105897:	66 8b 45 da          	mov    -0x26(%ebp),%ax
  10589b:	66 03 43 40          	add    0x40(%ebx),%ax
			cnt++;
  10589f:	ff 45 d0             	incl   -0x30(%ebp)
	*buff_len += cmd_len + 1; /* + 1 for space */
  1058a2:	40                   	inc    %eax
	memcpy(completion_addr, cmd, cmd_len);
  1058a3:	83 c4 0c             	add    $0xc,%esp
	*buff_len += cmd_len + 1; /* + 1 for space */
  1058a6:	66 89 43 40          	mov    %ax,0x40(%ebx)
			ret_val = command_add(shell->ctx->temp_buff,
  1058aa:	31 db                	xor    %ebx,%ebx
	} while (cmd_idx);
  1058ac:	ff 4d d4             	decl   -0x2c(%ebp)
  1058af:	0f 85 e6 fe ff ff    	jne    10579b <shell_wildcard_process+0x39>
  1058b5:	e9 76 ff ff ff       	jmp    105830 <shell_wildcard_process+0xce>
		return SHELL_WILDCARD_CMD_NO_MATCH_FOUND;
  1058ba:	bb 02 00 00 00       	mov    $0x2,%ebx
  1058bf:	e9 6c ff ff ff       	jmp    105830 <shell_wildcard_process+0xce>
}
  1058c4:	8d 65 f4             	lea    -0xc(%ebp),%esp
  1058c7:	89 d8                	mov    %ebx,%eax
  1058c9:	5b                   	pop    %ebx
  1058ca:	5e                   	pop    %esi
  1058cb:	5f                   	pop    %edi
  1058cc:	5d                   	pop    %ebp
  1058cd:	c3                   	ret    

001058ce <shell_wildcard_finalize>:

void shell_wildcard_finalize(const struct shell *shell)
{
  1058ce:	55                   	push   %ebp
  1058cf:	89 e5                	mov    %esp,%ebp
  1058d1:	53                   	push   %ebx
  1058d2:	8b 5d 08             	mov    0x8(%ebp),%ebx
	memcpy(shell->ctx->cmd_buff,
	       shell->ctx->temp_buff,
	       shell->ctx->cmd_tmp_buff_len);
  1058d5:	8b 43 08             	mov    0x8(%ebx),%eax
	memcpy(shell->ctx->cmd_buff,
  1058d8:	0f b7 50 40          	movzwl 0x40(%eax),%edx
  1058dc:	52                   	push   %edx
	       shell->ctx->temp_buff,
  1058dd:	8d 90 42 01 00 00    	lea    0x142(%eax),%edx
	memcpy(shell->ctx->cmd_buff,
  1058e3:	52                   	push   %edx
  1058e4:	83 c0 42             	add    $0x42,%eax
  1058e7:	50                   	push   %eax
  1058e8:	e8 25 15 00 00       	call   106e12 <memcpy>
	shell->ctx->cmd_buff_len = shell->ctx->cmd_tmp_buff_len;
  1058ed:	8b 43 08             	mov    0x8(%ebx),%eax
	memcpy(shell->ctx->cmd_buff,
  1058f0:	83 c4 0c             	add    $0xc,%esp
}
  1058f3:	8b 5d fc             	mov    -0x4(%ebp),%ebx
	shell->ctx->cmd_buff_len = shell->ctx->cmd_tmp_buff_len;
  1058f6:	8b 50 40             	mov    0x40(%eax),%edx
  1058f9:	66 89 50 3c          	mov    %dx,0x3c(%eax)
}
  1058fd:	c9                   	leave  
  1058fe:	c3                   	ret    

001058ff <console_out>:
 *
 * @return The character passed as input.
 */

static int console_out(int c)
{
  1058ff:	55                   	push   %ebp
  105900:	89 e5                	mov    %esp,%ebp
		return c;
	}

#endif  /* CONFIG_UART_CONSOLE_DEBUG_SERVER_HOOKS */

	if ('\n' == c) {
  105902:	83 7d 08 0a          	cmpl   $0xa,0x8(%ebp)
  105906:	75 10                	jne    105918 <console_out+0x19>
  105908:	a1 10 0b 11 00       	mov    0x110b10,%eax
	api->poll_out(dev, out_char);
  10590d:	8b 50 04             	mov    0x4(%eax),%edx
  105910:	6a 0d                	push   $0xd
  105912:	50                   	push   %eax
  105913:	ff 52 04             	call   *0x4(%edx)
  105916:	59                   	pop    %ecx
  105917:	58                   	pop    %eax
		uart_poll_out(uart_console_dev, '\r');
	}
	uart_poll_out(uart_console_dev, c);
  105918:	a1 10 0b 11 00       	mov    0x110b10,%eax
  10591d:	0f b6 4d 08          	movzbl 0x8(%ebp),%ecx
  105921:	8b 50 04             	mov    0x4(%eax),%edx
  105924:	51                   	push   %ecx
  105925:	50                   	push   %eax
  105926:	ff 52 04             	call   *0x4(%edx)
  105929:	58                   	pop    %eax
  10592a:	5a                   	pop    %edx

	return c;
}
  10592b:	8b 45 08             	mov    0x8(%ebp),%eax
  10592e:	c9                   	leave  
  10592f:	c3                   	ret    

00105930 <uart_console_hook_install>:
 *
 * @return N/A
 */

void uart_console_hook_install(void)
{
  105930:	55                   	push   %ebp
  105931:	89 e5                	mov    %esp,%ebp
	__stdout_hook_install(console_out);
  105933:	68 ff 58 10 00       	push   $0x1058ff
  105938:	e8 1d 23 00 00       	call   107c5a <__stdout_hook_install>
	__printk_hook_install(console_out);
  10593d:	c7 04 24 ff 58 10 00 	movl   $0x1058ff,(%esp)
  105944:	e8 1d ac ff ff       	call   100566 <__printk_hook_install>
  105949:	58                   	pop    %eax
}
  10594a:	c9                   	leave  
  10594b:	c3                   	ret    

0010594c <uart_console_init>:
 * @brief Initialize one UART as the console/debug port
 *
 * @return 0 if successful, otherwise failed.
 */
static int uart_console_init(struct device *arg)
{
  10594c:	55                   	push   %ebp
  10594d:	89 e5                	mov    %esp,%ebp
  10594f:	68 a5 e4 10 00       	push   $0x10e4a5
  105954:	e8 a5 43 00 00       	call   109cfe <z_impl_device_get_binding>
  105959:	5a                   	pop    %edx

	ARG_UNUSED(arg);

	uart_console_dev = device_get_binding(CONFIG_UART_CONSOLE_ON_DEV_NAME);
  10595a:	a3 10 0b 11 00       	mov    %eax,0x110b10
		}
	}
	k_busy_wait(1000000);
#endif

	uart_console_hook_install();
  10595f:	e8 cc ff ff ff       	call   105930 <uart_console_hook_install>

	return 0;
}
  105964:	31 c0                	xor    %eax,%eax
  105966:	c9                   	leave  
  105967:	c3                   	ret    

00105968 <__IoApicSet>:
	__asm__ volatile (
  105968:	9c                   	pushf  
  105969:	fa                   	cli    
  10596a:	59                   	pop    %ecx

	/* lock interrupts to ensure indirect addressing works "atomically" */

	key = irq_lock();

	*(volatile u32_t *)(DT_IOAPIC_BASE_ADDRESS + IOAPIC_IND) = (char)offset;
  10596b:	0f be c0             	movsbl %al,%eax
  10596e:	0f ba e1 09          	bt     $0x9,%ecx
  105972:	a3 00 00 c0 fe       	mov    %eax,0xfec00000
	*((volatile u32_t *)(DT_IOAPIC_BASE_ADDRESS + IOAPIC_DATA)) = value;
  105977:	89 15 10 00 c0 fe    	mov    %edx,0xfec00010
  10597d:	73 01                	jae    105980 <__IoApicSet+0x18>
	__asm__ volatile (
  10597f:	fb                   	sti    

	irq_unlock(key);
}
  105980:	c3                   	ret    

00105981 <IoApicRedUpdateLo>:
 * @return N/A
 */
static void IoApicRedUpdateLo(unsigned int irq,
				u32_t value,
				u32_t mask)
{
  105981:	55                   	push   %ebp
	s32_t offset = IOAPIC_REDTBL + (irq << 1); /* register offset */
  105982:	01 c0                	add    %eax,%eax
{
  105984:	89 e5                	mov    %esp,%ebp
  105986:	56                   	push   %esi
  105987:	53                   	push   %ebx
	s32_t offset = IOAPIC_REDTBL + (irq << 1); /* register offset */
  105988:	83 c0 10             	add    $0x10,%eax
	__asm__ volatile (
  10598b:	9c                   	pushf  
  10598c:	fa                   	cli    
  10598d:	5e                   	pop    %esi
		(DT_IOAPIC_BASE_ADDRESS + IOAPIC_IND)) = (char)offset;
  10598e:	0f be d8             	movsbl %al,%ebx
  105991:	0f ba e6 09          	bt     $0x9,%esi
  105995:	89 1d 00 00 c0 fe    	mov    %ebx,0xfec00000
	value = *((volatile u32_t *)(DT_IOAPIC_BASE_ADDRESS + IOAPIC_DATA));
  10599b:	8b 1d 10 00 c0 fe    	mov    0xfec00010,%ebx
  1059a1:	73 01                	jae    1059a4 <IoApicRedUpdateLo+0x23>
	__asm__ volatile (
  1059a3:	fb                   	sti    
	ioApicRedSetLo(irq, (ioApicRedGetLo(irq) & ~mask) | (value & mask));
  1059a4:	31 da                	xor    %ebx,%edx
  1059a6:	21 ca                	and    %ecx,%edx
  1059a8:	31 da                	xor    %ebx,%edx
}
  1059aa:	5b                   	pop    %ebx
  1059ab:	5e                   	pop    %esi
  1059ac:	5d                   	pop    %ebp
	__IoApicSet(offset, lower32);
  1059ad:	e9 b6 ff ff ff       	jmp    105968 <__IoApicSet>

001059b2 <_ioapic_init>:
{
  1059b2:	55                   	push   %ebp
  1059b3:	89 e5                	mov    %esp,%ebp
  1059b5:	53                   	push   %ebx
  1059b6:	bb 11 00 00 00       	mov    $0x11,%ebx
	__IoApicSet(offset, upper32);
  1059bb:	31 d2                	xor    %edx,%edx
  1059bd:	89 d8                	mov    %ebx,%eax
  1059bf:	e8 a4 ff ff ff       	call   105968 <__IoApicSet>
	__IoApicSet(offset, lower32);
  1059c4:	8d 43 ff             	lea    -0x1(%ebx),%eax
  1059c7:	ba 00 00 01 00       	mov    $0x10000,%edx
  1059cc:	83 c3 02             	add    $0x2,%ebx
  1059cf:	e8 94 ff ff ff       	call   105968 <__IoApicSet>
	for (ix = 0; ix < CONFIG_IOAPIC_NUM_RTES; ix++) {
  1059d4:	83 fb 41             	cmp    $0x41,%ebx
  1059d7:	75 e2                	jne    1059bb <_ioapic_init+0x9>
}
  1059d9:	5b                   	pop    %ebx
  1059da:	31 c0                	xor    %eax,%eax
  1059dc:	5d                   	pop    %ebp
  1059dd:	c3                   	ret    

001059de <z_ioapic_irq_enable>:
{
  1059de:	55                   	push   %ebp
	IoApicRedUpdateLo(irq, 0, IOAPIC_INT_MASK);
  1059df:	b9 00 00 01 00       	mov    $0x10000,%ecx
{
  1059e4:	89 e5                	mov    %esp,%ebp
	IoApicRedUpdateLo(irq, 0, IOAPIC_INT_MASK);
  1059e6:	31 d2                	xor    %edx,%edx
  1059e8:	8b 45 08             	mov    0x8(%ebp),%eax
}
  1059eb:	5d                   	pop    %ebp
	IoApicRedUpdateLo(irq, 0, IOAPIC_INT_MASK);
  1059ec:	e9 90 ff ff ff       	jmp    105981 <IoApicRedUpdateLo>

001059f1 <z_ioapic_irq_disable>:
{
  1059f1:	55                   	push   %ebp
	IoApicRedUpdateLo(irq, IOAPIC_INT_MASK, IOAPIC_INT_MASK);
  1059f2:	b9 00 00 01 00       	mov    $0x10000,%ecx
{
  1059f7:	89 e5                	mov    %esp,%ebp
	IoApicRedUpdateLo(irq, IOAPIC_INT_MASK, IOAPIC_INT_MASK);
  1059f9:	ba 00 00 01 00       	mov    $0x10000,%edx
  1059fe:	8b 45 08             	mov    0x8(%ebp),%eax
}
  105a01:	5d                   	pop    %ebp
	IoApicRedUpdateLo(irq, IOAPIC_INT_MASK, IOAPIC_INT_MASK);
  105a02:	e9 7a ff ff ff       	jmp    105981 <IoApicRedUpdateLo>

00105a07 <z_ioapic_irq_set>:
{
  105a07:	55                   	push   %ebp
	__IoApicSet(offset, upper32);
  105a08:	31 d2                	xor    %edx,%edx
{
  105a0a:	89 e5                	mov    %esp,%ebp
  105a0c:	57                   	push   %edi
  105a0d:	56                   	push   %esi
  105a0e:	53                   	push   %ebx
  105a0f:	8b 5d 08             	mov    0x8(%ebp),%ebx
	s32_t offset = IOAPIC_REDTBL + (irq << 1) + 1; /* register offset */
  105a12:	01 db                	add    %ebx,%ebx
{
  105a14:	8b 75 0c             	mov    0xc(%ebp),%esi
  105a17:	8b 7d 10             	mov    0x10(%ebp),%edi
	s32_t offset = IOAPIC_REDTBL + (irq << 1) + 1; /* register offset */
  105a1a:	8d 43 11             	lea    0x11(%ebx),%eax
	__IoApicSet(offset, upper32);
  105a1d:	e8 46 ff ff ff       	call   105968 <__IoApicSet>
		   (vector & IOAPIC_VEC_MASK) | flags;
  105a22:	89 f0                	mov    %esi,%eax
  105a24:	0f b6 d0             	movzbl %al,%edx
	s32_t offset = IOAPIC_REDTBL + (irq << 1); /* register offset */
  105a27:	8d 43 10             	lea    0x10(%ebx),%eax
}
  105a2a:	5b                   	pop    %ebx
		   (vector & IOAPIC_VEC_MASK) | flags;
  105a2b:	09 fa                	or     %edi,%edx
}
  105a2d:	5e                   	pop    %esi
  105a2e:	5f                   	pop    %edi
	rteValue = IOAPIC_FIXED | IOAPIC_INT_MASK | IOAPIC_PHYSICAL |
  105a2f:	81 ca 00 00 01 00    	or     $0x10000,%edx
}
  105a35:	5d                   	pop    %ebp
	__IoApicSet(offset, lower32);
  105a36:	e9 2d ff ff ff       	jmp    105968 <__IoApicSet>

00105a3b <loapic_init>:
static ALWAYS_INLINE
	u32_t sys_read32(mm_reg_t addr)
{
	u32_t ret;

	__asm__ volatile("movl	%1, %0;\n\t"
  105a3b:	a1 f0 00 e0 fe       	mov    0xfee000f0,%eax
{
	ARG_UNUSED(unused);
	s32_t loApicMaxLvt; /* local APIC Max LVT */

	/* enable the Local APIC */
	LOAPIC_WRITE(LOAPIC_SVR, LOAPIC_READ(LOAPIC_SVR) | LOAPIC_ENABLE);
  105a40:	80 cc 01             	or     $0x1,%ah
	__asm__ volatile("movl	%0, %1;\n\t"
  105a43:	a3 f0 00 e0 fe       	mov    %eax,0xfee000f0
	__asm__ volatile("movl	%1, %0;\n\t"
  105a48:	8b 15 30 00 e0 fe    	mov    0xfee00030,%edx
	loApicMaxLvt = (LOAPIC_READ(LOAPIC_VER) & LOAPIC_MAXLVT_MASK) >> 16;
  105a4e:	c1 ea 10             	shr    $0x10,%edx
	__asm__ volatile("movl	%0, %1;\n\t"
  105a51:	83 c8 ff             	or     $0xffffffff,%eax
  105a54:	0f b6 ca             	movzbl %dl,%ecx
  105a57:	a3 e0 00 e0 fe       	mov    %eax,0xfee000e0
  105a5c:	31 c0                	xor    %eax,%eax
  105a5e:	a3 80 00 e0 fe       	mov    %eax,0xfee00080
  105a63:	a3 e0 03 e0 fe       	mov    %eax,0xfee003e0
  105a68:	a3 80 03 e0 fe       	mov    %eax,0xfee00380
	__asm__ volatile("movl	%1, %0;\n\t"
  105a6d:	a1 50 03 e0 fe       	mov    0xfee00350,%eax
	 * ever be waiting for interrupts on those
	 */
#ifndef CONFIG_JAILHOUSE
	/* set LINT0: extInt, high-polarity, edge-trigger, not-masked */

	LOAPIC_WRITE(LOAPIC_LINT0, (LOAPIC_READ(LOAPIC_LINT0) &
  105a72:	25 ff 58 fe ff       	and    $0xfffe58ff,%eax
  105a77:	80 cc 07             	or     $0x7,%ah
	__asm__ volatile("movl	%0, %1;\n\t"
  105a7a:	a3 50 03 e0 fe       	mov    %eax,0xfee00350
	__asm__ volatile("movl	%1, %0;\n\t"
  105a7f:	a1 60 03 e0 fe       	mov    0xfee00360,%eax
		  LOAPIC_LEVEL | LOAPIC_LVT_MASKED)) |
		(LOAPIC_EXT | LOAPIC_HIGH | LOAPIC_EDGE));

	/* set LINT1: NMI, high-polarity, edge-trigger, not-masked */

	LOAPIC_WRITE(LOAPIC_LINT1, (LOAPIC_READ(LOAPIC_LINT1) &
  105a84:	25 ff 58 fe ff       	and    $0xfffe58ff,%eax
  105a89:	80 cc 04             	or     $0x4,%ah
	__asm__ volatile("movl	%0, %1;\n\t"
  105a8c:	a3 60 03 e0 fe       	mov    %eax,0xfee00360
  105a91:	b8 00 00 01 00       	mov    $0x10000,%eax
  105a96:	a3 20 03 e0 fe       	mov    %eax,0xfee00320
  105a9b:	a3 70 03 e0 fe       	mov    %eax,0xfee00370
	/* lock the Local APIC interrupts */

	LOAPIC_WRITE(LOAPIC_TIMER, LOAPIC_LVT_MASKED);
	LOAPIC_WRITE(LOAPIC_ERROR, LOAPIC_LVT_MASKED);

	if (loApicMaxLvt >= LOAPIC_LVT_P6)
  105aa0:	80 e2 fc             	and    $0xfc,%dl
  105aa3:	74 05                	je     105aaa <loapic_init+0x6f>
  105aa5:	a3 40 03 e0 fe       	mov    %eax,0xfee00340
		LOAPIC_WRITE(LOAPIC_PMC, LOAPIC_LVT_MASKED);

	if (loApicMaxLvt >= LOAPIC_LVT_PENTIUM4)
  105aaa:	83 f9 04             	cmp    $0x4,%ecx
  105aad:	7e 0a                	jle    105ab9 <loapic_init+0x7e>
  105aaf:	b8 00 00 01 00       	mov    $0x10000,%eax
  105ab4:	a3 30 03 e0 fe       	mov    %eax,0xfee00330
  105ab9:	31 c0                	xor    %eax,%eax
  105abb:	a3 b0 00 e0 fe       	mov    %eax,0xfee000b0
#else
	LOAPIC_WRITE(LOAPIC_EOI, 0);
#endif

	return 0;
}
  105ac0:	c3                   	ret    

00105ac1 <z_loapic_int_vec_set>:
 */

void z_loapic_int_vec_set(unsigned int irq, /* IRQ number of the interrupt */
				  unsigned int vector /* vector to copy into the LVT */
				  )
{
  105ac1:	55                   	push   %ebp
  105ac2:	89 e5                	mov    %esp,%ebp
	__asm__ volatile (
  105ac4:	9c                   	pushf  
  105ac5:	fa                   	cli    
  105ac6:	59                   	pop    %ecx

	/* update the 'vector' bits in the LVT */

	oldLevel = irq_lock();
	LOAPIC_WRITE(LOAPIC_TIMER + (irq * 0x10),
		     (LOAPIC_READ(LOAPIC_TIMER + (irq * 0x10)) &
  105ac7:	8b 45 08             	mov    0x8(%ebp),%eax
  105aca:	83 c0 32             	add    $0x32,%eax
  105acd:	c1 e0 04             	shl    $0x4,%eax
	__asm__ volatile("movl	%1, %0;\n\t"
  105ad0:	8b 90 00 00 e0 fe    	mov    -0x1200000(%eax),%edx
  105ad6:	30 d2                	xor    %dl,%dl
	LOAPIC_WRITE(LOAPIC_TIMER + (irq * 0x10),
  105ad8:	0b 55 0c             	or     0xc(%ebp),%edx
	__asm__ volatile("movl	%0, %1;\n\t"
  105adb:	89 90 00 00 e0 fe    	mov    %edx,-0x1200000(%eax)
  105ae1:	0f ba e1 09          	bt     $0x9,%ecx
  105ae5:	73 01                	jae    105ae8 <z_loapic_int_vec_set+0x27>
	__asm__ volatile (
  105ae7:	fb                   	sti    
		      ~LOAPIC_VECTOR) | vector);
	irq_unlock(oldLevel);
}
  105ae8:	5d                   	pop    %ebp
  105ae9:	c3                   	ret    

00105aea <z_loapic_irq_enable>:
 *
 * @return N/A
 */

void z_loapic_irq_enable(unsigned int irq)
{
  105aea:	55                   	push   %ebp
  105aeb:	89 e5                	mov    %esp,%ebp
	__asm__ volatile (
  105aed:	9c                   	pushf  
  105aee:	fa                   	cli    
  105aef:	59                   	pop    %ecx

	/* clear the mask bit in the LVT */

	oldLevel = irq_lock();
	LOAPIC_WRITE(LOAPIC_TIMER + (irq * 0x10),
		     LOAPIC_READ(LOAPIC_TIMER + (irq * 0x10)) &
  105af0:	8b 45 08             	mov    0x8(%ebp),%eax
  105af3:	83 c0 32             	add    $0x32,%eax
  105af6:	c1 e0 04             	shl    $0x4,%eax
	__asm__ volatile("movl	%1, %0;\n\t"
  105af9:	8b 90 00 00 e0 fe    	mov    -0x1200000(%eax),%edx
	LOAPIC_WRITE(LOAPIC_TIMER + (irq * 0x10),
  105aff:	81 e2 ff ff fe ff    	and    $0xfffeffff,%edx
	__asm__ volatile("movl	%0, %1;\n\t"
  105b05:	89 90 00 00 e0 fe    	mov    %edx,-0x1200000(%eax)
  105b0b:	0f ba e1 09          	bt     $0x9,%ecx
  105b0f:	73 01                	jae    105b12 <z_loapic_irq_enable+0x28>
	__asm__ volatile (
  105b11:	fb                   	sti    
		     ~LOAPIC_LVT_MASKED);
	irq_unlock(oldLevel);
}
  105b12:	5d                   	pop    %ebp
  105b13:	c3                   	ret    

00105b14 <z_loapic_irq_disable>:
 *
 * @return N/A
 */

void z_loapic_irq_disable(unsigned int irq)
{
  105b14:	55                   	push   %ebp
  105b15:	89 e5                	mov    %esp,%ebp
	__asm__ volatile (
  105b17:	9c                   	pushf  
  105b18:	fa                   	cli    
  105b19:	59                   	pop    %ecx

	/* set the mask bit in the LVT */

	oldLevel = irq_lock();
	LOAPIC_WRITE(LOAPIC_TIMER + (irq * 0x10),
		     LOAPIC_READ(LOAPIC_TIMER + (irq * 0x10)) |
  105b1a:	8b 45 08             	mov    0x8(%ebp),%eax
  105b1d:	83 c0 32             	add    $0x32,%eax
  105b20:	c1 e0 04             	shl    $0x4,%eax
	__asm__ volatile("movl	%1, %0;\n\t"
  105b23:	8b 90 00 00 e0 fe    	mov    -0x1200000(%eax),%edx
	LOAPIC_WRITE(LOAPIC_TIMER + (irq * 0x10),
  105b29:	81 ca 00 00 01 00    	or     $0x10000,%edx
	__asm__ volatile("movl	%0, %1;\n\t"
  105b2f:	89 90 00 00 e0 fe    	mov    %edx,-0x1200000(%eax)
  105b35:	0f ba e1 09          	bt     $0x9,%ecx
  105b39:	73 01                	jae    105b3c <z_loapic_irq_disable+0x28>
	__asm__ volatile (
  105b3b:	fb                   	sti    
		     LOAPIC_LVT_MASKED);
	irq_unlock(oldLevel);
}
  105b3c:	5d                   	pop    %ebp
  105b3d:	c3                   	ret    

00105b3e <__irq_controller_isr_vector_get>:
	int pReg, block;

	/* Block 0 bits never lit up as these are all exception or reserved
	 * vectors
	 */
	for (block = 7; likely(block > 0); block--) {
  105b3e:	b8 07 00 00 00       	mov    $0x7,%eax
	__asm__ volatile("movl	%1, %0;\n\t"
  105b43:	89 c2                	mov    %eax,%edx
  105b45:	c1 e2 04             	shl    $0x4,%edx
  105b48:	8b 92 00 01 e0 fe    	mov    -0x11fff00(%edx),%edx
		pReg = LOAPIC_READ(LOAPIC_ISR + (block * 0x10));
		if (pReg) {
  105b4e:	85 d2                	test   %edx,%edx
  105b50:	74 10                	je     105b62 <__irq_controller_isr_vector_get+0x24>
	__asm__ volatile (
  105b52:	0f bd d2             	bsr    %edx,%edx
  105b55:	75 05                	jne    105b5c <__irq_controller_isr_vector_get+0x1e>
  105b57:	ba ff ff ff ff       	mov    $0xffffffff,%edx
			return (block * 32) + (find_msb_set(pReg) - 1);
  105b5c:	c1 e0 05             	shl    $0x5,%eax
  105b5f:	01 d0                	add    %edx,%eax
  105b61:	c3                   	ret    
	for (block = 7; likely(block > 0); block--) {
  105b62:	48                   	dec    %eax
  105b63:	75 de                	jne    105b43 <__irq_controller_isr_vector_get+0x5>
		}

	}
	return -1;
  105b65:	83 c8 ff             	or     $0xffffffff,%eax
}
  105b68:	c3                   	ret    

00105b69 <__irq_controller_irq_config>:
 * @param flags interrupt flags
 *
 */
void __irq_controller_irq_config(unsigned int vector, unsigned int irq,
				 u32_t flags)
{
  105b69:	55                   	push   %ebp
  105b6a:	89 e5                	mov    %esp,%ebp
  105b6c:	8b 45 0c             	mov    0xc(%ebp),%eax
  105b6f:	8b 55 08             	mov    0x8(%ebp),%edx
	__ASSERT(irq <= HARDWARE_IRQ_LIMIT, "invalid irq line");

	if (IS_IOAPIC_IRQ(irq)) {
		z_ioapic_irq_set(irq, vector, flags);
  105b72:	89 55 0c             	mov    %edx,0xc(%ebp)
	if (IS_IOAPIC_IRQ(irq)) {
  105b75:	83 f8 17             	cmp    $0x17,%eax
  105b78:	77 09                	ja     105b83 <__irq_controller_irq_config+0x1a>
		z_ioapic_irq_set(irq, vector, flags);
  105b7a:	89 45 08             	mov    %eax,0x8(%ebp)
	} else {
		z_loapic_int_vec_set(irq - LOAPIC_IRQ_BASE, vector);
	}
}
  105b7d:	5d                   	pop    %ebp
		z_ioapic_irq_set(irq, vector, flags);
  105b7e:	e9 84 fe ff ff       	jmp    105a07 <z_ioapic_irq_set>
		z_loapic_int_vec_set(irq - LOAPIC_IRQ_BASE, vector);
  105b83:	83 e8 18             	sub    $0x18,%eax
  105b86:	89 45 08             	mov    %eax,0x8(%ebp)
}
  105b89:	5d                   	pop    %ebp
		z_loapic_int_vec_set(irq - LOAPIC_IRQ_BASE, vector);
  105b8a:	e9 32 ff ff ff       	jmp    105ac1 <z_loapic_int_vec_set>

00105b8f <z_arch_irq_enable>:
 * virtualization.
 *
 * @return N/A
 */
void z_arch_irq_enable(unsigned int irq)
{
  105b8f:	55                   	push   %ebp
  105b90:	89 e5                	mov    %esp,%ebp
  105b92:	8b 45 08             	mov    0x8(%ebp),%eax
	if (IS_IOAPIC_IRQ(irq)) {
  105b95:	83 f8 17             	cmp    $0x17,%eax
  105b98:	77 06                	ja     105ba0 <z_arch_irq_enable+0x11>
		z_ioapic_irq_enable(irq);
	} else {
		z_loapic_irq_enable(irq - LOAPIC_IRQ_BASE);
	}
}
  105b9a:	5d                   	pop    %ebp
		z_ioapic_irq_enable(irq);
  105b9b:	e9 3e fe ff ff       	jmp    1059de <z_ioapic_irq_enable>
		z_loapic_irq_enable(irq - LOAPIC_IRQ_BASE);
  105ba0:	83 e8 18             	sub    $0x18,%eax
  105ba3:	89 45 08             	mov    %eax,0x8(%ebp)
}
  105ba6:	5d                   	pop    %ebp
		z_loapic_irq_enable(irq - LOAPIC_IRQ_BASE);
  105ba7:	e9 3e ff ff ff       	jmp    105aea <z_loapic_irq_enable>

00105bac <z_arch_irq_disable>:
 * virtualization.
 *
 * @return N/A
 */
void z_arch_irq_disable(unsigned int irq)
{
  105bac:	55                   	push   %ebp
  105bad:	89 e5                	mov    %esp,%ebp
  105baf:	8b 45 08             	mov    0x8(%ebp),%eax
	if (IS_IOAPIC_IRQ(irq)) {
  105bb2:	83 f8 17             	cmp    $0x17,%eax
  105bb5:	77 06                	ja     105bbd <z_arch_irq_disable+0x11>
		z_ioapic_irq_disable(irq);
	} else {
		z_loapic_irq_disable(irq - LOAPIC_IRQ_BASE);
	}
}
  105bb7:	5d                   	pop    %ebp
		z_ioapic_irq_disable(irq);
  105bb8:	e9 34 fe ff ff       	jmp    1059f1 <z_ioapic_irq_disable>
		z_loapic_irq_disable(irq - LOAPIC_IRQ_BASE);
  105bbd:	83 e8 18             	sub    $0x18,%eax
  105bc0:	89 45 08             	mov    %eax,0x8(%ebp)
}
  105bc3:	5d                   	pop    %ebp
		z_loapic_irq_disable(irq - LOAPIC_IRQ_BASE);
  105bc4:	e9 4b ff ff ff       	jmp    105b14 <z_loapic_irq_disable>

00105bc9 <isr_register>:
 *  @param isr_func Pointer to the ISR function for the device.
 *  @param isr_dev Pointer to the device that will service the interrupt.
 */
static int isr_register(struct device *dev, isr_t isr_func,
				 struct device *isr_dev)
{
  105bc9:	55                   	push   %ebp
	struct shared_irq_runtime *clients = dev->driver_data;
	const struct shared_irq_config *config = dev->config->config_info;
	u32_t i;

	for (i = 0U; i < config->client_count; i++) {
  105bca:	31 d2                	xor    %edx,%edx
{
  105bcc:	89 e5                	mov    %esp,%ebp
  105bce:	53                   	push   %ebx
  105bcf:	8b 45 08             	mov    0x8(%ebp),%eax
	struct shared_irq_runtime *clients = dev->driver_data;
  105bd2:	8b 48 08             	mov    0x8(%eax),%ecx
	const struct shared_irq_config *config = dev->config->config_info;
  105bd5:	8b 00                	mov    (%eax),%eax
	for (i = 0U; i < config->client_count; i++) {
  105bd7:	8b 40 08             	mov    0x8(%eax),%eax
  105bda:	8b 58 08             	mov    0x8(%eax),%ebx
  105bdd:	39 d3                	cmp    %edx,%ebx
  105bdf:	74 1d                	je     105bfe <isr_register+0x35>
		if (!clients->client[i].isr_dev) {
  105be1:	6b c2 0c             	imul   $0xc,%edx,%eax
  105be4:	83 3c 01 00          	cmpl   $0x0,(%ecx,%eax,1)
  105be8:	75 11                	jne    105bfb <isr_register+0x32>
			clients->client[i].isr_dev = isr_dev;
  105bea:	01 c8                	add    %ecx,%eax
  105bec:	8b 55 10             	mov    0x10(%ebp),%edx
  105bef:	89 10                	mov    %edx,(%eax)
			clients->client[i].isr_func = isr_func;
  105bf1:	8b 55 0c             	mov    0xc(%ebp),%edx
  105bf4:	89 50 04             	mov    %edx,0x4(%eax)
			return 0;
  105bf7:	31 c0                	xor    %eax,%eax
  105bf9:	eb 08                	jmp    105c03 <isr_register+0x3a>
	for (i = 0U; i < config->client_count; i++) {
  105bfb:	42                   	inc    %edx
  105bfc:	eb df                	jmp    105bdd <isr_register+0x14>
		}
	}
	return -EIO;
  105bfe:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
}
  105c03:	5b                   	pop    %ebx
  105c04:	5d                   	pop    %ebp
  105c05:	c3                   	ret    

00105c06 <shared_irq_isr>:
	}
	return -EIO;
}

void shared_irq_isr(struct device *dev)
{
  105c06:	55                   	push   %ebp
  105c07:	89 e5                	mov    %esp,%ebp
  105c09:	57                   	push   %edi
  105c0a:	56                   	push   %esi
	struct shared_irq_runtime *clients = dev->driver_data;
	const struct shared_irq_config *config = dev->config->config_info;
	u32_t i;

	for (i = 0U; i < config->client_count; i++) {
  105c0b:	31 f6                	xor    %esi,%esi
{
  105c0d:	8b 45 08             	mov    0x8(%ebp),%eax
  105c10:	53                   	push   %ebx
	const struct shared_irq_config *config = dev->config->config_info;
  105c11:	8b 10                	mov    (%eax),%edx
  105c13:	8b 58 08             	mov    0x8(%eax),%ebx
  105c16:	8b 7a 08             	mov    0x8(%edx),%edi
	for (i = 0U; i < config->client_count; i++) {
  105c19:	39 77 08             	cmp    %esi,0x8(%edi)
  105c1c:	76 11                	jbe    105c2f <shared_irq_isr+0x29>
		if (clients->client[i].isr_dev) {
  105c1e:	8b 03                	mov    (%ebx),%eax
  105c20:	85 c0                	test   %eax,%eax
  105c22:	74 05                	je     105c29 <shared_irq_isr+0x23>
			clients->client[i].isr_func(clients->client[i].isr_dev);
  105c24:	50                   	push   %eax
  105c25:	ff 53 04             	call   *0x4(%ebx)
  105c28:	58                   	pop    %eax
	for (i = 0U; i < config->client_count; i++) {
  105c29:	46                   	inc    %esi
  105c2a:	83 c3 0c             	add    $0xc,%ebx
  105c2d:	eb ea                	jmp    105c19 <shared_irq_isr+0x13>
		}
	}
}
  105c2f:	8d 65 f4             	lea    -0xc(%ebp),%esp
  105c32:	5b                   	pop    %ebx
  105c33:	5e                   	pop    %esi
  105c34:	5f                   	pop    %edi
  105c35:	5d                   	pop    %ebp
  105c36:	c3                   	ret    

00105c37 <shared_irq_initialize>:
	.disable = disable,
};


int shared_irq_initialize(struct device *dev)
{
  105c37:	55                   	push   %ebp
  105c38:	89 e5                	mov    %esp,%ebp
	const struct shared_irq_config *config = dev->config->config_info;
  105c3a:	8b 45 08             	mov    0x8(%ebp),%eax
  105c3d:	8b 00                	mov    (%eax),%eax
	config->config();
  105c3f:	8b 40 08             	mov    0x8(%eax),%eax
  105c42:	ff 50 04             	call   *0x4(%eax)
	return 0;
}
  105c45:	31 c0                	xor    %eax,%eax
  105c47:	5d                   	pop    %ebp
  105c48:	c3                   	ret    

00105c49 <disable>:
{
  105c49:	55                   	push   %ebp
  105c4a:	89 e5                	mov    %esp,%ebp
  105c4c:	57                   	push   %edi
  105c4d:	56                   	push   %esi
  105c4e:	8b 45 08             	mov    0x8(%ebp),%eax
  105c51:	53                   	push   %ebx
	struct shared_irq_runtime *clients = dev->driver_data;
  105c52:	8b 50 08             	mov    0x8(%eax),%edx
	const struct shared_irq_config *config = dev->config->config_info;
  105c55:	8b 00                	mov    (%eax),%eax
  105c57:	8b 48 08             	mov    0x8(%eax),%ecx
	for (i = 0U; i < config->client_count; i++) {
  105c5a:	31 c0                	xor    %eax,%eax
  105c5c:	8b 59 08             	mov    0x8(%ecx),%ebx
  105c5f:	39 c3                	cmp    %eax,%ebx
  105c61:	74 29                	je     105c8c <disable+0x43>
		if (clients->client[i].isr_dev == isr_dev) {
  105c63:	6b f0 0c             	imul   $0xc,%eax,%esi
  105c66:	8b 7d 0c             	mov    0xc(%ebp),%edi
  105c69:	39 3c 32             	cmp    %edi,(%edx,%esi,1)
  105c6c:	75 1b                	jne    105c89 <disable+0x40>
			clients->client[i].enabled = 0U;
  105c6e:	c7 44 32 08 00 00 00 	movl   $0x0,0x8(%edx,%esi,1)
  105c75:	00 
	for (i = 0U; i < count; i++) {
  105c76:	31 c0                	xor    %eax,%eax
  105c78:	39 c3                	cmp    %eax,%ebx
  105c7a:	74 17                	je     105c93 <disable+0x4a>
		if (clients->client[i].enabled) {
  105c7c:	6b f0 0c             	imul   $0xc,%eax,%esi
  105c7f:	83 7c 32 08 00       	cmpl   $0x0,0x8(%edx,%esi,1)
  105c84:	75 15                	jne    105c9b <disable+0x52>
	for (i = 0U; i < count; i++) {
  105c86:	40                   	inc    %eax
  105c87:	eb ef                	jmp    105c78 <disable+0x2f>
	for (i = 0U; i < config->client_count; i++) {
  105c89:	40                   	inc    %eax
  105c8a:	eb d3                	jmp    105c5f <disable+0x16>
	return -EIO;
  105c8c:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
  105c91:	eb 0a                	jmp    105c9d <disable+0x54>
				irq_disable(config->irq_num);
  105c93:	ff 31                	pushl  (%ecx)
  105c95:	e8 12 ff ff ff       	call   105bac <z_arch_irq_disable>
  105c9a:	58                   	pop    %eax
			return 0;
  105c9b:	31 c0                	xor    %eax,%eax
}
  105c9d:	8d 65 f4             	lea    -0xc(%ebp),%esp
  105ca0:	5b                   	pop    %ebx
  105ca1:	5e                   	pop    %esi
  105ca2:	5f                   	pop    %edi
  105ca3:	5d                   	pop    %ebp
  105ca4:	c3                   	ret    

00105ca5 <enable>:
{
  105ca5:	55                   	push   %ebp
  105ca6:	89 e5                	mov    %esp,%ebp
  105ca8:	57                   	push   %edi
  105ca9:	56                   	push   %esi
  105caa:	8b 45 08             	mov    0x8(%ebp),%eax
  105cad:	53                   	push   %ebx
	struct shared_irq_runtime *clients = dev->driver_data;
  105cae:	8b 50 08             	mov    0x8(%eax),%edx
	const struct shared_irq_config *config = dev->config->config_info;
  105cb1:	8b 00                	mov    (%eax),%eax
  105cb3:	8b 48 08             	mov    0x8(%eax),%ecx
	for (i = 0U; i < config->client_count; i++) {
  105cb6:	31 c0                	xor    %eax,%eax
  105cb8:	8b 71 08             	mov    0x8(%ecx),%esi
  105cbb:	39 c6                	cmp    %eax,%esi
  105cbd:	74 22                	je     105ce1 <enable+0x3c>
		if (clients->client[i].isr_dev == isr_dev) {
  105cbf:	6b d8 0c             	imul   $0xc,%eax,%ebx
  105cc2:	8b 7d 0c             	mov    0xc(%ebp),%edi
  105cc5:	39 3c 1a             	cmp    %edi,(%edx,%ebx,1)
  105cc8:	75 14                	jne    105cde <enable+0x39>
			clients->client[i].enabled = 1U;
  105cca:	c7 44 1a 08 01 00 00 	movl   $0x1,0x8(%edx,%ebx,1)
  105cd1:	00 
			irq_enable(config->irq_num);
  105cd2:	ff 31                	pushl  (%ecx)
  105cd4:	e8 b6 fe ff ff       	call   105b8f <z_arch_irq_enable>
  105cd9:	58                   	pop    %eax
			return 0;
  105cda:	31 c0                	xor    %eax,%eax
  105cdc:	eb 08                	jmp    105ce6 <enable+0x41>
	for (i = 0U; i < config->client_count; i++) {
  105cde:	40                   	inc    %eax
  105cdf:	eb da                	jmp    105cbb <enable+0x16>
	return -EIO;
  105ce1:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
}
  105ce6:	8d 65 f4             	lea    -0xc(%ebp),%esp
  105ce9:	5b                   	pop    %ebx
  105cea:	5e                   	pop    %esi
  105ceb:	5f                   	pop    %edi
  105cec:	5d                   	pop    %ebp
  105ced:	c3                   	ret    

00105cee <shared_irq_config_0_irq>:
		shared_irq_initialize, &shared_irq_0_runtime,
		&shared_irq_config_0, POST_KERNEL,
		CONFIG_SHARED_IRQ_INIT_PRIORITY, &api_funcs);

void shared_irq_config_0_irq(void)
{
  105cee:	55                   	push   %ebp
  105cef:	89 e5                	mov    %esp,%ebp
	IRQ_CONNECT(DT_SHARED_IRQ_SHAREDIRQ0_IRQ_0,
  105cf1:	0f b6 05 8a f8 10 00 	movzbl 0x10f88a,%eax
 * @returns: N/A
 */
static inline void z_irq_controller_irq_config(unsigned int vector,
					      unsigned int irq, u32_t flags)
{
	__irq_controller_irq_config(vector, irq, flags);
  105cf8:	68 00 a0 00 00       	push   $0xa000
  105cfd:	6a 12                	push   $0x12
  105cff:	50                   	push   %eax
  105d00:	e8 64 fe ff ff       	call   105b69 <__irq_controller_irq_config>
  105d05:	83 c4 0c             	add    $0xc,%esp
		    DT_SHARED_IRQ_SHAREDIRQ0_IRQ_0_PRIORITY,
		    shared_irq_isr, DEVICE_GET(shared_irq_0),
		    DT_SHARED_IRQ_SHAREDIRQ0_IRQ_0_SENSE);
}
  105d08:	c9                   	leave  
  105d09:	c3                   	ret    

00105d0a <shared_irq_isr_irq18_stub>:
  105d0a:	68 68 33 11 00       	push   $0x113368
  105d0f:	68 06 5c 10 00       	push   $0x105c06
  105d14:	e9 13 0b 00 00       	jmp    10682c <_interrupt_enter>

00105d19 <pci_set_command_bits>:
	return 0;
}
#endif /* CONFIG_PCI_ENUMERATION */

static void pci_set_command_bits(struct pci_dev_info *dev_info, u32_t bits)
{
  105d19:	55                   	push   %ebp
  105d1a:	89 e5                	mov    %esp,%ebp
  105d1c:	56                   	push   %esi
  105d1d:	53                   	push   %ebx
  105d1e:	89 d6                	mov    %edx,%esi
  105d20:	51                   	push   %ecx
	union pci_addr_reg pci_ctrl_addr;
	u32_t pci_data;

	pci_ctrl_addr.value = 0;
	pci_ctrl_addr.field.func = dev_info->function;
  105d21:	8b 58 0c             	mov    0xc(%eax),%ebx
	pci_ctrl_addr.field.bus = dev_info->bus;
  105d24:	0f b6 50 0c          	movzbl 0xc(%eax),%edx
	pci_ctrl_addr.field.func = dev_info->function;
  105d28:	c1 eb 05             	shr    $0x5,%ebx
	pci_ctrl_addr.field.device = dev_info->dev;
  105d2b:	8a 40 0d             	mov    0xd(%eax),%al
	pci_ctrl_addr.field.bus = dev_info->bus;
  105d2e:	c1 e2 10             	shl    $0x10,%edx
  105d31:	81 e3 00 07 00 00    	and    $0x700,%ebx
	pci_ctrl_addr.field.device = dev_info->dev;
  105d37:	83 e0 1f             	and    $0x1f,%eax
  105d3a:	09 d3                	or     %edx,%ebx
  105d3c:	c1 e0 0b             	shl    $0xb,%eax
	pci_ctrl_addr.field.reg = 1;
  105d3f:	09 c3                	or     %eax,%ebx

	pci_read(DEFAULT_PCI_CONTROLLER, pci_ctrl_addr,
  105d41:	8d 45 f4             	lea    -0xc(%ebp),%eax
  105d44:	50                   	push   %eax
	pci_ctrl_addr.field.reg = 1;
  105d45:	83 cb 04             	or     $0x4,%ebx
	pci_read(DEFAULT_PCI_CONTROLLER, pci_ctrl_addr,
  105d48:	6a 02                	push   $0x2
  105d4a:	53                   	push   %ebx
  105d4b:	6a 00                	push   $0x0
  105d4d:	e8 2f 06 00 00       	call   106381 <pci_read>
  105d52:	83 c4 10             	add    $0x10,%esp
		 sizeof(u16_t), &pci_data);

	pci_data = pci_data | bits;
  105d55:	0b 75 f4             	or     -0xc(%ebp),%esi

	pci_write(DEFAULT_PCI_CONTROLLER, pci_ctrl_addr,
  105d58:	56                   	push   %esi
	pci_data = pci_data | bits;
  105d59:	89 75 f4             	mov    %esi,-0xc(%ebp)
	pci_write(DEFAULT_PCI_CONTROLLER, pci_ctrl_addr,
  105d5c:	6a 02                	push   $0x2
  105d5e:	53                   	push   %ebx
  105d5f:	6a 00                	push   $0x0
  105d61:	e8 8f 06 00 00       	call   1063f5 <pci_write>
  105d66:	83 c4 10             	add    $0x10,%esp
		  sizeof(u16_t), pci_data);
}
  105d69:	8d 65 f8             	lea    -0x8(%ebp),%esp
  105d6c:	5b                   	pop    %ebx
  105d6d:	5e                   	pop    %esi
  105d6e:	5d                   	pop    %ebp
  105d6f:	c3                   	ret    

00105d70 <pci_bus_scan_init>:
	lookup.info.function = PCI_FUNCTION_ANY;
  105d70:	a1 a9 22 11 00       	mov    0x1122a9,%eax
	lookup.info.vendor_id = 0;
  105d75:	c7 05 ad 22 11 00 00 	movl   $0x0,0x1122ad
  105d7c:	00 00 00 
	lookup.info.function = PCI_FUNCTION_ANY;
  105d7f:	25 1f 02 e0 00       	and    $0xe0021f,%eax
  105d84:	0d 00 01 18 00       	or     $0x180100,%eax
  105d89:	a3 a9 22 11 00       	mov    %eax,0x1122a9
	lookup.bus = 0;
  105d8e:	a1 b1 22 11 00       	mov    0x1122b1,%eax
  105d93:	25 00 00 fe 00       	and    $0xfe0000,%eax
  105d98:	0d 00 00 00 02       	or     $0x2000000,%eax
  105d9d:	a3 b1 22 11 00       	mov    %eax,0x1122b1
}
  105da2:	c3                   	ret    

00105da3 <pci_bus_scan>:
{
  105da3:	55                   	push   %ebp
  105da4:	89 e5                	mov    %esp,%ebp
  105da6:	57                   	push   %edi
  105da7:	56                   	push   %esi
  105da8:	53                   	push   %ebx
  105da9:	83 ec 24             	sub    $0x24,%esp
  105dac:	8b 5d 08             	mov    0x8(%ebp),%ebx
		lookup.info.bar == PCI_BAR_ANY &&
  105daf:	66 f7 05 aa 22 11 00 	testw  $0x3fc,0x1122aa
  105db6:	fc 03 
  105db8:	75 3b                	jne    105df5 <pci_bus_scan+0x52>
		!lookup.info.vendor_id &&
  105dba:	83 3d ac 22 11 00 00 	cmpl   $0x0,0x1122ac
  105dc1:	75 32                	jne    105df5 <pci_bus_scan+0x52>
		lookup.info.bar == PCI_BAR_ANY &&
  105dc3:	a1 a8 22 11 00       	mov    0x1122a8,%eax
  105dc8:	89 c2                	mov    %eax,%edx
  105dca:	81 e2 00 e0 01 1c    	and    $0x1c01e000,%edx
  105dd0:	81 fa 00 00 01 18    	cmp    $0x18010000,%edx
  105dd6:	75 1d                	jne    105df5 <pci_bus_scan+0x52>
		lookup.info.function = dev_info->function;
  105dd8:	8b 53 0c             	mov    0xc(%ebx),%edx
  105ddb:	25 ff 1f 02 e0       	and    $0xe0021fff,%eax
  105de0:	81 e2 00 e0 fd 1f    	and    $0x1ffde000,%edx
  105de6:	09 d0                	or     %edx,%eax
  105de8:	a3 a8 22 11 00       	mov    %eax,0x1122a8
		lookup.info.vendor_id = dev_info->vendor_id;
  105ded:	8b 43 10             	mov    0x10(%ebx),%eax
  105df0:	a3 ac 22 11 00       	mov    %eax,0x1122ac
	if (lookup.info.function != PCI_FUNCTION_ANY) {
  105df5:	a1 a8 22 11 00       	mov    0x1122a8,%eax
	pci_ctrl_addr.value = 0;
  105dfa:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
	if (lookup.info.function != PCI_FUNCTION_ANY) {
  105e01:	89 c2                	mov    %eax,%edx
  105e03:	81 e2 00 e0 01 00    	and    $0x1e000,%edx
  105e09:	81 fa 00 00 01 00    	cmp    $0x10000,%edx
  105e0f:	74 7d                	je     105e8e <pci_bus_scan+0xeb>
		lookup.func = lookup.info.function;
  105e11:	c1 e0 02             	shl    $0x2,%eax
  105e14:	8b 15 b0 22 11 00    	mov    0x1122b0,%edx
  105e1a:	25 00 80 07 00       	and    $0x78000,%eax
  105e1f:	81 e2 ff 7f f8 ff    	and    $0xfff87fff,%edx
  105e25:	09 d0                	or     %edx,%eax
  105e27:	a3 b0 22 11 00       	mov    %eax,0x1122b0
  105e2c:	eb 60                	jmp    105e8e <pci_bus_scan+0xeb>
			if (lookup.bus == 0 && lookup.dev == 0) {
  105e2e:	66 f7 c6 ff 7f       	test   $0x7fff,%si
  105e33:	75 73                	jne    105ea8 <pci_bus_scan+0x105>
		for (; lookup.dev < LSPCI_MAX_DEV; lookup.dev++) {
  105e35:	a0 b1 22 11 00       	mov    0x1122b1,%al
  105e3a:	88 c2                	mov    %al,%dl
  105e3c:	83 e0 81             	and    $0xffffff81,%eax
  105e3f:	d0 ea                	shr    %dl
  105e41:	8d 54 12 02          	lea    0x2(%edx,%edx,1),%edx
  105e45:	83 e2 7e             	and    $0x7e,%edx
  105e48:	09 d0                	or     %edx,%eax
  105e4a:	a2 b1 22 11 00       	mov    %al,0x1122b1
  105e4f:	8a 0d b1 22 11 00    	mov    0x1122b1,%cl
  105e55:	8b 35 b0 22 11 00    	mov    0x1122b0,%esi
  105e5b:	88 ca                	mov    %cl,%dl
  105e5d:	89 f0                	mov    %esi,%eax
  105e5f:	d0 ea                	shr    %dl
  105e61:	66 25 ff 01          	and    $0x1ff,%ax
  105e65:	83 e2 3f             	and    $0x3f,%edx
  105e68:	80 fa 1f             	cmp    $0x1f,%dl
  105e6b:	76 c1                	jbe    105e2e <pci_bus_scan+0x8b>
		lookup.dev = 0;
  105e6d:	83 e1 81             	and    $0xffffff81,%ecx
	for (; lookup.bus < lookup.buses; lookup.bus++) {
  105e70:	40                   	inc    %eax
  105e71:	66 25 ff 01          	and    $0x1ff,%ax
		lookup.dev = 0;
  105e75:	88 0d b1 22 11 00    	mov    %cl,0x1122b1
	for (; lookup.bus < lookup.buses; lookup.bus++) {
  105e7b:	8b 15 b0 22 11 00    	mov    0x1122b0,%edx
  105e81:	66 81 e2 00 fe       	and    $0xfe00,%dx
  105e86:	09 d0                	or     %edx,%eax
  105e88:	66 a3 b0 22 11 00    	mov    %ax,0x1122b0
  105e8e:	a1 b0 22 11 00       	mov    0x1122b0,%eax
  105e93:	0f b6 15 b4 22 11 00 	movzbl 0x1122b4,%edx
  105e9a:	66 25 ff 01          	and    $0x1ff,%ax
  105e9e:	66 39 d0             	cmp    %dx,%ax
  105ea1:	72 ac                	jb     105e4f <pci_bus_scan+0xac>
  105ea3:	e9 be 04 00 00       	jmp    106366 <pci_bus_scan+0x5c3>
			pci_ctrl_addr.field.bus = lookup.bus;
  105ea8:	8b 4d dc             	mov    -0x24(%ebp),%ecx
			pci_ctrl_addr.field.device = lookup.dev;
  105eab:	83 e2 1f             	and    $0x1f,%edx
			pci_ctrl_addr.field.bus = lookup.bus;
  105eae:	0f b6 c0             	movzbl %al,%eax
  105eb1:	c1 e0 10             	shl    $0x10,%eax
  105eb4:	81 e1 ff 07 00 ff    	and    $0xff0007ff,%ecx
			pci_ctrl_addr.field.device = lookup.dev;
  105eba:	c1 e2 0b             	shl    $0xb,%edx
  105ebd:	09 c8                	or     %ecx,%eax
  105ebf:	09 d0                	or     %edx,%eax
  105ec1:	89 45 dc             	mov    %eax,-0x24(%ebp)
	pci_read(DEFAULT_PCI_CONTROLLER, pci_ctrl_addr,
  105ec4:	89 c6                	mov    %eax,%esi
  105ec6:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  105ec9:	81 e6 ff f8 ff ff    	and    $0xfffff8ff,%esi
  105ecf:	50                   	push   %eax
  105ed0:	6a 04                	push   $0x4
  105ed2:	56                   	push   %esi
  105ed3:	6a 00                	push   $0x0
  105ed5:	e8 a7 04 00 00       	call   106381 <pci_read>
  105eda:	83 c4 10             	add    $0x10,%esp
	if (pci_data == 0xffffffff) {
  105edd:	83 7d e4 ff          	cmpl   $0xffffffff,-0x1c(%ebp)
  105ee1:	75 32                	jne    105f15 <pci_bus_scan+0x172>
			if (lookup.info.function != PCI_FUNCTION_ANY) {
  105ee3:	8b 15 a8 22 11 00    	mov    0x1122a8,%edx
  105ee9:	89 d0                	mov    %edx,%eax
  105eeb:	25 00 e0 01 00       	and    $0x1e000,%eax
  105ef0:	3d 00 00 01 00       	cmp    $0x10000,%eax
  105ef5:	a1 b0 22 11 00       	mov    0x1122b0,%eax
  105efa:	0f 84 57 04 00 00    	je     106357 <pci_bus_scan+0x5b4>
				lookup.func = lookup.info.function;
  105f00:	c1 e2 02             	shl    $0x2,%edx
  105f03:	25 ff 7f f8 ff       	and    $0xfff87fff,%eax
  105f08:	81 e2 00 80 07 00    	and    $0x78000,%edx
  105f0e:	09 d0                	or     %edx,%eax
  105f10:	e9 47 04 00 00       	jmp    10635c <pci_bus_scan+0x5b9>
	pci_read(DEFAULT_PCI_CONTROLLER, pci_ctrl_addr, sizeof(header_type),
  105f15:	8d 55 f0             	lea    -0x10(%ebp),%edx
  105f18:	89 f0                	mov    %esi,%eax
  105f1a:	52                   	push   %edx
	pci_ctrl_addr.field.offset = 0;
  105f1b:	b0 0c                	mov    $0xc,%al
	pci_read(DEFAULT_PCI_CONTROLLER, pci_ctrl_addr, sizeof(header_type),
  105f1d:	6a 04                	push   $0x4
  105f1f:	50                   	push   %eax
  105f20:	6a 00                	push   $0x0
  105f22:	e8 5a 04 00 00       	call   106381 <pci_read>
	return header_type >> 16 & 0x80;
  105f27:	0f b7 45 f2          	movzwl -0xe(%ebp),%eax
  105f2b:	25 80 00 00 00       	and    $0x80,%eax
	pci_read(DEFAULT_PCI_CONTROLLER, pci_ctrl_addr, sizeof(header_type),
  105f30:	83 c4 10             	add    $0x10,%esp
	return header_type >> 16 & 0x80;
  105f33:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	for (; lookup.func < LSPCI_MAX_FUNC;
  105f36:	8b 3d b0 22 11 00    	mov    0x1122b0,%edi
  105f3c:	8b 15 a8 22 11 00    	mov    0x1122a8,%edx
  105f42:	c1 ef 0f             	shr    $0xf,%edi
  105f45:	89 d1                	mov    %edx,%ecx
  105f47:	89 f8                	mov    %edi,%eax
  105f49:	81 e1 00 e0 01 00    	and    $0x1e000,%ecx
  105f4f:	83 e0 0f             	and    $0xf,%eax
  105f52:	3c 07                	cmp    $0x7,%al
  105f54:	77 8d                	ja     105ee3 <pci_bus_scan+0x140>
		if (lookup.info.function != PCI_FUNCTION_ANY &&
  105f56:	81 f9 00 00 01 00    	cmp    $0x10000,%ecx
  105f5c:	74 0e                	je     105f6c <pci_bus_scan+0x1c9>
		    lookup.func != lookup.info.function) {
  105f5e:	c1 ea 0d             	shr    $0xd,%edx
  105f61:	83 e2 0f             	and    $0xf,%edx
		if (lookup.info.function != PCI_FUNCTION_ANY &&
  105f64:	38 c2                	cmp    %al,%dl
  105f66:	0f 85 77 ff ff ff    	jne    105ee3 <pci_bus_scan+0x140>
		if (lookup.func != 0 && !multi_function) {
  105f6c:	8b 15 b0 22 11 00    	mov    0x1122b0,%edx
  105f72:	81 e2 00 80 07 00    	and    $0x78000,%edx
  105f78:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
  105f7c:	75 08                	jne    105f86 <pci_bus_scan+0x1e3>
  105f7e:	85 d2                	test   %edx,%edx
  105f80:	0f 85 5d ff ff ff    	jne    105ee3 <pci_bus_scan+0x140>
		pci_ctrl_addr.field.func = lookup.func;
  105f86:	83 e0 07             	and    $0x7,%eax
		if (lookup.func != 0) {
  105f89:	85 d2                	test   %edx,%edx
		pci_ctrl_addr.field.func = lookup.func;
  105f8b:	89 c7                	mov    %eax,%edi
		if (lookup.func != 0) {
  105f8d:	75 33                	jne    105fc2 <pci_bus_scan+0x21f>
		pci_header_get(DEFAULT_PCI_CONTROLLER,
  105f8f:	89 f8                	mov    %edi,%eax
  105f91:	81 e6 ff f8 ff ff    	and    $0xfffff8ff,%esi
  105f97:	83 e0 07             	and    $0x7,%eax
  105f9a:	68 a0 fd 10 00       	push   $0x10fda0
  105f9f:	c1 e0 08             	shl    $0x8,%eax
  105fa2:	09 c6                	or     %eax,%esi
  105fa4:	56                   	push   %esi
  105fa5:	6a 00                	push   $0x0
  105fa7:	e8 b7 04 00 00       	call   106463 <pci_header_get>
  105fac:	83 c4 0c             	add    $0xc,%esp
		if (pci_dev_header.field.class == PCI_CLASS_BRIDGE_CTLR &&
  105faf:	66 81 3d aa fd 10 00 	cmpw   $0x604,0x10fdaa
  105fb6:	04 06 
  105fb8:	75 5c                	jne    106016 <pci_bus_scan+0x273>
			lookup.buses++;
  105fba:	fe 05 b4 22 11 00    	incb   0x1122b4
  105fc0:	eb 54                	jmp    106016 <pci_bus_scan+0x273>
			pci_read(DEFAULT_PCI_CONTROLLER, pci_ctrl_addr,
  105fc2:	89 f8                	mov    %edi,%eax
  105fc4:	81 e6 ff f8 ff ff    	and    $0xfffff8ff,%esi
  105fca:	83 e0 07             	and    $0x7,%eax
  105fcd:	c1 e0 08             	shl    $0x8,%eax
  105fd0:	09 c6                	or     %eax,%esi
  105fd2:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  105fd5:	50                   	push   %eax
  105fd6:	6a 04                	push   $0x4
  105fd8:	56                   	push   %esi
  105fd9:	6a 00                	push   $0x0
  105fdb:	e8 a1 03 00 00       	call   106381 <pci_read>
  105fe0:	83 c4 10             	add    $0x10,%esp
			if (pci_data == 0xffffffff) {
  105fe3:	83 7d e4 ff          	cmpl   $0xffffffff,-0x1c(%ebp)
  105fe7:	75 a6                	jne    105f8f <pci_bus_scan+0x1ec>
	     lookup.baridx = 0, lookup.barofs = 0, lookup.func++) {
  105fe9:	66 81 25 b2 22 11 00 	andw   $0xfe07,0x1122b2
  105ff0:	07 fe 
  105ff2:	8b 15 b0 22 11 00    	mov    0x1122b0,%edx
  105ff8:	89 d0                	mov    %edx,%eax
  105ffa:	81 e2 ff 7f f8 ff    	and    $0xfff87fff,%edx
  106000:	c1 e8 0f             	shr    $0xf,%eax
  106003:	40                   	inc    %eax
  106004:	83 e0 0f             	and    $0xf,%eax
  106007:	c1 e0 0f             	shl    $0xf,%eax
  10600a:	09 d0                	or     %edx,%eax
  10600c:	a3 b0 22 11 00       	mov    %eax,0x1122b0
  106011:	e9 20 ff ff ff       	jmp    105f36 <pci_bus_scan+0x193>
		if (lookup.info.class_type &&
  106016:	66 a1 aa 22 11 00    	mov    0x1122aa,%ax
  10601c:	66 a9 fc 03          	test   $0x3fc,%ax
  106020:	74 0c                	je     10602e <pci_bus_scan+0x28b>
		    pci_dev_header.field.class != lookup.info.class_type) {
  106022:	66 c1 e8 02          	shr    $0x2,%ax
		if (lookup.info.class_type &&
  106026:	38 05 ab fd 10 00    	cmp    %al,0x10fdab
  10602c:	75 bb                	jne    105fe9 <pci_bus_scan+0x246>
		if (lookup.info.vendor_id && lookup.info.device_id &&
  10602e:	66 83 3d ac 22 11 00 	cmpw   $0x0,0x1122ac
  106035:	00 
  106036:	74 17                	je     10604f <pci_bus_scan+0x2ac>
  106038:	66 83 3d ae 22 11 00 	cmpw   $0x0,0x1122ae
  10603f:	00 
  106040:	74 0d                	je     10604f <pci_bus_scan+0x2ac>
  106042:	a1 a0 fd 10 00       	mov    0x10fda0,%eax
  106047:	39 05 ac 22 11 00    	cmp    %eax,0x1122ac
  10604d:	75 9a                	jne    105fe9 <pci_bus_scan+0x246>
		if ((pci_dev_header.field.hdr_type & 0x7f) == 1) {
  10604f:	a0 ae fd 10 00       	mov    0x10fdae,%al
  106054:	83 e0 7f             	and    $0x7f,%eax
			max_bars = PCI_MAX_BARS;
  106057:	fe c8                	dec    %al
  106059:	0f 95 c0             	setne  %al
  10605c:	0f b6 c0             	movzbl %al,%eax
  10605f:	8d 04 85 02 00 00 00 	lea    0x2(,%eax,4),%eax
  106066:	89 45 e0             	mov    %eax,-0x20(%ebp)
  106069:	89 f8                	mov    %edi,%eax
  10606b:	0f b6 c0             	movzbl %al,%eax
  10606e:	89 45 d0             	mov    %eax,-0x30(%ebp)
		for (; lookup.barofs < max_bars;
  106071:	66 a1 b2 22 11 00    	mov    0x1122b2,%ax
  106077:	66 c1 e8 06          	shr    $0x6,%ax
  10607b:	83 e0 07             	and    $0x7,%eax
  10607e:	0f b6 d0             	movzbl %al,%edx
  106081:	39 55 e0             	cmp    %edx,-0x20(%ebp)
  106084:	0f 8e 5f ff ff ff    	jle    105fe9 <pci_bus_scan+0x246>
	pci_ctrl_addr.field.reg = 4 + lookup.barofs;
  10608a:	83 c0 04             	add    $0x4,%eax
  10608d:	8b 55 d0             	mov    -0x30(%ebp),%edx
  106090:	88 45 d8             	mov    %al,-0x28(%ebp)
  106093:	81 e6 ff f8 ff ff    	and    $0xfffff8ff,%esi
  106099:	c1 e2 08             	shl    $0x8,%edx
	pci_read(DEFAULT_PCI_CONTROLLER, pci_ctrl_addr,
  10609c:	8b 7d d8             	mov    -0x28(%ebp),%edi
  10609f:	83 e7 0f             	and    $0xf,%edi
  1060a2:	09 d6                	or     %edx,%esi
  1060a4:	8d 04 bd 00 00 00 00 	lea    0x0(,%edi,4),%eax
  1060ab:	89 f7                	mov    %esi,%edi
  1060ad:	81 e7 03 ff ff ff    	and    $0xffffff03,%edi
  1060b3:	09 c7                	or     %eax,%edi
  1060b5:	8d 45 e8             	lea    -0x18(%ebp),%eax
  1060b8:	50                   	push   %eax
  1060b9:	6a 04                	push   $0x4
  1060bb:	57                   	push   %edi
  1060bc:	6a 00                	push   $0x0
  1060be:	e8 be 02 00 00       	call   106381 <pci_read>
  1060c3:	83 c4 10             	add    $0x10,%esp
	pci_read(DEFAULT_PCI_CONTROLLER, pci_ctrl_addr,
  1060c6:	8d 45 f0             	lea    -0x10(%ebp),%eax
  1060c9:	50                   	push   %eax
  1060ca:	6a 04                	push   $0x4
  1060cc:	57                   	push   %edi
  1060cd:	6a 00                	push   $0x0
  1060cf:	e8 ad 02 00 00       	call   106381 <pci_read>
  1060d4:	83 c4 10             	add    $0x10,%esp
	pci_write(DEFAULT_PCI_CONTROLLER, pci_ctrl_addr,
  1060d7:	6a ff                	push   $0xffffffff
  1060d9:	6a 04                	push   $0x4
  1060db:	57                   	push   %edi
  1060dc:	6a 00                	push   $0x0
  1060de:	e8 12 03 00 00       	call   1063f5 <pci_write>
  1060e3:	83 c4 10             	add    $0x10,%esp
	pci_read(DEFAULT_PCI_CONTROLLER, pci_ctrl_addr,
  1060e6:	8d 45 ec             	lea    -0x14(%ebp),%eax
  1060e9:	50                   	push   %eax
  1060ea:	6a 04                	push   $0x4
  1060ec:	57                   	push   %edi
  1060ed:	6a 00                	push   $0x0
  1060ef:	e8 8d 02 00 00       	call   106381 <pci_read>
  1060f4:	83 c4 10             	add    $0x10,%esp
	pci_write(DEFAULT_PCI_CONTROLLER, pci_ctrl_addr,
  1060f7:	ff 75 f0             	pushl  -0x10(%ebp)
  1060fa:	6a 04                	push   $0x4
  1060fc:	57                   	push   %edi
  1060fd:	6a 00                	push   $0x0
  1060ff:	e8 f1 02 00 00       	call   1063f5 <pci_write>
	if (*config != 0xffffffff && *config != 0U) {
  106104:	8b 4d ec             	mov    -0x14(%ebp),%ecx
	pci_write(DEFAULT_PCI_CONTROLLER, pci_ctrl_addr,
  106107:	83 c4 10             	add    $0x10,%esp
	if (*config != 0xffffffff && *config != 0U) {
  10610a:	8d 41 ff             	lea    -0x1(%ecx),%eax
  10610d:	83 f8 fd             	cmp    $0xfffffffd,%eax
  106110:	0f 87 fd 01 00 00    	ja     106313 <pci_bus_scan+0x570>
	if (BAR_SPACE(bar_config) == BAR_SPACE_MEM) {
  106116:	f6 c1 01             	test   $0x1,%cl
  106119:	8a 53 0e             	mov    0xe(%ebx),%dl
  10611c:	75 7d                	jne    10619b <pci_bus_scan+0x3f8>
  10611e:	66 a1 b2 22 11 00    	mov    0x1122b2,%ax
		dev_info->mem_type = BAR_SPACE_MEM;
  106124:	83 e2 fd             	and    $0xfffffffd,%edx
  106127:	66 c1 e8 06          	shr    $0x6,%ax
		if (BAR_TYPE(bar_config) == BAR_TYPE_64BIT) {
  10612b:	83 e1 06             	and    $0x6,%ecx
  10612e:	83 e0 07             	and    $0x7,%eax
		dev_info->mem_type = BAR_SPACE_MEM;
  106131:	88 53 0e             	mov    %dl,0xe(%ebx)
		if (BAR_TYPE(bar_config) == BAR_TYPE_64BIT) {
  106134:	83 f9 04             	cmp    $0x4,%ecx
  106137:	74 07                	je     106140 <pci_bus_scan+0x39d>
		mask = ~0xf;
  106139:	b9 f0 ff ff ff       	mov    $0xfffffff0,%ecx
  10613e:	eb 66                	jmp    1061a6 <pci_bus_scan+0x403>
  106140:	40                   	inc    %eax
			if (++lookup.barofs >= max_bars) {
  106141:	66 8b 15 b2 22 11 00 	mov    0x1122b2,%dx
  106148:	66 81 e2 3f fe       	and    $0xfe3f,%dx
  10614d:	83 e0 07             	and    $0x7,%eax
  106150:	89 c1                	mov    %eax,%ecx
  106152:	83 e1 07             	and    $0x7,%ecx
  106155:	c1 e1 06             	shl    $0x6,%ecx
  106158:	09 ca                	or     %ecx,%edx
  10615a:	0f b6 c0             	movzbl %al,%eax
  10615d:	66 89 15 b2 22 11 00 	mov    %dx,0x1122b2
  106164:	39 45 e0             	cmp    %eax,-0x20(%ebp)
  106167:	0f 8e a6 01 00 00    	jle    106313 <pci_bus_scan+0x570>
			pci_ctrl_addr.field.reg++;
  10616d:	8a 45 d8             	mov    -0x28(%ebp),%al
			pci_read(DEFAULT_PCI_CONTROLLER, pci_ctrl_addr,
  106170:	81 e7 03 ff ff ff    	and    $0xffffff03,%edi
			pci_ctrl_addr.field.reg++;
  106176:	40                   	inc    %eax
			pci_read(DEFAULT_PCI_CONTROLLER, pci_ctrl_addr,
  106177:	83 e0 1f             	and    $0x1f,%eax
  10617a:	c1 e0 02             	shl    $0x2,%eax
  10617d:	09 c7                	or     %eax,%edi
  10617f:	8d 45 f0             	lea    -0x10(%ebp),%eax
  106182:	50                   	push   %eax
  106183:	6a 04                	push   $0x4
  106185:	57                   	push   %edi
  106186:	6a 00                	push   $0x0
  106188:	e8 f4 01 00 00       	call   106381 <pci_read>
  10618d:	83 c4 10             	add    $0x10,%esp
			if (bar_hival) {
  106190:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
  106194:	74 a3                	je     106139 <pci_bus_scan+0x396>
  106196:	e9 78 01 00 00       	jmp    106313 <pci_bus_scan+0x570>
		dev_info->mem_type = BAR_SPACE_IO;
  10619b:	83 ca 02             	or     $0x2,%edx
		mask = ~0x3;
  10619e:	b9 fc ff ff ff       	mov    $0xfffffffc,%ecx
		dev_info->mem_type = BAR_SPACE_IO;
  1061a3:	88 53 0e             	mov    %dl,0xe(%ebx)
	dev_info->addr = bar_value & mask;
  1061a6:	8b 45 e8             	mov    -0x18(%ebp),%eax
  1061a9:	21 c8                	and    %ecx,%eax
	if (addr != 0U) {
  1061ab:	23 4d ec             	and    -0x14(%ebp),%ecx
	dev_info->addr = bar_value & mask;
  1061ae:	89 03                	mov    %eax,(%ebx)
	if (addr != 0U) {
  1061b0:	74 14                	je     1061c6 <pci_bus_scan+0x423>
	__asm__ volatile (
  1061b2:	0f bc c9             	bsf    %ecx,%ecx
  1061b5:	75 05                	jne    1061bc <pci_bus_scan+0x419>
  1061b7:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
		dev_info->size = 1 << (find_lsb_set(addr) - 1);
  1061bc:	b8 01 00 00 00       	mov    $0x1,%eax
  1061c1:	d3 e0                	shl    %cl,%eax
  1061c3:	89 43 04             	mov    %eax,0x4(%ebx)
			} else if (lookup.info.bar != PCI_BAR_ANY &&
  1061c6:	8a 15 ab 22 11 00    	mov    0x1122ab,%dl
  1061cc:	a0 b2 22 11 00       	mov    0x1122b2,%al
  1061d1:	c0 e8 03             	shr    $0x3,%al
  1061d4:	88 d1                	mov    %dl,%cl
  1061d6:	83 e1 1c             	and    $0x1c,%ecx
  1061d9:	83 e0 07             	and    $0x7,%eax
  1061dc:	80 f9 18             	cmp    $0x18,%cl
  1061df:	74 0e                	je     1061ef <pci_bus_scan+0x44c>
				   lookup.baridx != lookup.info.bar) {
  1061e1:	c0 ea 02             	shr    $0x2,%dl
  1061e4:	83 e2 07             	and    $0x7,%edx
			} else if (lookup.info.bar != PCI_BAR_ANY &&
  1061e7:	38 c2                	cmp    %al,%dl
  1061e9:	0f 85 24 01 00 00    	jne    106313 <pci_bus_scan+0x570>
				dev_info->bus = lookup.bus;
  1061ef:	8b 15 b0 22 11 00    	mov    0x1122b0,%edx
				dev_info->dev = lookup.dev;
  1061f5:	8a 0d b1 22 11 00    	mov    0x1122b1,%cl
				dev_info->bus = lookup.bus;
  1061fb:	66 81 e2 ff 01       	and    $0x1ff,%dx
  106200:	89 d7                	mov    %edx,%edi
  106202:	88 53 0c             	mov    %dl,0xc(%ebx)
				dev_info->dev = lookup.dev;
  106205:	d0 e9                	shr    %cl
  106207:	8a 53 0d             	mov    0xd(%ebx),%dl
  10620a:	83 e1 1f             	and    $0x1f,%ecx
  10620d:	83 e2 e0             	and    $0xffffffe0,%edx
  106210:	09 ca                	or     %ecx,%edx
  106212:	88 53 0d             	mov    %dl,0xd(%ebx)
				dev_info->vendor_id =
  106215:	8b 15 a0 fd 10 00    	mov    0x10fda0,%edx
  10621b:	89 53 10             	mov    %edx,0x10(%ebx)
				dev_info->class_type =
  10621e:	0f b6 15 ab fd 10 00 	movzbl 0x10fdab,%edx
  106225:	8d 0c 95 00 00 00 00 	lea    0x0(,%edx,4),%ecx
  10622c:	66 8b 53 0e          	mov    0xe(%ebx),%dx
  106230:	66 81 e2 03 fc       	and    $0xfc03,%dx
  106235:	09 ca                	or     %ecx,%edx
  106237:	66 89 53 0e          	mov    %dx,0xe(%ebx)
				dev_info->irq = pci_pin2irq(dev_info->bus,
  10623b:	89 fa                	mov    %edi,%edx
  10623d:	0f b6 f2             	movzbl %dl,%esi
  106240:	89 75 dc             	mov    %esi,-0x24(%ebp)
static inline int pci_pin2irq(int bus, int dev, int pin)
{
	ARG_UNUSED(dev);

	if (bus < 0 || bus > 1) {
		return -1;
  106243:	83 ce ff             	or     $0xffffffff,%esi
  106246:	0f b6 0d dd fd 10 00 	movzbl 0x10fddd,%ecx
	if (bus < 0 || bus > 1) {
  10624d:	80 fa 01             	cmp    $0x1,%dl
  106250:	77 11                	ja     106263 <pci_bus_scan+0x4c0>
	}
	if ((pin < PCI_INTA) || (pin > PCI_INTD)) {
  106252:	49                   	dec    %ecx
  106253:	83 f9 03             	cmp    $0x3,%ecx
  106256:	77 0b                	ja     106263 <pci_bus_scan+0x4c0>
		return -1;
	}
	return NUM_STD_IRQS + ((pin - 1 + bus) & 3);
  106258:	8b 55 dc             	mov    -0x24(%ebp),%edx
  10625b:	01 ca                	add    %ecx,%edx
  10625d:	83 e2 03             	and    $0x3,%edx
  106260:	8d 72 10             	lea    0x10(%edx),%esi
				dev_info->function = lookup.func;
  106263:	8b 15 b0 22 11 00    	mov    0x1122b0,%edx
				dev_info->irq = pci_pin2irq(dev_info->bus,
  106269:	89 73 08             	mov    %esi,0x8(%ebx)
				dev_info->function = lookup.func;
  10626c:	c1 ea 0f             	shr    $0xf,%edx
  10626f:	83 e2 0f             	and    $0xf,%edx
  106272:	89 d1                	mov    %edx,%ecx
  106274:	83 e1 0f             	and    $0xf,%ecx
  106277:	89 ce                	mov    %ecx,%esi
  106279:	8b 4b 0c             	mov    0xc(%ebx),%ecx
  10627c:	c1 e6 0d             	shl    $0xd,%esi
  10627f:	81 e1 ff 1f fe ff    	and    $0xfffe1fff,%ecx
  106285:	09 f1                	or     %esi,%ecx
  106287:	89 4b 0c             	mov    %ecx,0xc(%ebx)
				dev_info->bar = lookup.baridx;
  10628a:	88 c1                	mov    %al,%cl
  10628c:	83 e1 07             	and    $0x7,%ecx
				lookup.baridx++;
  10628f:	8d 04 c5 08 00 00 00 	lea    0x8(,%eax,8),%eax
  106296:	83 e0 38             	and    $0x38,%eax
				dev_info->bar = lookup.baridx;
  106299:	8d 34 8d 00 00 00 00 	lea    0x0(,%ecx,4),%esi
  1062a0:	8a 4b 0f             	mov    0xf(%ebx),%cl
  1062a3:	83 e1 e3             	and    $0xffffffe3,%ecx
  1062a6:	09 f1                	or     %esi,%ecx
  1062a8:	88 4b 0f             	mov    %cl,0xf(%ebx)
				lookup.baridx++;
  1062ab:	8a 0d b2 22 11 00    	mov    0x1122b2,%cl
  1062b1:	83 e1 c7             	and    $0xffffffc7,%ecx
  1062b4:	09 c8                	or     %ecx,%eax
  1062b6:	a2 b2 22 11 00       	mov    %al,0x1122b2
				lookup.barofs++;
  1062bb:	66 8b 0d b2 22 11 00 	mov    0x1122b2,%cx
  1062c2:	89 cb                	mov    %ecx,%ebx
  1062c4:	66 c1 eb 06          	shr    $0x6,%bx
  1062c8:	66 81 e1 3f fe       	and    $0xfe3f,%cx
  1062cd:	43                   	inc    %ebx
  1062ce:	83 e3 07             	and    $0x7,%ebx
  1062d1:	89 d8                	mov    %ebx,%eax
  1062d3:	83 e0 07             	and    $0x7,%eax
  1062d6:	c1 e0 06             	shl    $0x6,%eax
  1062d9:	09 c8                	or     %ecx,%eax
				if (lookup.barofs >= max_bars) {
  1062db:	0f b6 db             	movzbl %bl,%ebx
				lookup.barofs++;
  1062de:	66 a3 b2 22 11 00    	mov    %ax,0x1122b2
				if (lookup.barofs >= max_bars) {
  1062e4:	39 5d e0             	cmp    %ebx,-0x20(%ebp)
  1062e7:	7f 23                	jg     10630c <pci_bus_scan+0x569>
					lookup.baridx = 0;
  1062e9:	66 25 07 fe          	and    $0xfe07,%ax
					lookup.func++;
  1062ed:	42                   	inc    %edx
					lookup.baridx = 0;
  1062ee:	66 a3 b2 22 11 00    	mov    %ax,0x1122b2
					lookup.func++;
  1062f4:	83 e2 0f             	and    $0xf,%edx
  1062f7:	c1 e2 0f             	shl    $0xf,%edx
  1062fa:	a1 b0 22 11 00       	mov    0x1122b0,%eax
  1062ff:	25 ff 7f f8 ff       	and    $0xfff87fff,%eax
  106304:	09 c2                	or     %eax,%edx
  106306:	89 15 b0 22 11 00    	mov    %edx,0x1122b0
				return 1;
  10630c:	b8 01 00 00 00       	mov    $0x1,%eax
  106311:	eb 55                	jmp    106368 <pci_bus_scan+0x5c5>
		     lookup.baridx++, lookup.barofs++) {
  106313:	a0 b2 22 11 00       	mov    0x1122b2,%al
  106318:	88 c2                	mov    %al,%dl
  10631a:	83 e0 c7             	and    $0xffffffc7,%eax
  10631d:	c0 ea 03             	shr    $0x3,%dl
  106320:	8d 14 d5 08 00 00 00 	lea    0x8(,%edx,8),%edx
  106327:	83 e2 38             	and    $0x38,%edx
  10632a:	09 d0                	or     %edx,%eax
  10632c:	a2 b2 22 11 00       	mov    %al,0x1122b2
  106331:	66 8b 15 b2 22 11 00 	mov    0x1122b2,%dx
  106338:	89 d0                	mov    %edx,%eax
  10633a:	66 c1 e8 06          	shr    $0x6,%ax
  10633e:	66 81 e2 3f fe       	and    $0xfe3f,%dx
  106343:	40                   	inc    %eax
  106344:	83 e0 07             	and    $0x7,%eax
  106347:	c1 e0 06             	shl    $0x6,%eax
  10634a:	09 d0                	or     %edx,%eax
  10634c:	66 a3 b2 22 11 00    	mov    %ax,0x1122b2
  106352:	e9 1a fd ff ff       	jmp    106071 <pci_bus_scan+0x2ce>
				lookup.func = 0;
  106357:	25 ff 7f f8 ff       	and    $0xfff87fff,%eax
  10635c:	a3 b0 22 11 00       	mov    %eax,0x1122b0
  106361:	e9 cf fa ff ff       	jmp    105e35 <pci_bus_scan+0x92>
	return 0;
  106366:	31 c0                	xor    %eax,%eax
}
  106368:	8d 65 f4             	lea    -0xc(%ebp),%esp
  10636b:	5b                   	pop    %ebx
  10636c:	5e                   	pop    %esi
  10636d:	5f                   	pop    %edi
  10636e:	5d                   	pop    %ebp
  10636f:	c3                   	ret    

00106370 <pci_enable_regs>:

void pci_enable_regs(struct pci_dev_info *dev_info)
{
  106370:	55                   	push   %ebp
	pci_set_command_bits(dev_info, PCI_CMD_MEM_ENABLE);
  106371:	ba 02 00 00 00       	mov    $0x2,%edx
{
  106376:	89 e5                	mov    %esp,%ebp
	pci_set_command_bits(dev_info, PCI_CMD_MEM_ENABLE);
  106378:	8b 45 08             	mov    0x8(%ebp),%eax
}
  10637b:	5d                   	pop    %ebp
	pci_set_command_bits(dev_info, PCI_CMD_MEM_ENABLE);
  10637c:	e9 98 f9 ff ff       	jmp    105d19 <pci_set_command_bits>

00106381 <pci_read>:
 *
 */

void pci_read(u32_t controller, union pci_addr_reg addr,
	      u32_t size, u32_t *data)
{
  106381:	55                   	push   %ebp
  106382:	89 e5                	mov    %esp,%ebp
  106384:	56                   	push   %esi
  106385:	53                   	push   %ebx
  106386:	8b 55 10             	mov    0x10(%ebp),%edx
  106389:	8b 45 0c             	mov    0xc(%ebp),%eax
  10638c:	8b 5d 14             	mov    0x14(%ebp),%ebx
	u32_t access_size;
	u32_t access_offset;

	/* validate the access size */

	switch (size) {
  10638f:	83 fa 01             	cmp    $0x1,%edx
  106392:	74 0e                	je     1063a2 <pci_read+0x21>
  106394:	83 fa 02             	cmp    $0x2,%edx
  106397:	74 12                	je     1063ab <pci_read+0x2a>
		access_offset = addr.field.offset;
		break;
	case 4:
	default:
		access_size = SYS_PCI_ACCESS_32BIT;
		access_offset = 0U;
  106399:	31 c9                	xor    %ecx,%ecx
		access_size = SYS_PCI_ACCESS_32BIT;
  10639b:	be 03 00 00 00       	mov    $0x3,%esi
  1063a0:	eb 13                	jmp    1063b5 <pci_read+0x34>
		access_offset = addr.field.offset;
  1063a2:	89 c1                	mov    %eax,%ecx
		access_size = SYS_PCI_ACCESS_8BIT;
  1063a4:	31 f6                	xor    %esi,%esi
		access_offset = addr.field.offset;
  1063a6:	83 e1 03             	and    $0x3,%ecx
		break;
  1063a9:	eb 0a                	jmp    1063b5 <pci_read+0x34>
		access_offset = addr.field.offset;
  1063ab:	89 c1                	mov    %eax,%ecx
		access_size = SYS_PCI_ACCESS_16BIT;
  1063ad:	be 01 00 00 00       	mov    $0x1,%esi
		access_offset = addr.field.offset;
  1063b2:	83 e1 03             	and    $0x3,%ecx

	addr.field.enable = 1;

	/* clear the offset for the address register */

	addr.field.offset = 0;
  1063b5:	25 fc ff ff 7f       	and    $0x7ffffffc,%eax
  1063ba:	0d 00 00 00 80       	or     $0x80000000,%eax
	if (controller != DEFAULT_PCI_CONTROLLER) {
  1063bf:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  1063c3:	75 2c                	jne    1063f1 <pci_read+0x70>
	__asm__ volatile("outl	%0, %w1;\n\t"
  1063c5:	ba f8 0c 00 00       	mov    $0xcf8,%edx
  1063ca:	ef                   	out    %eax,(%dx)
	pci_ctrl_read(PCI_CTRL_DATA_REG + offset, data, size);
  1063cb:	8d 91 fc 0c 00 00    	lea    0xcfc(%ecx),%edx
	switch (size) {
  1063d1:	83 fe 01             	cmp    $0x1,%esi
  1063d4:	74 0c                	je     1063e2 <pci_read+0x61>
  1063d6:	85 f6                	test   %esi,%esi
  1063d8:	74 11                	je     1063eb <pci_read+0x6a>
  1063da:	83 fe 03             	cmp    $0x3,%esi
  1063dd:	75 12                	jne    1063f1 <pci_read+0x70>
	__asm__ volatile("inl	%w1, %0;\n\t"
  1063df:	ed                   	in     (%dx),%eax
	return ret;
  1063e0:	eb 05                	jmp    1063e7 <pci_read+0x66>
	__asm__ volatile("inw	%w1, %w0;\n\t"
  1063e2:	66 ed                	in     (%dx),%ax
		*data = sys_in16(reg);
  1063e4:	0f b7 c0             	movzwl %ax,%eax
  1063e7:	89 03                	mov    %eax,(%ebx)
		break;
  1063e9:	eb 06                	jmp    1063f1 <pci_read+0x70>
	__asm__ volatile("inb	%w1, %b0;\n\t"
  1063eb:	ec                   	in     (%dx),%al
		*data = sys_in8(reg);
  1063ec:	0f b6 d0             	movzbl %al,%edx
  1063ef:	89 13                	mov    %edx,(%ebx)

	pci_ctrl_addr_write(
		controller, PCI_NO_OFFSET, addr.value, SYS_PCI_ACCESS_32BIT);

	pci_ctrl_data_read(controller, access_offset, data, access_size);
}
  1063f1:	5b                   	pop    %ebx
  1063f2:	5e                   	pop    %esi
  1063f3:	5d                   	pop    %ebp
  1063f4:	c3                   	ret    

001063f5 <pci_write>:
 *
 */

void pci_write(u32_t controller, union pci_addr_reg addr,
	       u32_t size, u32_t data)
{
  1063f5:	55                   	push   %ebp
  1063f6:	89 e5                	mov    %esp,%ebp
  1063f8:	53                   	push   %ebx
  1063f9:	8b 55 10             	mov    0x10(%ebp),%edx
  1063fc:	8b 45 0c             	mov    0xc(%ebp),%eax
	u32_t access_size;
	u32_t access_offset;

	/* validate the access size */

	switch (size) {
  1063ff:	83 fa 01             	cmp    $0x1,%edx
  106402:	74 0e                	je     106412 <pci_write+0x1d>
  106404:	83 fa 02             	cmp    $0x2,%edx
  106407:	74 12                	je     10641b <pci_write+0x26>
		access_offset = addr.field.offset;
		break;
	case 4:
	default:
		access_size = SYS_PCI_ACCESS_32BIT;
		access_offset = 0U;
  106409:	31 c9                	xor    %ecx,%ecx
		access_size = SYS_PCI_ACCESS_32BIT;
  10640b:	bb 03 00 00 00       	mov    $0x3,%ebx
  106410:	eb 13                	jmp    106425 <pci_write+0x30>
		access_offset = addr.field.offset;
  106412:	89 c1                	mov    %eax,%ecx
		access_size = SYS_PCI_ACCESS_8BIT;
  106414:	31 db                	xor    %ebx,%ebx
		access_offset = addr.field.offset;
  106416:	83 e1 03             	and    $0x3,%ecx
		break;
  106419:	eb 0a                	jmp    106425 <pci_write+0x30>
		access_offset = addr.field.offset;
  10641b:	89 c1                	mov    %eax,%ecx
		access_size = SYS_PCI_ACCESS_16BIT;
  10641d:	bb 01 00 00 00       	mov    $0x1,%ebx
		access_offset = addr.field.offset;
  106422:	83 e1 03             	and    $0x3,%ecx

	addr.field.enable = 1;

	/* clear the offset for the address register */

	addr.field.offset = 0;
  106425:	25 fc ff ff 7f       	and    $0x7ffffffc,%eax
  10642a:	0d 00 00 00 80       	or     $0x80000000,%eax
	if (controller != DEFAULT_PCI_CONTROLLER) {
  10642f:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  106433:	75 2b                	jne    106460 <pci_write+0x6b>
	__asm__ volatile("outl	%0, %w1;\n\t"
  106435:	ba f8 0c 00 00       	mov    $0xcf8,%edx
  10643a:	ef                   	out    %eax,(%dx)
	pci_ctrl_write(PCI_CTRL_DATA_REG + offset, data, size);
  10643b:	8d 91 fc 0c 00 00    	lea    0xcfc(%ecx),%edx
	switch (size) {
  106441:	83 fb 01             	cmp    $0x1,%ebx
  106444:	74 0f                	je     106455 <pci_write+0x60>
  106446:	85 db                	test   %ebx,%ebx
  106448:	74 12                	je     10645c <pci_write+0x67>
  10644a:	83 fb 03             	cmp    $0x3,%ebx
  10644d:	75 11                	jne    106460 <pci_write+0x6b>
  10644f:	8b 45 14             	mov    0x14(%ebp),%eax
  106452:	ef                   	out    %eax,(%dx)
  106453:	eb 0b                	jmp    106460 <pci_write+0x6b>
	__asm__ volatile("outw	%w0, %w1;\n\t"
  106455:	8b 45 14             	mov    0x14(%ebp),%eax
  106458:	66 ef                	out    %ax,(%dx)
  10645a:	eb 04                	jmp    106460 <pci_write+0x6b>
	__asm__ volatile("outb	%b0, %w1;\n\t"
  10645c:	8a 45 14             	mov    0x14(%ebp),%al
  10645f:	ee                   	out    %al,(%dx)
	/* write the data to the PCI controller */

	pci_ctrl_addr_write(
		controller, PCI_NO_OFFSET, addr.value, SYS_PCI_ACCESS_32BIT);
	pci_ctrl_data_write(controller, access_offset, data, access_size);
}
  106460:	5b                   	pop    %ebx
  106461:	5d                   	pop    %ebp
  106462:	c3                   	ret    

00106463 <pci_header_get>:
 */

void pci_header_get(u32_t controller,
		    union pci_addr_reg pci_ctrl_addr,
		    union pci_dev *pci_dev_header)
{
  106463:	55                   	push   %ebp
  106464:	89 e5                	mov    %esp,%ebp
  106466:	57                   	push   %edi
  106467:	56                   	push   %esi

	(void)memset(pci_dev_header, 0, sizeof(*pci_dev_header));

	/* fill in the PCI header from the device */

	for (i = 0U; i < PCI_HEADER_WORDS; i++) {
  106468:	31 ff                	xor    %edi,%edi
{
  10646a:	53                   	push   %ebx
  10646b:	8b 75 10             	mov    0x10(%ebp),%esi
	(void)memset(pci_dev_header, 0, sizeof(*pci_dev_header));
  10646e:	68 00 01 00 00       	push   $0x100
{
  106473:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	(void)memset(pci_dev_header, 0, sizeof(*pci_dev_header));
  106476:	6a 00                	push   $0x0
  106478:	56                   	push   %esi
  106479:	e8 03 0a 00 00       	call   106e81 <memset>
  10647e:	83 c4 0c             	add    $0xc,%esp
		pci_ctrl_addr.field.reg = i;
  106481:	89 f8                	mov    %edi,%eax
  106483:	80 e3 03             	and    $0x3,%bl
  106486:	83 e0 3f             	and    $0x3f,%eax
  106489:	c1 e0 02             	shl    $0x2,%eax
  10648c:	09 c3                	or     %eax,%ebx
		pci_read(controller,
  10648e:	8d 04 be             	lea    (%esi,%edi,4),%eax
  106491:	50                   	push   %eax
	for (i = 0U; i < PCI_HEADER_WORDS; i++) {
  106492:	47                   	inc    %edi
		pci_read(controller,
  106493:	6a 04                	push   $0x4
  106495:	53                   	push   %ebx
  106496:	ff 75 08             	pushl  0x8(%ebp)
  106499:	e8 e3 fe ff ff       	call   106381 <pci_read>
  10649e:	83 c4 10             	add    $0x10,%esp
	for (i = 0U; i < PCI_HEADER_WORDS; i++) {
  1064a1:	83 ff 40             	cmp    $0x40,%edi
  1064a4:	75 db                	jne    106481 <pci_header_get+0x1e>
			pci_ctrl_addr,
			sizeof(u32_t),
			&pci_dev_header->words.word[i]);
	}
}
  1064a6:	8d 65 f4             	lea    -0xc(%ebp),%esp
  1064a9:	5b                   	pop    %ebx
  1064aa:	5e                   	pop    %esi
  1064ab:	5f                   	pop    %edi
  1064ac:	5d                   	pop    %ebp
  1064ad:	c3                   	ret    

001064ae <pci_legacy_bridge_detect>:
 *
 * @return 0 if legacy bridge is detected and -1 otherwise
 */

int pci_legacy_bridge_detect(struct pci_dev_info *dev_info)
{
  1064ae:	55                   	push   %ebp
  1064af:	89 e5                	mov    %esp,%ebp
  1064b1:	53                   	push   %ebx
  1064b2:	83 ec 10             	sub    $0x10,%esp
	pci_ctrl_addr.field.device = CONFIG_PCI_LEGACY_BRIDGE_DEV;

	/* verify first if there is a valid device at this point */
	pci_ctrl_addr.field.func = 0U;

	pci_read(DEFAULT_PCI_CONTROLLER,
  1064b5:	8d 45 ec             	lea    -0x14(%ebp),%eax
{
  1064b8:	8b 5d 08             	mov    0x8(%ebp),%ebx
	pci_read(DEFAULT_PCI_CONTROLLER,
  1064bb:	50                   	push   %eax
  1064bc:	6a 04                	push   $0x4
  1064be:	68 00 f8 00 00       	push   $0xf800
  1064c3:	6a 00                	push   $0x0
  1064c5:	e8 b7 fe ff ff       	call   106381 <pci_read>
  1064ca:	83 c4 10             	add    $0x10,%esp
			pci_ctrl_addr,
			sizeof(pci_data),
			&pci_data);

	if (pci_data == 0xffffffff) {
  1064cd:	83 7d ec ff          	cmpl   $0xffffffff,-0x14(%ebp)
  1064d1:	0f 84 91 00 00 00    	je     106568 <pci_legacy_bridge_detect+0xba>
		return -1;
	}

	/* get the PCI header from the device */
	pci_header_get(DEFAULT_PCI_CONTROLLER,
  1064d7:	68 a0 fe 10 00       	push   $0x10fea0
  1064dc:	68 00 f8 00 00       	push   $0xf800
  1064e1:	6a 00                	push   $0x0
  1064e3:	e8 7b ff ff ff       	call   106463 <pci_header_get>
  1064e8:	83 c4 0c             	add    $0xc,%esp
		       pci_ctrl_addr,
		       &pci_dev_header);

	if (pci_dev_header.field.vendor_id != CONFIG_PCI_LEGACY_BRIDGE_VENDOR_ID ||
  1064eb:	81 3d a0 fe 10 00 86 	cmpl   $0x95e8086,0x10fea0
  1064f2:	80 5e 09 
  1064f5:	75 71                	jne    106568 <pci_legacy_bridge_detect+0xba>
	}

	pci_ctrl_addr.field.reg = PCI_LEGACY_BRIDGE_REG;

	/* read RCBA PCI register */
	pci_read(DEFAULT_PCI_CONTROLLER,
  1064f7:	8d 45 f0             	lea    -0x10(%ebp),%eax
  1064fa:	50                   	push   %eax
  1064fb:	6a 04                	push   $0x4
  1064fd:	68 f0 f8 00 00       	push   $0xf8f0
  106502:	6a 00                	push   $0x0
  106504:	e8 78 fe ff ff       	call   106381 <pci_read>
  106509:	83 c4 10             	add    $0x10,%esp
	pci_read(DEFAULT_PCI_CONTROLLER,
  10650c:	8d 45 f8             	lea    -0x8(%ebp),%eax
  10650f:	50                   	push   %eax
  106510:	6a 04                	push   $0x4
  106512:	68 f0 f8 00 00       	push   $0xf8f0
  106517:	6a 00                	push   $0x0
  106519:	e8 63 fe ff ff       	call   106381 <pci_read>
  10651e:	83 c4 10             	add    $0x10,%esp
	pci_write(DEFAULT_PCI_CONTROLLER,
  106521:	6a ff                	push   $0xffffffff
  106523:	6a 04                	push   $0x4
  106525:	68 f0 f8 00 00       	push   $0xf8f0
  10652a:	6a 00                	push   $0x0
  10652c:	e8 c4 fe ff ff       	call   1063f5 <pci_write>
  106531:	83 c4 10             	add    $0x10,%esp
	pci_read(DEFAULT_PCI_CONTROLLER,
  106534:	8d 45 f4             	lea    -0xc(%ebp),%eax
  106537:	50                   	push   %eax
  106538:	6a 04                	push   $0x4
  10653a:	68 f0 f8 00 00       	push   $0xf8f0
  10653f:	6a 00                	push   $0x0
  106541:	e8 3b fe ff ff       	call   106381 <pci_read>
  106546:	83 c4 10             	add    $0x10,%esp
	pci_write(DEFAULT_PCI_CONTROLLER,
  106549:	ff 75 f8             	pushl  -0x8(%ebp)
  10654c:	6a 04                	push   $0x4
  10654e:	68 f0 f8 00 00       	push   $0xf8f0
  106553:	6a 00                	push   $0x0
  106555:	e8 9b fe ff ff       	call   1063f5 <pci_write>
	if (*mask != 0xffffffff && *mask != 0U) {
  10655a:	8b 4d f4             	mov    -0xc(%ebp),%ecx
	pci_write(DEFAULT_PCI_CONTROLLER,
  10655d:	83 c4 10             	add    $0x10,%esp
	if (*mask != 0xffffffff && *mask != 0U) {
  106560:	8d 41 ff             	lea    -0x1(%ecx),%eax
  106563:	83 f8 fd             	cmp    $0xfffffffd,%eax
  106566:	76 05                	jbe    10656d <pci_legacy_bridge_detect+0xbf>
			pci_ctrl_addr,
			sizeof(rcba),
			&rcba);

	if (pci_rcba_mask_get(pci_ctrl_addr, &rcba_mask) != 0) {
		return -1;
  106568:	83 c8 ff             	or     $0xffffffff,%eax
  10656b:	eb 5b                	jmp    1065c8 <pci_legacy_bridge_detect+0x11a>
		*mask &= ~0x01;
  10656d:	83 e1 fe             	and    $0xfffffffe,%ecx
	}

	dev_info->addr = rcba & rcba_mask;
  106570:	89 c8                	mov    %ecx,%eax
  106572:	23 45 f0             	and    -0x10(%ebp),%eax
  106575:	89 03                	mov    %eax,(%ebx)
	if (dev_info->addr != 0U) {
  106577:	74 14                	je     10658d <pci_legacy_bridge_detect+0xdf>
	__asm__ volatile (
  106579:	0f bc c9             	bsf    %ecx,%ecx
  10657c:	75 05                	jne    106583 <pci_legacy_bridge_detect+0xd5>
  10657e:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
		/* calculate the size of the root complex memory required */
		dev_info->size = 1 << (find_lsb_set(rcba_mask) - 1);
  106583:	b8 01 00 00 00       	mov    $0x1,%eax
  106588:	d3 e0                	shl    %cl,%eax
  10658a:	89 43 04             	mov    %eax,0x4(%ebx)
	dev_info->irq = -1;
	dev_info->bus = CONFIG_PCI_LEGACY_BRIDGE_BUS;
	dev_info->dev = CONFIG_PCI_LEGACY_BRIDGE_DEV;
	dev_info->function = 0U;
	dev_info->mem_type = BAR_SPACE_MEM;
	dev_info->class_type = pci_dev_header.field.class;
  10658d:	0f b6 05 ab fe 10 00 	movzbl 0x10feab,%eax
	dev_info->irq = -1;
  106594:	c7 43 08 ff ff ff ff 	movl   $0xffffffff,0x8(%ebx)
	dev_info->class_type = pci_dev_header.field.class;
  10659b:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  1065a2:	66 8b 43 0e          	mov    0xe(%ebx),%ax
  1065a6:	66 25 03 fc          	and    $0xfc03,%ax
  1065aa:	09 d0                	or     %edx,%eax
  1065ac:	66 89 43 0e          	mov    %ax,0xe(%ebx)
	dev_info->bus = CONFIG_PCI_LEGACY_BRIDGE_BUS;
  1065b0:	8b 43 0c             	mov    0xc(%ebx),%eax
  1065b3:	25 00 00 fc e3       	and    $0xe3fc0000,%eax
  1065b8:	80 cc 1f             	or     $0x1f,%ah
  1065bb:	89 43 0c             	mov    %eax,0xc(%ebx)
	dev_info->bar = 0U;
	dev_info->vendor_id = pci_dev_header.field.vendor_id;
  1065be:	a1 a0 fe 10 00       	mov    0x10fea0,%eax
  1065c3:	89 43 10             	mov    %eax,0x10(%ebx)
	dev_info->device_id = pci_dev_header.field.device_id;

	return 0;
  1065c6:	31 c0                	xor    %eax,%eax
}
  1065c8:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  1065cb:	c9                   	leave  
  1065cc:	c3                   	ret    

001065cd <pci_legacy_bridge_configure>:
 */
void pci_legacy_bridge_configure(struct pci_dev_info *dev_info,
				 int io_block_num,
				 int pci_interrupt_pin,
				 int irq_number)
{
  1065cd:	55                   	push   %ebp
  1065ce:	89 e5                	mov    %esp,%ebp
  1065d0:	57                   	push   %edi
  1065d1:	56                   	push   %esi
	u32_t addr = (io_block_num == 0) ? PCI_ADDR_IRQAGENT1 :
  1065d2:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
	 *            0-7, which corresponds IRQ 16 - IRQ 23
	 * Bits 11:8  indicates which IRQ is used for INTC.
	 * Bits 7:4   indicates which IRQ is used for INTB.
	 * Bits 3:0   indicates which IRQ is used for INTA.
	 */
	int offset = (pci_interrupt_pin - 1) * 4;
  1065d6:	8b 55 10             	mov    0x10(%ebp),%edx
{
  1065d9:	8b 75 08             	mov    0x8(%ebp),%esi
	u32_t addr = (io_block_num == 0) ? PCI_ADDR_IRQAGENT1 :
  1065dc:	19 c0                	sbb    %eax,%eax
{
  1065de:	53                   	push   %ebx
	u32_t addr = (io_block_num == 0) ? PCI_ADDR_IRQAGENT1 :
  1065df:	83 e0 fc             	and    $0xfffffffc,%eax
	int offset = (pci_interrupt_pin - 1) * 4;
  1065e2:	8d 0c 95 fc ff ff ff 	lea    -0x4(,%edx,4),%ecx
	u32_t addr = (io_block_num == 0) ? PCI_ADDR_IRQAGENT1 :
  1065e9:	05 46 31 00 00       	add    $0x3146,%eax
	u16_t irq_routing = sys_read16(dev_info->addr + addr);
  1065ee:	8b 16                	mov    (%esi),%edx
  1065f0:	01 c2                	add    %eax,%edx
	__asm__ volatile("movw	%1, %0;\n\t"
  1065f2:	66 8b 3a             	mov    (%edx),%di

	irq_routing &= ~(0x0f << offset);
  1065f5:	bb 0f 00 00 00       	mov    $0xf,%ebx
	irq_routing |= (irq_number - NUM_STD_IRQS) << offset;
	sys_write16(irq_routing, dev_info->addr + addr);
  1065fa:	03 06                	add    (%esi),%eax
	irq_routing &= ~(0x0f << offset);
  1065fc:	d3 e3                	shl    %cl,%ebx
  1065fe:	f7 d3                	not    %ebx
  106600:	21 fb                	and    %edi,%ebx
	irq_routing |= (irq_number - NUM_STD_IRQS) << offset;
  106602:	8b 7d 14             	mov    0x14(%ebp),%edi
  106605:	8d 57 f0             	lea    -0x10(%edi),%edx
  106608:	d3 e2                	shl    %cl,%edx
  10660a:	09 da                	or     %ebx,%edx
	__asm__ volatile("movw	%0, %1;\n\t"
  10660c:	66 89 10             	mov    %dx,(%eax)
}
  10660f:	5b                   	pop    %ebx
  106610:	5e                   	pop    %esi
  106611:	5f                   	pop    %edi
  106612:	5d                   	pop    %ebp
  106613:	c3                   	ret    

00106614 <hpet_isr>:
static unsigned int max_ticks;
static unsigned int cyc_per_tick;
static unsigned int last_count;

static void hpet_isr(void *arg)
{
  106614:	55                   	push   %ebp
  106615:	89 e5                	mov    %esp,%ebp
  106617:	53                   	push   %ebx
	__asm__ volatile (
  106618:	9c                   	pushf  
  106619:	fa                   	cli    
  10661a:	5b                   	pop    %ebx
	ARG_UNUSED(arg);
	k_spinlock_key_t key = k_spin_lock(&lock);
	u32_t now = MAIN_COUNTER_REG;
  10661b:	a1 f0 00 d0 fe       	mov    0xfed000f0,%eax
	u32_t dticks = (now - last_count) / cyc_per_tick;
  106620:	8b 0d 18 0b 11 00    	mov    0x110b18,%ecx
  106626:	2b 05 14 0b 11 00    	sub    0x110b14,%eax
  10662c:	31 d2                	xor    %edx,%edx
  10662e:	f7 f1                	div    %ecx

	last_count += dticks * cyc_per_tick;
  106630:	0f af c8             	imul   %eax,%ecx
  106633:	03 0d 14 0b 11 00    	add    0x110b14,%ecx
  106639:	0f ba e3 09          	bt     $0x9,%ebx
  10663d:	89 0d 14 0b 11 00    	mov    %ecx,0x110b14
  106643:	73 01                	jae    106646 <hpet_isr+0x32>
	__asm__ volatile (
  106645:	fb                   	sti    
		TIMER0_COMPARATOR_REG = next;
	}

	k_spin_unlock(&lock, key);
	z_clock_announce(IS_ENABLED(CONFIG_TICKLESS_KERNEL) ? dticks : 1);
}
  106646:	5b                   	pop    %ebx
	z_clock_announce(IS_ENABLED(CONFIG_TICKLESS_KERNEL) ? dticks : 1);
  106647:	89 45 08             	mov    %eax,0x8(%ebp)
}
  10664a:	5d                   	pop    %ebp
	z_clock_announce(IS_ENABLED(CONFIG_TICKLESS_KERNEL) ? dticks : 1);
  10664b:	e9 fd 4a 00 00       	jmp    10b14d <z_clock_announce>

00106650 <z_clock_driver_init>:

	TIMER0_CONF_REG = val;
}

int z_clock_driver_init(struct device *device)
{
  106650:	55                   	push   %ebp
  106651:	89 e5                	mov    %esp,%ebp
	extern int z_clock_hw_cycles_per_sec;
	u32_t hz;

	IRQ_CONNECT(CONFIG_HPET_TIMER_IRQ, CONFIG_HPET_TIMER_IRQ_PRIORITY,
  106653:	0f b6 05 7a f8 10 00 	movzbl 0x10f87a,%eax
  10665a:	6a 00                	push   $0x0
  10665c:	6a 02                	push   $0x2
  10665e:	50                   	push   %eax
  10665f:	e8 05 f5 ff ff       	call   105b69 <__irq_controller_irq_config>
	u32_t val = (TIMER0_CONF_REG & ~(0x1f << 9)) | ((irq & 0x1f) << 9);
  106664:	a1 00 01 d0 fe       	mov    0xfed00100,%eax
  106669:	83 c4 0c             	add    $0xc,%esp
  10666c:	80 e4 c1             	and    $0xc1,%ah
  10666f:	80 cc 04             	or     $0x4,%ah
	TIMER0_CONF_REG = val;
  106672:	a3 00 01 d0 fe       	mov    %eax,0xfed00100
		    hpet_isr, 0, 0);
	set_timer0_irq(CONFIG_HPET_TIMER_IRQ);
	irq_enable(CONFIG_HPET_TIMER_IRQ);
  106677:	6a 02                	push   $0x2
  106679:	e8 11 f5 ff ff       	call   105b8f <z_arch_irq_enable>

	/* CLK_PERIOD_REG is in femtoseconds (1e-15 sec) */
	hz = (u32_t)(1000000000000000ull / CLK_PERIOD_REG);
  10667e:	a1 04 00 d0 fe       	mov    0xfed00004,%eax
  106683:	31 d2                	xor    %edx,%edx
  106685:	89 14 24             	mov    %edx,(%esp)
  106688:	50                   	push   %eax
  106689:	68 7e 8d 03 00       	push   $0x38d7e
  10668e:	68 00 80 c6 a4       	push   $0xa4c68000
  106693:	e8 25 9b ff ff       	call   1001bd <__udivdi3>
	z_clock_hw_cycles_per_sec = hz;
	cyc_per_tick = hz / CONFIG_SYS_CLOCK_TICKS_PER_SEC;
  106698:	b9 64 00 00 00       	mov    $0x64,%ecx
  10669d:	31 d2                	xor    %edx,%edx
	z_clock_hw_cycles_per_sec = hz;
  10669f:	a3 cc 32 11 00       	mov    %eax,0x1132cc
	hz = (u32_t)(1000000000000000ull / CLK_PERIOD_REG);
  1066a4:	83 c4 10             	add    $0x10,%esp
	cyc_per_tick = hz / CONFIG_SYS_CLOCK_TICKS_PER_SEC;
  1066a7:	f7 f1                	div    %ecx
  1066a9:	a3 18 0b 11 00       	mov    %eax,0x110b18
	 */
	GENERAL_CONF_REG |= GCONF_LR | GCONF_ENABLE;
	TIMER0_CONF_REG &= ~TCONF_PERIODIC;
	TIMER0_CONF_REG |= TCONF_MODE32;

	max_ticks = (0x7fffffff - cyc_per_tick) / cyc_per_tick;
  1066ae:	31 d2                	xor    %edx,%edx
	GENERAL_CONF_REG |= GCONF_LR | GCONF_ENABLE;
  1066b0:	a1 10 00 d0 fe       	mov    0xfed00010,%eax
  1066b5:	83 c8 03             	or     $0x3,%eax
  1066b8:	a3 10 00 d0 fe       	mov    %eax,0xfed00010
	TIMER0_CONF_REG &= ~TCONF_PERIODIC;
  1066bd:	a1 00 01 d0 fe       	mov    0xfed00100,%eax
  1066c2:	83 e0 f7             	and    $0xfffffff7,%eax
  1066c5:	a3 00 01 d0 fe       	mov    %eax,0xfed00100
	TIMER0_CONF_REG |= TCONF_MODE32;
  1066ca:	a1 00 01 d0 fe       	mov    0xfed00100,%eax
  1066cf:	80 cc 01             	or     $0x1,%ah
  1066d2:	a3 00 01 d0 fe       	mov    %eax,0xfed00100
	max_ticks = (0x7fffffff - cyc_per_tick) / cyc_per_tick;
  1066d7:	b8 ff ff ff 7f       	mov    $0x7fffffff,%eax
  1066dc:	8b 0d 18 0b 11 00    	mov    0x110b18,%ecx
  1066e2:	29 c8                	sub    %ecx,%eax
  1066e4:	f7 f1                	div    %ecx
  1066e6:	a3 1c 0b 11 00       	mov    %eax,0x110b1c
	last_count = MAIN_COUNTER_REG;
  1066eb:	a1 f0 00 d0 fe       	mov    0xfed000f0,%eax
  1066f0:	a3 14 0b 11 00       	mov    %eax,0x110b14

	TIMER0_CONF_REG |= TCONF_INT_ENABLE;
  1066f5:	a1 00 01 d0 fe       	mov    0xfed00100,%eax
  1066fa:	83 c8 04             	or     $0x4,%eax
  1066fd:	a3 00 01 d0 fe       	mov    %eax,0xfed00100
	TIMER0_COMPARATOR_REG = MAIN_COUNTER_REG + cyc_per_tick;
  106702:	a1 f0 00 d0 fe       	mov    0xfed000f0,%eax
  106707:	03 05 18 0b 11 00    	add    0x110b18,%eax
  10670d:	a3 08 01 d0 fe       	mov    %eax,0xfed00108

	return 0;
}
  106712:	31 c0                	xor    %eax,%eax
  106714:	c9                   	leave  
  106715:	c3                   	ret    

00106716 <hpet_isr_irq2_stub>:
  106716:	6a 00                	push   $0x0
  106718:	68 14 66 10 00       	push   $0x106614
  10671d:	e9 0a 01 00 00       	jmp    10682c <_interrupt_enter>

00106722 <z_clock_set_timeout>:
	 * nothing to do at initialization on auxiliary CPUs.
	 */
}

void z_clock_set_timeout(s32_t ticks, bool idle)
{
  106722:	55                   	push   %ebp
  106723:	89 e5                	mov    %esp,%ebp
  106725:	57                   	push   %edi
  106726:	56                   	push   %esi
  106727:	8b 45 08             	mov    0x8(%ebp),%eax
  10672a:	53                   	push   %ebx
  10672b:	8b 55 0c             	mov    0xc(%ebp),%edx
	ARG_UNUSED(idle);

#if defined(CONFIG_TICKLESS_KERNEL) && !defined(CONFIG_QEMU_TICKLESS_WORKAROUND)
	if (ticks == K_FOREVER && idle) {
  10672e:	83 f8 ff             	cmp    $0xffffffff,%eax
  106731:	75 13                	jne    106746 <z_clock_set_timeout+0x24>
  106733:	84 d2                	test   %dl,%dl
  106735:	74 0f                	je     106746 <z_clock_set_timeout+0x24>
		GENERAL_CONF_REG &= ~GCONF_ENABLE;
  106737:	a1 10 00 d0 fe       	mov    0xfed00010,%eax
  10673c:	83 e0 fe             	and    $0xfffffffe,%eax
  10673f:	a3 10 00 d0 fe       	mov    %eax,0xfed00010
		return;
  106744:	eb 5d                	jmp    1067a3 <z_clock_set_timeout+0x81>
	}

	ticks = ticks == K_FOREVER ? max_ticks : ticks;
  106746:	8b 15 1c 0b 11 00    	mov    0x110b1c,%edx
  10674c:	83 f8 ff             	cmp    $0xffffffff,%eax
  10674f:	75 02                	jne    106753 <z_clock_set_timeout+0x31>
  106751:	89 d0                	mov    %edx,%eax
	__asm__ volatile (
  106753:	9c                   	pushf  
  106754:	fa                   	cli    
  106755:	5f                   	pop    %edi
	ticks = MAX(MIN(ticks - 1, (s32_t)max_ticks), 0);
  106756:	48                   	dec    %eax

	k_spinlock_key_t key = k_spin_lock(&lock);
	u32_t now = MAIN_COUNTER_REG, cyc;
  106757:	8b 35 f0 00 d0 fe    	mov    0xfed000f0,%esi

	/* Round up to next tick boundary */
	cyc = ticks * cyc_per_tick + (now - last_count) + (cyc_per_tick - 1);
  10675d:	8b 1d 18 0b 11 00    	mov    0x110b18,%ebx
  106763:	8b 0d 14 0b 11 00    	mov    0x110b14,%ecx
	ticks = MAX(MIN(ticks - 1, (s32_t)max_ticks), 0);
  106769:	39 d0                	cmp    %edx,%eax
  10676b:	7e 02                	jle    10676f <z_clock_set_timeout+0x4d>
  10676d:	89 d0                	mov    %edx,%eax
  10676f:	85 c0                	test   %eax,%eax
  106771:	79 02                	jns    106775 <z_clock_set_timeout+0x53>
  106773:	31 c0                	xor    %eax,%eax
	cyc = ticks * cyc_per_tick + (now - last_count) + (cyc_per_tick - 1);
  106775:	0f af c3             	imul   %ebx,%eax
  106778:	8d 54 33 ff          	lea    -0x1(%ebx,%esi,1),%edx
  10677c:	29 ca                	sub    %ecx,%edx
  10677e:	01 d0                	add    %edx,%eax
	cyc = (cyc / cyc_per_tick) * cyc_per_tick;
  106780:	31 d2                	xor    %edx,%edx
  106782:	f7 f3                	div    %ebx
  106784:	0f af c3             	imul   %ebx,%eax
	cyc += last_count;
  106787:	01 c1                	add    %eax,%ecx

	if ((cyc - now) < MIN_DELAY) {
  106789:	89 c8                	mov    %ecx,%eax
  10678b:	29 f0                	sub    %esi,%eax
  10678d:	3d e7 03 00 00       	cmp    $0x3e7,%eax
  106792:	77 02                	ja     106796 <z_clock_set_timeout+0x74>
		cyc += cyc_per_tick;
  106794:	01 d9                	add    %ebx,%ecx
  106796:	0f ba e7 09          	bt     $0x9,%edi
	}

	TIMER0_COMPARATOR_REG = cyc;
  10679a:	89 0d 08 01 d0 fe    	mov    %ecx,0xfed00108
  1067a0:	73 01                	jae    1067a3 <z_clock_set_timeout+0x81>
	__asm__ volatile (
  1067a2:	fb                   	sti    
	k_spin_unlock(&lock, key);
#endif
}
  1067a3:	5b                   	pop    %ebx
  1067a4:	5e                   	pop    %esi
  1067a5:	5f                   	pop    %edi
  1067a6:	5d                   	pop    %ebp
  1067a7:	c3                   	ret    

001067a8 <z_clock_elapsed>:
	__asm__ volatile (
  1067a8:	9c                   	pushf  
  1067a9:	fa                   	cli    
  1067aa:	59                   	pop    %ecx
	if (!IS_ENABLED(CONFIG_TICKLESS_KERNEL)) {
		return 0;
	}

	k_spinlock_key_t key = k_spin_lock(&lock);
	u32_t ret = (MAIN_COUNTER_REG - last_count) / cyc_per_tick;
  1067ab:	a1 f0 00 d0 fe       	mov    0xfed000f0,%eax
  1067b0:	31 d2                	xor    %edx,%edx
  1067b2:	2b 05 14 0b 11 00    	sub    0x110b14,%eax
  1067b8:	f7 35 18 0b 11 00    	divl   0x110b18
  1067be:	0f ba e1 09          	bt     $0x9,%ecx
  1067c2:	73 01                	jae    1067c5 <z_clock_elapsed+0x1d>
	__asm__ volatile (
  1067c4:	fb                   	sti    

	k_spin_unlock(&lock, key);
	return ret;
}
  1067c5:	c3                   	ret    

001067c6 <z_timer_cycle_get_32>:

u32_t z_timer_cycle_get_32(void)
{
	return MAIN_COUNTER_REG;
  1067c6:	a1 f0 00 d0 fe       	mov    0xfed000f0,%eax
}
  1067cb:	c3                   	ret    

001067cc <init_cache>:
#else
#define init_cache_line_size() do { } while ((0))
#endif

static int init_cache(struct device *unused)
{
  1067cc:	55                   	push   %ebp
  1067cd:	89 e5                	mov    %esp,%ebp
	sys_cache_line_size = z_cache_line_size_get();
  1067cf:	e8 09 00 00 00       	call   1067dd <z_cache_line_size_get>

	init_cache_flush();
	init_cache_line_size();

	return 0;
}
  1067d4:	5d                   	pop    %ebp
	sys_cache_line_size = z_cache_line_size_get();
  1067d5:	a3 20 0b 11 00       	mov    %eax,0x110b20
}
  1067da:	31 c0                	xor    %eax,%eax
  1067dc:	c3                   	ret    

001067dd <z_cache_line_size_get>:
	#define CPUID_CACHE_LINE_MASK (0xff << 8)

	GTEXT(z_cache_line_size_get)

SECTION_FUNC(TEXT, z_cache_line_size_get)
	pushl %ebx
  1067dd:	53                   	push   %ebx
	movl $1, %eax
  1067de:	b8 01 00 00 00       	mov    $0x1,%eax
	cpuid
  1067e3:	0f a2                	cpuid  
	movl %ebx, %eax
  1067e5:	89 d8                	mov    %ebx,%eax
	andl $CPUID_CACHE_LINE_MASK, %eax
  1067e7:	25 00 ff 00 00       	and    $0xff00,%eax
	shrl $5,%eax	/* shift right 8 to get value, then multiple by 8
  1067ec:	c1 e8 05             	shr    $0x5,%eax
					 * to get cache line size */
	popl %ebx
  1067ef:	5b                   	pop    %ebx
	ret
  1067f0:	c3                   	ret    

001067f1 <k_cpu_idle>:
	z_sys_trace_idle();
#if defined(CONFIG_BOOT_TIME_MEASUREMENT)
	__idle_time_stamp = (u64_t)k_cycle_get_32();
#endif

	__asm__ volatile (
  1067f1:	fb                   	sti    
  1067f2:	f4                   	hlt    
	    "sti\n\t"
	    "hlt\n\t");
}
  1067f3:	c3                   	ret    

001067f4 <_exception_enter>:
	 *
	 * Clear the direction flag.  It is automatically restored when the
	 * exception exits.
	 */

	cld
  1067f4:	fc                   	cld    
	call z_x86_trampoline_to_kernel
#endif
	/*
	 * Swap ecx and handler function on the current stack;
	 */
	xchgl	%ecx, (%esp)
  1067f5:	87 0c 24             	xchg   %ecx,(%esp)

	/*
	 * Push the remaining volatile registers on the existing stack.
	 */

	pushl	%eax
  1067f8:	50                   	push   %eax
	pushl	%edx
  1067f9:	52                   	push   %edx
	/*
	 * Push the cooperative registers on the existing stack as they are
	 * required by debug tools.
	 */

	pushl	%edi
  1067fa:	57                   	push   %edi
	pushl	%esi
  1067fb:	56                   	push   %esi
	pushl	%ebx
  1067fc:	53                   	push   %ebx
	pushl	%ebp
  1067fd:	55                   	push   %ebp
	 */
	pushl	44(%esp)
	jmp 2f
1:
#endif
	leal	44(%esp), %eax   /* Calculate ESP before interrupt occurred */
  1067fe:	8d 44 24 2c          	lea    0x2c(%esp),%eax
	pushl	%eax             /* Save calculated ESP */
  106802:	50                   	push   %eax
	 * Test IF bit of saved EFLAGS and re-enable interrupts if IF=1.
	 */

	/* ESP is still pointing to the ESF at this point */

	testl	$0x200, __NANO_ESF_eflags_OFFSET(%esp)
  106803:	f7 44 24 2c 00 02 00 	testl  $0x200,0x2c(%esp)
  10680a:	00 
	je	allDone
  10680b:	74 01                	je     10680e <allDone>
	sti
  10680d:	fb                   	sti    

0010680e <allDone>:

allDone:
#if CONFIG_X86_IAMCU
	movl	%esp, %eax		/* NANO_ESF * parameter */
#else
	pushl	%esp			/* push NANO_ESF * parameter */
  10680e:	54                   	push   %esp
#endif
	INDIRECT_CALL(%ecx)		/* call exception handler */
  10680f:	ff d1                	call   *%ecx

#ifndef CONFIG_X86_IAMCU
	addl	$0x4, %esp
  106811:	83 c4 04             	add    $0x4,%esp
	 * Pop the non-volatile registers from the stack.
	 * Note that debug tools may have altered the saved register values while
	 * the task was stopped, and we want to pick up the altered values.
	 */

	popl	%ebp		/* Discard saved ESP */
  106814:	5d                   	pop    %ebp
	popl	%ebp
  106815:	5d                   	pop    %ebp
	popl	%ebx
  106816:	5b                   	pop    %ebx
	popl	%esi
  106817:	5e                   	pop    %esi
	popl	%edi
  106818:	5f                   	pop    %edi

	/* restore edx and ecx which are always saved on the stack */

	popl	%edx
  106819:	5a                   	pop    %edx
	popl	%eax
  10681a:	58                   	pop    %eax
	popl	%ecx
  10681b:	59                   	pop    %ecx

	addl	$4, %esp	/* "pop" error code */
  10681c:	83 c4 04             	add    $0x4,%esp

	/* Pop of EFLAGS will re-enable interrupts and restore direction flag */
	KPTI_IRET
  10681f:	cf                   	iret   

00106820 <_kernel_oops_handler>:

#if CONFIG_X86_KERNEL_OOPS
SECTION_FUNC(TEXT, _kernel_oops_handler)
	push $0 /* dummy error code */
  106820:	6a 00                	push   $0x0
	push $z_do_kernel_oops
  106822:	68 00 6b 10 00       	push   $0x106b00
	jmp _exception_enter
  106827:	e9 c8 ff ff ff       	jmp    1067f4 <_exception_enter>

0010682c <_interrupt_enter>:
	 *
	 * Clear the direction flag.  It is automatically restored when the
	 * interrupt exits via the IRET instruction.
	 */

	cld
  10682c:	fc                   	cld    
#endif
	/*
	 * Swap EAX with isr_param and EDX with isr.
	 * Push ECX onto the stack
	 */
	xchgl	%eax, 4(%esp)
  10682d:	87 44 24 04          	xchg   %eax,0x4(%esp)
	xchgl	%edx, (%esp)
  106831:	87 14 24             	xchg   %edx,(%esp)
	pushl	%ecx
  106834:	51                   	push   %ecx

	/* Push EDI as we will use it for scratch space.
	 * Rest of the callee-saved regs get saved by invocation of C
	 * functions (isr handler, __swap(), etc)
	 */
	pushl	%edi
  106835:	57                   	push   %edi
	popl	%eax
#endif

	/* load %ecx with &_kernel */

	movl	$_kernel, %ecx
  106836:	b9 20 0a 11 00       	mov    $0x110a20,%ecx

	/* switch to the interrupt stack for the non-nested case */

	incl	_kernel_offset_to_nested(%ecx)
  10683b:	ff 01                	incl   (%ecx)

	/* use interrupt stack if not nested */
	cmpl	$1, _kernel_offset_to_nested(%ecx)
  10683d:	83 39 01             	cmpl   $0x1,(%ecx)
	jne	alreadyOnIntStack
  106840:	75 06                	jne    106848 <alreadyOnIntStack>
	/*
	 * switch to base of the interrupt stack: save esp in edi, then load
	 * irq_stack pointer
	 */

	movl	%esp, %edi
  106842:	89 e7                	mov    %esp,%edi
	movl	_kernel_offset_to_irq_stack(%ecx), %esp
  106844:	8b 61 04             	mov    0x4(%ecx),%esp


	/* save thread's stack pointer onto base of interrupt stack */

	pushl	%edi			/* Save stack pointer */
  106847:	57                   	push   %edi

00106848 <alreadyOnIntStack>:

#ifndef CONFIG_X86_IAMCU
	/* EAX has the interrupt handler argument, needs to go on
	 * stack for sys V calling convention
	 */
	push	%eax
  106848:	50                   	push   %eax
	pop %edx
	pop %eax
#endif

#ifdef CONFIG_NESTED_INTERRUPTS
	sti			/* re-enable interrupts */
  106849:	fb                   	sti    
#endif
	/* Now call the interrupt handler */
	INDIRECT_CALL(%edx)
  10684a:	ff d2                	call   *%edx
#ifndef CONFIG_X86_IAMCU
	/* Discard ISR argument */
	addl	$0x4, %esp
  10684c:	83 c4 04             	add    $0x4,%esp
#endif
#ifdef CONFIG_NESTED_INTERRUPTS
	cli			/* disable interrupts again */
  10684f:	fa                   	cli    
#endif

	/* irq_controller.h interface */
	_irq_controller_eoi_macro
  106850:	31 c0                	xor    %eax,%eax
  106852:	a3 b0 00 e0 fe       	mov    %eax,0xfee000b0
#ifdef CONFIG_INT_LATENCY_BENCHMARK
	call	z_int_latency_start
#endif

	/* determine whether exiting from a nested interrupt */
	movl	$_kernel, %ecx
  106857:	b9 20 0a 11 00       	mov    $0x110a20,%ecx
	decl	_kernel_offset_to_nested(%ecx)	/* dec interrupt nest count */
  10685c:	ff 09                	decl   (%ecx)
	jne	nestedInterrupt                 /* 'iret' if nested case */
  10685e:	75 18                	jne    106878 <nestedInterrupt>


#ifdef CONFIG_PREEMPT_ENABLED
	movl	_kernel_offset_to_current(%ecx), %edx
  106860:	8b 51 08             	mov    0x8(%ecx),%edx

	/* reschedule only if the scheduler says that we must do so */
	cmpl	%edx, _kernel_offset_to_ready_q_cache(%ecx)
  106863:	39 51 20             	cmp    %edx,0x20(%ecx)
	je	noReschedule
  106866:	74 0f                	je     106877 <noReschedule>
	 * the existing __swap() primitive to save the remaining
	 * thread's registers (including floating point) and perform
	 * a switch to the new thread.
	 */

	popl	%esp	/* switch back to outgoing thread's stack */
  106868:	5c                   	pop    %esp

#ifdef CONFIG_STACK_SENTINEL
	call	z_check_stack_sentinel
#endif
	pushfl			/* push KERNEL_LOCK_KEY argument */
  106869:	9c                   	pushf  
#ifdef CONFIG_X86_IAMCU
	/* IAMCU first argument goes into a register, not the stack.
	 */
	popl	%eax
#endif
	call	__swap
  10686a:	e8 26 00 00 00       	call   106895 <__swap>

#ifndef CONFIG_X86_IAMCU
	addl 	$4, %esp	/* pop KERNEL_LOCK_KEY argument */
  10686f:	83 c4 04             	add    $0x4,%esp

	/* Restore volatile registers and return to the interrupted thread */
#ifdef CONFIG_INT_LATENCY_BENCHMARK
	call	z_int_latency_stop
#endif
	popl	%edi
  106872:	5f                   	pop    %edi
	popl	%ecx
  106873:	59                   	pop    %ecx
	popl	%edx
  106874:	5a                   	pop    %edx
	popl	%eax
  106875:	58                   	pop    %eax

	/* Pop of EFLAGS will re-enable interrupts and restore direction flag */
	KPTI_IRET
  106876:	cf                   	iret   

00106877 <noReschedule>:
	/*
	 * A thread reschedule is not required; switch back to the
	 * interrupted thread's stack and restore volatile registers
	 */

	popl	%esp		/* pop thread stack pointer */
  106877:	5c                   	pop    %esp

00106878 <nestedInterrupt>:
nestedInterrupt:
#ifdef CONFIG_INT_LATENCY_BENCHMARK
	call	z_int_latency_stop
#endif

	popl	%edi
  106878:	5f                   	pop    %edi
	popl	%ecx		/* pop volatile registers in reverse order */
  106879:	59                   	pop    %ecx
	popl	%edx
  10687a:	5a                   	pop    %edx
	popl	%eax
  10687b:	58                   	pop    %eax
	/* Pop of EFLAGS will re-enable interrupts and restore direction flag */
	KPTI_IRET
  10687c:	cf                   	iret   

0010687d <z_SpuriousIntNoErrCodeHandler>:
 * thus z_SpuriousIntNoErrCodeHandler()/z_SpuriousIntHandler() shall be
 * invoked with interrupts disabled.
 */
SECTION_FUNC(TEXT, z_SpuriousIntNoErrCodeHandler)

	pushl	$0			/* push dummy err code onto stk */
  10687d:	6a 00                	push   $0x0

0010687f <z_SpuriousIntHandler>:
	/* fall through to z_SpuriousIntHandler */


SECTION_FUNC(TEXT, z_SpuriousIntHandler)

	cld				/* Clear direction flag */
  10687f:	fc                   	cld    

	/* Create the ESF */

	pushl %eax
  106880:	50                   	push   %eax
	pushl %ecx
  106881:	51                   	push   %ecx
	pushl %edx
  106882:	52                   	push   %edx
	pushl %edi
  106883:	57                   	push   %edi
	pushl %esi
  106884:	56                   	push   %esi
	pushl %ebx
  106885:	53                   	push   %ebx
	pushl %ebp
  106886:	55                   	push   %ebp

	leal	44(%esp), %ecx   /* Calculate ESP before exception occurred */
  106887:	8d 4c 24 2c          	lea    0x2c(%esp),%ecx
	pushl	%ecx             /* Save calculated ESP */
  10688b:	51                   	push   %ecx

#ifndef CONFIG_X86_IAMCU
	pushl	%esp			/* push cur stack pointer: pEsf arg */
  10688c:	54                   	push   %esp
#else
	mov	%esp, %edx
#endif

	/* re-enable interrupts */
	sti
  10688d:	fb                   	sti    

	/* push the 'unsigned int reason' parameter */
#ifndef CONFIG_X86_IAMCU
	pushl	$_NANO_ERR_SPURIOUS_INT
  10688e:	6a 00                	push   $0x0
#else
	movl	$_NANO_ERR_SPURIOUS_INT, %eax
#endif
	/* call the fatal error handler */
	call	z_NanoFatalErrorHandler
  106890:	e8 12 01 00 00       	call   1069a7 <z_NanoFatalErrorHandler>

00106895 <__swap>:
	 * any of these registers into the k_thread.  Only the 'esp' register
	 * after all the pushes have been performed) will be stored in the
	 * k_thread.
	 */

	pushl	%edi
  106895:	57                   	push   %edi

	movl	$_kernel, %edi
  106896:	bf 20 0a 11 00       	mov    $0x110a20,%edi

	pushl	%esi
  10689b:	56                   	push   %esi
	pushl	%ebx
  10689c:	53                   	push   %ebx
	pushl	%ebp
  10689d:	55                   	push   %ebp
	 * -EAGAIN eliminates the need for the timeout code to set it.
	 * If another value is ever needed, it can be modified with
	 * z_set_thread_return_value().
	 */

	pushl   _k_neg_eagain
  10689e:	ff 35 00 de 10 00    	pushl  0x10de00


	/* save esp into k_thread structure */

	movl	_kernel_offset_to_current(%edi), %edx
  1068a4:	8b 57 08             	mov    0x8(%edi),%edx
	movl	%esp, _thread_offset_to_esp(%edx)
  1068a7:	89 62 28             	mov    %esp,0x28(%edx)
	/* Register the context switch */
	push %edx
	call	z_sys_trace_thread_switched_in
	pop %edx
#endif
	movl	_kernel_offset_to_ready_q_cache(%edi), %eax
  1068aa:	8b 47 20             	mov    0x20(%edi),%eax

#endif /* CONFIG_LAZY_FP_SHARING */

	/* update _kernel.current to reflect incoming thread */

	movl    %eax, _kernel_offset_to_current(%edi)
  1068ad:	89 47 08             	mov    %eax,0x8(%edi)

	/* recover thread stack pointer from k_thread */

	movl	_thread_offset_to_esp(%eax), %esp
  1068b0:	8b 60 28             	mov    0x28(%eax),%esp


	/* load return value from a possible z_set_thread_return_value() */

	popl	%eax
  1068b3:	58                   	pop    %eax

	/* pop the non-volatile registers from the stack */

	popl	%ebp
  1068b4:	5d                   	pop    %ebp
	popl	%ebx
  1068b5:	5b                   	pop    %ebx
	popl	%esi
  1068b6:	5e                   	pop    %esi
	popl	%edi
  1068b7:	5f                   	pop    %edi
	 * - -EINVAL
	 */

	/* Utilize the 'eflags' parameter to __swap() */

	pushl	4(%esp)
  1068b8:	ff 74 24 04          	pushl  0x4(%esp)
	/* restore __swap's %eax */
	popl	%eax

skipIntLatencyStop:
#endif
	popfl
  1068bc:	9d                   	popf   
	read_tsc __common_var_swap_end_time
	pushl __start_swap_time
	popl __temp_start_swap_time
time_read_not_needed:
#endif
	ret
  1068bd:	c3                   	ret    

001068be <z_SysFatalErrorHandler>:
 *
 * @return This function does not return.
 */
FUNC_NORETURN __weak void z_SysFatalErrorHandler(unsigned int reason,
					 const NANO_ESF *pEsf)
{
  1068be:	55                   	push   %ebp
  1068bf:	89 e5                	mov    %esp,%ebp
K_SYSCALL_DECLARE0_VOID(K_SYSCALL_LOG_PANIC, log_panic)
  1068c1:	e8 a0 ab ff ff       	call   101466 <z_impl_log_panic>
#ifdef CONFIG_STACK_SENTINEL
	if (reason == _NANO_ERR_STACK_CHK_FAIL) {
		goto hang_system;
	}
#endif
	if (reason == _NANO_ERR_KERNEL_PANIC) {
  1068c6:	83 7d 08 08          	cmpl   $0x8,0x8(%ebp)
  1068ca:	74 54                	je     106920 <z_SysFatalErrorHandler+0x62>
		goto hang_system;
	}
	if (k_is_in_isr() || z_is_thread_essential()) {
  1068cc:	e8 b1 43 00 00       	call   10ac82 <k_is_in_isr>
  1068d1:	84 c0                	test   %al,%al
  1068d3:	74 15                	je     1068ea <z_SysFatalErrorHandler+0x2c>
		printk("Fatal fault in %s! Spinning...\n",
		       k_is_in_isr() ? "ISR" : "essential thread");
  1068d5:	e8 a8 43 00 00       	call   10ac82 <k_is_in_isr>
		printk("Fatal fault in %s! Spinning...\n",
  1068da:	ba 72 eb 10 00       	mov    $0x10eb72,%edx
  1068df:	84 c0                	test   %al,%al
  1068e1:	75 30                	jne    106913 <z_SysFatalErrorHandler+0x55>
  1068e3:	ba 76 eb 10 00       	mov    $0x10eb76,%edx
  1068e8:	eb 29                	jmp    106913 <z_SysFatalErrorHandler+0x55>
	if (k_is_in_isr() || z_is_thread_essential()) {
  1068ea:	e8 9e 43 00 00       	call   10ac8d <z_is_thread_essential>
  1068ef:	84 c0                	test   %al,%al
  1068f1:	75 e2                	jne    1068d5 <z_SysFatalErrorHandler+0x17>
		goto hang_system;
	}
	printk("Fatal fault in thread %p! Aborting.\n", _current);
  1068f3:	ff 35 28 0a 11 00    	pushl  0x110a28
  1068f9:	68 a7 eb 10 00       	push   $0x10eba7
  1068fe:	e8 0e a0 ff ff       	call   100911 <printk>
  106903:	58                   	pop    %eax
  106904:	5a                   	pop    %edx
K_SYSCALL_DECLARE1_VOID(K_SYSCALL_K_THREAD_ABORT, k_thread_abort, k_tid_t, thread)
  106905:	ff 35 28 0a 11 00    	pushl  0x110a28
  10690b:	e8 45 46 00 00       	call   10af55 <z_impl_k_thread_abort>
  106910:	59                   	pop    %ecx
  106911:	eb 0d                	jmp    106920 <z_SysFatalErrorHandler+0x62>
		printk("Fatal fault in %s! Spinning...\n",
  106913:	52                   	push   %edx
  106914:	68 87 eb 10 00       	push   $0x10eb87
  106919:	e8 f3 9f ff ff       	call   100911 <printk>
  10691e:	58                   	pop    %eax
  10691f:	5a                   	pop    %edx
	 * -device isa-debug-exit,iobase=0xf4,iosize=0x04
	 */
	sys_out32(0, 0xf4);
#else
	for (;;) {
		k_cpu_idle();
  106920:	e8 cc fe ff ff       	call   1067f1 <k_cpu_idle>
  106925:	eb f9                	jmp    106920 <z_SysFatalErrorHandler+0x62>

00106927 <z_new_thread>:
 */
void z_new_thread(struct k_thread *thread, k_thread_stack_t *stack,
		 size_t stack_size, k_thread_entry_t entry,
		 void *parameter1, void *parameter2, void *parameter3,
		 int priority, unsigned int options)
{
  106927:	55                   	push   %ebp
  106928:	89 e5                	mov    %esp,%ebp
  10692a:	57                   	push   %edi
  10692b:	56                   	push   %esi
  10692c:	53                   	push   %ebx
  10692d:	8b 7d 10             	mov    0x10(%ebp),%edi
	ARG_UNUSED(pStack);
	ARG_UNUSED(stackSize);
#endif

#ifdef CONFIG_INIT_STACKS
	memset(pStack, 0xaa, stackSize);
  106930:	57                   	push   %edi
  106931:	8b 75 0c             	mov    0xc(%ebp),%esi
  106934:	68 aa 00 00 00       	push   $0xaa
  106939:	8b 5d 08             	mov    0x8(%ebp),%ebx
  10693c:	56                   	push   %esi
  10693d:	e8 3f 05 00 00       	call   106e81 <memset>
  106942:	83 c4 0c             	add    $0xc,%esp
	 * if it isn't.
	 */
	*((u32_t *)pStack) = STACK_SENTINEL;
#endif /* CONFIG_STACK_SENTINEL */
	/* Initialize various struct k_thread members */
	z_init_thread_base(&thread->base, prio, _THREAD_PRESTART, options);
  106945:	ff 75 28             	pushl  0x28(%ebp)
  106948:	6a 04                	push   $0x4
  10694a:	ff 75 24             	pushl  0x24(%ebp)
  10694d:	53                   	push   %ebx
  10694e:	e8 d6 45 00 00       	call   10af29 <z_init_thread_base>
#if CONFIG_X86_STACK_PROTECTION
	z_x86_mmu_set_flags(&z_x86_kernel_pdpt, stack, MMU_PAGE_SIZE,
			   MMU_ENTRY_NOT_PRESENT, MMU_PTE_P_MASK);
#endif

	stack_high = (char *)STACK_ROUND_DOWN(stack_buf + stack_size);
  106953:	8d 04 3e             	lea    (%esi,%edi,1),%eax

	/* Create an initial context on the stack expected by z_swap() */
	initial_frame = (struct _x86_initial_frame *)
		(stack_high - sizeof(struct _x86_initial_frame));
	/* z_thread_entry() arguments */
	initial_frame->entry = entry;
  106956:	8b 55 14             	mov    0x14(%ebp),%edx
	stack_high = (char *)STACK_ROUND_DOWN(stack_buf + stack_size);
  106959:	83 e0 fc             	and    $0xfffffffc,%eax

	/* static threads overwrite it afterwards with real value */
	thread->init_data = NULL;
  10695c:	c7 43 2c 00 00 00 00 	movl   $0x0,0x2c(%ebx)
	thread->fn_abort = NULL;
  106963:	c7 43 30 00 00 00 00 	movl   $0x0,0x30(%ebx)
	/* Initialize custom data field (value is opaque to kernel) */
	thread->custom_data = NULL;
#endif

#ifdef CONFIG_THREAD_NAME
	thread->name[0] = '\0';
  10696a:	c6 43 48 00          	movb   $0x0,0x48(%ebx)
	initial_frame->entry = entry;
  10696e:	89 50 f0             	mov    %edx,-0x10(%eax)
	initial_frame->p1 = parameter1;
  106971:	8b 55 18             	mov    0x18(%ebp),%edx
  106974:	89 50 f4             	mov    %edx,-0xc(%eax)
	initial_frame->p2 = parameter2;
  106977:	8b 55 1c             	mov    0x1c(%ebp),%edx
  10697a:	89 50 f8             	mov    %edx,-0x8(%eax)
	initial_frame->p3 = parameter3;
  10697d:	8b 55 20             	mov    0x20(%ebp),%edx
	z_init_thread_base(&thread->base, prio, _THREAD_PRESTART, options);
  106980:	83 c4 10             	add    $0x10,%esp
  106983:	89 50 fc             	mov    %edx,-0x4(%eax)
 */
static inline unsigned int EflagsGet(void)
{
	unsigned int eflags; /* EFLAGS register contents */

	__asm__ volatile(
  106986:	9c                   	pushf  
  106987:	5a                   	pop    %edx
	/* initial EFLAGS; only modify IF and IOPL bits */
	initial_frame->eflags = (EflagsGet() & ~EFLAGS_MASK) | EFLAGS_INITIAL;
  106988:	80 e6 cd             	and    $0xcd,%dh
	{
#ifdef _THREAD_WRAPPER_REQUIRED
		initial_frame->edi = (u32_t)z_thread_entry;
		initial_frame->thread_entry = z_x86_thread_entry_wrapper;
#else
		initial_frame->thread_entry = z_thread_entry;
  10698b:	c7 40 e8 23 04 10 00 	movl   $0x100423,-0x18(%eax)
	initial_frame->eflags = (EflagsGet() & ~EFLAGS_MASK) | EFLAGS_INITIAL;
  106992:	80 ce 02             	or     $0x2,%dh
	initial_frame = (struct _x86_initial_frame *)
  106995:	83 e8 2c             	sub    $0x2c,%eax
	initial_frame->eflags = (EflagsGet() & ~EFLAGS_MASK) | EFLAGS_INITIAL;
  106998:	89 50 18             	mov    %edx,0x18(%eax)
	initial_frame = (struct _x86_initial_frame *)
  10699b:	89 43 28             	mov    %eax,0x28(%ebx)
	thread->callee_saved.esp = (unsigned long)initial_frame;

#if defined(CONFIG_LAZY_FP_SHARING)
	thread->arch.excNestCount = 0;
#endif /* CONFIG_LAZY_FP_SHARING */
}
  10699e:	8d 65 f4             	lea    -0xc(%ebp),%esp
  1069a1:	5b                   	pop    %ebx
  1069a2:	5e                   	pop    %esi
  1069a3:	5f                   	pop    %edi
  1069a4:	5d                   	pop    %ebp
  1069a5:	c3                   	ret    

001069a6 <z_debug_fatal_hook>:
#include <exception.h>
#include <inttypes.h>
#include <exc_handle.h>
#include <logging/log_ctrl.h>

__weak void z_debug_fatal_hook(const NANO_ESF *esf) { ARG_UNUSED(esf); }
  1069a6:	c3                   	ret    

001069a7 <z_NanoFatalErrorHandler>:
 *
 * @return This function does not return.
 */
FUNC_NORETURN void z_NanoFatalErrorHandler(unsigned int reason,
					  const NANO_ESF *pEsf)
{
  1069a7:	55                   	push   %ebp
  1069a8:	89 e5                	mov    %esp,%ebp
  1069aa:	57                   	push   %edi
  1069ab:	56                   	push   %esi
  1069ac:	53                   	push   %ebx
  1069ad:	83 ec 28             	sub    $0x28,%esp
  1069b0:	8b 7d 0c             	mov    0xc(%ebp),%edi
  1069b3:	8b 75 08             	mov    0x8(%ebp),%esi
  1069b6:	e8 ab aa ff ff       	call   101466 <z_impl_log_panic>
	LOG_PANIC();

	z_debug_fatal_hook(pEsf);
  1069bb:	57                   	push   %edi
  1069bc:	e8 e5 ff ff ff       	call   1069a6 <z_debug_fatal_hook>
  1069c1:	58                   	pop    %eax

#ifdef CONFIG_PRINTK

	/* Display diagnostic information about the error */

	switch (reason) {
  1069c2:	83 fe 08             	cmp    $0x8,%esi
  1069c5:	77 4c                	ja     106a13 <z_NanoFatalErrorHandler+0x6c>
  1069c7:	ff 24 b5 c8 dc 10 00 	jmp    *0x10dcc8(,%esi,4)
 * @return the vector of the interrupt that is currently being processed, or
 * -1 if this can't be determined
 */
static inline int z_irq_controller_isr_vector_get(void)
{
	return __irq_controller_isr_vector_get();
  1069ce:	e8 6b f1 ff ff       	call   105b3e <__irq_controller_isr_vector_get>
		break;

	case _NANO_ERR_SPURIOUS_INT: {
		int vector = z_irq_controller_isr_vector_get();

		printk("***** Unhandled interrupt vector ");
  1069d3:	68 cc eb 10 00       	push   $0x10ebcc
  1069d8:	89 c3                	mov    %eax,%ebx
  1069da:	e8 32 9f ff ff       	call   100911 <printk>
  1069df:	58                   	pop    %eax
		if (vector >= 0) {
  1069e0:	85 db                	test   %ebx,%ebx
  1069e2:	78 0d                	js     1069f1 <z_NanoFatalErrorHandler+0x4a>
			printk("%d ", vector);
  1069e4:	53                   	push   %ebx
  1069e5:	68 ee eb 10 00       	push   $0x10ebee
  1069ea:	e8 22 9f ff ff       	call   100911 <printk>
  1069ef:	5b                   	pop    %ebx
  1069f0:	58                   	pop    %eax
		}
		printk("*****\n");
  1069f1:	68 05 ec 10 00       	push   $0x10ec05
  1069f6:	eb 05                	jmp    1069fd <z_NanoFatalErrorHandler+0x56>
		printk("***** Stack Check Fail! *****\n");
		break;
#endif /* CONFIG_STACK_CANARIES */

	case _NANO_ERR_KERNEL_OOPS:
		printk("***** Kernel OOPS! *****\n");
  1069f8:	68 f2 eb 10 00       	push   $0x10ebf2
  1069fd:	e8 0f 9f ff ff       	call   100911 <printk>
  106a02:	59                   	pop    %ecx
		break;
  106a03:	eb 1b                	jmp    106a20 <z_NanoFatalErrorHandler+0x79>

	case _NANO_ERR_KERNEL_PANIC:
		printk("***** Kernel Panic! *****\n");
  106a05:	68 0c ec 10 00       	push   $0x10ec0c
  106a0a:	eb f1                	jmp    1069fd <z_NanoFatalErrorHandler+0x56>
		break;

	case _NANO_ERR_ALLOCATION_FAIL:
		printk("**** Kernel Allocation Failure! ****\n");
  106a0c:	68 27 ec 10 00       	push   $0x10ec27
  106a11:	eb ea                	jmp    1069fd <z_NanoFatalErrorHandler+0x56>
		break;

	default:
		printk("**** Unknown Fatal Error %d! ****\n", reason);
  106a13:	56                   	push   %esi
  106a14:	68 4d ec 10 00       	push   $0x10ec4d
  106a19:	e8 f3 9e ff ff       	call   100911 <printk>
  106a1e:	58                   	pop    %eax
  106a1f:	5a                   	pop    %edx
		break;
	}

	printk("Current thread ID = %p\n"
  106a20:	8b 47 2c             	mov    0x2c(%edi),%eax
  106a23:	8b 4f 24             	mov    0x24(%edi),%ecx
  106a26:	89 45 f0             	mov    %eax,-0x10(%ebp)
  106a29:	8b 07                	mov    (%edi),%eax
  106a2b:	89 45 ec             	mov    %eax,-0x14(%ebp)
  106a2e:	8b 47 04             	mov    0x4(%edi),%eax
  106a31:	89 45 e8             	mov    %eax,-0x18(%ebp)
  106a34:	8b 47 10             	mov    0x10(%edi),%eax
  106a37:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  106a3a:	8b 47 0c             	mov    0xc(%edi),%eax
  106a3d:	89 45 e0             	mov    %eax,-0x20(%ebp)
  106a40:	8b 47 14             	mov    0x14(%edi),%eax
  106a43:	0f b7 57 28          	movzwl 0x28(%edi),%edx
  106a47:	89 45 dc             	mov    %eax,-0x24(%ebp)
  106a4a:	8b 47 1c             	mov    0x1c(%edi),%eax
  106a4d:	89 45 d8             	mov    %eax,-0x28(%ebp)
  106a50:	8b 47 08             	mov    0x8(%edi),%eax
  106a53:	89 4d cc             	mov    %ecx,-0x34(%ebp)
  106a56:	89 55 d0             	mov    %edx,-0x30(%ebp)
  106a59:	8b 5f 18             	mov    0x18(%edi),%ebx
  106a5c:	89 45 d4             	mov    %eax,-0x2c(%ebp)
K_SYSCALL_DECLARE0(K_SYSCALL_K_CURRENT_GET, k_current_get, k_tid_t)
  106a5f:	e8 bf 40 00 00       	call   10ab23 <z_impl_k_current_get>
  106a64:	8b 4d cc             	mov    -0x34(%ebp),%ecx
  106a67:	51                   	push   %ecx
  106a68:	8b 55 d0             	mov    -0x30(%ebp),%edx
  106a6b:	52                   	push   %edx
  106a6c:	ff 75 f0             	pushl  -0x10(%ebp)
  106a6f:	ff 75 ec             	pushl  -0x14(%ebp)
  106a72:	ff 75 e8             	pushl  -0x18(%ebp)
  106a75:	ff 75 e4             	pushl  -0x1c(%ebp)
  106a78:	ff 75 e0             	pushl  -0x20(%ebp)
  106a7b:	ff 75 dc             	pushl  -0x24(%ebp)
  106a7e:	ff 75 d8             	pushl  -0x28(%ebp)
  106a81:	ff 75 d4             	pushl  -0x2c(%ebp)
  106a84:	53                   	push   %ebx
  106a85:	50                   	push   %eax
  106a86:	68 70 ec 10 00       	push   $0x10ec70
  106a8b:	e8 81 9e ff ff       	call   100911 <printk>
  106a90:	83 c4 34             	add    $0x34,%esp
	/*
	 * Error was fatal to a kernel task or a thread; invoke the system
	 * fatal error handling policy defined for the platform.
	 */

	z_SysFatalErrorHandler(reason, pEsf);
  106a93:	57                   	push   %edi
  106a94:	56                   	push   %esi
  106a95:	e8 24 fe ff ff       	call   1068be <z_SysFatalErrorHandler>

00106a9a <generic_exc_handle>:

#if CONFIG_EXCEPTION_DEBUG

static FUNC_NORETURN void generic_exc_handle(unsigned int vector,
					     const NANO_ESF *pEsf)
{
  106a9a:	55                   	push   %ebp
  106a9b:	89 e5                	mov    %esp,%ebp
  106a9d:	56                   	push   %esi
  106a9e:	53                   	push   %ebx
  106a9f:	89 c3                	mov    %eax,%ebx
	printk("***** ");
  106aa1:	68 14 ed 10 00       	push   $0x10ed14
{
  106aa6:	89 d6                	mov    %edx,%esi
	printk("***** ");
  106aa8:	e8 64 9e ff ff       	call   100911 <printk>
  106aad:	58                   	pop    %eax
	switch (vector) {
  106aae:	83 fb 07             	cmp    $0x7,%ebx
  106ab1:	74 12                	je     106ac5 <generic_exc_handle+0x2b>
  106ab3:	83 fb 0d             	cmp    $0xd,%ebx
  106ab6:	75 1a                	jne    106ad2 <generic_exc_handle+0x38>
	case IV_GENERAL_PROTECTION:
		printk("General Protection Fault\n");
  106ab8:	68 1b ed 10 00       	push   $0x10ed1b
  106abd:	e8 4f 9e ff ff       	call   100911 <printk>
  106ac2:	58                   	pop    %eax
		break;
	default:
		printk("CPU exception %d\n", vector);
		break;
	}
	if ((BIT(vector) & _EXC_ERROR_CODE_FAULTS) != 0) {
  106ac3:	eb 24                	jmp    106ae9 <generic_exc_handle+0x4f>
		printk("Floating point unit not enabled\n");
  106ac5:	68 35 ed 10 00       	push   $0x10ed35
  106aca:	e8 42 9e ff ff       	call   100911 <printk>
  106acf:	58                   	pop    %eax
	if ((BIT(vector) & _EXC_ERROR_CODE_FAULTS) != 0) {
  106ad0:	eb 26                	jmp    106af8 <generic_exc_handle+0x5e>
		printk("CPU exception %d\n", vector);
  106ad2:	53                   	push   %ebx
  106ad3:	68 56 ed 10 00       	push   $0x10ed56
  106ad8:	e8 34 9e ff ff       	call   100911 <printk>
  106add:	59                   	pop    %ecx
  106ade:	58                   	pop    %eax
	if ((BIT(vector) & _EXC_ERROR_CODE_FAULTS) != 0) {
  106adf:	b8 00 7d 02 00       	mov    $0x27d00,%eax
  106ae4:	0f a3 d8             	bt     %ebx,%eax
  106ae7:	73 0f                	jae    106af8 <generic_exc_handle+0x5e>
		printk("***** Exception code: 0x%x\n", pEsf->errorCode);
  106ae9:	ff 76 20             	pushl  0x20(%esi)
  106aec:	68 68 ed 10 00       	push   $0x10ed68
  106af1:	e8 1b 9e ff ff       	call   100911 <printk>
  106af6:	58                   	pop    %eax
  106af7:	5a                   	pop    %edx
	}
	z_NanoFatalErrorHandler(_NANO_ERR_CPU_EXCEPTION, pEsf);
  106af8:	56                   	push   %esi
  106af9:	6a 06                	push   $0x6
  106afb:	e8 a7 fe ff ff       	call   1069a7 <z_NanoFatalErrorHandler>

00106b00 <z_do_kernel_oops>:
{
  106b00:	55                   	push   %ebp
  106b01:	89 e5                	mov    %esp,%ebp
  106b03:	8b 45 08             	mov    0x8(%ebp),%eax
	z_NanoFatalErrorHandler(*stack_ptr, esf);
  106b06:	50                   	push   %eax
  106b07:	8b 00                	mov    (%eax),%eax
  106b09:	ff 30                	pushl  (%eax)
  106b0b:	e8 97 fe ff ff       	call   1069a7 <z_NanoFatalErrorHandler>

00106b10 <handle_exc_0>:
	Z_EXC_FUNC_NOCODE(vector)

#define EXC_FUNC_CODE(vector) \
	Z_EXC_FUNC_CODE(vector)

EXC_FUNC_NOCODE(IV_DIVIDE_ERROR);
  106b10:	55                   	push   %ebp
  106b11:	31 c0                	xor    %eax,%eax
  106b13:	89 e5                	mov    %esp,%ebp
  106b15:	8b 55 08             	mov    0x8(%ebp),%edx
  106b18:	e8 7d ff ff ff       	call   106a9a <generic_exc_handle>

00106b1d <handle_exc_2>:
EXC_FUNC_NOCODE(IV_NON_MASKABLE_INTERRUPT);
  106b1d:	55                   	push   %ebp
  106b1e:	b8 02 00 00 00       	mov    $0x2,%eax
  106b23:	89 e5                	mov    %esp,%ebp
  106b25:	8b 55 08             	mov    0x8(%ebp),%edx
  106b28:	e8 6d ff ff ff       	call   106a9a <generic_exc_handle>

00106b2d <handle_exc_4>:
EXC_FUNC_NOCODE(IV_OVERFLOW);
  106b2d:	55                   	push   %ebp
  106b2e:	b8 04 00 00 00       	mov    $0x4,%eax
  106b33:	89 e5                	mov    %esp,%ebp
  106b35:	8b 55 08             	mov    0x8(%ebp),%edx
  106b38:	e8 5d ff ff ff       	call   106a9a <generic_exc_handle>

00106b3d <handle_exc_5>:
EXC_FUNC_NOCODE(IV_BOUND_RANGE);
  106b3d:	55                   	push   %ebp
  106b3e:	b8 05 00 00 00       	mov    $0x5,%eax
  106b43:	89 e5                	mov    %esp,%ebp
  106b45:	8b 55 08             	mov    0x8(%ebp),%edx
  106b48:	e8 4d ff ff ff       	call   106a9a <generic_exc_handle>

00106b4d <handle_exc_6>:
EXC_FUNC_NOCODE(IV_INVALID_OPCODE);
  106b4d:	55                   	push   %ebp
  106b4e:	b8 06 00 00 00       	mov    $0x6,%eax
  106b53:	89 e5                	mov    %esp,%ebp
  106b55:	8b 55 08             	mov    0x8(%ebp),%edx
  106b58:	e8 3d ff ff ff       	call   106a9a <generic_exc_handle>

00106b5d <handle_exc_7>:
EXC_FUNC_NOCODE(IV_DEVICE_NOT_AVAILABLE);
  106b5d:	55                   	push   %ebp
  106b5e:	b8 07 00 00 00       	mov    $0x7,%eax
  106b63:	89 e5                	mov    %esp,%ebp
  106b65:	8b 55 08             	mov    0x8(%ebp),%edx
  106b68:	e8 2d ff ff ff       	call   106a9a <generic_exc_handle>

00106b6d <handle_exc_8>:
#ifndef CONFIG_X86_ENABLE_TSS
EXC_FUNC_NOCODE(IV_DOUBLE_FAULT);
  106b6d:	55                   	push   %ebp
  106b6e:	b8 08 00 00 00       	mov    $0x8,%eax
  106b73:	89 e5                	mov    %esp,%ebp
  106b75:	8b 55 08             	mov    0x8(%ebp),%edx
  106b78:	e8 1d ff ff ff       	call   106a9a <generic_exc_handle>

00106b7d <handle_exc_10>:
#endif
EXC_FUNC_CODE(IV_INVALID_TSS);
  106b7d:	55                   	push   %ebp
  106b7e:	b8 0a 00 00 00       	mov    $0xa,%eax
  106b83:	89 e5                	mov    %esp,%ebp
  106b85:	8b 55 08             	mov    0x8(%ebp),%edx
  106b88:	e8 0d ff ff ff       	call   106a9a <generic_exc_handle>

00106b8d <handle_exc_11>:
EXC_FUNC_CODE(IV_SEGMENT_NOT_PRESENT);
  106b8d:	55                   	push   %ebp
  106b8e:	b8 0b 00 00 00       	mov    $0xb,%eax
  106b93:	89 e5                	mov    %esp,%ebp
  106b95:	8b 55 08             	mov    0x8(%ebp),%edx
  106b98:	e8 fd fe ff ff       	call   106a9a <generic_exc_handle>

00106b9d <handle_exc_12>:
EXC_FUNC_CODE(IV_STACK_FAULT);
  106b9d:	55                   	push   %ebp
  106b9e:	b8 0c 00 00 00       	mov    $0xc,%eax
  106ba3:	89 e5                	mov    %esp,%ebp
  106ba5:	8b 55 08             	mov    0x8(%ebp),%edx
  106ba8:	e8 ed fe ff ff       	call   106a9a <generic_exc_handle>

00106bad <handle_exc_13>:
EXC_FUNC_CODE(IV_GENERAL_PROTECTION);
  106bad:	55                   	push   %ebp
  106bae:	b8 0d 00 00 00       	mov    $0xd,%eax
  106bb3:	89 e5                	mov    %esp,%ebp
  106bb5:	8b 55 08             	mov    0x8(%ebp),%edx
  106bb8:	e8 dd fe ff ff       	call   106a9a <generic_exc_handle>

00106bbd <handle_exc_16>:
EXC_FUNC_NOCODE(IV_X87_FPU_FP_ERROR);
  106bbd:	55                   	push   %ebp
  106bbe:	b8 10 00 00 00       	mov    $0x10,%eax
  106bc3:	89 e5                	mov    %esp,%ebp
  106bc5:	8b 55 08             	mov    0x8(%ebp),%edx
  106bc8:	e8 cd fe ff ff       	call   106a9a <generic_exc_handle>

00106bcd <handle_exc_17>:
EXC_FUNC_CODE(IV_ALIGNMENT_CHECK);
  106bcd:	55                   	push   %ebp
  106bce:	b8 11 00 00 00       	mov    $0x11,%eax
  106bd3:	89 e5                	mov    %esp,%ebp
  106bd5:	8b 55 08             	mov    0x8(%ebp),%edx
  106bd8:	e8 bd fe ff ff       	call   106a9a <generic_exc_handle>

00106bdd <handle_exc_18>:
EXC_FUNC_NOCODE(IV_MACHINE_CHECK);
  106bdd:	55                   	push   %ebp
  106bde:	b8 12 00 00 00       	mov    $0x12,%eax
  106be3:	89 e5                	mov    %esp,%ebp
  106be5:	8b 55 08             	mov    0x8(%ebp),%edx
  106be8:	e8 ad fe ff ff       	call   106a9a <generic_exc_handle>

00106bed <page_fault_handler>:
	Z_EXC_HANDLE(z_arch_user_string_nlen)
};
#endif

void page_fault_handler(NANO_ESF *esf)
{
  106bed:	55                   	push   %ebp
  106bee:	89 e5                	mov    %esp,%ebp
  106bf0:	57                   	push   %edi
  106bf1:	56                   	push   %esi
  106bf2:	8b 75 08             	mov    0x8(%ebp),%esi
  106bf5:	53                   	push   %ebx
	__asm__ ("mov %%cr2, %0" : "=r" (cr2));
  106bf6:	0f 20 d7             	mov    %cr2,%edi
	err = esf->errorCode;
  106bf9:	8b 5e 20             	mov    0x20(%esi),%ebx
	printk("***** CPU Page Fault (error code 0x%08x)\n", err);
  106bfc:	53                   	push   %ebx
  106bfd:	68 a3 ed 10 00       	push   $0x10eda3
  106c02:	e8 0a 9d ff ff       	call   100911 <printk>
  106c07:	58                   	pop    %eax
	printk("%s thread %s address 0x%08x\n",
  106c08:	b8 84 ed 10 00       	mov    $0x10ed84,%eax
	printk("***** CPU Page Fault (error code 0x%08x)\n", err);
  106c0d:	5a                   	pop    %edx
	printk("%s thread %s address 0x%08x\n",
  106c0e:	f6 c3 10             	test   $0x10,%bl
  106c11:	75 0f                	jne    106c22 <page_fault_handler+0x35>
	       (err & ID) != 0U ? "executed" : ((err & WR) != 0U ? "wrote" :
  106c13:	b8 8d ed 10 00       	mov    $0x10ed8d,%eax
  106c18:	f6 c3 02             	test   $0x2,%bl
  106c1b:	75 05                	jne    106c22 <page_fault_handler+0x35>
  106c1d:	b8 82 eb 10 00       	mov    $0x10eb82,%eax
	printk("%s thread %s address 0x%08x\n",
  106c22:	ba 93 ed 10 00       	mov    $0x10ed93,%edx
  106c27:	80 e3 04             	and    $0x4,%bl
  106c2a:	75 05                	jne    106c31 <page_fault_handler+0x44>
  106c2c:	ba 98 ed 10 00       	mov    $0x10ed98,%edx
  106c31:	57                   	push   %edi
  106c32:	50                   	push   %eax
  106c33:	52                   	push   %edx
  106c34:	68 cd ed 10 00       	push   $0x10edcd
  106c39:	e8 d3 9c ff ff       	call   100911 <printk>
  106c3e:	83 c4 10             	add    $0x10,%esp
#ifdef CONFIG_THREAD_STACK_INFO
	if (check_stack_bounds(esf->esp, 0, esf->cs)) {
		z_NanoFatalErrorHandler(_NANO_ERR_STACK_CHK_FAIL, esf);
	}
#endif
	z_NanoFatalErrorHandler(_NANO_ERR_CPU_EXCEPTION, esf);
  106c41:	56                   	push   %esi
  106c42:	6a 06                	push   $0x6
  106c44:	e8 5e fd ff ff       	call   1069a7 <z_NanoFatalErrorHandler>

00106c49 <atoi>:

#include <stdlib.h>
#include <ctype.h>

int atoi(const char *s)
{
  106c49:	55                   	push   %ebp
  106c4a:	89 e5                	mov    %esp,%ebp
  106c4c:	56                   	push   %esi
  106c4d:	53                   	push   %ebx
  106c4e:	8b 55 08             	mov    0x8(%ebp),%edx
	int n = 0;
	int neg = 0;

	while (isspace(*s)) {
  106c51:	0f be 0a             	movsbl (%edx),%ecx
  106c54:	89 c8                	mov    %ecx,%eax
  106c56:	83 e9 09             	sub    $0x9,%ecx
  106c59:	83 f9 04             	cmp    $0x4,%ecx
  106c5c:	77 03                	ja     106c61 <atoi+0x18>
		s++;
  106c5e:	42                   	inc    %edx
  106c5f:	eb f0                	jmp    106c51 <atoi+0x8>
	while (isspace(*s)) {
  106c61:	3c 20                	cmp    $0x20,%al
  106c63:	74 f9                	je     106c5e <atoi+0x15>
	}
	switch (*s) {
  106c65:	3c 2b                	cmp    $0x2b,%al
  106c67:	74 0e                	je     106c77 <atoi+0x2e>
	int neg = 0;
  106c69:	31 c9                	xor    %ecx,%ecx
	switch (*s) {
  106c6b:	3c 2d                	cmp    $0x2d,%al
  106c6d:	75 0b                	jne    106c7a <atoi+0x31>
	case '-':
		neg = 1;
		s++;
  106c6f:	42                   	inc    %edx
		neg = 1;
  106c70:	b9 01 00 00 00       	mov    $0x1,%ecx
		break;	/* artifact to quiet coverity warning */
  106c75:	eb 03                	jmp    106c7a <atoi+0x31>
	case '+':
		s++;
  106c77:	42                   	inc    %edx
	int neg = 0;
  106c78:	31 c9                	xor    %ecx,%ecx
  106c7a:	31 c0                	xor    %eax,%eax
	}
	/* Compute n as a negative number to avoid overflow on INT_MIN */
	while (isdigit(*s)) {
  106c7c:	0f be 1a             	movsbl (%edx),%ebx
	return (int)(((unsigned)(a)-(unsigned)'0') < 10U);
  106c7f:	8d 73 d0             	lea    -0x30(%ebx),%esi
  106c82:	83 fe 09             	cmp    $0x9,%esi
  106c85:	77 0b                	ja     106c92 <atoi+0x49>
		n = 10*n - (*s++ - '0');
  106c87:	6b c0 0a             	imul   $0xa,%eax,%eax
  106c8a:	83 c0 30             	add    $0x30,%eax
  106c8d:	42                   	inc    %edx
  106c8e:	29 d8                	sub    %ebx,%eax
  106c90:	eb ea                	jmp    106c7c <atoi+0x33>
	}
	return neg ? n : -n;
  106c92:	85 c9                	test   %ecx,%ecx
  106c94:	75 02                	jne    106c98 <atoi+0x4f>
  106c96:	f7 d8                	neg    %eax
}
  106c98:	5b                   	pop    %ebx
  106c99:	5e                   	pop    %esi
  106c9a:	5d                   	pop    %ebp
  106c9b:	c3                   	ret    

00106c9c <strstr>:
/*
 * Find the first occurrence of find in s.
 */
char *
strstr(const char *s, const char *find)
{
  106c9c:	55                   	push   %ebp
  106c9d:	89 e5                	mov    %esp,%ebp
  106c9f:	57                   	push   %edi
  106ca0:	56                   	push   %esi
  106ca1:	53                   	push   %ebx
  106ca2:	83 ec 08             	sub    $0x8,%esp
  106ca5:	8b 75 0c             	mov    0xc(%ebp),%esi
  106ca8:	8b 7d 08             	mov    0x8(%ebp),%edi
	char c, sc;
	size_t len;

	c = *find++;
  106cab:	8a 1e                	mov    (%esi),%bl
	if (c != 0) {
  106cad:	84 db                	test   %bl,%bl
  106caf:	74 3b                	je     106cec <strstr+0x50>
	c = *find++;
  106cb1:	46                   	inc    %esi
		len = strlen(find);
  106cb2:	56                   	push   %esi
  106cb3:	e8 be 00 00 00       	call   106d76 <strlen>
  106cb8:	5a                   	pop    %edx
  106cb9:	89 c1                	mov    %eax,%ecx
		do {
			do {
				sc = *s++;
  106cbb:	8d 57 01             	lea    0x1(%edi),%edx
  106cbe:	8a 42 ff             	mov    -0x1(%edx),%al
				if (sc == 0)
  106cc1:	84 c0                	test   %al,%al
  106cc3:	74 25                	je     106cea <strstr+0x4e>
				return NULL;
			} while (sc != c);
  106cc5:	38 c3                	cmp    %al,%bl
  106cc7:	74 04                	je     106ccd <strstr+0x31>
{
  106cc9:	89 d7                	mov    %edx,%edi
  106ccb:	eb ee                	jmp    106cbb <strstr+0x1f>
		} while (strncmp(s, find, len) != 0);
  106ccd:	51                   	push   %ecx
  106cce:	89 4d ec             	mov    %ecx,-0x14(%ebp)
  106cd1:	56                   	push   %esi
  106cd2:	89 55 f0             	mov    %edx,-0x10(%ebp)
  106cd5:	52                   	push   %edx
  106cd6:	e8 ce 00 00 00       	call   106da9 <strncmp>
  106cdb:	83 c4 0c             	add    $0xc,%esp
  106cde:	8b 55 f0             	mov    -0x10(%ebp),%edx
  106ce1:	85 c0                	test   %eax,%eax
  106ce3:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  106ce6:	75 e1                	jne    106cc9 <strstr+0x2d>
  106ce8:	eb 02                	jmp    106cec <strstr+0x50>
				return NULL;
  106cea:	31 ff                	xor    %edi,%edi
	s--;
	}
	return (char *)s;
}
  106cec:	8d 65 f4             	lea    -0xc(%ebp),%esp
  106cef:	89 f8                	mov    %edi,%eax
  106cf1:	5b                   	pop    %ebx
  106cf2:	5e                   	pop    %esi
  106cf3:	5f                   	pop    %edi
  106cf4:	5d                   	pop    %ebp
  106cf5:	c3                   	ret    

00106cf6 <strcpy>:
 *
 * @return pointer to destination buffer <d>
 */

char *strcpy(char *_MLIBC_RESTRICT d, const char *_MLIBC_RESTRICT s)
{
  106cf6:	55                   	push   %ebp
	char *dest = d;

	while (*s != '\0') {
  106cf7:	31 d2                	xor    %edx,%edx
{
  106cf9:	89 e5                	mov    %esp,%ebp
  106cfb:	53                   	push   %ebx
  106cfc:	8b 45 08             	mov    0x8(%ebp),%eax
	while (*s != '\0') {
  106cff:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  106d02:	8d 1c 10             	lea    (%eax,%edx,1),%ebx
  106d05:	8a 0c 11             	mov    (%ecx,%edx,1),%cl
  106d08:	84 c9                	test   %cl,%cl
  106d0a:	74 06                	je     106d12 <strcpy+0x1c>
		*d = *s;
  106d0c:	88 0c 10             	mov    %cl,(%eax,%edx,1)
		d++;
		s++;
  106d0f:	42                   	inc    %edx
  106d10:	eb ed                	jmp    106cff <strcpy+0x9>
	}

	*d = '\0';
  106d12:	c6 03 00             	movb   $0x0,(%ebx)

	return dest;
}
  106d15:	5b                   	pop    %ebx
  106d16:	5d                   	pop    %ebp
  106d17:	c3                   	ret    

00106d18 <strncpy>:
 *
 * @return pointer to destination buffer <d>
 */

char *strncpy(char *_MLIBC_RESTRICT d, const char *_MLIBC_RESTRICT s, size_t n)
{
  106d18:	55                   	push   %ebp
  106d19:	89 e5                	mov    %esp,%ebp
  106d1b:	57                   	push   %edi
  106d1c:	56                   	push   %esi
  106d1d:	53                   	push   %ebx
  106d1e:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  106d21:	8b 45 10             	mov    0x10(%ebp),%eax
	char *dest = d;

	while ((n > 0) && *s != '\0') {
  106d24:	8b 55 08             	mov    0x8(%ebp),%edx
  106d27:	85 c0                	test   %eax,%eax
  106d29:	74 21                	je     106d4c <strncpy+0x34>
  106d2b:	8a 19                	mov    (%ecx),%bl
  106d2d:	8d 72 01             	lea    0x1(%edx),%esi
  106d30:	8d 78 ff             	lea    -0x1(%eax),%edi
  106d33:	84 db                	test   %bl,%bl
  106d35:	74 0a                	je     106d41 <strncpy+0x29>
		*d = *s;
  106d37:	88 5e ff             	mov    %bl,-0x1(%esi)
		s++;
  106d3a:	41                   	inc    %ecx
		d++;
		n--;
  106d3b:	89 f8                	mov    %edi,%eax
  106d3d:	89 f2                	mov    %esi,%edx
  106d3f:	eb e6                	jmp    106d27 <strncpy+0xf>
  106d41:	31 c9                	xor    %ecx,%ecx
	}

	while (n > 0) {
		*d = '\0';
  106d43:	c6 04 0a 00          	movb   $0x0,(%edx,%ecx,1)
		d++;
		n--;
  106d47:	41                   	inc    %ecx
	while (n > 0) {
  106d48:	39 c8                	cmp    %ecx,%eax
  106d4a:	75 f7                	jne    106d43 <strncpy+0x2b>
	}

	return dest;
}
  106d4c:	5b                   	pop    %ebx
  106d4d:	8b 45 08             	mov    0x8(%ebp),%eax
  106d50:	5e                   	pop    %esi
  106d51:	5f                   	pop    %edi
  106d52:	5d                   	pop    %ebp
  106d53:	c3                   	ret    

00106d54 <strchr>:
 *
 * @return pointer to 1st instance of found byte, or NULL if not found
 */

char *strchr(const char *s, int c)
{
  106d54:	55                   	push   %ebp
  106d55:	89 e5                	mov    %esp,%ebp
  106d57:	53                   	push   %ebx
  106d58:	8b 55 0c             	mov    0xc(%ebp),%edx
	char tmp = (char) c;

	while ((*s != tmp) && (*s != '\0'))
  106d5b:	8b 45 08             	mov    0x8(%ebp),%eax
	char tmp = (char) c;
  106d5e:	88 d3                	mov    %dl,%bl
	while ((*s != tmp) && (*s != '\0'))
  106d60:	8a 08                	mov    (%eax),%cl
  106d62:	38 d9                	cmp    %bl,%cl
  106d64:	74 0d                	je     106d73 <strchr+0x1f>
  106d66:	84 c9                	test   %cl,%cl
  106d68:	74 03                	je     106d6d <strchr+0x19>
		s++;
  106d6a:	40                   	inc    %eax
  106d6b:	eb f3                	jmp    106d60 <strchr+0xc>

	return (*s == tmp) ? (char *) s : NULL;
  106d6d:	84 d2                	test   %dl,%dl
  106d6f:	74 02                	je     106d73 <strchr+0x1f>
  106d71:	31 c0                	xor    %eax,%eax
}
  106d73:	5b                   	pop    %ebx
  106d74:	5d                   	pop    %ebp
  106d75:	c3                   	ret    

00106d76 <strlen>:
 *
 * @return number of bytes in string <s>
 */

size_t strlen(const char *s)
{
  106d76:	55                   	push   %ebp
	size_t n = 0;
  106d77:	31 c0                	xor    %eax,%eax
{
  106d79:	89 e5                	mov    %esp,%ebp
  106d7b:	8b 55 08             	mov    0x8(%ebp),%edx

	while (*s != '\0') {
  106d7e:	80 3c 02 00          	cmpb   $0x0,(%edx,%eax,1)
  106d82:	74 03                	je     106d87 <strlen+0x11>
		s++;
		n++;
  106d84:	40                   	inc    %eax
  106d85:	eb f7                	jmp    106d7e <strlen+0x8>
	}

	return n;
}
  106d87:	5d                   	pop    %ebp
  106d88:	c3                   	ret    

00106d89 <strcmp>:
 *
 * @return negative # if <s1> < <s2>, 0 if <s1> == <s2>, else positive #
 */

int strcmp(const char *s1, const char *s2)
{
  106d89:	55                   	push   %ebp
	while ((*s1 == *s2) && (*s1 != '\0')) {
  106d8a:	31 c9                	xor    %ecx,%ecx
{
  106d8c:	89 e5                	mov    %esp,%ebp
	while ((*s1 == *s2) && (*s1 != '\0')) {
  106d8e:	8b 45 08             	mov    0x8(%ebp),%eax
  106d91:	8b 55 0c             	mov    0xc(%ebp),%edx
  106d94:	0f be 04 08          	movsbl (%eax,%ecx,1),%eax
  106d98:	0f be 14 0a          	movsbl (%edx,%ecx,1),%edx
  106d9c:	38 d0                	cmp    %dl,%al
  106d9e:	75 05                	jne    106da5 <strcmp+0x1c>
  106da0:	41                   	inc    %ecx
  106da1:	84 c0                	test   %al,%al
  106da3:	75 e9                	jne    106d8e <strcmp+0x5>
		s1++;
		s2++;
	}

	return *s1 - *s2;
  106da5:	29 d0                	sub    %edx,%eax
}
  106da7:	5d                   	pop    %ebp
  106da8:	c3                   	ret    

00106da9 <strncmp>:
 *
 * @return negative # if <s1> < <s2>, 0 if <s1> == <s2>, else positive #
 */

int strncmp(const char *s1, const char *s2, size_t n)
{
  106da9:	55                   	push   %ebp
  106daa:	89 e5                	mov    %esp,%ebp
  106dac:	56                   	push   %esi
  106dad:	53                   	push   %ebx
  106dae:	8b 55 08             	mov    0x8(%ebp),%edx
  106db1:	8b 75 10             	mov    0x10(%ebp),%esi
  106db4:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	while ((n > 0) && (*s1 == *s2) && (*s1 != '\0')) {
  106db7:	01 d6                	add    %edx,%esi
  106db9:	39 f2                	cmp    %esi,%edx
  106dbb:	74 12                	je     106dcf <strncmp+0x26>
  106dbd:	0f be 02             	movsbl (%edx),%eax
  106dc0:	0f be 0b             	movsbl (%ebx),%ecx
  106dc3:	84 c0                	test   %al,%al
  106dc5:	74 0c                	je     106dd3 <strncmp+0x2a>
  106dc7:	38 c8                	cmp    %cl,%al
  106dc9:	75 08                	jne    106dd3 <strncmp+0x2a>
		s1++;
  106dcb:	42                   	inc    %edx
		s2++;
  106dcc:	43                   	inc    %ebx
		n--;
  106dcd:	eb ea                	jmp    106db9 <strncmp+0x10>
	}

	return (n == 0) ? 0 : (*s1 - *s2);
  106dcf:	31 c0                	xor    %eax,%eax
  106dd1:	eb 02                	jmp    106dd5 <strncmp+0x2c>
  106dd3:	29 c8                	sub    %ecx,%eax
}
  106dd5:	5b                   	pop    %ebx
  106dd6:	5e                   	pop    %esi
  106dd7:	5d                   	pop    %ebp
  106dd8:	c3                   	ret    

00106dd9 <memmove>:
 *
 * @return pointer to destination buffer <d>
 */

void *memmove(void *d, const void *s, size_t n)
{
  106dd9:	55                   	push   %ebp
  106dda:	89 e5                	mov    %esp,%ebp
  106ddc:	56                   	push   %esi
  106ddd:	53                   	push   %ebx
  106dde:	8b 45 08             	mov    0x8(%ebp),%eax
  106de1:	8b 4d 0c             	mov    0xc(%ebp),%ecx
	char *dest = d;
	const char *src  = s;

	if ((size_t) (dest - src) < n) {
  106de4:	89 c3                	mov    %eax,%ebx
{
  106de6:	8b 55 10             	mov    0x10(%ebp),%edx
	if ((size_t) (dest - src) < n) {
  106de9:	29 cb                	sub    %ecx,%ebx
  106deb:	39 d3                	cmp    %edx,%ebx
  106ded:	72 07                	jb     106df6 <memmove+0x1d>
  106def:	8d 34 0a             	lea    (%edx,%ecx,1),%esi
  106df2:	89 c3                	mov    %eax,%ebx
  106df4:	eb 0b                	jmp    106e01 <memmove+0x28>
		 * The <src> buffer overlaps with the start of the <dest> buffer.
		 * Copy backwards to prevent the premature corruption of <src>.
		 */

		while (n > 0) {
			n--;
  106df6:	4a                   	dec    %edx
			dest[n] = src[n];
  106df7:	8a 1c 11             	mov    (%ecx,%edx,1),%bl
  106dfa:	88 1c 10             	mov    %bl,(%eax,%edx,1)
		while (n > 0) {
  106dfd:	75 f7                	jne    106df6 <memmove+0x1d>
  106dff:	eb 0d                	jmp    106e0e <memmove+0x35>
		}
	} else {
		/* It is safe to perform a forward-copy */
		while (n > 0) {
  106e01:	39 f1                	cmp    %esi,%ecx
  106e03:	74 09                	je     106e0e <memmove+0x35>
			*dest = *src;
  106e05:	8a 11                	mov    (%ecx),%dl
			dest++;
  106e07:	43                   	inc    %ebx
			*dest = *src;
  106e08:	88 53 ff             	mov    %dl,-0x1(%ebx)
			src++;
  106e0b:	41                   	inc    %ecx
			n--;
  106e0c:	eb f3                	jmp    106e01 <memmove+0x28>
		}
	}

	return d;
}
  106e0e:	5b                   	pop    %ebx
  106e0f:	5e                   	pop    %esi
  106e10:	5d                   	pop    %ebp
  106e11:	c3                   	ret    

00106e12 <memcpy>:
 *
 * @return pointer to start of destination buffer
 */

void *memcpy(void *_MLIBC_RESTRICT d, const void *_MLIBC_RESTRICT s, size_t n)
{
  106e12:	55                   	push   %ebp
  106e13:	89 e5                	mov    %esp,%ebp
  106e15:	57                   	push   %edi
  106e16:	56                   	push   %esi
	/* attempt word-sized copying only if buffers have identical alignment */

	unsigned char *d_byte = (unsigned char *)d;
	const unsigned char *s_byte = (const unsigned char *)s;

	if ((((unsigned int)d ^ (unsigned int)s_byte) & 0x3) == 0U) {
  106e17:	8b 45 08             	mov    0x8(%ebp),%eax
{
  106e1a:	53                   	push   %ebx
	if ((((unsigned int)d ^ (unsigned int)s_byte) & 0x3) == 0U) {
  106e1b:	33 45 0c             	xor    0xc(%ebp),%eax
{
  106e1e:	8b 55 10             	mov    0x10(%ebp),%edx
	if ((((unsigned int)d ^ (unsigned int)s_byte) & 0x3) == 0U) {
  106e21:	a8 03                	test   $0x3,%al
  106e23:	74 05                	je     106e2a <memcpy+0x18>
	unsigned char *d_byte = (unsigned char *)d;
  106e25:	8b 7d 08             	mov    0x8(%ebp),%edi
  106e28:	eb 40                	jmp    106e6a <memcpy+0x58>
  106e2a:	8b 45 08             	mov    0x8(%ebp),%eax

		/* do byte-sized copying until word-aligned or finished */

		while (((unsigned int)d_byte) & 0x3) {
  106e2d:	a8 03                	test   $0x3,%al
  106e2f:	74 12                	je     106e43 <memcpy+0x31>
			if (n == 0) {
  106e31:	85 d2                	test   %edx,%edx
  106e33:	74 44                	je     106e79 <memcpy+0x67>
				return d;
			}
			*(d_byte++) = *(s_byte++);
  106e35:	89 c7                	mov    %eax,%edi
  106e37:	8b 75 0c             	mov    0xc(%ebp),%esi
  106e3a:	a4                   	movsb  %ds:(%esi),%es:(%edi)
			n--;
  106e3b:	4a                   	dec    %edx
			*(d_byte++) = *(s_byte++);
  106e3c:	89 75 0c             	mov    %esi,0xc(%ebp)
  106e3f:	89 f8                	mov    %edi,%eax
			n--;
  106e41:	eb ea                	jmp    106e2d <memcpy+0x1b>
  106e43:	8b 75 0c             	mov    0xc(%ebp),%esi
  106e46:	89 c7                	mov    %eax,%edi
  106e48:	8d 0c 10             	lea    (%eax,%edx,1),%ecx
		/* do word-sized copying as long as possible */

		unsigned int *d_word = (unsigned int *)d_byte;
		const unsigned int *s_word = (const unsigned int *)s_byte;

		while (n >= sizeof(unsigned int)) {
  106e4b:	89 cb                	mov    %ecx,%ebx
  106e4d:	29 fb                	sub    %edi,%ebx
  106e4f:	83 fb 03             	cmp    $0x3,%ebx
  106e52:	76 03                	jbe    106e57 <memcpy+0x45>
			*(d_word++) = *(s_word++);
  106e54:	a5                   	movsl  %ds:(%esi),%es:(%edi)
			n -= sizeof(unsigned int);
  106e55:	eb f4                	jmp    106e4b <memcpy+0x39>
  106e57:	89 d3                	mov    %edx,%ebx
  106e59:	c1 eb 02             	shr    $0x2,%ebx
  106e5c:	6b f3 fc             	imul   $0xfffffffc,%ebx,%esi
  106e5f:	c1 e3 02             	shl    $0x2,%ebx
  106e62:	01 f2                	add    %esi,%edx
  106e64:	01 5d 0c             	add    %ebx,0xc(%ebp)
  106e67:	8d 3c 18             	lea    (%eax,%ebx,1),%edi
  106e6a:	01 fa                	add    %edi,%edx
		s_byte = (unsigned char *)s_word;
	}

	/* do byte-sized copying until finished */

	while (n > 0) {
  106e6c:	39 d7                	cmp    %edx,%edi
  106e6e:	74 09                	je     106e79 <memcpy+0x67>
		*(d_byte++) = *(s_byte++);
  106e70:	8b 75 0c             	mov    0xc(%ebp),%esi
  106e73:	a4                   	movsb  %ds:(%esi),%es:(%edi)
  106e74:	89 75 0c             	mov    %esi,0xc(%ebp)
		n--;
  106e77:	eb f3                	jmp    106e6c <memcpy+0x5a>
	}

	return d;
}
  106e79:	5b                   	pop    %ebx
  106e7a:	8b 45 08             	mov    0x8(%ebp),%eax
  106e7d:	5e                   	pop    %esi
  106e7e:	5f                   	pop    %edi
  106e7f:	5d                   	pop    %ebp
  106e80:	c3                   	ret    

00106e81 <memset>:
 *
 * @return pointer to start of buffer
 */

void *memset(void *buf, int c, size_t n)
{
  106e81:	55                   	push   %ebp
  106e82:	89 e5                	mov    %esp,%ebp
  106e84:	57                   	push   %edi
  106e85:	56                   	push   %esi
  106e86:	53                   	push   %ebx
  106e87:	51                   	push   %ecx
  106e88:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  106e8b:	8b 55 10             	mov    0x10(%ebp),%edx
	/* do byte-sized initialization until word-aligned or finished */

	unsigned char *d_byte = (unsigned char *)buf;
	unsigned char c_byte = (unsigned char)c;
  106e8e:	88 5d f3             	mov    %bl,-0xd(%ebp)
	unsigned char *d_byte = (unsigned char *)buf;
  106e91:	8b 45 08             	mov    0x8(%ebp),%eax

	while (((unsigned int)d_byte) & 0x3) {
  106e94:	a8 03                	test   $0x3,%al
  106e96:	74 0e                	je     106ea6 <memset+0x25>
		if (n == 0) {
  106e98:	85 d2                	test   %edx,%edx
  106e9a:	74 4d                	je     106ee9 <memset+0x68>
			return buf;
		}
		*(d_byte++) = c_byte;
  106e9c:	40                   	inc    %eax
  106e9d:	8a 4d f3             	mov    -0xd(%ebp),%cl
		n--;
  106ea0:	4a                   	dec    %edx
		*(d_byte++) = c_byte;
  106ea1:	88 48 ff             	mov    %cl,-0x1(%eax)
		n--;
  106ea4:	eb ee                	jmp    106e94 <memset+0x13>
	};

	/* do word-sized initialization as long as possible */

	unsigned int *d_word = (unsigned int *)d_byte;
	unsigned int c_word = (unsigned int)(unsigned char)c;
  106ea6:	0f b6 db             	movzbl %bl,%ebx

	c_word |= c_word << 8;
  106ea9:	89 d9                	mov    %ebx,%ecx
  106eab:	8d 34 10             	lea    (%eax,%edx,1),%esi
  106eae:	c1 e1 08             	shl    $0x8,%ecx
  106eb1:	09 cb                	or     %ecx,%ebx
	c_word |= c_word << 16;
  106eb3:	89 d9                	mov    %ebx,%ecx
  106eb5:	c1 e1 10             	shl    $0x10,%ecx
  106eb8:	09 cb                	or     %ecx,%ebx

	while (n >= sizeof(unsigned int)) {
  106eba:	89 c1                	mov    %eax,%ecx
  106ebc:	89 f7                	mov    %esi,%edi
  106ebe:	29 cf                	sub    %ecx,%edi
  106ec0:	83 ff 03             	cmp    $0x3,%edi
  106ec3:	76 08                	jbe    106ecd <memset+0x4c>
		*(d_word++) = c_word;
  106ec5:	83 c1 04             	add    $0x4,%ecx
  106ec8:	89 59 fc             	mov    %ebx,-0x4(%ecx)
		n -= sizeof(unsigned int);
  106ecb:	eb ef                	jmp    106ebc <memset+0x3b>
  106ecd:	89 d1                	mov    %edx,%ecx
  106ecf:	c1 e9 02             	shr    $0x2,%ecx
  106ed2:	8d 04 88             	lea    (%eax,%ecx,4),%eax
  106ed5:	6b c9 fc             	imul   $0xfffffffc,%ecx,%ecx
  106ed8:	01 ca                	add    %ecx,%edx
  106eda:	01 c2                	add    %eax,%edx

	/* do byte-sized initialization until finished */

	d_byte = (unsigned char *)d_word;

	while (n > 0) {
  106edc:	39 d0                	cmp    %edx,%eax
  106ede:	74 09                	je     106ee9 <memset+0x68>
		*(d_byte++) = c_byte;
  106ee0:	40                   	inc    %eax
  106ee1:	8a 5d f3             	mov    -0xd(%ebp),%bl
  106ee4:	88 58 ff             	mov    %bl,-0x1(%eax)
		n--;
  106ee7:	eb f3                	jmp    106edc <memset+0x5b>
	}

	return buf;
}
  106ee9:	8b 45 08             	mov    0x8(%ebp),%eax
  106eec:	5a                   	pop    %edx
  106eed:	5b                   	pop    %ebx
  106eee:	5e                   	pop    %esi
  106eef:	5f                   	pop    %edi
  106ef0:	5d                   	pop    %ebp
  106ef1:	c3                   	ret    

00106ef2 <_to_x>:
/* Writes the specified number into the buffer in the given base,
 * using the digit characters 0-9a-z (i.e. base>36 will start writing
 * odd bytes), padding with leading zeros up to the minimum length.
 */
static int _to_x(char *buf, uint32_t n, int base, int minlen)
{
  106ef2:	55                   	push   %ebp
  106ef3:	89 e5                	mov    %esp,%ebp
  106ef5:	57                   	push   %edi
  106ef6:	56                   	push   %esi
  106ef7:	89 d7                	mov    %edx,%edi
  106ef9:	53                   	push   %ebx
  106efa:	89 c6                	mov    %eax,%esi
  106efc:	53                   	push   %ebx
  106efd:	89 c3                	mov    %eax,%ebx
	char *buf0 = buf;

	do {
		int d = n % base;
  106eff:	31 d2                	xor    %edx,%edx
  106f01:	89 f8                	mov    %edi,%eax
  106f03:	f7 f1                	div    %ecx

		n /= base;
		*buf++ = '0' + d + (d > 9 ? ('a' - '0' - 10) : 0);
  106f05:	83 fa 0a             	cmp    $0xa,%edx
  106f08:	89 45 f0             	mov    %eax,-0x10(%ebp)
  106f0b:	19 c0                	sbb    %eax,%eax
  106f0d:	43                   	inc    %ebx
  106f0e:	f7 d0                	not    %eax
  106f10:	83 e0 27             	and    $0x27,%eax
	} while (n);
  106f13:	39 f9                	cmp    %edi,%ecx
		*buf++ = '0' + d + (d > 9 ? ('a' - '0' - 10) : 0);
  106f15:	8d 54 10 30          	lea    0x30(%eax,%edx,1),%edx
  106f19:	88 53 ff             	mov    %dl,-0x1(%ebx)
	} while (n);
  106f1c:	77 05                	ja     106f23 <_to_x+0x31>
		n /= base;
  106f1e:	8b 7d f0             	mov    -0x10(%ebp),%edi
  106f21:	eb dc                	jmp    106eff <_to_x+0xd>
	while (end - start < minlen) {
  106f23:	89 d8                	mov    %ebx,%eax
  106f25:	29 f0                	sub    %esi,%eax
  106f27:	39 45 08             	cmp    %eax,0x8(%ebp)
  106f2a:	7e 07                	jle    106f33 <_to_x+0x41>
		*end++ = '0';
  106f2c:	43                   	inc    %ebx
  106f2d:	c6 43 ff 30          	movb   $0x30,-0x1(%ebx)
  106f31:	eb f0                	jmp    106f23 <_to_x+0x31>
	*end = 0;
  106f33:	c6 03 00             	movb   $0x0,(%ebx)
	for (end--; end > start; end--, start++) {
  106f36:	4b                   	dec    %ebx
  106f37:	39 f3                	cmp    %esi,%ebx
  106f39:	76 0d                	jbe    106f48 <_to_x+0x56>
		char tmp = *end;
  106f3b:	8a 0b                	mov    (%ebx),%cl
		*end = *start;
  106f3d:	8a 16                	mov    (%esi),%dl
  106f3f:	88 13                	mov    %dl,(%ebx)
	for (end--; end > start; end--, start++) {
  106f41:	46                   	inc    %esi
		*start = tmp;
  106f42:	88 4e ff             	mov    %cl,-0x1(%esi)
	for (end--; end > start; end--, start++) {
  106f45:	4b                   	dec    %ebx
  106f46:	eb ef                	jmp    106f37 <_to_x+0x45>
	return _reverse_and_pad(buf0, buf, minlen);
}
  106f48:	5a                   	pop    %edx
  106f49:	5b                   	pop    %ebx
  106f4a:	5e                   	pop    %esi
  106f4b:	5f                   	pop    %edi
  106f4c:	5d                   	pop    %ebp
  106f4d:	c3                   	ret    

00106f4e <_rlrshift>:

	return (buf + _to_udec(buf, (uint32_t) value, precision)) - start;
}

static	void _rlrshift(uint64_t *v)
{
  106f4e:	55                   	push   %ebp
	*v = (*v & 1) + (*v >> 1);
  106f4f:	8b 10                	mov    (%eax),%edx
{
  106f51:	89 e5                	mov    %esp,%ebp
  106f53:	57                   	push   %edi
  106f54:	56                   	push   %esi
	*v = (*v & 1) + (*v >> 1);
  106f55:	8b 48 04             	mov    0x4(%eax),%ecx
{
  106f58:	53                   	push   %ebx
	*v = (*v & 1) + (*v >> 1);
  106f59:	89 d3                	mov    %edx,%ebx
  106f5b:	83 e3 01             	and    $0x1,%ebx
  106f5e:	31 ff                	xor    %edi,%edi
  106f60:	89 de                	mov    %ebx,%esi
  106f62:	89 cb                	mov    %ecx,%ebx
  106f64:	89 d1                	mov    %edx,%ecx
  106f66:	0f ac d9 01          	shrd   $0x1,%ebx,%ecx
  106f6a:	d1 eb                	shr    %ebx
  106f6c:	01 f1                	add    %esi,%ecx
  106f6e:	11 fb                	adc    %edi,%ebx
  106f70:	89 08                	mov    %ecx,(%eax)
  106f72:	89 58 04             	mov    %ebx,0x4(%eax)
}
  106f75:	5b                   	pop    %ebx
  106f76:	5e                   	pop    %esi
  106f77:	5f                   	pop    %edi
  106f78:	5d                   	pop    %ebp
  106f79:	c3                   	ret    

00106f7a <_ldiv5>:
 * six.  This was tested exhaustively through the first ~10B values in
 * the input space, and for ~2e12 (4 hours runtime) random inputs
 * taken from the full 64 bit space.
 */
static void _ldiv5(uint64_t *v)
{
  106f7a:	55                   	push   %ebp
	 */
	rem += 2U;

	for (i = 0U; i < 3; i++) {
		hi = rem >> shifts[i];
		q = (uint64_t)(hi / 5U) << shifts[i];
  106f7b:	b9 05 00 00 00       	mov    $0x5,%ecx
{
  106f80:	89 e5                	mov    %esp,%ebp
  106f82:	57                   	push   %edi
  106f83:	56                   	push   %esi
  106f84:	53                   	push   %ebx
  106f85:	89 c3                	mov    %eax,%ebx
  106f87:	83 ec 14             	sub    $0x14,%esp
	rem += 2U;
  106f8a:	8b 30                	mov    (%eax),%esi
  106f8c:	8b 78 04             	mov    0x4(%eax),%edi
  106f8f:	83 c6 02             	add    $0x2,%esi
  106f92:	83 d7 00             	adc    $0x0,%edi
		q = (uint64_t)(hi / 5U) << shifts[i];
  106f95:	31 d2                	xor    %edx,%edx
		hi = rem >> shifts[i];
  106f97:	89 f8                	mov    %edi,%eax
		q = (uint64_t)(hi / 5U) << shifts[i];
  106f99:	f7 f1                	div    %ecx
  106f9b:	89 c2                	mov    %eax,%edx
  106f9d:	b8 00 00 00 00       	mov    $0x0,%eax
  106fa2:	89 55 f0             	mov    %edx,-0x10(%ebp)
  106fa5:	89 45 ec             	mov    %eax,-0x14(%ebp)
		rem -= q * 5U;
  106fa8:	6b 45 f0 05          	imul   $0x5,-0x10(%ebp),%eax
  106fac:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  106faf:	8b 45 ec             	mov    -0x14(%ebp),%eax
  106fb2:	f7 e1                	mul    %ecx
  106fb4:	03 55 e4             	add    -0x1c(%ebp),%edx
  106fb7:	29 c6                	sub    %eax,%esi
  106fb9:	19 d7                	sbb    %edx,%edi
		hi = rem >> shifts[i];
  106fbb:	89 f0                	mov    %esi,%eax
  106fbd:	89 fa                	mov    %edi,%edx
  106fbf:	0f ac d0 03          	shrd   $0x3,%edx,%eax
		q = (uint64_t)(hi / 5U) << shifts[i];
  106fc3:	31 d2                	xor    %edx,%edx
  106fc5:	f7 f1                	div    %ecx
  106fc7:	31 d2                	xor    %edx,%edx
  106fc9:	0f a4 c2 03          	shld   $0x3,%eax,%edx
  106fcd:	c1 e0 03             	shl    $0x3,%eax
  106fd0:	89 55 e8             	mov    %edx,-0x18(%ebp)
  106fd3:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		quot += q;
  106fd6:	8b 45 ec             	mov    -0x14(%ebp),%eax
  106fd9:	03 45 e4             	add    -0x1c(%ebp),%eax
  106fdc:	8b 55 f0             	mov    -0x10(%ebp),%edx
  106fdf:	13 55 e8             	adc    -0x18(%ebp),%edx
  106fe2:	89 45 ec             	mov    %eax,-0x14(%ebp)
		rem -= q * 5U;
  106fe5:	6b 45 e8 05          	imul   $0x5,-0x18(%ebp),%eax
  106fe9:	89 45 e0             	mov    %eax,-0x20(%ebp)
  106fec:	8b 45 e4             	mov    -0x1c(%ebp),%eax
		quot += q;
  106fef:	89 55 f0             	mov    %edx,-0x10(%ebp)
		rem -= q * 5U;
  106ff2:	f7 e1                	mul    %ecx
  106ff4:	29 c6                	sub    %eax,%esi
		q = (uint64_t)(hi / 5U) << shifts[i];
  106ff6:	31 d2                	xor    %edx,%edx
		rem -= q * 5U;
  106ff8:	89 f0                	mov    %esi,%eax
		q = (uint64_t)(hi / 5U) << shifts[i];
  106ffa:	f7 f1                	div    %ecx
  106ffc:	31 d2                	xor    %edx,%edx
		quot += q;
  106ffe:	03 45 ec             	add    -0x14(%ebp),%eax
  107001:	13 55 f0             	adc    -0x10(%ebp),%edx
  107004:	89 03                	mov    %eax,(%ebx)
  107006:	89 53 04             	mov    %edx,0x4(%ebx)
	}

	*v = quot;
}
  107009:	83 c4 14             	add    $0x14,%esp
  10700c:	5b                   	pop    %ebx
  10700d:	5e                   	pop    %esi
  10700e:	5f                   	pop    %edi
  10700f:	5d                   	pop    %ebp
  107010:	c3                   	ret    

00107011 <_get_digit>:

static	char _get_digit(uint64_t *fr, int *digit_count)
{
  107011:	55                   	push   %ebp
  107012:	89 e5                	mov    %esp,%ebp
  107014:	57                   	push   %edi
  107015:	56                   	push   %esi
  107016:	89 c6                	mov    %eax,%esi
  107018:	53                   	push   %ebx
	int		rval;

	if (*digit_count > 0) {
  107019:	8b 02                	mov    (%edx),%eax
  10701b:	85 c0                	test   %eax,%eax
  10701d:	7e 2d                	jle    10704c <_get_digit+0x3b>
		*digit_count -= 1;
  10701f:	48                   	dec    %eax
		*fr = *fr * 10U;
  107020:	bb 0a 00 00 00       	mov    $0xa,%ebx
		*digit_count -= 1;
  107025:	89 02                	mov    %eax,(%edx)
		*fr = *fr * 10U;
  107027:	89 d8                	mov    %ebx,%eax
  107029:	f7 26                	mull   (%esi)
  10702b:	6b 7e 04 0a          	imul   $0xa,0x4(%esi),%edi
  10702f:	89 d3                	mov    %edx,%ebx
  107031:	89 c1                	mov    %eax,%ecx
  107033:	01 fb                	add    %edi,%ebx
		rval = ((*fr >> 60) & 0xF) + '0';
		*fr &= 0x0FFFFFFFFFFFFFFFull;
  107035:	89 0e                	mov    %ecx,(%esi)
		rval = ((*fr >> 60) & 0xF) + '0';
  107037:	89 d8                	mov    %ebx,%eax
		*fr &= 0x0FFFFFFFFFFFFFFFull;
  107039:	89 da                	mov    %ebx,%edx
		rval = ((*fr >> 60) & 0xF) + '0';
  10703b:	c1 e8 1c             	shr    $0x1c,%eax
		*fr &= 0x0FFFFFFFFFFFFFFFull;
  10703e:	81 e2 ff ff ff 0f    	and    $0xfffffff,%edx
		rval = ((*fr >> 60) & 0xF) + '0';
  107044:	83 c0 30             	add    $0x30,%eax
		*fr &= 0x0FFFFFFFFFFFFFFFull;
  107047:	89 56 04             	mov    %edx,0x4(%esi)
  10704a:	eb 05                	jmp    107051 <_get_digit+0x40>
	} else {
		rval = '0';
  10704c:	b8 30 00 00 00       	mov    $0x30,%eax
	}

	return (char) (rval);
}
  107051:	5b                   	pop    %ebx
  107052:	5e                   	pop    %esi
  107053:	5f                   	pop    %edi
  107054:	5d                   	pop    %ebp
  107055:	c3                   	ret    

00107056 <z_prf>:
	*sptr = p;
	return i;
}

int z_prf(int (*func)(), void *dest, char *format, va_list vargs)
{
  107056:	8d 4c 24 04          	lea    0x4(%esp),%ecx
  10705a:	83 e4 f8             	and    $0xfffffff8,%esp
  10705d:	ff 71 fc             	pushl  -0x4(%ecx)
  107060:	55                   	push   %ebp
  107061:	89 e5                	mov    %esp,%ebp
  107063:	57                   	push   %edi
  107064:	56                   	push   %esi
  107065:	53                   	push   %ebx
  107066:	51                   	push   %ecx
  107067:	81 ec 20 01 00 00    	sub    $0x120,%esp
	int32_t			*int32ptr_temp;
	int32_t			int32_temp;
	uint32_t			uint32_temp;
	uint64_t			double_temp;

	count = 0;
  10706d:	c7 85 e8 fe ff ff 00 	movl   $0x0,-0x118(%ebp)
  107074:	00 00 00 
{
  107077:	8b 01                	mov    (%ecx),%eax
  107079:	8b 59 0c             	mov    0xc(%ecx),%ebx
  10707c:	89 85 d8 fe ff ff    	mov    %eax,-0x128(%ebp)
  107082:	8b 41 04             	mov    0x4(%ecx),%eax
  107085:	89 85 d4 fe ff ff    	mov    %eax,-0x12c(%ebp)
  10708b:	8b 41 08             	mov    0x8(%ecx),%eax
  10708e:	89 85 04 ff ff ff    	mov    %eax,-0xfc(%ebp)

	while ((c = *format++)) {
  107094:	8b 85 04 ff ff ff    	mov    -0xfc(%ebp),%eax
  10709a:	8d 78 01             	lea    0x1(%eax),%edi
  10709d:	0f be 00             	movsbl (%eax),%eax
  1070a0:	85 c0                	test   %eax,%eax
  1070a2:	0f 84 9c 0b 00 00    	je     107c44 <z_prf+0xbee>
		if (c != '%') {
  1070a8:	83 f8 25             	cmp    $0x25,%eax
  1070ab:	74 31                	je     1070de <z_prf+0x88>
			if ((*func) (c, dest) == EOF) {
  1070ad:	ff b5 d4 fe ff ff    	pushl  -0x12c(%ebp)
  1070b3:	50                   	push   %eax
  1070b4:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
  1070ba:	ff d0                	call   *%eax
  1070bc:	5e                   	pop    %esi
  1070bd:	5a                   	pop    %edx
  1070be:	40                   	inc    %eax
  1070bf:	75 0f                	jne    1070d0 <z_prf+0x7a>
				return EOF;
  1070c1:	c7 85 e8 fe ff ff ff 	movl   $0xffffffff,-0x118(%ebp)
  1070c8:	ff ff ff 
  1070cb:	e9 74 0b 00 00       	jmp    107c44 <z_prf+0xbee>
			}

			count++;
  1070d0:	ff 85 e8 fe ff ff    	incl   -0x118(%ebp)
	while ((c = *format++)) {
  1070d6:	89 bd 04 ff ff ff    	mov    %edi,-0xfc(%ebp)
  1070dc:	eb b6                	jmp    107094 <z_prf+0x3e>

		} else {
			fminus = fplus = fspace = falt = false;
			pad = ' ';		/* Default pad character    */
  1070de:	c6 85 f7 fe ff ff 20 	movb   $0x20,-0x109(%ebp)
			fminus = fplus = fspace = falt = false;
  1070e5:	c7 85 e4 fe ff ff 00 	movl   $0x0,-0x11c(%ebp)
  1070ec:	00 00 00 
  1070ef:	c7 85 e0 fe ff ff 00 	movl   $0x0,-0x120(%ebp)
  1070f6:	00 00 00 
  1070f9:	c7 85 dc fe ff ff 00 	movl   $0x0,-0x124(%ebp)
  107100:	00 00 00 
  107103:	c7 85 08 ff ff ff 00 	movl   $0x0,-0xf8(%ebp)
  10710a:	00 00 00 
			precision = -1;	/* No precision specified   */

			while (strchr("-+ #0", (c = *format++)) != NULL) {
  10710d:	0f be 37             	movsbl (%edi),%esi
  107110:	8d 47 01             	lea    0x1(%edi),%eax
  107113:	56                   	push   %esi
  107114:	89 f2                	mov    %esi,%edx
  107116:	68 ea ed 10 00       	push   $0x10edea
  10711b:	88 95 0c ff ff ff    	mov    %dl,-0xf4(%ebp)
  107121:	89 85 04 ff ff ff    	mov    %eax,-0xfc(%ebp)
  107127:	e8 28 fc ff ff       	call   106d54 <strchr>
  10712c:	5a                   	pop    %edx
  10712d:	59                   	pop    %ecx
  10712e:	85 c0                	test   %eax,%eax
  107130:	8a 95 0c ff ff ff    	mov    -0xf4(%ebp),%dl
  107136:	74 65                	je     10719d <z_prf+0x147>
				switch (c) {
  107138:	80 fa 23             	cmp    $0x23,%dl
  10713b:	74 36                	je     107173 <z_prf+0x11d>
  10713d:	7f 19                	jg     107158 <z_prf+0x102>
  10713f:	84 d2                	test   %dl,%dl
  107141:	0f 84 fd 0a 00 00    	je     107c44 <z_prf+0xbee>
  107147:	80 fa 20             	cmp    $0x20,%dl
  10714a:	75 46                	jne    107192 <z_prf+0x13c>
				case '+':
					fplus = true;
					break;

				case ' ':
					fspace = true;
  10714c:	c7 85 e4 fe ff ff 01 	movl   $0x1,-0x11c(%ebp)
  107153:	00 00 00 
  107156:	eb 3a                	jmp    107192 <z_prf+0x13c>
				switch (c) {
  107158:	80 fa 2d             	cmp    $0x2d,%dl
  10715b:	74 22                	je     10717f <z_prf+0x129>
  10715d:	80 fa 30             	cmp    $0x30,%dl
  107160:	74 29                	je     10718b <z_prf+0x135>
  107162:	80 fa 2b             	cmp    $0x2b,%dl
  107165:	75 2b                	jne    107192 <z_prf+0x13c>
					fplus = true;
  107167:	c7 85 e0 fe ff ff 01 	movl   $0x1,-0x120(%ebp)
  10716e:	00 00 00 
  107171:	eb 1f                	jmp    107192 <z_prf+0x13c>
					break;

				case '#':
					falt = true;
  107173:	c7 85 08 ff ff ff 01 	movl   $0x1,-0xf8(%ebp)
  10717a:	00 00 00 
  10717d:	eb 13                	jmp    107192 <z_prf+0x13c>
					fminus = true;
  10717f:	c7 85 dc fe ff ff 01 	movl   $0x1,-0x124(%ebp)
  107186:	00 00 00 
  107189:	eb 07                	jmp    107192 <z_prf+0x13c>
					break;

				case '0':
					pad = '0';
  10718b:	c6 85 f7 fe ff ff 30 	movb   $0x30,-0x109(%ebp)
					fminus = true;
  107192:	8b bd 04 ff ff ff    	mov    -0xfc(%ebp),%edi
  107198:	e9 70 ff ff ff       	jmp    10710d <z_prf+0xb7>
				case '\0':
					return count;
				}
			}

			if (c == '*') {
  10719d:	83 fe 2a             	cmp    $0x2a,%esi
  1071a0:	75 30                	jne    1071d2 <z_prf+0x17c>
				/* Is the width a parameter? */
				width = (int32_t) va_arg(vargs, int32_t);
  1071a2:	8b 13                	mov    (%ebx),%edx
  1071a4:	8d 43 04             	lea    0x4(%ebx),%eax
  1071a7:	89 95 fc fe ff ff    	mov    %edx,-0x104(%ebp)
				if (width < 0) {
  1071ad:	85 d2                	test   %edx,%edx
  1071af:	79 10                	jns    1071c1 <z_prf+0x16b>
					fminus = true;
					width = -width;
  1071b1:	f7 9d fc fe ff ff    	negl   -0x104(%ebp)
					fminus = true;
  1071b7:	c7 85 dc fe ff ff 01 	movl   $0x1,-0x124(%ebp)
  1071be:	00 00 00 
				width = (int32_t) va_arg(vargs, int32_t);
  1071c1:	89 c3                	mov    %eax,%ebx
				}
				c = *format++;
  1071c3:	8d 47 02             	lea    0x2(%edi),%eax
  1071c6:	0f be 77 01          	movsbl 0x1(%edi),%esi
  1071ca:	89 85 04 ff ff ff    	mov    %eax,-0xfc(%ebp)
  1071d0:	eb 3f                	jmp    107211 <z_prf+0x1bb>
  1071d2:	8d 46 d0             	lea    -0x30(%esi),%eax
			} else if (!isdigit(c)) {
				width = 0;
  1071d5:	c7 85 fc fe ff ff 00 	movl   $0x0,-0x104(%ebp)
  1071dc:	00 00 00 
			} else if (!isdigit(c)) {
  1071df:	83 f8 09             	cmp    $0x9,%eax
  1071e2:	77 43                	ja     107227 <z_prf+0x1d1>
	while (isdigit(((int) *p))) {
  1071e4:	0f be 37             	movsbl (%edi),%esi
  1071e7:	8d 47 01             	lea    0x1(%edi),%eax
  1071ea:	89 85 04 ff ff ff    	mov    %eax,-0xfc(%ebp)
  1071f0:	8d 46 d0             	lea    -0x30(%esi),%eax
  1071f3:	83 f8 09             	cmp    $0x9,%eax
  1071f6:	77 19                	ja     107211 <z_prf+0x1bb>
		i = 10 * i + *p++ - '0';
  1071f8:	6b 85 fc fe ff ff 0a 	imul   $0xa,-0x104(%ebp),%eax
  1071ff:	8b bd 04 ff ff ff    	mov    -0xfc(%ebp),%edi
  107205:	8d 44 06 d0          	lea    -0x30(%esi,%eax,1),%eax
  107209:	89 85 fc fe ff ff    	mov    %eax,-0x104(%ebp)
  10720f:	eb d3                	jmp    1071e4 <z_prf+0x18e>
			 * If <width> is INT_MIN, then its absolute value can
			 * not be expressed as a positive number using 32-bit
			 * two's complement.  To cover that case, cast it to
			 * an unsigned before comparing it against MAXFLD.
			 */
			if ((unsigned) width > MAXFLD) {
  107211:	81 bd fc fe ff ff c8 	cmpl   $0xc8,-0x104(%ebp)
  107218:	00 00 00 
  10721b:	76 0a                	jbe    107227 <z_prf+0x1d1>
				width = MAXFLD;
  10721d:	c7 85 fc fe ff ff c8 	movl   $0xc8,-0x104(%ebp)
  107224:	00 00 00 
			precision = -1;	/* No precision specified   */
  107227:	c7 85 0c ff ff ff ff 	movl   $0xffffffff,-0xf4(%ebp)
  10722e:	ff ff ff 
			}

			if (c == '.') {
  107231:	83 fe 2e             	cmp    $0x2e,%esi
  107234:	0f 85 80 00 00 00    	jne    1072ba <z_prf+0x264>
				c = *format++;
				if (c == '*') {
  10723a:	8b 85 04 ff ff ff    	mov    -0xfc(%ebp),%eax
  107240:	80 38 2a             	cmpb   $0x2a,(%eax)
  107243:	75 13                	jne    107258 <z_prf+0x202>
					precision = (int32_t)
  107245:	8b 03                	mov    (%ebx),%eax
				c = *format++;
  107247:	ff 85 04 ff ff ff    	incl   -0xfc(%ebp)
					precision = (int32_t)
  10724d:	89 85 0c ff ff ff    	mov    %eax,-0xf4(%ebp)
  107253:	83 c3 04             	add    $0x4,%ebx
  107256:	eb 3b                	jmp    107293 <z_prf+0x23d>
	i = 0;
  107258:	c7 85 0c ff ff ff 00 	movl   $0x0,-0xf4(%ebp)
  10725f:	00 00 00 
	while (isdigit(((int) *p))) {
  107262:	8b 85 04 ff ff ff    	mov    -0xfc(%ebp),%eax
  107268:	8b 8d 04 ff ff ff    	mov    -0xfc(%ebp),%ecx
  10726e:	41                   	inc    %ecx
  10726f:	0f be 00             	movsbl (%eax),%eax
  107272:	8d 50 d0             	lea    -0x30(%eax),%edx
  107275:	83 fa 09             	cmp    $0x9,%edx
  107278:	77 19                	ja     107293 <z_prf+0x23d>
		i = 10 * i + *p++ - '0';
  10727a:	6b 95 0c ff ff ff 0a 	imul   $0xa,-0xf4(%ebp),%edx
  107281:	89 8d 04 ff ff ff    	mov    %ecx,-0xfc(%ebp)
  107287:	8d 44 10 d0          	lea    -0x30(%eax,%edx,1),%eax
  10728b:	89 85 0c ff ff ff    	mov    %eax,-0xf4(%ebp)
  107291:	eb cf                	jmp    107262 <z_prf+0x20c>
					va_arg(vargs, int32_t);
				} else {
					precision = _atoi(&format);
				}

				if (precision > MAXFLD) {
  107293:	81 bd 0c ff ff ff c8 	cmpl   $0xc8,-0xf4(%ebp)
  10729a:	00 00 00 
  10729d:	7e 0a                	jle    1072a9 <z_prf+0x253>
					precision = -1;
  10729f:	c7 85 0c ff ff ff ff 	movl   $0xffffffff,-0xf4(%ebp)
  1072a6:	ff ff ff 
				}

				c = *format++;
  1072a9:	8b 85 04 ff ff ff    	mov    -0xfc(%ebp),%eax
  1072af:	40                   	inc    %eax
  1072b0:	0f be 70 ff          	movsbl -0x1(%eax),%esi
  1072b4:	89 85 04 ff ff ff    	mov    %eax,-0xfc(%ebp)
			 *    L: long double
			 *    z: size_t or ssize_t
			 * No further special processing is done for them.
			 */

			if (strchr("hlLz", c) != NULL) {
  1072ba:	56                   	push   %esi
  1072bb:	68 f0 ed 10 00       	push   $0x10edf0
  1072c0:	e8 8f fa ff ff       	call   106d54 <strchr>
  1072c5:	5a                   	pop    %edx
  1072c6:	85 c0                	test   %eax,%eax
  1072c8:	59                   	pop    %ecx
  1072c9:	74 11                	je     1072dc <z_prf+0x286>
				i = c;
				c = *format++;
  1072cb:	8b 85 04 ff ff ff    	mov    -0xfc(%ebp),%eax
  1072d1:	40                   	inc    %eax
  1072d2:	0f be 70 ff          	movsbl -0x1(%eax),%esi
  1072d6:	89 85 04 ff ff ff    	mov    %eax,-0xfc(%ebp)
				 */
			}

			need_justifying = false;
			prefix = 0;
			switch (c) {
  1072dc:	83 fe 67             	cmp    $0x67,%esi
  1072df:	0f 8f 5d 08 00 00    	jg     107b42 <z_prf+0xaec>
  1072e5:	83 fe 65             	cmp    $0x65,%esi
  1072e8:	0f 8c 81 06 00 00    	jl     10796f <z_prf+0x919>
				union {
					double d;
					uint64_t i;
				} u;

				u.d = (double) va_arg(vargs, double);
  1072ee:	8d 43 08             	lea    0x8(%ebx),%eax
  1072f1:	8b 0b                	mov    (%ebx),%ecx
  1072f3:	8b 5b 04             	mov    0x4(%ebx),%ebx
  1072f6:	89 85 f8 fe ff ff    	mov    %eax,-0x108(%ebp)
	exp = double_temp >> 52 & 0x7ff;
  1072fc:	89 d8                	mov    %ebx,%eax
	fract = (double_temp << 11) & ~HIGHBIT64;
  1072fe:	89 da                	mov    %ebx,%edx
	exp = double_temp >> 52 & 0x7ff;
  107300:	c1 e8 14             	shr    $0x14,%eax
	sign = !!(double_temp & HIGHBIT64);
  107303:	89 9d d0 fe ff ff    	mov    %ebx,-0x130(%ebp)
	exp = double_temp >> 52 & 0x7ff;
  107309:	25 ff 07 00 00       	and    $0x7ff,%eax
  10730e:	89 85 00 ff ff ff    	mov    %eax,-0x100(%ebp)
	fract = (double_temp << 11) & ~HIGHBIT64;
  107314:	89 c8                	mov    %ecx,%eax
  107316:	0f a4 c2 0b          	shld   $0xb,%eax,%edx
  10731a:	c1 e0 0b             	shl    $0xb,%eax
  10731d:	89 95 f0 fe ff ff    	mov    %edx,-0x110(%ebp)
  107323:	89 85 ec fe ff ff    	mov    %eax,-0x114(%ebp)
  107329:	8b bd f0 fe ff ff    	mov    -0x110(%ebp),%edi
  10732f:	81 e7 ff ff ff 7f    	and    $0x7fffffff,%edi
  107335:	8b 95 ec fe ff ff    	mov    -0x114(%ebp),%edx
  10733b:	89 95 14 ff ff ff    	mov    %edx,-0xec(%ebp)
  107341:	89 bd 18 ff ff ff    	mov    %edi,-0xe8(%ebp)
	if (exp == 0x7ff) {
  107347:	81 bd 00 ff ff ff ff 	cmpl   $0x7ff,-0x100(%ebp)
  10734e:	07 00 00 
  107351:	75 66                	jne    1073b9 <z_prf+0x363>
		if (sign) {
  107353:	8d 8d 27 ff ff ff    	lea    -0xd9(%ebp),%ecx
  107359:	85 db                	test   %ebx,%ebx
  10735b:	79 0d                	jns    10736a <z_prf+0x314>
			*buf++ = '-';
  10735d:	c6 85 27 ff ff ff 2d 	movb   $0x2d,-0xd9(%ebp)
  107364:	8d 8d 28 ff ff ff    	lea    -0xd8(%ebp),%ecx
		if (!fract) {
  10736a:	8d 5e bf             	lea    -0x41(%esi),%ebx
  10736d:	8d 41 03             	lea    0x3(%ecx),%eax
  107370:	09 d7                	or     %edx,%edi
  107372:	75 1b                	jne    10738f <z_prf+0x339>
			if (isupper(c)) {
  107374:	83 fb 19             	cmp    $0x19,%ebx
  107377:	77 0b                	ja     107384 <z_prf+0x32e>
				*buf++ = 'I';
  107379:	66 c7 01 49 4e       	movw   $0x4e49,(%ecx)
				*buf++ = 'F';
  10737e:	c6 41 02 46          	movb   $0x46,0x2(%ecx)
  107382:	eb 24                	jmp    1073a8 <z_prf+0x352>
				*buf++ = 'i';
  107384:	66 c7 01 69 6e       	movw   $0x6e69,(%ecx)
				*buf++ = 'f';
  107389:	c6 41 02 66          	movb   $0x66,0x2(%ecx)
  10738d:	eb 19                	jmp    1073a8 <z_prf+0x352>
			if (isupper(c)) {
  10738f:	83 fb 19             	cmp    $0x19,%ebx
  107392:	77 0b                	ja     10739f <z_prf+0x349>
				*buf++ = 'N';
  107394:	66 c7 01 4e 41       	movw   $0x414e,(%ecx)
				*buf++ = 'N';
  107399:	c6 41 02 4e          	movb   $0x4e,0x2(%ecx)
  10739d:	eb 09                	jmp    1073a8 <z_prf+0x352>
				*buf++ = 'n';
  10739f:	66 c7 01 6e 61       	movw   $0x616e,(%ecx)
				*buf++ = 'n';
  1073a4:	c6 41 02 6e          	movb   $0x6e,0x2(%ecx)
		return buf - start;
  1073a8:	8d 95 27 ff ff ff    	lea    -0xd9(%ebp),%edx
		*buf = 0;
  1073ae:	c6 41 03 00          	movb   $0x0,0x3(%ecx)
		return buf - start;
  1073b2:	29 d0                	sub    %edx,%eax
  1073b4:	e9 36 04 00 00       	jmp    1077ef <z_prf+0x799>
	if (c == 'F') {
  1073b9:	83 fe 46             	cmp    $0x46,%esi
  1073bc:	75 05                	jne    1073c3 <z_prf+0x36d>
		c = 'f';
  1073be:	be 66 00 00 00       	mov    $0x66,%esi
	if ((exp | fract) != 0) {
  1073c3:	8b 8d 00 ff ff ff    	mov    -0x100(%ebp),%ecx
  1073c9:	89 cb                	mov    %ecx,%ebx
  1073cb:	8b 8d 00 ff ff ff    	mov    -0x100(%ebp),%ecx
  1073d1:	c1 fb 1f             	sar    $0x1f,%ebx
  1073d4:	09 d1                	or     %edx,%ecx
  1073d6:	89 9d f0 fe ff ff    	mov    %ebx,-0x110(%ebp)
  1073dc:	8b 9d f0 fe ff ff    	mov    -0x110(%ebp),%ebx
  1073e2:	09 fb                	or     %edi,%ebx
  1073e4:	09 cb                	or     %ecx,%ebx
  1073e6:	74 35                	je     10741d <z_prf+0x3c7>
		exp -= (1023 - 1);	/* +1 since .1 vs 1. */
  1073e8:	8b 85 00 ff ff ff    	mov    -0x100(%ebp),%eax
		fract |= HIGHBIT64;
  1073ee:	81 cf 00 00 00 80    	or     $0x80000000,%edi
		exp -= (1023 - 1);	/* +1 since .1 vs 1. */
  1073f4:	2d fe 03 00 00       	sub    $0x3fe,%eax
		fract |= HIGHBIT64;
  1073f9:	89 95 14 ff ff ff    	mov    %edx,-0xec(%ebp)
		exp -= (1023 - 1);	/* +1 since .1 vs 1. */
  1073ff:	89 85 ec fe ff ff    	mov    %eax,-0x114(%ebp)
		fract |= HIGHBIT64;
  107405:	89 bd 18 ff ff ff    	mov    %edi,-0xe8(%ebp)
	if (decexp && sign) {
  10740b:	83 bd d0 fe ff ff 00 	cmpl   $0x0,-0x130(%ebp)
  107412:	79 13                	jns    107427 <z_prf+0x3d1>
		*buf++ = '-';
  107414:	c6 85 27 ff ff ff 2d 	movb   $0x2d,-0xd9(%ebp)
  10741b:	eb 32                	jmp    10744f <z_prf+0x3f9>
	if ((exp | fract) != 0) {
  10741d:	c7 85 ec fe ff ff 00 	movl   $0x0,-0x114(%ebp)
  107424:	00 00 00 
	} else if (fplus) {
  107427:	83 bd e0 fe ff ff 00 	cmpl   $0x0,-0x120(%ebp)
  10742e:	74 09                	je     107439 <z_prf+0x3e3>
		*buf++ = '+';
  107430:	c6 85 27 ff ff ff 2b 	movb   $0x2b,-0xd9(%ebp)
  107437:	eb 16                	jmp    10744f <z_prf+0x3f9>
	} else if (fspace) {
  107439:	8d 9d 27 ff ff ff    	lea    -0xd9(%ebp),%ebx
  10743f:	83 bd e4 fe ff ff 00 	cmpl   $0x0,-0x11c(%ebp)
  107446:	74 0d                	je     107455 <z_prf+0x3ff>
		*buf++ = ' ';
  107448:	c6 85 27 ff ff ff 20 	movb   $0x20,-0xd9(%ebp)
  10744f:	8d 9d 28 ff ff ff    	lea    -0xd8(%ebp),%ebx
	decexp = 0;
  107455:	c7 85 00 ff ff ff 00 	movl   $0x0,-0x100(%ebp)
  10745c:	00 00 00 
	while (exp <= -3) {
  10745f:	83 bd ec fe ff ff fe 	cmpl   $0xfffffffe,-0x114(%ebp)
  107466:	0f 8d 80 00 00 00    	jge    1074ec <z_prf+0x496>
		while ((fract >> 32) >= (MAXFP1 / 5)) {
  10746c:	8b 8d 18 ff ff ff    	mov    -0xe8(%ebp),%ecx
  107472:	ff 85 ec fe ff ff    	incl   -0x114(%ebp)
  107478:	8b 85 14 ff ff ff    	mov    -0xec(%ebp),%eax
  10747e:	81 f9 32 33 33 33    	cmp    $0x33333332,%ecx
  107484:	76 0d                	jbe    107493 <z_prf+0x43d>
			_rlrshift(&fract);
  107486:	8d 85 14 ff ff ff    	lea    -0xec(%ebp),%eax
  10748c:	e8 bd fa ff ff       	call   106f4e <_rlrshift>
			exp++;
  107491:	eb d9                	jmp    10746c <z_prf+0x416>
		fract *= 5U;
  107493:	ba 05 00 00 00       	mov    $0x5,%edx
  107498:	8d 0c 89             	lea    (%ecx,%ecx,4),%ecx
  10749b:	f7 e2                	mul    %edx
		decexp--;
  10749d:	ff 8d 00 ff ff ff    	decl   -0x100(%ebp)
		fract *= 5U;
  1074a3:	01 ca                	add    %ecx,%edx
  1074a5:	89 85 14 ff ff ff    	mov    %eax,-0xec(%ebp)
  1074ab:	89 95 18 ff ff ff    	mov    %edx,-0xe8(%ebp)
		decexp--;
  1074b1:	31 c9                	xor    %ecx,%ecx
		while ((fract >> 32) <= (MAXFP1 / 2)) {
  1074b3:	bf ff ff ff 7f       	mov    $0x7fffffff,%edi
  1074b8:	39 d7                	cmp    %edx,%edi
  1074ba:	72 0e                	jb     1074ca <z_prf+0x474>
			fract <<= 1;
  1074bc:	01 c0                	add    %eax,%eax
  1074be:	b1 01                	mov    $0x1,%cl
  1074c0:	11 d2                	adc    %edx,%edx
			exp--;
  1074c2:	ff 8d ec fe ff ff    	decl   -0x114(%ebp)
  1074c8:	eb ee                	jmp    1074b8 <z_prf+0x462>
  1074ca:	84 c9                	test   %cl,%cl
  1074cc:	74 91                	je     10745f <z_prf+0x409>
  1074ce:	89 85 14 ff ff ff    	mov    %eax,-0xec(%ebp)
  1074d4:	89 95 18 ff ff ff    	mov    %edx,-0xe8(%ebp)
  1074da:	eb 83                	jmp    10745f <z_prf+0x409>
  1074dc:	84 c9                	test   %cl,%cl
  1074de:	74 0c                	je     1074ec <z_prf+0x496>
  1074e0:	89 85 14 ff ff ff    	mov    %eax,-0xec(%ebp)
  1074e6:	89 95 18 ff ff ff    	mov    %edx,-0xe8(%ebp)
	while (exp > 0) {
  1074ec:	83 bd ec fe ff ff 00 	cmpl   $0x0,-0x114(%ebp)
  1074f3:	7e 3c                	jle    107531 <z_prf+0x4db>
		_ldiv5(&fract);
  1074f5:	8d 85 14 ff ff ff    	lea    -0xec(%ebp),%eax
		while ((fract >> 32) <= (MAXFP1 / 2)) {
  1074fb:	bf ff ff ff 7f       	mov    $0x7fffffff,%edi
		_ldiv5(&fract);
  107500:	e8 75 fa ff ff       	call   106f7a <_ldiv5>
		exp--;
  107505:	ff 8d ec fe ff ff    	decl   -0x114(%ebp)
		decexp++;
  10750b:	ff 85 00 ff ff ff    	incl   -0x100(%ebp)
  107511:	8b 85 14 ff ff ff    	mov    -0xec(%ebp),%eax
  107517:	8b 95 18 ff ff ff    	mov    -0xe8(%ebp),%edx
  10751d:	31 c9                	xor    %ecx,%ecx
		while ((fract >> 32) <= (MAXFP1 / 2)) {
  10751f:	39 d7                	cmp    %edx,%edi
  107521:	72 b9                	jb     1074dc <z_prf+0x486>
			fract <<= 1;
  107523:	01 c0                	add    %eax,%eax
  107525:	b1 01                	mov    $0x1,%cl
  107527:	11 d2                	adc    %edx,%edx
			exp--;
  107529:	ff 8d ec fe ff ff    	decl   -0x114(%ebp)
  10752f:	eb ee                	jmp    10751f <z_prf+0x4c9>
		_rlrshift(&fract);
  107531:	8d 85 14 ff ff ff    	lea    -0xec(%ebp),%eax
  107537:	e8 12 fa ff ff       	call   106f4e <_rlrshift>
		exp++;
  10753c:	ff 85 ec fe ff ff    	incl   -0x114(%ebp)
	while (exp < (0 + 4)) {
  107542:	83 bd ec fe ff ff 04 	cmpl   $0x4,-0x114(%ebp)
  107549:	75 e6                	jne    107531 <z_prf+0x4db>
	if (precision < 0)
  10754b:	83 bd 0c ff ff ff 00 	cmpl   $0x0,-0xf4(%ebp)
  107552:	79 0a                	jns    10755e <z_prf+0x508>
		precision = 6;		/* Default precision if none given */
  107554:	c7 85 0c ff ff ff 06 	movl   $0x6,-0xf4(%ebp)
  10755b:	00 00 00 
	if ((c == 'g') || (c == 'G')) {
  10755e:	89 f0                	mov    %esi,%eax
  107560:	83 bd 0c ff ff ff 00 	cmpl   $0x0,-0xf4(%ebp)
  107567:	0f 9f 85 ec fe ff ff 	setg   -0x114(%ebp)
  10756e:	83 e0 df             	and    $0xffffffdf,%eax
  107571:	83 f8 47             	cmp    $0x47,%eax
  107574:	75 3c                	jne    1075b2 <z_prf+0x55c>
		if (!falt && (precision > 0)) {
  107576:	8b 85 08 ff ff ff    	mov    -0xf8(%ebp),%eax
  10757c:	83 f0 01             	xor    $0x1,%eax
  10757f:	23 85 ec fe ff ff    	and    -0x114(%ebp),%eax
	prune_zero = false;		/* Assume trailing 0's allowed     */
  107585:	0f b6 c0             	movzbl %al,%eax
  107588:	89 85 d0 fe ff ff    	mov    %eax,-0x130(%ebp)
		if ((decexp < (-4 + 1)) || (decexp > (precision + 1))) {
  10758e:	83 bd 00 ff ff ff fd 	cmpl   $0xfffffffd,-0x100(%ebp)
  107595:	7c 0f                	jl     1075a6 <z_prf+0x550>
  107597:	8b 85 0c ff ff ff    	mov    -0xf4(%ebp),%eax
  10759d:	40                   	inc    %eax
  10759e:	39 85 00 ff ff ff    	cmp    %eax,-0x100(%ebp)
  1075a4:	7e 1b                	jle    1075c1 <z_prf+0x56b>
			if (c == 'g') {
  1075a6:	83 fe 67             	cmp    $0x67,%esi
  1075a9:	75 37                	jne    1075e2 <z_prf+0x58c>
				c = 'e';
  1075ab:	be 65 00 00 00       	mov    $0x65,%esi
  1075b0:	eb 35                	jmp    1075e7 <z_prf+0x591>
	prune_zero = false;		/* Assume trailing 0's allowed     */
  1075b2:	c7 85 d0 fe ff ff 00 	movl   $0x0,-0x130(%ebp)
  1075b9:	00 00 00 
	if (c == 'f') {
  1075bc:	83 fe 66             	cmp    $0x66,%esi
  1075bf:	75 26                	jne    1075e7 <z_prf+0x591>
		if (exp < 0) {
  1075c1:	8b bd 00 ff ff ff    	mov    -0x100(%ebp),%edi
  1075c7:	be 66 00 00 00       	mov    $0x66,%esi
  1075cc:	03 bd 0c ff ff ff    	add    -0xf4(%ebp),%edi
  1075d2:	79 1c                	jns    1075f0 <z_prf+0x59a>
	digit_count = 16;
  1075d4:	c7 85 10 ff ff ff 10 	movl   $0x10,-0xf0(%ebp)
  1075db:	00 00 00 
			exp = 0;
  1075de:	31 ff                	xor    %edi,%edi
  1075e0:	eb 22                	jmp    107604 <z_prf+0x5ae>
				c = 'E';
  1075e2:	be 45 00 00 00       	mov    $0x45,%esi
		exp = precision + 1;
  1075e7:	8b 85 0c ff ff ff    	mov    -0xf4(%ebp),%eax
  1075ed:	8d 78 01             	lea    0x1(%eax),%edi
	digit_count = 16;
  1075f0:	c7 85 10 ff ff ff 10 	movl   $0x10,-0xf0(%ebp)
  1075f7:	00 00 00 
	if (exp > 16) {
  1075fa:	83 ff 10             	cmp    $0x10,%edi
  1075fd:	7e 05                	jle    107604 <z_prf+0x5ae>
  1075ff:	bf 10 00 00 00       	mov    $0x10,%edi
	ltemp = 0x0800000000000000;
  107604:	c7 85 1c ff ff ff 00 	movl   $0x0,-0xe4(%ebp)
  10760b:	00 00 00 
  10760e:	c7 85 20 ff ff ff 00 	movl   $0x8000000,-0xe0(%ebp)
  107615:	00 00 08 
	while (exp--) {
  107618:	4f                   	dec    %edi
  107619:	83 ff ff             	cmp    $0xffffffff,%edi
  10761c:	74 18                	je     107636 <z_prf+0x5e0>
		_ldiv5(&ltemp);
  10761e:	8d 85 1c ff ff ff    	lea    -0xe4(%ebp),%eax
  107624:	e8 51 f9 ff ff       	call   106f7a <_ldiv5>
		_rlrshift(&ltemp);
  107629:	8d 85 1c ff ff ff    	lea    -0xe4(%ebp),%eax
  10762f:	e8 1a f9 ff ff       	call   106f4e <_rlrshift>
  107634:	eb e2                	jmp    107618 <z_prf+0x5c2>
	fract += ltemp;
  107636:	8b 85 1c ff ff ff    	mov    -0xe4(%ebp),%eax
  10763c:	8b 95 20 ff ff ff    	mov    -0xe0(%ebp),%edx
  107642:	03 85 14 ff ff ff    	add    -0xec(%ebp),%eax
  107648:	13 95 18 ff ff ff    	adc    -0xe8(%ebp),%edx
  10764e:	89 85 14 ff ff ff    	mov    %eax,-0xec(%ebp)
	if ((fract >> 32) & 0xF0000000) {
  107654:	89 d0                	mov    %edx,%eax
	fract += ltemp;
  107656:	89 95 18 ff ff ff    	mov    %edx,-0xe8(%ebp)
	if ((fract >> 32) & 0xF0000000) {
  10765c:	a9 00 00 00 f0       	test   $0xf0000000,%eax
  107661:	74 1c                	je     10767f <z_prf+0x629>
		_ldiv5(&fract);
  107663:	8d 85 14 ff ff ff    	lea    -0xec(%ebp),%eax
  107669:	e8 0c f9 ff ff       	call   106f7a <_ldiv5>
		_rlrshift(&fract);
  10766e:	8d 85 14 ff ff ff    	lea    -0xec(%ebp),%eax
  107674:	e8 d5 f8 ff ff       	call   106f4e <_rlrshift>
		decexp++;
  107679:	ff 85 00 ff ff ff    	incl   -0x100(%ebp)
	if (c == 'f') {
  10767f:	8d 7b 01             	lea    0x1(%ebx),%edi
  107682:	83 fe 66             	cmp    $0x66,%esi
  107685:	0f 85 97 00 00 00    	jne    107722 <z_prf+0x6cc>
		if (decexp > 0) {
  10768b:	83 bd 00 ff ff ff 00 	cmpl   $0x0,-0x100(%ebp)
  107692:	7e 2d                	jle    1076c1 <z_prf+0x66b>
  107694:	8b bd 00 ff ff ff    	mov    -0x100(%ebp),%edi
  10769a:	01 df                	add    %ebx,%edi
				*buf++ = _get_digit(&fract, &digit_count);
  10769c:	8d 95 10 ff ff ff    	lea    -0xf0(%ebp),%edx
  1076a2:	8d 85 14 ff ff ff    	lea    -0xec(%ebp),%eax
  1076a8:	e8 64 f9 ff ff       	call   107011 <_get_digit>
  1076ad:	43                   	inc    %ebx
			while (decexp > 0) {
  1076ae:	39 df                	cmp    %ebx,%edi
				*buf++ = _get_digit(&fract, &digit_count);
  1076b0:	88 43 ff             	mov    %al,-0x1(%ebx)
			while (decexp > 0) {
  1076b3:	75 e7                	jne    10769c <z_prf+0x646>
  1076b5:	c7 85 00 ff ff ff 00 	movl   $0x0,-0x100(%ebp)
  1076bc:	00 00 00 
  1076bf:	eb 03                	jmp    1076c4 <z_prf+0x66e>
			*buf++ = '0';
  1076c1:	c6 03 30             	movb   $0x30,(%ebx)
		if (falt || (precision > 0)) {
  1076c4:	f6 85 08 ff ff ff 01 	testb  $0x1,-0xf8(%ebp)
  1076cb:	75 09                	jne    1076d6 <z_prf+0x680>
  1076cd:	80 bd ec fe ff ff 00 	cmpb   $0x0,-0x114(%ebp)
  1076d4:	74 06                	je     1076dc <z_prf+0x686>
			*buf++ = '.';
  1076d6:	c6 07 2e             	movb   $0x2e,(%edi)
  1076d9:	47                   	inc    %edi
  1076da:	eb 0a                	jmp    1076e6 <z_prf+0x690>
		if (falt || (precision > 0)) {
  1076dc:	c7 85 0c ff ff ff 00 	movl   $0x0,-0xf4(%ebp)
  1076e3:	00 00 00 
  1076e6:	8b 9d 0c ff ff ff    	mov    -0xf4(%ebp),%ebx
  1076ec:	01 fb                	add    %edi,%ebx
		while (precision-- > 0) {
  1076ee:	39 fb                	cmp    %edi,%ebx
  1076f0:	0f 84 91 00 00 00    	je     107787 <z_prf+0x731>
			if (decexp < 0) {
  1076f6:	47                   	inc    %edi
  1076f7:	83 bd 00 ff ff ff 00 	cmpl   $0x0,-0x100(%ebp)
  1076fe:	74 0c                	je     10770c <z_prf+0x6b6>
				*buf++ = '0';
  107700:	c6 47 ff 30          	movb   $0x30,-0x1(%edi)
				decexp++;
  107704:	ff 85 00 ff ff ff    	incl   -0x100(%ebp)
  10770a:	eb e2                	jmp    1076ee <z_prf+0x698>
				*buf++ = _get_digit(&fract, &digit_count);
  10770c:	8d 95 10 ff ff ff    	lea    -0xf0(%ebp),%edx
  107712:	8d 85 14 ff ff ff    	lea    -0xec(%ebp),%eax
  107718:	e8 f4 f8 ff ff       	call   107011 <_get_digit>
  10771d:	88 47 ff             	mov    %al,-0x1(%edi)
  107720:	eb cc                	jmp    1076ee <z_prf+0x698>
		*buf = _get_digit(&fract, &digit_count);
  107722:	8d 95 10 ff ff ff    	lea    -0xf0(%ebp),%edx
  107728:	8d 85 14 ff ff ff    	lea    -0xec(%ebp),%eax
  10772e:	e8 de f8 ff ff       	call   107011 <_get_digit>
  107733:	88 03                	mov    %al,(%ebx)
		if (*buf++ != '0') {
  107735:	3c 30                	cmp    $0x30,%al
  107737:	74 06                	je     10773f <z_prf+0x6e9>
			decexp--;
  107739:	ff 8d 00 ff ff ff    	decl   -0x100(%ebp)
		if (falt || (precision > 0)) {
  10773f:	f6 85 08 ff ff ff 01 	testb  $0x1,-0xf8(%ebp)
  107746:	75 09                	jne    107751 <z_prf+0x6fb>
  107748:	80 bd ec fe ff ff 00 	cmpb   $0x0,-0x114(%ebp)
  10774f:	74 09                	je     10775a <z_prf+0x704>
			*buf++ = '.';
  107751:	8d 7b 02             	lea    0x2(%ebx),%edi
  107754:	c6 43 01 2e          	movb   $0x2e,0x1(%ebx)
  107758:	eb 0a                	jmp    107764 <z_prf+0x70e>
		if (falt || (precision > 0)) {
  10775a:	c7 85 0c ff ff ff 00 	movl   $0x0,-0xf4(%ebp)
  107761:	00 00 00 
  107764:	8b 9d 0c ff ff ff    	mov    -0xf4(%ebp),%ebx
  10776a:	01 fb                	add    %edi,%ebx
		while (precision-- > 0) {
  10776c:	39 fb                	cmp    %edi,%ebx
  10776e:	74 17                	je     107787 <z_prf+0x731>
			*buf++ = _get_digit(&fract, &digit_count);
  107770:	8d 95 10 ff ff ff    	lea    -0xf0(%ebp),%edx
  107776:	8d 85 14 ff ff ff    	lea    -0xec(%ebp),%eax
  10777c:	e8 90 f8 ff ff       	call   107011 <_get_digit>
  107781:	47                   	inc    %edi
  107782:	88 47 ff             	mov    %al,-0x1(%edi)
  107785:	eb e5                	jmp    10776c <z_prf+0x716>
	if (prune_zero) {
  107787:	83 bd d0 fe ff ff 00 	cmpl   $0x0,-0x130(%ebp)
  10778e:	74 11                	je     1077a1 <z_prf+0x74b>
		while (*--buf == '0')
  107790:	89 f8                	mov    %edi,%eax
  107792:	4f                   	dec    %edi
  107793:	8a 17                	mov    (%edi),%dl
  107795:	80 fa 30             	cmp    $0x30,%dl
  107798:	74 f6                	je     107790 <z_prf+0x73a>
		if (*buf != '.') {
  10779a:	80 fa 2e             	cmp    $0x2e,%dl
  10779d:	74 02                	je     1077a1 <z_prf+0x74b>
  10779f:	89 c7                	mov    %eax,%edi
	if ((c == 'e') || (c == 'E')) {
  1077a1:	89 f0                	mov    %esi,%eax
  1077a3:	83 e0 df             	and    $0xffffffdf,%eax
  1077a6:	83 f8 45             	cmp    $0x45,%eax
  1077a9:	75 37                	jne    1077e2 <z_prf+0x78c>
		*buf++ = (char) c;
  1077ab:	89 f0                	mov    %esi,%eax
  1077ad:	88 07                	mov    %al,(%edi)
			*buf++ = '+';
  1077af:	b0 2b                	mov    $0x2b,%al
		if (decexp < 0) {
  1077b1:	83 bd 00 ff ff ff 00 	cmpl   $0x0,-0x100(%ebp)
  1077b8:	79 08                	jns    1077c2 <z_prf+0x76c>
			decexp = -decexp;
  1077ba:	f7 9d 00 ff ff ff    	negl   -0x100(%ebp)
			*buf++ = '-';
  1077c0:	b0 2d                	mov    $0x2d,%al
  1077c2:	88 47 01             	mov    %al,0x1(%edi)
		*buf++ = (char) ((decexp / 10) + '0');
  1077c5:	8b 85 00 ff ff ff    	mov    -0x100(%ebp),%eax
  1077cb:	b9 0a 00 00 00       	mov    $0xa,%ecx
		*buf++ = (char) (decexp + '0');
  1077d0:	83 c7 04             	add    $0x4,%edi
		*buf++ = (char) ((decexp / 10) + '0');
  1077d3:	99                   	cltd   
  1077d4:	f7 f9                	idiv   %ecx
  1077d6:	83 c0 30             	add    $0x30,%eax
		*buf++ = (char) (decexp + '0');
  1077d9:	83 c2 30             	add    $0x30,%edx
		*buf++ = (char) ((decexp / 10) + '0');
  1077dc:	88 47 fe             	mov    %al,-0x2(%edi)
		*buf++ = (char) (decexp + '0');
  1077df:	88 57 ff             	mov    %dl,-0x1(%edi)
	return buf - start;
  1077e2:	8d 85 27 ff ff ff    	lea    -0xd9(%ebp),%eax
	*buf = 0;
  1077e8:	c6 07 00             	movb   $0x0,(%edi)
	return buf - start;
  1077eb:	29 c7                	sub    %eax,%edi
  1077ed:	89 f8                	mov    %edi,%eax
#endif
			}

				c = _to_float(buf, double_temp, c, falt, fplus,
					      fspace, precision);
				if (fplus || fspace || (buf[0] == '-')) {
  1077ef:	8b b5 e0 fe ff ff    	mov    -0x120(%ebp),%esi
  1077f5:	0b b5 e4 fe ff ff    	or     -0x11c(%ebp),%esi
  1077fb:	0f 85 8a 00 00 00    	jne    10788b <z_prf+0x835>
  107801:	31 c9                	xor    %ecx,%ecx
  107803:	80 bd 27 ff ff ff 2d 	cmpb   $0x2d,-0xd9(%ebp)
  10780a:	0f 94 c1             	sete   %cl
  10780d:	89 ce                	mov    %ecx,%esi
  10780f:	eb 7a                	jmp    10788b <z_prf+0x835>
			switch (c) {
  107811:	0f 8e a3 02 00 00    	jle    107aba <z_prf+0xa64>
				int32_temp = (int32_t) va_arg(vargs, int32_t);
  107817:	8d 43 04             	lea    0x4(%ebx),%eax
  10781a:	8b 33                	mov    (%ebx),%esi
  10781c:	89 85 f8 fe ff ff    	mov    %eax,-0x108(%ebp)
	if (value < 0) {
  107822:	85 f6                	test   %esi,%esi
  107824:	0f 89 5a 02 00 00    	jns    107a84 <z_prf+0xa2e>
		*buf++ = '-';
  10782a:	c6 85 27 ff ff ff 2d 	movb   $0x2d,-0xd9(%ebp)
		if (value != 0x80000000) {
  107831:	ba 00 00 00 80       	mov    $0x80000000,%edx
  107836:	81 fe 00 00 00 80    	cmp    $0x80000000,%esi
  10783c:	74 04                	je     107842 <z_prf+0x7ec>
			value = -value;
  10783e:	89 f2                	mov    %esi,%edx
  107840:	f7 da                	neg    %edx
		*buf++ = '-';
  107842:	8d 9d 28 ff ff ff    	lea    -0xd8(%ebp),%ebx
	return _to_x(buf, value, 10, precision);
  107848:	ff b5 0c ff ff ff    	pushl  -0xf4(%ebp)
  10784e:	89 d8                	mov    %ebx,%eax
  107850:	b9 0a 00 00 00       	mov    $0xa,%ecx
				if (fplus || fspace || (int32_temp < 0)) {
  107855:	c1 ee 1f             	shr    $0x1f,%esi
	return _to_x(buf, value, 10, precision);
  107858:	e8 95 f6 ff ff       	call   106ef2 <_to_x>
				if (fplus || fspace || (int32_temp < 0)) {
  10785d:	8a 95 e0 fe ff ff    	mov    -0x120(%ebp),%dl
	return _to_x(buf, value, 10, precision);
  107863:	5f                   	pop    %edi
				if (fplus || fspace || (int32_temp < 0)) {
  107864:	0b 95 e4 fe ff ff    	or     -0x11c(%ebp),%edx
	return (buf + _to_udec(buf, (uint32_t) value, precision)) - start;
  10786a:	8d 7d f0             	lea    -0x10(%ebp),%edi
  10786d:	29 fb                	sub    %edi,%ebx
			prefix = 0;
  10786f:	09 f2                	or     %esi,%edx
  107871:	0f b6 f2             	movzbl %dl,%esi
	return (buf + _to_udec(buf, (uint32_t) value, precision)) - start;
  107874:	8d 84 03 c9 00 00 00 	lea    0xc9(%ebx,%eax,1),%eax
				c = _to_hex(buf, uint32_temp, falt, precision, c);
				if (falt) {
					prefix = 2;
				}
				need_justifying = true;
				if (precision != -1) {
  10787b:	83 bd 0c ff ff ff ff 	cmpl   $0xffffffff,-0xf4(%ebp)
  107882:	74 07                	je     10788b <z_prf+0x835>
					pad = ' ';
  107884:	c6 85 f7 fe ff ff 20 	movb   $0x20,-0x109(%ebp)

			case 0:
				return count;
			}

			if (c >= MAXFLD + 1) {
  10788b:	3d c8 00 00 00       	cmp    $0xc8,%eax
  107890:	0f 8f 2b f8 ff ff    	jg     1070c1 <z_prf+0x6b>
  107896:	89 85 08 ff ff ff    	mov    %eax,-0xf8(%ebp)
				return EOF;
			}

			if (need_justifying) {
				if (c < width) {
  10789c:	8b bd 08 ff ff ff    	mov    -0xf8(%ebp),%edi
  1078a2:	39 bd fc fe ff ff    	cmp    %edi,-0x104(%ebp)
  1078a8:	7e 74                	jle    10791e <z_prf+0x8c8>
					if (fminus) {
  1078aa:	83 bd dc fe ff ff 00 	cmpl   $0x0,-0x124(%ebp)
  1078b1:	74 24                	je     1078d7 <z_prf+0x881>
						/* Left justify? */
						for (i = c; i < width; i++)
							buf[i] = ' ';
  1078b3:	8b 85 08 ff ff ff    	mov    -0xf8(%ebp),%eax
						for (i = c; i < width; i++)
  1078b9:	ff 85 08 ff ff ff    	incl   -0xf8(%ebp)
  1078bf:	8b b5 08 ff ff ff    	mov    -0xf8(%ebp),%esi
							buf[i] = ' ';
  1078c5:	c6 84 05 27 ff ff ff 	movb   $0x20,-0xd9(%ebp,%eax,1)
  1078cc:	20 
						for (i = c; i < width; i++)
  1078cd:	39 b5 fc fe ff ff    	cmp    %esi,-0x104(%ebp)
  1078d3:	75 de                	jne    1078b3 <z_prf+0x85d>
  1078d5:	eb 53                	jmp    10792a <z_prf+0x8d4>
					} else {
						/* Right justify */
						(void) memmove((buf + (width - c)), buf, (size_t) (c
  1078d7:	8b 9d fc fe ff ff    	mov    -0x104(%ebp),%ebx
										+ 1));
  1078dd:	8b 85 08 ff ff ff    	mov    -0xf8(%ebp),%eax
						(void) memmove((buf + (width - c)), buf, (size_t) (c
  1078e3:	2b 9d 08 ff ff ff    	sub    -0xf8(%ebp),%ebx
										+ 1));
  1078e9:	40                   	inc    %eax
						(void) memmove((buf + (width - c)), buf, (size_t) (c
  1078ea:	50                   	push   %eax
  1078eb:	8d 85 27 ff ff ff    	lea    -0xd9(%ebp),%eax
  1078f1:	50                   	push   %eax
  1078f2:	01 d8                	add    %ebx,%eax
  1078f4:	50                   	push   %eax
  1078f5:	e8 df f4 ff ff       	call   106dd9 <memmove>
  1078fa:	83 c4 0c             	add    $0xc,%esp
						if (pad == ' ')
  1078fd:	80 bd f7 fe ff ff 20 	cmpb   $0x20,-0x109(%ebp)
  107904:	75 02                	jne    107908 <z_prf+0x8b2>
							prefix = 0;
  107906:	31 f6                	xor    %esi,%esi
						c = width - c + prefix;
  107908:	01 f3                	add    %esi,%ebx
						for (i = prefix; i < c; i++)
  10790a:	39 de                	cmp    %ebx,%esi
  10790c:	7d 1c                	jge    10792a <z_prf+0x8d4>
							buf[i] = pad;
  10790e:	8a 85 f7 fe ff ff    	mov    -0x109(%ebp),%al
  107914:	88 84 35 27 ff ff ff 	mov    %al,-0xd9(%ebp,%esi,1)
						for (i = prefix; i < c; i++)
  10791b:	46                   	inc    %esi
  10791c:	eb ec                	jmp    10790a <z_prf+0x8b4>
  10791e:	8b 85 08 ff ff ff    	mov    -0xf8(%ebp),%eax
  107924:	89 85 fc fe ff ff    	mov    %eax,-0x104(%ebp)
  10792a:	31 db                	xor    %ebx,%ebx
  10792c:	8b 85 e8 fe ff ff    	mov    -0x118(%ebp),%eax
  107932:	01 d8                	add    %ebx,%eax
					}
					c = width;
				}

				for (cptr = buf; c > 0; c--, cptr++, count++) {
  107934:	39 9d fc fe ff ff    	cmp    %ebx,-0x104(%ebp)
  10793a:	74 22                	je     10795e <z_prf+0x908>
					if ((*func)(*cptr, dest) == EOF) {
  10793c:	ff b5 d4 fe ff ff    	pushl  -0x12c(%ebp)
  107942:	0f be 84 1d 27 ff ff 	movsbl -0xd9(%ebp,%ebx,1),%eax
  107949:	ff 
  10794a:	50                   	push   %eax
  10794b:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
  107951:	ff d0                	call   *%eax
  107953:	5a                   	pop    %edx
  107954:	43                   	inc    %ebx
  107955:	59                   	pop    %ecx
  107956:	40                   	inc    %eax
  107957:	75 d3                	jne    10792c <z_prf+0x8d6>
  107959:	e9 63 f7 ff ff       	jmp    1070c1 <z_prf+0x6b>
  10795e:	8b 9d f8 fe ff ff    	mov    -0x108(%ebp),%ebx
  107964:	89 85 e8 fe ff ff    	mov    %eax,-0x118(%ebp)
  10796a:	e9 25 f7 ff ff       	jmp    107094 <z_prf+0x3e>
			switch (c) {
  10796f:	83 fe 47             	cmp    $0x47,%esi
  107972:	7f 6e                	jg     1079e2 <z_prf+0x98c>
  107974:	83 fe 45             	cmp    $0x45,%esi
  107977:	0f 8d 71 f9 ff ff    	jge    1072ee <z_prf+0x298>
  10797d:	85 f6                	test   %esi,%esi
  10797f:	0f 84 bf 02 00 00    	je     107c44 <z_prf+0xbee>
  107985:	83 fe 25             	cmp    $0x25,%esi
  107988:	0f 85 06 f7 ff ff    	jne    107094 <z_prf+0x3e>
				if ((*func)('%', dest) == EOF) {
  10798e:	ff b5 d4 fe ff ff    	pushl  -0x12c(%ebp)
  107994:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
  10799a:	6a 25                	push   $0x25
  10799c:	ff d0                	call   *%eax
  10799e:	5e                   	pop    %esi
  10799f:	40                   	inc    %eax
  1079a0:	5f                   	pop    %edi
  1079a1:	0f 84 1a f7 ff ff    	je     1070c1 <z_prf+0x6b>
				count++;
  1079a7:	ff 85 e8 fe ff ff    	incl   -0x118(%ebp)
				break;
  1079ad:	89 9d f8 fe ff ff    	mov    %ebx,-0x108(%ebp)
  1079b3:	eb 22                	jmp    1079d7 <z_prf+0x981>
			switch (c) {
  1079b5:	0f 8f 41 02 00 00    	jg     107bfc <z_prf+0xba6>
  1079bb:	83 fe 6e             	cmp    $0x6e,%esi
  1079be:	0f 85 b3 01 00 00    	jne    107b77 <z_prf+0xb21>
				int32ptr_temp = (int32_t *)va_arg(vargs, int32_t *);
  1079c4:	8d 43 04             	lea    0x4(%ebx),%eax
				*int32ptr_temp = count;
  1079c7:	8b b5 e8 fe ff ff    	mov    -0x118(%ebp),%esi
				int32ptr_temp = (int32_t *)va_arg(vargs, int32_t *);
  1079cd:	89 85 f8 fe ff ff    	mov    %eax,-0x108(%ebp)
				*int32ptr_temp = count;
  1079d3:	8b 03                	mov    (%ebx),%eax
  1079d5:	89 30                	mov    %esi,(%eax)
			if (need_justifying) {
  1079d7:	8b 9d f8 fe ff ff    	mov    -0x108(%ebp),%ebx
  1079dd:	e9 b2 f6 ff ff       	jmp    107094 <z_prf+0x3e>
			switch (c) {
  1079e2:	83 fe 63             	cmp    $0x63,%esi
  1079e5:	0f 85 26 fe ff ff    	jne    107811 <z_prf+0x7bb>
				buf[0] = (char) ((int32_t) va_arg(vargs, int32_t));
  1079eb:	8d 43 04             	lea    0x4(%ebx),%eax
				buf[1] = '\0';
  1079ee:	c6 85 28 ff ff ff 00 	movb   $0x0,-0xd8(%ebp)
				buf[0] = (char) ((int32_t) va_arg(vargs, int32_t));
  1079f5:	89 85 f8 fe ff ff    	mov    %eax,-0x108(%ebp)
  1079fb:	8b 03                	mov    (%ebx),%eax
  1079fd:	88 85 27 ff ff ff    	mov    %al,-0xd9(%ebp)
				c = 1;
  107a03:	c7 85 08 ff ff ff 01 	movl   $0x1,-0xf8(%ebp)
  107a0a:	00 00 00 
				break;
  107a0d:	eb 6e                	jmp    107a7d <z_prf+0xa27>
			switch (c) {
  107a0f:	83 fe 78             	cmp    $0x78,%esi
  107a12:	0f 84 ab 00 00 00    	je     107ac3 <z_prf+0xa6d>
  107a18:	83 fe 73             	cmp    $0x73,%esi
  107a1b:	0f 85 73 f6 ff ff    	jne    107094 <z_prf+0x3e>
				cptr_temp = (char *) va_arg(vargs, char *);
  107a21:	8d 43 04             	lea    0x4(%ebx),%eax
				for (c = 0; c < MAXFLD; c++) {
  107a24:	c7 85 08 ff ff ff 00 	movl   $0x0,-0xf8(%ebp)
  107a2b:	00 00 00 
				cptr_temp = (char *) va_arg(vargs, char *);
  107a2e:	89 85 f8 fe ff ff    	mov    %eax,-0x108(%ebp)
  107a34:	8b 03                	mov    (%ebx),%eax
					if (cptr_temp[c] == '\0') {
  107a36:	8b b5 08 ff ff ff    	mov    -0xf8(%ebp),%esi
  107a3c:	80 3c 30 00          	cmpb   $0x0,(%eax,%esi,1)
  107a40:	0f 85 e3 01 00 00    	jne    107c29 <z_prf+0xbd3>
				if ((precision >= 0) && (precision < c)) {
  107a46:	8b bd 0c ff ff ff    	mov    -0xf4(%ebp),%edi
  107a4c:	39 bd 08 ff ff ff    	cmp    %edi,-0xf8(%ebp)
  107a52:	76 06                	jbe    107a5a <z_prf+0xa04>
  107a54:	89 bd 08 ff ff ff    	mov    %edi,-0xf8(%ebp)
				if (c > 0) {
  107a5a:	83 bd 08 ff ff ff 00 	cmpl   $0x0,-0xf8(%ebp)
  107a61:	0f 84 70 ff ff ff    	je     1079d7 <z_prf+0x981>
					memcpy(buf, cptr_temp, (size_t) c);
  107a67:	ff b5 08 ff ff ff    	pushl  -0xf8(%ebp)
  107a6d:	50                   	push   %eax
  107a6e:	8d 85 27 ff ff ff    	lea    -0xd9(%ebp),%eax
  107a74:	50                   	push   %eax
  107a75:	e8 98 f3 ff ff       	call   106e12 <memcpy>
  107a7a:	83 c4 0c             	add    $0xc,%esp
					prefix = 2;
  107a7d:	31 f6                	xor    %esi,%esi
  107a7f:	e9 18 fe ff ff       	jmp    10789c <z_prf+0x846>
	} else if (fplus) {
  107a84:	83 bd e0 fe ff ff 00 	cmpl   $0x0,-0x120(%ebp)
  107a8b:	74 09                	je     107a96 <z_prf+0xa40>
		*buf++ = '+';
  107a8d:	c6 85 27 ff ff ff 2b 	movb   $0x2b,-0xd9(%ebp)
  107a94:	eb 10                	jmp    107aa6 <z_prf+0xa50>
	} else if (fspace) {
  107a96:	83 bd e4 fe ff ff 00 	cmpl   $0x0,-0x11c(%ebp)
  107a9d:	74 0e                	je     107aad <z_prf+0xa57>
		*buf++ = ' ';
  107a9f:	c6 85 27 ff ff ff 20 	movb   $0x20,-0xd9(%ebp)
  107aa6:	89 f2                	mov    %esi,%edx
  107aa8:	e9 95 fd ff ff       	jmp    107842 <z_prf+0x7ec>
	} else if (fspace) {
  107aad:	89 f2                	mov    %esi,%edx
  107aaf:	8d 9d 27 ff ff ff    	lea    -0xd9(%ebp),%ebx
  107ab5:	e9 8e fd ff ff       	jmp    107848 <z_prf+0x7f2>
			switch (c) {
  107aba:	83 fe 58             	cmp    $0x58,%esi
  107abd:	0f 85 d1 f5 ff ff    	jne    107094 <z_prf+0x3e>
				uint32_temp = (uint32_t) va_arg(vargs, uint32_t);
  107ac3:	8d 43 04             	lea    0x4(%ebx),%eax
  107ac6:	8b 13                	mov    (%ebx),%edx
  107ac8:	89 85 f8 fe ff ff    	mov    %eax,-0x108(%ebp)
	if (alt_form) {
  107ace:	8d 9d 27 ff ff ff    	lea    -0xd9(%ebp),%ebx
  107ad4:	83 bd 08 ff ff ff 00 	cmpl   $0x0,-0xf8(%ebp)
  107adb:	74 0f                	je     107aec <z_prf+0xa96>
		*buf++ = '0';
  107add:	66 c7 85 27 ff ff ff 	movw   $0x7830,-0xd9(%ebp)
  107ae4:	30 78 
		*buf++ = 'x';
  107ae6:	8d 9d 29 ff ff ff    	lea    -0xd7(%ebp),%ebx
	len = _to_x(buf, value, 16, precision);
  107aec:	ff b5 0c ff ff ff    	pushl  -0xf4(%ebp)
  107af2:	b9 10 00 00 00       	mov    $0x10,%ecx
  107af7:	89 d8                	mov    %ebx,%eax
  107af9:	e8 f4 f3 ff ff       	call   106ef2 <_to_x>
  107afe:	5a                   	pop    %edx
  107aff:	89 c7                	mov    %eax,%edi
	if (prefix == 'X') {
  107b01:	83 fe 58             	cmp    $0x58,%esi
  107b04:	74 1f                	je     107b25 <z_prf+0xacf>
	return len + (buf - buf0);
  107b06:	8d 45 f0             	lea    -0x10(%ebp),%eax
  107b09:	29 c3                	sub    %eax,%ebx
			prefix = 0;
  107b0b:	83 bd 08 ff ff ff 01 	cmpl   $0x1,-0xf8(%ebp)
  107b12:	19 f6                	sbb    %esi,%esi
	return len + (buf - buf0);
  107b14:	8d 84 3b c9 00 00 00 	lea    0xc9(%ebx,%edi,1),%eax
			prefix = 0;
  107b1b:	f7 d6                	not    %esi
  107b1d:	83 e6 02             	and    $0x2,%esi
  107b20:	e9 56 fd ff ff       	jmp    10787b <z_prf+0x825>
	if (prefix == 'X') {
  107b25:	8d 8d 27 ff ff ff    	lea    -0xd9(%ebp),%ecx
	for (/**/; *buf; buf++) {
  107b2b:	8a 11                	mov    (%ecx),%dl
  107b2d:	84 d2                	test   %dl,%dl
  107b2f:	74 d5                	je     107b06 <z_prf+0xab0>
		if (*buf >= 'a' && *buf <= 'z') {
  107b31:	8d 72 9f             	lea    -0x61(%edx),%esi
  107b34:	89 f0                	mov    %esi,%eax
  107b36:	3c 19                	cmp    $0x19,%al
  107b38:	77 05                	ja     107b3f <z_prf+0xae9>
			*buf += 'A' - 'a';
  107b3a:	83 ea 20             	sub    $0x20,%edx
  107b3d:	88 11                	mov    %dl,(%ecx)
	for (/**/; *buf; buf++) {
  107b3f:	41                   	inc    %ecx
  107b40:	eb e9                	jmp    107b2b <z_prf+0xad5>
			switch (c) {
  107b42:	83 fe 70             	cmp    $0x70,%esi
  107b45:	0f 85 6a fe ff ff    	jne    1079b5 <z_prf+0x95f>
				uint32_temp = (uint32_t) va_arg(vargs, uint32_t);
  107b4b:	8d 43 04             	lea    0x4(%ebx),%eax
  107b4e:	8b 13                	mov    (%ebx),%edx
  107b50:	89 85 f8 fe ff ff    	mov    %eax,-0x108(%ebp)
	len = _to_x(buf, value, 16, precision);
  107b56:	b9 10 00 00 00       	mov    $0x10,%ecx
  107b5b:	8d 85 29 ff ff ff    	lea    -0xd7(%ebp),%eax
  107b61:	6a 08                	push   $0x8
		*buf++ = '0';
  107b63:	66 c7 85 27 ff ff ff 	movw   $0x7830,-0xd9(%ebp)
  107b6a:	30 78 
	len = _to_x(buf, value, 16, precision);
  107b6c:	e8 81 f3 ff ff       	call   106ef2 <_to_x>
  107b71:	5b                   	pop    %ebx
	return len + (buf - buf0);
  107b72:	83 c0 02             	add    $0x2,%eax
				if (precision != -1) {
  107b75:	eb 46                	jmp    107bbd <z_prf+0xb67>
			switch (c) {
  107b77:	7e 75                	jle    107bee <z_prf+0xb98>
				uint32_temp = (uint32_t) va_arg(vargs, uint32_t);
  107b79:	8d 43 04             	lea    0x4(%ebx),%eax
  107b7c:	8b 13                	mov    (%ebx),%edx
  107b7e:	89 85 f8 fe ff ff    	mov    %eax,-0x108(%ebp)
	if (alt_form) {
  107b84:	83 bd 08 ff ff ff 00 	cmpl   $0x0,-0xf8(%ebp)
  107b8b:	74 59                	je     107be6 <z_prf+0xb90>
		*buf++ = '0';
  107b8d:	c6 85 27 ff ff ff 30 	movb   $0x30,-0xd9(%ebp)
  107b94:	8d 9d 28 ff ff ff    	lea    -0xd8(%ebp),%ebx
		if (!value) {
  107b9a:	85 d2                	test   %edx,%edx
  107b9c:	74 26                	je     107bc4 <z_prf+0xb6e>
	return (buf - buf0) + _to_x(buf, value, 8, precision);
  107b9e:	ff b5 0c ff ff ff    	pushl  -0xf4(%ebp)
  107ba4:	89 d8                	mov    %ebx,%eax
  107ba6:	b9 08 00 00 00       	mov    $0x8,%ecx
  107bab:	e8 42 f3 ff ff       	call   106ef2 <_to_x>
  107bb0:	8d 7d f0             	lea    -0x10(%ebp),%edi
  107bb3:	29 fb                	sub    %edi,%ebx
  107bb5:	5e                   	pop    %esi
  107bb6:	8d 84 03 c9 00 00 00 	lea    0xc9(%ebx,%eax,1),%eax
			prefix = 0;
  107bbd:	31 f6                	xor    %esi,%esi
  107bbf:	e9 b7 fc ff ff       	jmp    10787b <z_prf+0x825>
  107bc4:	31 f6                	xor    %esi,%esi
			*buf++ = 0;
  107bc6:	c6 85 28 ff ff ff 00 	movb   $0x0,-0xd8(%ebp)
				if (precision != -1) {
  107bcd:	83 bd 0c ff ff ff ff 	cmpl   $0xffffffff,-0xf4(%ebp)
  107bd4:	0f 84 c2 fc ff ff    	je     10789c <z_prf+0x846>
					pad = ' ';
  107bda:	c6 85 f7 fe ff ff 20 	movb   $0x20,-0x109(%ebp)
  107be1:	e9 b6 fc ff ff       	jmp    10789c <z_prf+0x846>
	if (alt_form) {
  107be6:	8d 9d 27 ff ff ff    	lea    -0xd9(%ebp),%ebx
  107bec:	eb b0                	jmp    107b9e <z_prf+0xb48>
			switch (c) {
  107bee:	83 fe 69             	cmp    $0x69,%esi
  107bf1:	0f 84 20 fc ff ff    	je     107817 <z_prf+0x7c1>
  107bf7:	e9 98 f4 ff ff       	jmp    107094 <z_prf+0x3e>
  107bfc:	83 fe 75             	cmp    $0x75,%esi
  107bff:	0f 85 0a fe ff ff    	jne    107a0f <z_prf+0x9b9>
	return _to_x(buf, value, 10, precision);
  107c05:	ff b5 0c ff ff ff    	pushl  -0xf4(%ebp)
				uint32_temp = (uint32_t) va_arg(vargs, uint32_t);
  107c0b:	8d 43 04             	lea    0x4(%ebx),%eax
	return _to_x(buf, value, 10, precision);
  107c0e:	b9 0a 00 00 00       	mov    $0xa,%ecx
				uint32_temp = (uint32_t) va_arg(vargs, uint32_t);
  107c13:	89 85 f8 fe ff ff    	mov    %eax,-0x108(%ebp)
	return _to_x(buf, value, 10, precision);
  107c19:	8b 13                	mov    (%ebx),%edx
  107c1b:	8d 85 27 ff ff ff    	lea    -0xd9(%ebp),%eax
  107c21:	e8 cc f2 ff ff       	call   106ef2 <_to_x>
  107c26:	59                   	pop    %ecx
  107c27:	eb 94                	jmp    107bbd <z_prf+0xb67>
				for (c = 0; c < MAXFLD; c++) {
  107c29:	ff 85 08 ff ff ff    	incl   -0xf8(%ebp)
  107c2f:	81 bd 08 ff ff ff c8 	cmpl   $0xc8,-0xf8(%ebp)
  107c36:	00 00 00 
  107c39:	0f 85 f7 fd ff ff    	jne    107a36 <z_prf+0x9e0>
  107c3f:	e9 02 fe ff ff       	jmp    107a46 <z_prf+0x9f0>
				}
			}
		}
	}
	return count;
}
  107c44:	8b 85 e8 fe ff ff    	mov    -0x118(%ebp),%eax
  107c4a:	8d 65 f0             	lea    -0x10(%ebp),%esp
  107c4d:	59                   	pop    %ecx
  107c4e:	5b                   	pop    %ebx
  107c4f:	5e                   	pop    %esi
  107c50:	5f                   	pop    %edi
  107c51:	5d                   	pop    %ebp
  107c52:	8d 61 fc             	lea    -0x4(%ecx),%esp
  107c55:	c3                   	ret    

00107c56 <_stdout_hook_default>:
static int _stdout_hook_default(int c)
{
	(void)(c);  /* Prevent warning about unused argument */

	return EOF;
}
  107c56:	83 c8 ff             	or     $0xffffffff,%eax
  107c59:	c3                   	ret    

00107c5a <__stdout_hook_install>:

static int (*_stdout_hook)(int) = _stdout_hook_default;

void __stdout_hook_install(int (*hook)(int))
{
  107c5a:	55                   	push   %ebp
  107c5b:	89 e5                	mov    %esp,%ebp
	_stdout_hook = hook;
  107c5d:	8b 45 08             	mov    0x8(%ebp),%eax
}
  107c60:	5d                   	pop    %ebp
	_stdout_hook = hook;
  107c61:	a3 4c 32 11 00       	mov    %eax,0x11324c
}
  107c66:	c3                   	ret    

00107c67 <sprintf_out>:
	char *ptr;
	int len;
};

static int sprintf_out(int c, struct emitter *p)
{
  107c67:	55                   	push   %ebp
  107c68:	89 e5                	mov    %esp,%ebp
  107c6a:	8b 45 0c             	mov    0xc(%ebp),%eax
	if (p->len > 1) { /* need to reserve a byte for EOS */
  107c6d:	83 78 04 01          	cmpl   $0x1,0x4(%eax)
  107c71:	7e 0c                	jle    107c7f <sprintf_out+0x18>
		*(p->ptr) = c;
  107c73:	8b 10                	mov    (%eax),%edx
  107c75:	8b 4d 08             	mov    0x8(%ebp),%ecx
  107c78:	88 0a                	mov    %cl,(%edx)
		p->ptr += 1;
  107c7a:	ff 00                	incl   (%eax)
		p->len -= 1;
  107c7c:	ff 48 04             	decl   0x4(%eax)
	}
	return 0; /* indicate keep going so we get the total count */
}
  107c7f:	31 c0                	xor    %eax,%eax
  107c81:	5d                   	pop    %ebp
  107c82:	c3                   	ret    

00107c83 <snprintf>:

int snprintf(char *_MLIBC_RESTRICT s, size_t len,
	     const char *_MLIBC_RESTRICT format, ...)
{
  107c83:	55                   	push   %ebp
  107c84:	89 e5                	mov    %esp,%ebp
  107c86:	83 ec 0c             	sub    $0xc,%esp
  107c89:	8b 45 0c             	mov    0xc(%ebp),%eax
  107c8c:	8b 55 08             	mov    0x8(%ebp),%edx

	struct emitter p;
	int     r;
	char    dummy;

	if (len == 0) {
  107c8f:	85 c0                	test   %eax,%eax
  107c91:	75 03                	jne    107c96 <snprintf+0x13>
		s = &dummy; /* write final NUL to dummy, can't change *s */
  107c93:	8d 55 f7             	lea    -0x9(%ebp),%edx
	}

	p.ptr = s;
	p.len = (int) len;
  107c96:	89 45 fc             	mov    %eax,-0x4(%ebp)

	va_start(vargs, format);
  107c99:	8d 45 14             	lea    0x14(%ebp),%eax
	r = z_prf(sprintf_out, (void *) (&p), format, vargs);
  107c9c:	50                   	push   %eax
  107c9d:	8d 45 f8             	lea    -0x8(%ebp),%eax
  107ca0:	ff 75 10             	pushl  0x10(%ebp)
	p.ptr = s;
  107ca3:	89 55 f8             	mov    %edx,-0x8(%ebp)
	r = z_prf(sprintf_out, (void *) (&p), format, vargs);
  107ca6:	50                   	push   %eax
  107ca7:	68 67 7c 10 00       	push   $0x107c67
  107cac:	e8 a5 f3 ff ff       	call   107056 <z_prf>
	va_end(vargs);

	*(p.ptr) = 0;
  107cb1:	8b 55 f8             	mov    -0x8(%ebp),%edx
	r = z_prf(sprintf_out, (void *) (&p), format, vargs);
  107cb4:	83 c4 10             	add    $0x10,%esp
	*(p.ptr) = 0;
  107cb7:	c6 02 00             	movb   $0x0,(%edx)
	return r;
}
  107cba:	c9                   	leave  
  107cbb:	c3                   	ret    

00107cbc <pinmux_pullup>:
	ARG_UNUSED(dev);
	ARG_UNUSED(pin);
	ARG_UNUSED(func);

	return 0;
}
  107cbc:	31 c0                	xor    %eax,%eax
  107cbe:	c3                   	ret    

00107cbf <pinmux_get>:
}

static int pinmux_get(struct device *dev,
				u32_t pin,
				u32_t *func)
{
  107cbf:	55                   	push   %ebp
  107cc0:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
  107cc5:	89 e5                	mov    %esp,%ebp
  107cc7:	8b 55 0c             	mov    0xc(%ebp),%edx
	if (pin > PINMUX_NUM_PINS) {
  107cca:	83 fa 14             	cmp    $0x14,%edx
  107ccd:	77 14                	ja     107ce3 <pinmux_get+0x24>
	struct pin_config *mux_config = drv_data->mux_config;
  107ccf:	8b 45 08             	mov    0x8(%ebp),%eax
  107cd2:	8b 40 08             	mov    0x8(%eax),%eax
	*func = mux_config[pin].mode;
  107cd5:	8b 40 1c             	mov    0x1c(%eax),%eax
  107cd8:	8b 54 d0 04          	mov    0x4(%eax,%edx,8),%edx
  107cdc:	8b 45 10             	mov    0x10(%ebp),%eax
  107cdf:	89 10                	mov    %edx,(%eax)
		return -EINVAL;
	}

	return z_galileo_pinmux_get_pin(dev, pin, func);
  107ce1:	31 c0                	xor    %eax,%eax
}
  107ce3:	5d                   	pop    %ebp
  107ce4:	c3                   	ret    

00107ce5 <pinmux_input_enable>:
  107ce5:	31 c0                	xor    %eax,%eax
  107ce7:	c3                   	ret    

00107ce8 <gpio_pin_write>:
 * @param value Value set on the pin.
 * @return 0 if successful, negative errno code on failure.
 */
static inline int gpio_pin_write(struct device *port, u32_t pin,
				 u32_t value)
{
  107ce8:	55                   	push   %ebp
  107ce9:	89 e5                	mov    %esp,%ebp
  107ceb:	53                   	push   %ebx
	return api->write(port, access_op, pin, value);
  107cec:	8b 58 04             	mov    0x4(%eax),%ebx
  107cef:	51                   	push   %ecx
  107cf0:	52                   	push   %edx
  107cf1:	6a 00                	push   $0x0
  107cf3:	50                   	push   %eax
  107cf4:	ff 53 04             	call   *0x4(%ebx)
  107cf7:	83 c4 10             	add    $0x10,%esp
	return gpio_write(port, GPIO_ACCESS_BY_PIN, pin, value);
}
  107cfa:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  107cfd:	c9                   	leave  
  107cfe:	c3                   	ret    

00107cff <gpio_pin_configure>:
{
  107cff:	55                   	push   %ebp
  107d00:	89 e5                	mov    %esp,%ebp
  107d02:	53                   	push   %ebx
	return api->config(port, access_op, pin, flags);
  107d03:	8b 58 04             	mov    0x4(%eax),%ebx
  107d06:	51                   	push   %ecx
  107d07:	52                   	push   %edx
  107d08:	6a 00                	push   $0x0
  107d0a:	50                   	push   %eax
  107d0b:	ff 13                	call   *(%ebx)
  107d0d:	83 c4 10             	add    $0x10,%esp
}
  107d10:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  107d13:	c9                   	leave  
  107d14:	c3                   	ret    

00107d15 <z_galileo_pinmux_set_pin>:
{
  107d15:	55                   	push   %ebp
  107d16:	89 e5                	mov    %esp,%ebp
  107d18:	57                   	push   %edi
  107d19:	56                   	push   %esi
  107d1a:	53                   	push   %ebx
  107d1b:	50                   	push   %eax
	struct galileo_data * const drv_data = port->driver_data;
  107d1c:	8b 45 08             	mov    0x8(%ebp),%eax
{
  107d1f:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  107d22:	8b 55 10             	mov    0x10(%ebp),%edx
	if (pin > PINMUX_NUM_PINS) {
  107d25:	80 fb 14             	cmp    $0x14,%bl
	struct galileo_data * const drv_data = port->driver_data;
  107d28:	8b 70 08             	mov    0x8(%eax),%esi
	struct pin_config *mux_config = drv_data->mux_config;
  107d2b:	b8 dd ff ff ff       	mov    $0xffffffdd,%eax
  107d30:	8b 4e 1c             	mov    0x1c(%esi),%ecx
	if (pin > PINMUX_NUM_PINS) {
  107d33:	0f 87 d3 00 00 00    	ja     107e0c <z_galileo_pinmux_set_pin+0xf7>
	mux_config[pin].mode = func;
  107d39:	0f b6 c3             	movzbl %bl,%eax
	mux_index += func;
  107d3c:	8d 1c 9a             	lea    (%edx,%ebx,4),%ebx
	for (i = 0U; i < 5; i++) {
  107d3f:	c6 45 f3 00          	movb   $0x0,-0xd(%ebp)
  107d43:	0f b6 db             	movzbl %bl,%ebx
  107d46:	6b db 54             	imul   $0x54,%ebx,%ebx
	mux_config[pin].mode = func;
  107d49:	89 54 c1 04          	mov    %edx,0x4(%ecx,%eax,8)
	for (i = 0U; i < 5; i++) {
  107d4d:	81 c3 c0 be 10 00    	add    $0x10bec0,%ebx
		switch (enable->path[i].mux) {
  107d53:	8b 43 04             	mov    0x4(%ebx),%eax
  107d56:	48                   	dec    %eax
  107d57:	83 f8 06             	cmp    $0x6,%eax
  107d5a:	0f 87 9a 00 00 00    	ja     107dfa <z_galileo_pinmux_set_pin+0xe5>
  107d60:	0f b6 7b 08          	movzbl 0x8(%ebx),%edi
  107d64:	8b 4b 0c             	mov    0xc(%ebx),%ecx
  107d67:	ff 24 85 ec dc 10 00 	jmp    *0x10dcec(,%eax,4)
			gpio_pin_write(drv_data->exp0,
  107d6e:	89 fa                	mov    %edi,%edx
  107d70:	8b 06                	mov    (%esi),%eax
  107d72:	e8 71 ff ff ff       	call   107ce8 <gpio_pin_write>
			gpio_pin_configure(drv_data->exp0,
  107d77:	8b 4b 10             	mov    0x10(%ebx),%ecx
  107d7a:	89 fa                	mov    %edi,%edx
  107d7c:	8b 06                	mov    (%esi),%eax
  107d7e:	eb 75                	jmp    107df5 <z_galileo_pinmux_set_pin+0xe0>
			gpio_pin_write(drv_data->exp1,
  107d80:	8b 46 04             	mov    0x4(%esi),%eax
  107d83:	89 fa                	mov    %edi,%edx
  107d85:	e8 5e ff ff ff       	call   107ce8 <gpio_pin_write>
			gpio_pin_configure(drv_data->exp1,
  107d8a:	8b 4b 10             	mov    0x10(%ebx),%ecx
  107d8d:	8b 46 04             	mov    0x4(%esi),%eax
  107d90:	eb 61                	jmp    107df3 <z_galileo_pinmux_set_pin+0xde>
			gpio_pin_write(drv_data->exp2,
  107d92:	8b 46 08             	mov    0x8(%esi),%eax
  107d95:	89 fa                	mov    %edi,%edx
  107d97:	e8 4c ff ff ff       	call   107ce8 <gpio_pin_write>
			gpio_pin_configure(drv_data->exp2,
  107d9c:	8b 4b 10             	mov    0x10(%ebx),%ecx
  107d9f:	8b 46 08             	mov    0x8(%esi),%eax
  107da2:	eb 4f                	jmp    107df3 <z_galileo_pinmux_set_pin+0xde>
			pwm_pin_set_cycles(drv_data->pwm0,
  107da4:	85 c9                	test   %ecx,%ecx
  107da6:	74 05                	je     107dad <z_galileo_pinmux_set_pin+0x98>
  107da8:	b9 64 00 00 00       	mov    $0x64,%ecx
  107dad:	8b 46 0c             	mov    0xc(%esi),%eax
					   u32_t period, u32_t pulse)
{
	struct pwm_driver_api *api;

	api = (struct pwm_driver_api *)dev->driver_api;
	return api->pin_set(dev, pwm, period, pulse);
  107db0:	8b 50 04             	mov    0x4(%eax),%edx
  107db3:	51                   	push   %ecx
  107db4:	6a 64                	push   $0x64
  107db6:	57                   	push   %edi
  107db7:	50                   	push   %eax
  107db8:	ff 12                	call   *(%edx)
  107dba:	83 c4 10             	add    $0x10,%esp
  107dbd:	eb 3b                	jmp    107dfa <z_galileo_pinmux_set_pin+0xe5>
			gpio_pin_write(drv_data->gpio_dw,
  107dbf:	8b 46 10             	mov    0x10(%esi),%eax
  107dc2:	89 fa                	mov    %edi,%edx
  107dc4:	e8 1f ff ff ff       	call   107ce8 <gpio_pin_write>
			gpio_pin_configure(drv_data->gpio_dw,
  107dc9:	8b 4b 10             	mov    0x10(%ebx),%ecx
  107dcc:	8b 46 10             	mov    0x10(%esi),%eax
  107dcf:	eb 22                	jmp    107df3 <z_galileo_pinmux_set_pin+0xde>
			gpio_pin_write(drv_data->gpio_core,
  107dd1:	8b 46 14             	mov    0x14(%esi),%eax
  107dd4:	89 fa                	mov    %edi,%edx
  107dd6:	e8 0d ff ff ff       	call   107ce8 <gpio_pin_write>
			gpio_pin_configure(drv_data->gpio_core,
  107ddb:	8b 4b 10             	mov    0x10(%ebx),%ecx
  107dde:	8b 46 14             	mov    0x14(%esi),%eax
  107de1:	eb 10                	jmp    107df3 <z_galileo_pinmux_set_pin+0xde>
			gpio_pin_write(drv_data->gpio_resume,
  107de3:	8b 46 18             	mov    0x18(%esi),%eax
  107de6:	89 fa                	mov    %edi,%edx
  107de8:	e8 fb fe ff ff       	call   107ce8 <gpio_pin_write>
			gpio_pin_configure(drv_data->gpio_resume,
  107ded:	8b 4b 10             	mov    0x10(%ebx),%ecx
  107df0:	8b 46 18             	mov    0x18(%esi),%eax
  107df3:	89 fa                	mov    %edi,%edx
  107df5:	e8 05 ff ff ff       	call   107cff <gpio_pin_configure>
	for (i = 0U; i < 5; i++) {
  107dfa:	fe 45 f3             	incb   -0xd(%ebp)
  107dfd:	83 c3 10             	add    $0x10,%ebx
  107e00:	80 7d f3 05          	cmpb   $0x5,-0xd(%ebp)
  107e04:	0f 85 49 ff ff ff    	jne    107d53 <z_galileo_pinmux_set_pin+0x3e>
	return 0;
  107e0a:	31 c0                	xor    %eax,%eax
}
  107e0c:	8d 65 f4             	lea    -0xc(%ebp),%esp
  107e0f:	5b                   	pop    %ebx
  107e10:	5e                   	pop    %esi
  107e11:	5f                   	pop    %edi
  107e12:	5d                   	pop    %ebp
  107e13:	c3                   	ret    

00107e14 <pinmux_galileo_initialize>:
	.pwm0 = NULL,
	.mux_config = mux_config,
};

static int pinmux_galileo_initialize(struct device *port)
{
  107e14:	55                   	push   %ebp
  107e15:	89 e5                	mov    %esp,%ebp
  107e17:	56                   	push   %esi
  107e18:	53                   	push   %ebx
  107e19:	8b 75 08             	mov    0x8(%ebp),%esi
	struct galileo_data *dev = port->driver_data;
  107e1c:	8b 5e 08             	mov    0x8(%esi),%ebx
  107e1f:	68 f5 ed 10 00       	push   $0x10edf5
  107e24:	e8 d5 1e 00 00       	call   109cfe <z_impl_device_get_binding>
  107e29:	5a                   	pop    %edx
	int i;

	/* Grab the EXP0, EXP1, EXP2, and PWM0 now by name */
	dev->exp0 = device_get_binding(PINMUX_GALILEO_EXP0_NAME);
	if (!dev->exp0) {
  107e2a:	85 c0                	test   %eax,%eax
	dev->exp0 = device_get_binding(PINMUX_GALILEO_EXP0_NAME);
  107e2c:	89 03                	mov    %eax,(%ebx)
	if (!dev->exp0) {
  107e2e:	0f 84 91 00 00 00    	je     107ec5 <pinmux_galileo_initialize+0xb1>
  107e34:	68 fa ed 10 00       	push   $0x10edfa
  107e39:	e8 c0 1e 00 00       	call   109cfe <z_impl_device_get_binding>
  107e3e:	59                   	pop    %ecx
		return -EINVAL;
	}
	dev->exp1 = device_get_binding(PINMUX_GALILEO_EXP1_NAME);
	if (!dev->exp1) {
  107e3f:	85 c0                	test   %eax,%eax
	dev->exp1 = device_get_binding(PINMUX_GALILEO_EXP1_NAME);
  107e41:	89 43 04             	mov    %eax,0x4(%ebx)
	if (!dev->exp1) {
  107e44:	74 7f                	je     107ec5 <pinmux_galileo_initialize+0xb1>
  107e46:	68 ff ed 10 00       	push   $0x10edff
  107e4b:	e8 ae 1e 00 00       	call   109cfe <z_impl_device_get_binding>
  107e50:	5a                   	pop    %edx
		return -EINVAL;
	}
	dev->exp2 = device_get_binding(PINMUX_GALILEO_EXP2_NAME);
	if (!dev->exp2) {
  107e51:	85 c0                	test   %eax,%eax
	dev->exp2 = device_get_binding(PINMUX_GALILEO_EXP2_NAME);
  107e53:	89 43 08             	mov    %eax,0x8(%ebx)
	if (!dev->exp2) {
  107e56:	74 6d                	je     107ec5 <pinmux_galileo_initialize+0xb1>
  107e58:	68 04 ee 10 00       	push   $0x10ee04
  107e5d:	e8 9c 1e 00 00       	call   109cfe <z_impl_device_get_binding>
  107e62:	59                   	pop    %ecx
		return -EINVAL;
	}
	dev->pwm0 = device_get_binding(PINMUX_GALILEO_PWM0_NAME);
	if (!dev->pwm0) {
  107e63:	85 c0                	test   %eax,%eax
	dev->pwm0 = device_get_binding(PINMUX_GALILEO_PWM0_NAME);
  107e65:	89 43 0c             	mov    %eax,0xc(%ebx)
	if (!dev->pwm0) {
  107e68:	74 5b                	je     107ec5 <pinmux_galileo_initialize+0xb1>
  107e6a:	68 09 ee 10 00       	push   $0x10ee09
  107e6f:	e8 8a 1e 00 00       	call   109cfe <z_impl_device_get_binding>
  107e74:	5a                   	pop    %edx
		return -EINVAL;
	}
	dev->gpio_dw = device_get_binding(PINMUX_GALILEO_GPIO_DW_NAME);
	if (!dev->gpio_dw) {
  107e75:	85 c0                	test   %eax,%eax
	dev->gpio_dw = device_get_binding(PINMUX_GALILEO_GPIO_DW_NAME);
  107e77:	89 43 10             	mov    %eax,0x10(%ebx)
	if (!dev->gpio_dw) {
  107e7a:	74 49                	je     107ec5 <pinmux_galileo_initialize+0xb1>
  107e7c:	68 10 ee 10 00       	push   $0x10ee10
  107e81:	e8 78 1e 00 00       	call   109cfe <z_impl_device_get_binding>
  107e86:	59                   	pop    %ecx
		return -EINVAL;
	}
	dev->gpio_core = device_get_binding(
			    PINMUX_GALILEO_GPIO_INTEL_CW_NAME);
	if (!dev->gpio_core) {
  107e87:	85 c0                	test   %eax,%eax
	dev->gpio_core = device_get_binding(
  107e89:	89 43 14             	mov    %eax,0x14(%ebx)
	if (!dev->gpio_core) {
  107e8c:	74 37                	je     107ec5 <pinmux_galileo_initialize+0xb1>
  107e8e:	68 18 ee 10 00       	push   $0x10ee18
  107e93:	e8 66 1e 00 00       	call   109cfe <z_impl_device_get_binding>
  107e98:	5a                   	pop    %edx
		return -EINVAL;
	}
	dev->gpio_resume = device_get_binding(
			    PINMUX_GALILEO_GPIO_INTEL_RW_NAME);
	if (!dev->gpio_resume) {
  107e99:	85 c0                	test   %eax,%eax
	dev->gpio_resume = device_get_binding(
  107e9b:	89 43 18             	mov    %eax,0x18(%ebx)
	if (!dev->gpio_resume) {
  107e9e:	74 25                	je     107ec5 <pinmux_galileo_initialize+0xb1>

	/*
	 * Now that we have everything, let us start parsing everything
	 * from the above mapping as selected by the end user
	 */
	for (i = 0; i < PINMUX_NUM_PINS; i++) {
  107ea0:	31 db                	xor    %ebx,%ebx
		z_galileo_pinmux_set_pin(port,
  107ea2:	ff 34 dd e4 2f 11 00 	pushl  0x112fe4(,%ebx,8)
  107ea9:	0f b6 04 dd e0 2f 11 	movzbl 0x112fe0(,%ebx,8),%eax
  107eb0:	00 
  107eb1:	50                   	push   %eax
	for (i = 0; i < PINMUX_NUM_PINS; i++) {
  107eb2:	43                   	inc    %ebx
		z_galileo_pinmux_set_pin(port,
  107eb3:	56                   	push   %esi
  107eb4:	e8 5c fe ff ff       	call   107d15 <z_galileo_pinmux_set_pin>
  107eb9:	83 c4 0c             	add    $0xc,%esp
	for (i = 0; i < PINMUX_NUM_PINS; i++) {
  107ebc:	83 fb 14             	cmp    $0x14,%ebx
  107ebf:	75 e1                	jne    107ea2 <pinmux_galileo_initialize+0x8e>
				 mux_config[i].pin_num,
				 mux_config[i].mode);
	}

	return 0;
  107ec1:	31 c0                	xor    %eax,%eax
  107ec3:	eb 05                	jmp    107eca <pinmux_galileo_initialize+0xb6>
		return -EINVAL;
  107ec5:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
}
  107eca:	8d 65 f8             	lea    -0x8(%ebp),%esp
  107ecd:	5b                   	pop    %ebx
  107ece:	5e                   	pop    %esi
  107ecf:	5d                   	pop    %ebp
  107ed0:	c3                   	ret    

00107ed1 <pinmux_set>:
{
  107ed1:	55                   	push   %ebp
  107ed2:	89 e5                	mov    %esp,%ebp
	if (pin > PINMUX_NUM_PINS) {
  107ed4:	83 7d 0c 14          	cmpl   $0x14,0xc(%ebp)
  107ed8:	77 06                	ja     107ee0 <pinmux_set+0xf>
}
  107eda:	5d                   	pop    %ebp
	return z_galileo_pinmux_set_pin(dev, pin, func);
  107edb:	e9 35 fe ff ff       	jmp    107d15 <z_galileo_pinmux_set_pin>
}
  107ee0:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
  107ee5:	5d                   	pop    %ebp
  107ee6:	c3                   	ret    

00107ee7 <dw_set_bit>:
	sys_write32(val, base_addr + offset);
}

static void dw_set_bit(u32_t base_addr, u32_t offset,
		       u32_t bit, u8_t value)
{
  107ee7:	55                   	push   %ebp
  107ee8:	01 d0                	add    %edx,%eax
  107eea:	89 e5                	mov    %esp,%ebp
	if (!value) {
  107eec:	80 7d 08 00          	cmpb   $0x0,0x8(%ebp)
  107ef0:	75 05                	jne    107ef7 <dw_set_bit+0x10>
}

static ALWAYS_INLINE
	void sys_clear_bit(mem_addr_t addr, unsigned int bit)
{
	__asm__ volatile("btrl	%1, %0;\n\t"
  107ef2:	0f b3 08             	btr    %ecx,(%eax)
  107ef5:	eb 03                	jmp    107efa <dw_set_bit+0x13>
	__asm__ volatile("btsl	%1, %0;\n\t"
  107ef7:	0f ab 08             	bts    %ecx,(%eax)
		sys_clear_bit(base_addr + offset, bit);
	} else {
		sys_set_bit(base_addr + offset, bit);
	}
}
  107efa:	5d                   	pop    %ebp
  107efb:	c3                   	ret    

00107efc <gpio_dw_write>:
	return 0;
}

static inline int gpio_dw_write(struct device *port, int access_op,
				u32_t pin, u32_t value)
{
  107efc:	55                   	push   %ebp
  107efd:	89 e5                	mov    %esp,%ebp
	struct gpio_dw_runtime *context = port->driver_data;
	u32_t base_addr = context->base_addr;
  107eff:	8b 45 08             	mov    0x8(%ebp),%eax
{
  107f02:	8b 55 14             	mov    0x14(%ebp),%edx

	if (GPIO_ACCESS_BY_PIN == access_op) {
  107f05:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
	u32_t base_addr = context->base_addr;
  107f09:	8b 40 08             	mov    0x8(%eax),%eax
  107f0c:	8b 00                	mov    (%eax),%eax
	if (GPIO_ACCESS_BY_PIN == access_op) {
  107f0e:	75 11                	jne    107f21 <gpio_dw_write+0x25>
		dw_set_bit(base_addr, SWPORTA_DR, pin, value);
  107f10:	0f b6 d2             	movzbl %dl,%edx
  107f13:	52                   	push   %edx
  107f14:	8b 4d 10             	mov    0x10(%ebp),%ecx
  107f17:	31 d2                	xor    %edx,%edx
  107f19:	e8 c9 ff ff ff       	call   107ee7 <dw_set_bit>
  107f1e:	58                   	pop    %eax
  107f1f:	eb 02                	jmp    107f23 <gpio_dw_write+0x27>
	__asm__ volatile("movl	%0, %1;\n\t"
  107f21:	89 10                	mov    %edx,(%eax)
	} else {
		dw_write(base_addr, SWPORTA_DR, value);
	}

	return 0;
}
  107f23:	31 c0                	xor    %eax,%eax
  107f25:	c9                   	leave  
  107f26:	c3                   	ret    

00107f27 <gpio_dw_read>:

static inline int gpio_dw_read(struct device *port, int access_op,
			       u32_t pin, u32_t *value)
{
  107f27:	55                   	push   %ebp
	u32_t port = (base_addr & 0x3f) / 12U;
  107f28:	31 d2                	xor    %edx,%edx
{
  107f2a:	89 e5                	mov    %esp,%ebp
  107f2c:	56                   	push   %esi
  107f2d:	53                   	push   %ebx
	u32_t port = (base_addr & 0x3f) / 12U;
  107f2e:	be 0c 00 00 00       	mov    $0xc,%esi
	struct gpio_dw_runtime *context = port->driver_data;
	u32_t base_addr = context->base_addr;
  107f33:	8b 45 08             	mov    0x8(%ebp),%eax
{
  107f36:	8b 5d 14             	mov    0x14(%ebp),%ebx
	u32_t base_addr = context->base_addr;
  107f39:	8b 40 08             	mov    0x8(%eax),%eax
  107f3c:	8b 08                	mov    (%eax),%ecx
	u32_t port = (base_addr & 0x3f) / 12U;
  107f3e:	89 c8                	mov    %ecx,%eax
  107f40:	83 e0 3f             	and    $0x3f,%eax
  107f43:	f7 f6                	div    %esi
  107f45:	ba 50 00 00 00       	mov    $0x50,%edx
  107f4a:	8d 70 ff             	lea    -0x1(%eax),%esi
  107f4d:	83 fe 02             	cmp    $0x2,%esi
  107f50:	77 07                	ja     107f59 <gpio_dw_read+0x32>
  107f52:	0f b6 90 26 ee 10 00 	movzbl 0x10ee26(%eax),%edx
	return (base_addr & 0xFFFFFFC0);
  107f59:	83 e1 c0             	and    $0xffffffc0,%ecx
	return sys_read32(base_addr + offset);
  107f5c:	01 d1                	add    %edx,%ecx
	__asm__ volatile("movl	%1, %0;\n\t"
  107f5e:	8b 01                	mov    (%ecx),%eax
		break;
	}
	*value = dw_read(dw_base_to_block_base(base_addr), ext_port);
#endif

	if (GPIO_ACCESS_BY_PIN == access_op) {
  107f60:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  107f64:	75 08                	jne    107f6e <gpio_dw_read+0x47>
		*value = !!(*value & BIT(pin));
  107f66:	8b 4d 10             	mov    0x10(%ebp),%ecx
  107f69:	d3 e8                	shr    %cl,%eax
  107f6b:	83 e0 01             	and    $0x1,%eax
  107f6e:	89 03                	mov    %eax,(%ebx)
	}
	return 0;
}
  107f70:	31 c0                	xor    %eax,%eax
  107f72:	5b                   	pop    %ebx
  107f73:	5e                   	pop    %esi
  107f74:	5d                   	pop    %ebp
  107f75:	c3                   	ret    

00107f76 <gpio_dw_manage_callback>:

static inline int gpio_dw_manage_callback(struct device *port,
					  struct gpio_callback *callback,
					  bool set)
{
  107f76:	55                   	push   %ebp
  107f77:	89 e5                	mov    %esp,%ebp
  107f79:	57                   	push   %edi
  107f7a:	56                   	push   %esi
	struct gpio_dw_runtime *context = port->driver_data;
  107f7b:	8b 45 08             	mov    0x8(%ebp),%eax
{
  107f7e:	53                   	push   %ebx
  107f7f:	8b 4d 0c             	mov    0xc(%ebp),%ecx
 * @return true if node was removed
 */
static inline bool sys_slist_find_and_remove(sys_slist_t *list,
					     sys_snode_t *node);

Z_GENLIST_FIND_AND_REMOVE(slist, snode)
  107f82:	31 db                	xor    %ebx,%ebx
	struct gpio_dw_runtime *context = port->driver_data;
  107f84:	8b 50 08             	mov    0x8(%eax),%edx
{
  107f87:	8b 75 10             	mov    0x10(%ebp),%esi
Z_GENLIST_IS_EMPTY(slist)
  107f8a:	8b 42 18             	mov    0x18(%edx),%eax
					bool set)
{
	__ASSERT(callback, "No callback!");
	__ASSERT(callback->handler, "No callback handler!");

	if (!sys_slist_is_empty(callbacks)) {
  107f8d:	85 c0                	test   %eax,%eax
  107f8f:	74 53                	je     107fe4 <gpio_dw_manage_callback+0x6e>
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
  107f91:	39 c1                	cmp    %eax,%ecx
  107f93:	75 25                	jne    107fba <gpio_dw_manage_callback+0x44>
Z_GENLIST_REMOVE(slist, snode)
  107f95:	8b 01                	mov    (%ecx),%eax
  107f97:	85 db                	test   %ebx,%ebx
  107f99:	75 0d                	jne    107fa8 <gpio_dw_manage_callback+0x32>
	list->head = node;
  107f9b:	89 42 18             	mov    %eax,0x18(%edx)
Z_GENLIST_REMOVE(slist, snode)
  107f9e:	3b 4a 1c             	cmp    0x1c(%edx),%ecx
  107fa1:	75 0f                	jne    107fb2 <gpio_dw_manage_callback+0x3c>
	list->tail = node;
  107fa3:	89 42 1c             	mov    %eax,0x1c(%edx)
  107fa6:	eb 0a                	jmp    107fb2 <gpio_dw_manage_callback+0x3c>
	parent->next = child;
  107fa8:	89 03                	mov    %eax,(%ebx)
Z_GENLIST_REMOVE(slist, snode)
  107faa:	3b 4a 1c             	cmp    0x1c(%edx),%ecx
  107fad:	75 03                	jne    107fb2 <gpio_dw_manage_callback+0x3c>
	list->tail = node;
  107faf:	89 5a 1c             	mov    %ebx,0x1c(%edx)
	parent->next = child;
  107fb2:	c7 01 00 00 00 00    	movl   $0x0,(%ecx)
  107fb8:	eb 2a                	jmp    107fe4 <gpio_dw_manage_callback+0x6e>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
  107fba:	8b 38                	mov    (%eax),%edi
	return node->next;
  107fbc:	89 c3                	mov    %eax,%ebx
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
  107fbe:	85 ff                	test   %edi,%edi
  107fc0:	74 04                	je     107fc6 <gpio_dw_manage_callback+0x50>
  107fc2:	89 f8                	mov    %edi,%eax
  107fc4:	eb cb                	jmp    107f91 <gpio_dw_manage_callback+0x1b>
		if (!sys_slist_find_and_remove(callbacks, &callback->node)) {
			if (!set) {
  107fc6:	89 f3                	mov    %esi,%ebx
				return -EINVAL;
  107fc8:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
			if (!set) {
  107fcd:	84 db                	test   %bl,%bl
  107fcf:	74 1b                	je     107fec <gpio_dw_manage_callback+0x76>
Z_GENLIST_PREPEND(slist, snode)
  107fd1:	8b 42 18             	mov    0x18(%edx),%eax
	parent->next = child;
  107fd4:	89 01                	mov    %eax,(%ecx)
	list->head = node;
  107fd6:	89 4a 18             	mov    %ecx,0x18(%edx)
Z_GENLIST_PREPEND(slist, snode)
  107fd9:	83 7a 1c 00          	cmpl   $0x0,0x1c(%edx)
  107fdd:	75 0b                	jne    107fea <gpio_dw_manage_callback+0x74>
	list->tail = node;
  107fdf:	89 4a 1c             	mov    %ecx,0x1c(%edx)
  107fe2:	eb 06                	jmp    107fea <gpio_dw_manage_callback+0x74>
			}
		}
	}

	if (set) {
  107fe4:	89 f0                	mov    %esi,%eax
  107fe6:	84 c0                	test   %al,%al
  107fe8:	75 e7                	jne    107fd1 <gpio_dw_manage_callback+0x5b>
		sys_slist_prepend(callbacks, &callback->node);
	}

	return 0;
  107fea:	31 c0                	xor    %eax,%eax

	return gpio_manage_callback(&context->callbacks, callback, set);
}
  107fec:	5b                   	pop    %ebx
  107fed:	5e                   	pop    %esi
  107fee:	5f                   	pop    %edi
  107fef:	5d                   	pop    %ebp
  107ff0:	c3                   	ret    

00107ff1 <gpio_dw_enable_callback>:

static inline int gpio_dw_enable_callback(struct device *port, int access_op,
					  u32_t pin)
{
  107ff1:	55                   	push   %ebp
  107ff2:	89 e5                	mov    %esp,%ebp
  107ff4:	8b 55 08             	mov    0x8(%ebp),%edx
  107ff7:	8b 4d 10             	mov    0x10(%ebp),%ecx
	const struct gpio_dw_config *config = port->config->config_info;
	struct gpio_dw_runtime *context = port->driver_data;
	u32_t base_addr = dw_base_to_block_base(context->base_addr);
  107ffa:	8b 42 08             	mov    0x8(%edx),%eax
	return (base_addr & 0xFFFFFFC0);
  107ffd:	8b 00                	mov    (%eax),%eax
  107fff:	83 e0 c0             	and    $0xffffffc0,%eax

	if (GPIO_ACCESS_BY_PIN == access_op) {
  108002:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  108006:	75 19                	jne    108021 <gpio_dw_enable_callback+0x30>
		dw_write(base_addr, PORTA_EOI, BIT(pin));
  108008:	ba 01 00 00 00       	mov    $0x1,%edx
  10800d:	d3 e2                	shl    %cl,%edx
	__asm__ volatile("movl	%0, %1;\n\t"
  10800f:	89 50 4c             	mov    %edx,0x4c(%eax)
		dw_set_bit(base_addr, INTMASK, pin, 0);
  108012:	ba 34 00 00 00       	mov    $0x34,%edx
  108017:	6a 00                	push   $0x0
  108019:	e8 c9 fe ff ff       	call   107ee7 <dw_set_bit>
  10801e:	58                   	pop    %eax
  10801f:	eb 17                	jmp    108038 <gpio_dw_enable_callback+0x47>
	const struct gpio_dw_config *config = port->config->config_info;
  108021:	8b 12                	mov    (%edx),%edx
	} else {
		dw_write(base_addr, PORTA_EOI, BIT_MASK(config->bits));
  108023:	8b 52 08             	mov    0x8(%edx),%edx
  108026:	8b 0a                	mov    (%edx),%ecx
  108028:	ba 01 00 00 00       	mov    $0x1,%edx
  10802d:	d3 e2                	shl    %cl,%edx
  10802f:	4a                   	dec    %edx
  108030:	89 50 4c             	mov    %edx,0x4c(%eax)
  108033:	31 d2                	xor    %edx,%edx
  108035:	89 50 34             	mov    %edx,0x34(%eax)
		dw_write(base_addr, INTMASK, 0);
	}

	return 0;
}
  108038:	31 c0                	xor    %eax,%eax
  10803a:	c9                   	leave  
  10803b:	c3                   	ret    

0010803c <gpio_dw_disable_callback>:

static inline int gpio_dw_disable_callback(struct device *port, int access_op,
					   u32_t pin)
{
  10803c:	55                   	push   %ebp
  10803d:	89 e5                	mov    %esp,%ebp
  10803f:	8b 55 08             	mov    0x8(%ebp),%edx
	const struct gpio_dw_config *config = port->config->config_info;
	struct gpio_dw_runtime *context = port->driver_data;
	u32_t base_addr = dw_base_to_block_base(context->base_addr);
  108042:	8b 42 08             	mov    0x8(%edx),%eax
	return (base_addr & 0xFFFFFFC0);
  108045:	8b 00                	mov    (%eax),%eax
  108047:	83 e0 c0             	and    $0xffffffc0,%eax

	if (GPIO_ACCESS_BY_PIN == access_op) {
  10804a:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  10804e:	75 12                	jne    108062 <gpio_dw_disable_callback+0x26>
		dw_set_bit(base_addr, INTMASK, pin, 1);
  108050:	6a 01                	push   $0x1
  108052:	8b 4d 10             	mov    0x10(%ebp),%ecx
  108055:	ba 34 00 00 00       	mov    $0x34,%edx
  10805a:	e8 88 fe ff ff       	call   107ee7 <dw_set_bit>
  10805f:	58                   	pop    %eax
  108060:	eb 12                	jmp    108074 <gpio_dw_disable_callback+0x38>
	const struct gpio_dw_config *config = port->config->config_info;
  108062:	8b 12                	mov    (%edx),%edx
	} else {
		dw_write(base_addr, INTMASK, BIT_MASK(config->bits));
  108064:	8b 52 08             	mov    0x8(%edx),%edx
  108067:	8b 0a                	mov    (%edx),%ecx
  108069:	ba 01 00 00 00       	mov    $0x1,%edx
  10806e:	d3 e2                	shl    %cl,%edx
  108070:	4a                   	dec    %edx
  108071:	89 50 34             	mov    %edx,0x34(%eax)
	}

	return 0;
}
  108074:	31 c0                	xor    %eax,%eax
  108076:	c9                   	leave  
  108077:	c3                   	ret    

00108078 <gpio_dw_isr>:
#else
#define gpio_dw_unmask_int(...)
#endif

static void gpio_dw_isr(void *arg)
{
  108078:	55                   	push   %ebp
  108079:	89 e5                	mov    %esp,%ebp
  10807b:	57                   	push   %edi
  10807c:	56                   	push   %esi
  10807d:	8b 75 08             	mov    0x8(%ebp),%esi
  108080:	53                   	push   %ebx
	struct device *port = (struct device *)arg;
	struct gpio_dw_runtime *context = port->driver_data;
  108081:	8b 56 08             	mov    0x8(%esi),%edx
	return (base_addr & 0xFFFFFFC0);
  108084:	8b 02                	mov    (%edx),%eax
  108086:	83 e0 c0             	and    $0xffffffc0,%eax
	__asm__ volatile("movl	%1, %0;\n\t"
  108089:	8b 78 40             	mov    0x40(%eax),%edi
#ifdef CONFIG_SHARED_IRQ
	/* If using with shared IRQ, this function will be called
	 * by the shared IRQ driver. So check here if the interrupt
	 * is coming from the GPIO controller (or somewhere else).
	 */
	if (!int_status) {
  10808c:	85 ff                	test   %edi,%edi
  10808e:	74 24                	je     1080b4 <gpio_dw_isr+0x3c>
	__asm__ volatile("movl	%0, %1;\n\t"
  108090:	89 78 4c             	mov    %edi,0x4c(%eax)
					struct device *port,
					u32_t pins)
{
	struct gpio_callback *cb, *tmp;

	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(list, cb, tmp, node) {
  108093:	8b 42 18             	mov    0x18(%edx),%eax
  108096:	85 c0                	test   %eax,%eax
  108098:	74 1a                	je     1080b4 <gpio_dw_isr+0x3c>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
  10809a:	8b 18                	mov    (%eax),%ebx
		if (cb->pin_mask & pins) {
  10809c:	85 78 08             	test   %edi,0x8(%eax)
  10809f:	74 09                	je     1080aa <gpio_dw_isr+0x32>
			__ASSERT(cb->handler, "No callback handler!");
			cb->handler(port, cb, pins);
  1080a1:	57                   	push   %edi
  1080a2:	50                   	push   %eax
  1080a3:	56                   	push   %esi
  1080a4:	ff 50 04             	call   *0x4(%eax)
  1080a7:	83 c4 0c             	add    $0xc,%esp
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(list, cb, tmp, node) {
  1080aa:	85 db                	test   %ebx,%ebx
  1080ac:	74 06                	je     1080b4 <gpio_dw_isr+0x3c>
  1080ae:	89 d8                	mov    %ebx,%eax
  1080b0:	8b 1b                	mov    (%ebx),%ebx
  1080b2:	eb e8                	jmp    10809c <gpio_dw_isr+0x24>
#endif

	dw_write(base_addr, PORTA_EOI, int_status);

	gpio_fire_callbacks(&context->callbacks, port, int_status);
}
  1080b4:	8d 65 f4             	lea    -0xc(%ebp),%esp
  1080b7:	5b                   	pop    %ebx
  1080b8:	5e                   	pop    %esi
  1080b9:	5f                   	pop    %edi
  1080ba:	5d                   	pop    %ebp
  1080bb:	c3                   	ret    

001080bc <gpio_dw_initialize>:
#define gpio_dw_setup(_unused_) (1)
#endif /* CONFIG_PCI */


static int gpio_dw_initialize(struct device *port)
{
  1080bc:	55                   	push   %ebp
  1080bd:	89 e5                	mov    %esp,%ebp
  1080bf:	57                   	push   %edi
  1080c0:	56                   	push   %esi
  1080c1:	53                   	push   %ebx
  1080c2:	51                   	push   %ecx
  1080c3:	8b 75 08             	mov    0x8(%ebp),%esi
	struct gpio_dw_runtime *context = port->driver_data;
	const struct gpio_dw_config *config = port->config->config_info;
  1080c6:	8b 06                	mov    (%esi),%eax
	struct gpio_dw_runtime *context = port->driver_data;
  1080c8:	8b 5e 08             	mov    0x8(%esi),%ebx
	const struct gpio_dw_config *config = port->config->config_info;
  1080cb:	8b 78 08             	mov    0x8(%eax),%edi
	pci_bus_scan_init();
  1080ce:	e8 9d dc ff ff       	call   105d70 <pci_bus_scan_init>
	if (!pci_bus_scan(&context->pci_dev)) {
  1080d3:	8d 53 04             	lea    0x4(%ebx),%edx
  1080d6:	52                   	push   %edx
  1080d7:	89 55 f0             	mov    %edx,-0x10(%ebp)
  1080da:	e8 c4 dc ff ff       	call   105da3 <pci_bus_scan>
  1080df:	5a                   	pop    %edx
  1080e0:	85 c0                	test   %eax,%eax
  1080e2:	8b 55 f0             	mov    -0x10(%ebp),%edx
  1080e5:	75 10                	jne    1080f7 <gpio_dw_initialize+0x3b>
	u32_t base_addr;

	if (!gpio_dw_setup(port)) {
		port->driver_api = NULL;
  1080e7:	c7 46 04 00 00 00 00 	movl   $0x0,0x4(%esi)
		return -EPERM;
  1080ee:	c7 45 f0 ff ff ff ff 	movl   $0xffffffff,-0x10(%ebp)
  1080f5:	eb 49                	jmp    108140 <gpio_dw_initialize+0x84>
	context->base_addr = context->pci_dev.addr;
  1080f7:	8b 43 04             	mov    0x4(%ebx),%eax
  1080fa:	89 03                	mov    %eax,(%ebx)
	config->irq_num = context->pci_dev.irq;
  1080fc:	8b 43 0c             	mov    0xc(%ebx),%eax
  1080ff:	89 47 04             	mov    %eax,0x4(%edi)
	pci_enable_regs(&context->pci_dev);
  108102:	52                   	push   %edx
  108103:	e8 68 e2 ff ff       	call   106370 <pci_enable_regs>
  108108:	5a                   	pop    %edx
		config->config_func(port);
	}

	gpio_dw_set_power_state(port, DEVICE_PM_ACTIVE_STATE);

	return 0;
  108109:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	if (dw_interrupt_support(config)) {
  108110:	83 7f 04 00          	cmpl   $0x0,0x4(%edi)
  108114:	7e 2a                	jle    108140 <gpio_dw_initialize+0x84>
	return (base_addr & 0xFFFFFFC0);
  108116:	8b 1b                	mov    (%ebx),%ebx
		dw_set_bit(base_addr, INT_CLOCK_SYNC, LS_SYNC_POS, 1);
  108118:	31 c9                	xor    %ecx,%ecx
	return (base_addr & 0xFFFFFFC0);
  10811a:	83 e3 c0             	and    $0xffffffc0,%ebx
		dw_set_bit(base_addr, INT_CLOCK_SYNC, LS_SYNC_POS, 1);
  10811d:	ba 60 00 00 00       	mov    $0x60,%edx
  108122:	89 d8                	mov    %ebx,%eax
  108124:	6a 01                	push   $0x1
  108126:	e8 bc fd ff ff       	call   107ee7 <dw_set_bit>
  10812b:	83 c8 ff             	or     $0xffffffff,%eax
  10812e:	89 43 34             	mov    %eax,0x34(%ebx)
  108131:	31 c9                	xor    %ecx,%ecx
  108133:	89 4b 30             	mov    %ecx,0x30(%ebx)
  108136:	89 43 4c             	mov    %eax,0x4c(%ebx)
		config->config_func(port);
  108139:	89 34 24             	mov    %esi,(%esp)
  10813c:	ff 57 08             	call   *0x8(%edi)
  10813f:	58                   	pop    %eax
}
  108140:	8b 45 f0             	mov    -0x10(%ebp),%eax
  108143:	8d 65 f4             	lea    -0xc(%ebp),%esp
  108146:	5b                   	pop    %ebx
  108147:	5e                   	pop    %esi
  108148:	5f                   	pop    %edi
  108149:	5d                   	pop    %ebp
  10814a:	c3                   	ret    

0010814b <dw_pin_config>:
{
  10814b:	55                   	push   %ebp
  10814c:	89 e5                	mov    %esp,%ebp
  10814e:	57                   	push   %edi
  10814f:	56                   	push   %esi
  108150:	89 c6                	mov    %eax,%esi
  108152:	53                   	push   %ebx
  108153:	89 d7                	mov    %edx,%edi
  108155:	83 ec 08             	sub    $0x8,%esp
  108158:	89 4d f0             	mov    %ecx,-0x10(%ebp)
	u32_t base_addr = dw_base_to_block_base(context->base_addr);
  10815b:	8b 40 08             	mov    0x8(%eax),%eax
  10815e:	8b 00                	mov    (%eax),%eax
  108160:	89 45 ec             	mov    %eax,-0x14(%ebp)
	const struct gpio_dw_config *config = port->config->config_info;
  108163:	8b 06                	mov    (%esi),%eax
	int interrupt_support = dw_interrupt_support(config);
  108165:	8b 40 08             	mov    0x8(%eax),%eax
	return ((int)(config->irq_num) > 0);
  108168:	8b 58 04             	mov    0x4(%eax),%ebx
	if (interrupt_support) {
  10816b:	85 db                	test   %ebx,%ebx
  10816d:	7e 15                	jle    108184 <dw_pin_config+0x39>
	return (base_addr & 0xFFFFFFC0);
  10816f:	8b 45 ec             	mov    -0x14(%ebp),%eax
		dw_set_bit(base_addr, INTEN, pin, 0);
  108172:	6a 00                	push   $0x0
	return (base_addr & 0xFFFFFFC0);
  108174:	83 e0 c0             	and    $0xffffffc0,%eax
		dw_set_bit(base_addr, INTEN, pin, 0);
  108177:	89 d1                	mov    %edx,%ecx
  108179:	ba 30 00 00 00       	mov    $0x30,%edx
  10817e:	e8 64 fd ff ff       	call   107ee7 <dw_set_bit>
  108183:	58                   	pop    %eax
	dw_set_bit(port_base_addr, SWPORTA_DDR, pin, (flags & GPIO_DIR_MASK));
  108184:	8b 45 f0             	mov    -0x10(%ebp),%eax
  108187:	89 f9                	mov    %edi,%ecx
  108189:	83 e0 01             	and    $0x1,%eax
  10818c:	ba 04 00 00 00       	mov    $0x4,%edx
  108191:	50                   	push   %eax
  108192:	8b 45 ec             	mov    -0x14(%ebp),%eax
  108195:	e8 4d fd ff ff       	call   107ee7 <dw_set_bit>
  10819a:	58                   	pop    %eax
	if (interrupt_support && (flags & GPIO_INT)) {
  10819b:	85 db                	test   %ebx,%ebx
  10819d:	0f 8e b6 00 00 00    	jle    108259 <dw_pin_config+0x10e>
  1081a3:	f6 45 f0 02          	testb  $0x2,-0x10(%ebp)
  1081a7:	0f 84 ac 00 00 00    	je     108259 <dw_pin_config+0x10e>
	const struct gpio_dw_config *config = port->config->config_info;
  1081ad:	8b 06                	mov    (%esi),%eax
	dw_set_bit(context->base_addr, SWPORTA_DDR, pin, 0);
  1081af:	ba 04 00 00 00       	mov    $0x4,%edx
	const struct gpio_dw_config *config = port->config->config_info;
  1081b4:	8b 58 08             	mov    0x8(%eax),%ebx
	u32_t base_addr = dw_base_to_block_base(context->base_addr);
  1081b7:	8b 46 08             	mov    0x8(%esi),%eax
  1081ba:	8b 30                	mov    (%eax),%esi
	dw_set_bit(context->base_addr, SWPORTA_DDR, pin, 0);
  1081bc:	6a 00                	push   $0x0
  1081be:	89 f0                	mov    %esi,%eax
  1081c0:	e8 22 fd ff ff       	call   107ee7 <dw_set_bit>
  1081c5:	58                   	pop    %eax
	if (dw_interrupt_support(config)) {
  1081c6:	83 7b 04 00          	cmpl   $0x0,0x4(%ebx)
  1081ca:	0f 8e 89 00 00 00    	jle    108259 <dw_pin_config+0x10e>
		flag_is_set = (flags & GPIO_INT_EDGE);
  1081d0:	8a 45 f0             	mov    -0x10(%ebp),%al
	return (base_addr & 0xFFFFFFC0);
  1081d3:	83 e6 c0             	and    $0xffffffc0,%esi
		flag_is_set = (flags & GPIO_INT_EDGE);
  1081d6:	83 e0 20             	and    $0x20,%eax
		dw_set_bit(base_addr, INTTYPE_LEVEL, pin, flag_is_set);
  1081d9:	ba 38 00 00 00       	mov    $0x38,%edx
  1081de:	0f b6 c0             	movzbl %al,%eax
  1081e1:	50                   	push   %eax
  1081e2:	89 f0                	mov    %esi,%eax
  1081e4:	e8 fe fc ff ff       	call   107ee7 <dw_set_bit>
		flag_is_set = (flags & GPIO_INT_ACTIVE_HIGH);
  1081e9:	8a 45 f0             	mov    -0x10(%ebp),%al
  1081ec:	83 e0 04             	and    $0x4,%eax
		dw_set_bit(base_addr, INT_POLARITY, pin, flag_is_set);
  1081ef:	ba 3c 00 00 00       	mov    $0x3c,%edx
  1081f4:	0f b6 c0             	movzbl %al,%eax
  1081f7:	89 04 24             	mov    %eax,(%esp)
  1081fa:	89 f0                	mov    %esi,%eax
  1081fc:	e8 e6 fc ff ff       	call   107ee7 <dw_set_bit>
		if (flag_is_set) {
  108201:	8a 5d f0             	mov    -0x10(%ebp),%bl
  108204:	80 e3 40             	and    $0x40,%bl
		dw_set_bit(base_addr, INT_POLARITY, pin, flag_is_set);
  108207:	59                   	pop    %ecx
		if (flag_is_set) {
  108208:	74 23                	je     10822d <dw_pin_config+0xe2>
	dw_set_bit(base_addr, INT_BOTHEDGE, pin, 1);
  10820a:	89 f9                	mov    %edi,%ecx
  10820c:	ba 68 00 00 00       	mov    $0x68,%edx
  108211:	89 f0                	mov    %esi,%eax
  108213:	6a 01                	push   $0x1
  108215:	e8 cd fc ff ff       	call   107ee7 <dw_set_bit>
			dw_set_bit(base_addr, INTTYPE_LEVEL, pin, flag_is_set);
  10821a:	ba 38 00 00 00       	mov    $0x38,%edx
  10821f:	0f b6 db             	movzbl %bl,%ebx
  108222:	89 f0                	mov    %esi,%eax
  108224:	89 1c 24             	mov    %ebx,(%esp)
  108227:	e8 bb fc ff ff       	call   107ee7 <dw_set_bit>
  10822c:	5a                   	pop    %edx
		flag_is_set = (flags & GPIO_INT_DEBOUNCE);
  10822d:	8a 45 f0             	mov    -0x10(%ebp),%al
		dw_set_bit(base_addr, PORTA_DEBOUNCE, pin, flag_is_set);
  108230:	89 f9                	mov    %edi,%ecx
		flag_is_set = (flags & GPIO_INT_DEBOUNCE);
  108232:	83 e0 10             	and    $0x10,%eax
		dw_set_bit(base_addr, PORTA_DEBOUNCE, pin, flag_is_set);
  108235:	ba 48 00 00 00       	mov    $0x48,%edx
  10823a:	0f b6 c0             	movzbl %al,%eax
  10823d:	50                   	push   %eax
  10823e:	89 f0                	mov    %esi,%eax
  108240:	e8 a2 fc ff ff       	call   107ee7 <dw_set_bit>
		dw_set_bit(base_addr, INTEN, pin, 1);
  108245:	89 f0                	mov    %esi,%eax
  108247:	ba 30 00 00 00       	mov    $0x30,%edx
  10824c:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  108253:	e8 8f fc ff ff       	call   107ee7 <dw_set_bit>
  108258:	58                   	pop    %eax
}
  108259:	8d 65 f4             	lea    -0xc(%ebp),%esp
  10825c:	5b                   	pop    %ebx
  10825d:	5e                   	pop    %esi
  10825e:	5f                   	pop    %edi
  10825f:	5d                   	pop    %ebp
  108260:	c3                   	ret    

00108261 <gpio_dw_config>:
{
  108261:	55                   	push   %ebp
  108262:	89 e5                	mov    %esp,%ebp
  108264:	57                   	push   %edi
  108265:	56                   	push   %esi
	if ((flags & GPIO_INT) && (flags & GPIO_DIR_OUT)) {
  108266:	8b 45 14             	mov    0x14(%ebp),%eax
{
  108269:	53                   	push   %ebx
	if ((flags & GPIO_INT) && (flags & GPIO_DIR_OUT)) {
  10826a:	83 e0 03             	and    $0x3,%eax
{
  10826d:	8b 75 08             	mov    0x8(%ebp),%esi
  108270:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	if ((flags & GPIO_INT) && (flags & GPIO_DIR_OUT)) {
  108273:	83 f8 03             	cmp    $0x3,%eax
  108276:	74 31                	je     1082a9 <gpio_dw_config+0x48>
	if (GPIO_ACCESS_BY_PIN == access_op) {
  108278:	85 db                	test   %ebx,%ebx
  10827a:	75 0f                	jne    10828b <gpio_dw_config+0x2a>
		dw_pin_config(port, pin, flags);
  10827c:	8b 4d 14             	mov    0x14(%ebp),%ecx
  10827f:	8b 55 10             	mov    0x10(%ebp),%edx
  108282:	89 f0                	mov    %esi,%eax
  108284:	e8 c2 fe ff ff       	call   10814b <dw_pin_config>
  108289:	eb 23                	jmp    1082ae <gpio_dw_config+0x4d>
	const struct gpio_dw_config *config = port->config->config_info;
  10828b:	8b 06                	mov    (%esi),%eax
	for (i = 0; i < config->bits; i++) {
  10828d:	31 db                	xor    %ebx,%ebx
	const struct gpio_dw_config *config = port->config->config_info;
  10828f:	8b 78 08             	mov    0x8(%eax),%edi
	for (i = 0; i < config->bits; i++) {
  108292:	39 1f                	cmp    %ebx,(%edi)
  108294:	76 0f                	jbe    1082a5 <gpio_dw_config+0x44>
		dw_pin_config(port, i, flags);
  108296:	89 da                	mov    %ebx,%edx
  108298:	8b 4d 14             	mov    0x14(%ebp),%ecx
  10829b:	89 f0                	mov    %esi,%eax
	for (i = 0; i < config->bits; i++) {
  10829d:	43                   	inc    %ebx
		dw_pin_config(port, i, flags);
  10829e:	e8 a8 fe ff ff       	call   10814b <dw_pin_config>
  1082a3:	eb ed                	jmp    108292 <gpio_dw_config+0x31>
	return 0;
  1082a5:	31 db                	xor    %ebx,%ebx
  1082a7:	eb 05                	jmp    1082ae <gpio_dw_config+0x4d>
		return -EINVAL;
  1082a9:	bb ea ff ff ff       	mov    $0xffffffea,%ebx
}
  1082ae:	89 d8                	mov    %ebx,%eax
  1082b0:	5b                   	pop    %ebx
  1082b1:	5e                   	pop    %esi
  1082b2:	5f                   	pop    %edi
  1082b3:	5d                   	pop    %ebp
  1082b4:	c3                   	ret    

001082b5 <gpio_config_0_irq>:
		    POST_KERNEL, CONFIG_GPIO_DW_INIT_PRIORITY,
		    &api_funcs);
#endif

static void gpio_config_0_irq(struct device *port)
{
  1082b5:	55                   	push   %ebp
  1082b6:	89 e5                	mov    %esp,%ebp
  1082b8:	56                   	push   %esi
  1082b9:	53                   	push   %ebx
  1082ba:	8b 75 08             	mov    0x8(%ebp),%esi
#if (DT_GPIO_DW_0_IRQ > 0)
	const struct gpio_dw_config *config = port->config->config_info;
  1082bd:	8b 06                	mov    (%esi),%eax
		    DEVICE_GET(gpio_dw_0), DT_GPIO_DW_0_IRQ_FLAGS);
	irq_enable(config->irq_num);
#elif defined(CONFIG_GPIO_DW_0_IRQ_SHARED)
	struct device *shared_irq_dev;

	shared_irq_dev = device_get_binding(config->shared_irq_dev_name);
  1082bf:	8b 40 08             	mov    0x8(%eax),%eax
  1082c2:	ff 70 0c             	pushl  0xc(%eax)
  1082c5:	e8 34 1a 00 00       	call   109cfe <z_impl_device_get_binding>
  1082ca:	89 c3                	mov    %eax,%ebx
static inline int shared_irq_isr_register(struct device *dev, isr_t isr_func,
				 struct device *isr_dev)
{
	const struct shared_irq_driver_api *api = dev->driver_api;

	return api->isr_register(dev, isr_func, isr_dev);
  1082cc:	8b 40 04             	mov    0x4(%eax),%eax
  1082cf:	89 34 24             	mov    %esi,(%esp)
  1082d2:	68 78 80 10 00       	push   $0x108078
  1082d7:	53                   	push   %ebx
  1082d8:	ff 10                	call   *(%eax)
  1082da:	83 c4 0c             	add    $0xc,%esp
 */
static inline int shared_irq_enable(struct device *dev, struct device *isr_dev)
{
	const struct shared_irq_driver_api *api = dev->driver_api;

	return api->enable(dev, isr_dev);
  1082dd:	8b 43 04             	mov    0x4(%ebx),%eax
  1082e0:	56                   	push   %esi
  1082e1:	53                   	push   %ebx
  1082e2:	ff 50 04             	call   *0x4(%eax)
  1082e5:	58                   	pop    %eax
  1082e6:	5a                   	pop    %edx
	shared_irq_isr_register(shared_irq_dev, (isr_t)gpio_dw_isr, port);
	shared_irq_enable(shared_irq_dev, port);
#endif
	gpio_dw_unmask_int(GPIO_DW_PORT_0_INT_MASK);
#endif
}
  1082e7:	8d 65 f8             	lea    -0x8(%ebp),%esp
  1082ea:	5b                   	pop    %ebx
  1082eb:	5e                   	pop    %esi
  1082ec:	5d                   	pop    %ebp
  1082ed:	c3                   	ret    

001082ee <gpio_pcal9535a_init>:
 *
 * @param dev Device struct
 * @return 0 if successful, failed otherwise.
 */
static int gpio_pcal9535a_init(struct device *dev)
{
  1082ee:	55                   	push   %ebp
  1082ef:	89 e5                	mov    %esp,%ebp
  1082f1:	53                   	push   %ebx
  1082f2:	8b 45 08             	mov    0x8(%ebp),%eax
	const struct gpio_pcal9535a_config * const config =
		dev->config->config_info;
	struct gpio_pcal9535a_drv_data * const drv_data =
  1082f5:	8b 58 08             	mov    0x8(%eax),%ebx
	const struct gpio_pcal9535a_config * const config =
  1082f8:	8b 00                	mov    (%eax),%eax
		(struct gpio_pcal9535a_drv_data * const)dev->driver_data;
	struct device *i2c_master;

	/* Find out the device struct of the I2C master */
	i2c_master = device_get_binding((char *)config->i2c_master_dev_name);
  1082fa:	8b 40 08             	mov    0x8(%eax),%eax
  1082fd:	ff 30                	pushl  (%eax)
  1082ff:	e8 fa 19 00 00       	call   109cfe <z_impl_device_get_binding>
  108304:	5a                   	pop    %edx
	if (!i2c_master) {
  108305:	85 c0                	test   %eax,%eax
  108307:	ba ea ff ff ff       	mov    $0xffffffea,%edx
  10830c:	74 04                	je     108312 <gpio_pcal9535a_init+0x24>
		return -EINVAL;
	}
	drv_data->i2c_master = i2c_master;
  10830e:	89 03                	mov    %eax,(%ebx)

	return 0;
  108310:	31 d2                	xor    %edx,%edx
}
  108312:	89 d0                	mov    %edx,%eax
  108314:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  108317:	c9                   	leave  
  108318:	c3                   	ret    

00108319 <gpio_pcal9535a_read>:
{
  108319:	55                   	push   %ebp
  10831a:	89 e5                	mov    %esp,%ebp
  10831c:	57                   	push   %edi
  10831d:	56                   	push   %esi
  10831e:	53                   	push   %ebx
  10831f:	83 ec 20             	sub    $0x20,%esp
  108322:	8b 4d 08             	mov    0x8(%ebp),%ecx
  108325:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  108328:	8b 75 14             	mov    0x14(%ebp),%esi
	struct device * const i2c_master = drv_data->i2c_master;
  10832b:	8b 41 08             	mov    0x8(%ecx),%eax
  10832e:	8b 10                	mov    (%eax),%edx
		return -EINVAL;
  108330:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
	if (i2c_master)
  108335:	85 d2                	test   %edx,%edx
  108337:	0f 84 9d 00 00 00    	je     1083da <gpio_pcal9535a_read+0xc1>
	const struct gpio_pcal9535a_config * const config =
  10833d:	8b 01                	mov    (%ecx),%eax
				     u16_t addr)
{
	const struct i2c_driver_api *api =
		(const struct i2c_driver_api *)dev->driver_api;

	return api->transfer(dev, msgs, num_msgs, addr);
  10833f:	8d 4d dc             	lea    -0x24(%ebp),%ecx
  108342:	c6 45 d9 00          	movb   $0x0,-0x27(%ebp)
	u16_t i2c_addr = config->i2c_slave_addr;
  108346:	8b 40 08             	mov    0x8(%eax),%eax
  108349:	0f b7 78 04          	movzwl 0x4(%eax),%edi
				 const void *write_buf, size_t num_write,
				 void *read_buf, size_t num_read)
{
	struct i2c_msg msg[2];

	msg[0].buf = (u8_t *)write_buf;
  10834d:	8d 45 d9             	lea    -0x27(%ebp),%eax
	msg[0].len = num_write;
	msg[0].flags = I2C_MSG_WRITE;
  108350:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
	msg[0].buf = (u8_t *)write_buf;
  108354:	89 45 dc             	mov    %eax,-0x24(%ebp)

	msg[1].buf = (u8_t *)read_buf;
	msg[1].len = num_read;
	msg[1].flags = I2C_MSG_RESTART | I2C_MSG_READ | I2C_MSG_STOP;
  108357:	c6 45 f0 07          	movb   $0x7,-0x10(%ebp)
	msg[1].buf = (u8_t *)read_buf;
  10835b:	8d 45 da             	lea    -0x26(%ebp),%eax
	msg[0].len = num_write;
  10835e:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	msg[1].buf = (u8_t *)read_buf;
  108365:	89 45 e8             	mov    %eax,-0x18(%ebp)
	return api->transfer(dev, msgs, num_msgs, addr);
  108368:	8b 42 04             	mov    0x4(%edx),%eax
  10836b:	57                   	push   %edi
	msg[1].len = num_read;
  10836c:	c7 45 ec 02 00 00 00 	movl   $0x2,-0x14(%ebp)
	return api->transfer(dev, msgs, num_msgs, addr);
  108373:	6a 02                	push   $0x2
  108375:	51                   	push   %ecx
  108376:	52                   	push   %edx
  108377:	ff 50 04             	call   *0x4(%eax)
  10837a:	83 c4 10             	add    $0x10,%esp
	if (ret) {
  10837d:	85 c0                	test   %eax,%eax
  10837f:	74 37                	je     1083b8 <gpio_pcal9535a_read+0x9f>
		LOG_ERR("PCAL9535A[0x%X]: error reading register 0x%X (%d)",
  108381:	f6 05 04 34 11 00 07 	testb  $0x7,0x113404
  108388:	74 50                	je     1083da <gpio_pcal9535a_read+0xc1>
  10838a:	ba e0 b9 10 00       	mov    $0x10b9e0,%edx
  10838f:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  108392:	81 ea e0 b9 10 00    	sub    $0x10b9e0,%edx
  108398:	c1 ea 03             	shr    $0x3,%edx
  10839b:	c1 e2 06             	shl    $0x6,%edx
  10839e:	83 ca 01             	or     $0x1,%edx
  1083a1:	52                   	push   %edx
  1083a2:	50                   	push   %eax
  1083a3:	6a 00                	push   $0x0
  1083a5:	57                   	push   %edi
  1083a6:	68 2a ee 10 00       	push   $0x10ee2a
  1083ab:	e8 c2 8e ff ff       	call   101272 <log_3>
  1083b0:	83 c4 14             	add    $0x14,%esp
  1083b3:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  1083b6:	eb 22                	jmp    1083da <gpio_pcal9535a_read+0xc1>
	switch (access_op) {
  1083b8:	85 db                	test   %ebx,%ebx
  1083ba:	75 0e                	jne    1083ca <gpio_pcal9535a_read+0xb1>
		*value = (buf.all >> pin) & 0x01;
  1083bc:	0f b7 55 da          	movzwl -0x26(%ebp),%edx
  1083c0:	8b 4d 10             	mov    0x10(%ebp),%ecx
  1083c3:	d3 fa                	sar    %cl,%edx
  1083c5:	83 e2 01             	and    $0x1,%edx
  1083c8:	eb 07                	jmp    1083d1 <gpio_pcal9535a_read+0xb8>
	switch (access_op) {
  1083ca:	4b                   	dec    %ebx
  1083cb:	75 08                	jne    1083d5 <gpio_pcal9535a_read+0xbc>
		*value = buf.all;
  1083cd:	0f b7 55 da          	movzwl -0x26(%ebp),%edx
  1083d1:	89 16                	mov    %edx,(%esi)
		break;
  1083d3:	eb 05                	jmp    1083da <gpio_pcal9535a_read+0xc1>
		ret = -ENOTSUP;
  1083d5:	b8 dd ff ff ff       	mov    $0xffffffdd,%eax
}
  1083da:	8d 65 f4             	lea    -0xc(%ebp),%esp
  1083dd:	5b                   	pop    %ebx
  1083de:	5e                   	pop    %esi
  1083df:	5f                   	pop    %edi
  1083e0:	5d                   	pop    %ebp
  1083e1:	c3                   	ret    

001083e2 <write_port_regs>:
{
  1083e2:	55                   	push   %ebp
  1083e3:	89 e5                	mov    %esp,%ebp
  1083e5:	56                   	push   %esi
  1083e6:	53                   	push   %ebx
  1083e7:	89 d3                	mov    %edx,%ebx
  1083e9:	83 ec 20             	sub    $0x20,%esp
	struct device * const i2c_master = drv_data->i2c_master;
  1083ec:	8b 50 08             	mov    0x8(%eax),%edx
	const struct gpio_pcal9535a_config * const config =
  1083ef:	8b 00                	mov    (%eax),%eax
	u16_t i2c_addr = config->i2c_slave_addr;
  1083f1:	8b 40 08             	mov    0x8(%eax),%eax
	struct device * const i2c_master = drv_data->i2c_master;
  1083f4:	8b 12                	mov    (%edx),%edx
	u16_t i2c_addr = config->i2c_slave_addr;
  1083f6:	88 5d df             	mov    %bl,-0x21(%ebp)
  1083f9:	0f b7 70 04          	movzwl 0x4(%eax),%esi
				  const u8_t *buf,
				  u32_t num_bytes)
{
	struct i2c_msg msg[2];

	msg[0].buf = &start_addr;
  1083fd:	8d 45 df             	lea    -0x21(%ebp),%eax
	msg[0].len = 1U;
	msg[0].flags = I2C_MSG_WRITE;
  108400:	c6 45 e8 00          	movb   $0x0,-0x18(%ebp)

	msg[1].buf = (u8_t *)buf;
	msg[1].len = num_bytes;
	msg[1].flags = I2C_MSG_WRITE | I2C_MSG_STOP;
  108404:	c6 45 f4 02          	movb   $0x2,-0xc(%ebp)
	msg[0].buf = &start_addr;
  108408:	89 45 e0             	mov    %eax,-0x20(%ebp)
	return api->transfer(dev, msgs, num_msgs, addr);
  10840b:	8b 42 04             	mov    0x4(%edx),%eax
  10840e:	56                   	push   %esi
  10840f:	6a 02                	push   $0x2
	msg[1].buf = (u8_t *)buf;
  108411:	89 4d ec             	mov    %ecx,-0x14(%ebp)
	return api->transfer(dev, msgs, num_msgs, addr);
  108414:	8d 4d e0             	lea    -0x20(%ebp),%ecx
	msg[0].len = 1U;
  108417:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
	return api->transfer(dev, msgs, num_msgs, addr);
  10841e:	51                   	push   %ecx
	msg[1].len = num_bytes;
  10841f:	c7 45 f0 02 00 00 00 	movl   $0x2,-0x10(%ebp)
	return api->transfer(dev, msgs, num_msgs, addr);
  108426:	52                   	push   %edx
  108427:	ff 50 04             	call   *0x4(%eax)
  10842a:	83 c4 10             	add    $0x10,%esp
	if (ret) {
  10842d:	85 c0                	test   %eax,%eax
  10842f:	74 37                	je     108468 <write_port_regs+0x86>
		LOG_ERR("PCAL9535A[0x%X]: error writing from register 0x%X "
  108431:	f6 05 04 34 11 00 07 	testb  $0x7,0x113404
  108438:	74 2e                	je     108468 <write_port_regs+0x86>
  10843a:	b9 e0 b9 10 00       	mov    $0x10b9e0,%ecx
  10843f:	89 45 d8             	mov    %eax,-0x28(%ebp)
  108442:	81 e9 e0 b9 10 00    	sub    $0x10b9e0,%ecx
  108448:	c1 e9 03             	shr    $0x3,%ecx
  10844b:	c1 e1 06             	shl    $0x6,%ecx
  10844e:	83 c9 01             	or     $0x1,%ecx
  108451:	51                   	push   %ecx
  108452:	50                   	push   %eax
  108453:	0f b6 db             	movzbl %bl,%ebx
  108456:	53                   	push   %ebx
  108457:	56                   	push   %esi
  108458:	68 5c ee 10 00       	push   $0x10ee5c
  10845d:	e8 10 8e ff ff       	call   101272 <log_3>
  108462:	83 c4 14             	add    $0x14,%esp
  108465:	8b 45 d8             	mov    -0x28(%ebp),%eax
}
  108468:	8d 65 f8             	lea    -0x8(%ebp),%esp
  10846b:	5b                   	pop    %ebx
  10846c:	5e                   	pop    %esi
  10846d:	5d                   	pop    %ebp
  10846e:	c3                   	ret    

0010846f <gpio_pcal9535a_write>:
{
  10846f:	55                   	push   %ebp
  108470:	89 e5                	mov    %esp,%ebp
  108472:	56                   	push   %esi
  108473:	53                   	push   %ebx
  108474:	8b 45 08             	mov    0x8(%ebp),%eax
  108477:	8b 75 0c             	mov    0xc(%ebp),%esi
  10847a:	8b 4d 10             	mov    0x10(%ebp),%ecx
  10847d:	8b 55 14             	mov    0x14(%ebp),%edx
	struct gpio_pcal9535a_drv_data * const drv_data =
  108480:	8b 58 08             	mov    0x8(%eax),%ebx
	if (i2c_master)
  108483:	83 3b 00             	cmpl   $0x0,(%ebx)
  108486:	74 49                	je     1084d1 <gpio_pcal9535a_write+0x62>
	switch (access_op) {
  108488:	85 f6                	test   %esi,%esi
  10848a:	74 0a                	je     108496 <gpio_pcal9535a_write+0x27>
  10848c:	4e                   	dec    %esi
  10848d:	74 1f                	je     1084ae <gpio_pcal9535a_write+0x3f>
		ret = -ENOTSUP;
  10848f:	b8 dd ff ff ff       	mov    $0xffffffdd,%eax
  108494:	eb 40                	jmp    1084d6 <gpio_pcal9535a_write+0x67>
		new_value = (value << pin) & bit_mask;
  108496:	d3 e2                	shl    %cl,%edx
		bit_mask = BIT(pin);
  108498:	be 01 00 00 00       	mov    $0x1,%esi
		new_value ^= (drv_data->out_pol_inv & bit_mask);
  10849d:	33 53 04             	xor    0x4(%ebx),%edx
		bit_mask = BIT(pin);
  1084a0:	d3 e6                	shl    %cl,%esi
		new_value ^= (drv_data->out_pol_inv & bit_mask);
  1084a2:	21 f2                	and    %esi,%edx
		port->all &= ~bit_mask;
  1084a4:	f7 d6                	not    %esi
  1084a6:	66 23 73 08          	and    0x8(%ebx),%si
		port->all |= new_value;
  1084aa:	09 f2                	or     %esi,%edx
  1084ac:	eb 0f                	jmp    1084bd <gpio_pcal9535a_write+0x4e>
		bit_mask = drv_data->out_pol_inv;
  1084ae:	8b 73 04             	mov    0x4(%ebx),%esi
		port->all &= ~bit_mask;
  1084b1:	89 f1                	mov    %esi,%ecx
  1084b3:	f7 d1                	not    %ecx
  1084b5:	21 d1                	and    %edx,%ecx
		new_value ^= drv_data->out_pol_inv;
  1084b7:	f7 d2                	not    %edx
  1084b9:	21 f2                	and    %esi,%edx
		port->all |= new_value;
  1084bb:	09 ca                	or     %ecx,%edx
  1084bd:	66 89 53 08          	mov    %dx,0x8(%ebx)
	union gpio_pcal9535a_port_data *port = &drv_data->reg_cache.output;
  1084c1:	8d 4b 08             	lea    0x8(%ebx),%ecx
}
  1084c4:	5b                   	pop    %ebx
	ret = write_port_regs(dev, REG_OUTPUT_PORT0, port);
  1084c5:	ba 02 00 00 00       	mov    $0x2,%edx
}
  1084ca:	5e                   	pop    %esi
  1084cb:	5d                   	pop    %ebp
	ret = write_port_regs(dev, REG_OUTPUT_PORT0, port);
  1084cc:	e9 11 ff ff ff       	jmp    1083e2 <write_port_regs>
		return -EINVAL;
  1084d1:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
}
  1084d6:	5b                   	pop    %ebx
  1084d7:	5e                   	pop    %esi
  1084d8:	5d                   	pop    %ebp
  1084d9:	c3                   	ret    

001084da <gpio_pcal9535a_config>:
{
  1084da:	55                   	push   %ebp
		return -ENOTSUP;
  1084db:	b8 dd ff ff ff       	mov    $0xffffffdd,%eax
{
  1084e0:	89 e5                	mov    %esp,%ebp
  1084e2:	57                   	push   %edi
  1084e3:	56                   	push   %esi
  1084e4:	53                   	push   %ebx
  1084e5:	83 ec 08             	sub    $0x8,%esp
  1084e8:	8b 7d 14             	mov    0x14(%ebp),%edi
	if (flags & GPIO_INT) {
  1084eb:	f7 c7 02 00 00 00    	test   $0x2,%edi
  1084f1:	0f 85 68 02 00 00    	jne    10875f <gpio_pcal9535a_config+0x285>
	if (!has_i2c_master(dev)) {
  1084f7:	8b 45 08             	mov    0x8(%ebp),%eax
  1084fa:	8b 50 08             	mov    0x8(%eax),%edx
		return -EINVAL;
  1084fd:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
	if (i2c_master)
  108502:	83 3a 00             	cmpl   $0x0,(%edx)
  108505:	0f 84 54 02 00 00    	je     10875f <gpio_pcal9535a_config+0x285>
	const struct gpio_pcal9535a_config * const config =
  10850b:	8b 45 08             	mov    0x8(%ebp),%eax
	switch (access_op) {
  10850e:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
	const struct gpio_pcal9535a_config * const config =
  108512:	8b 00                	mov    (%eax),%eax
	u16_t i2c_addr = config->i2c_slave_addr;
  108514:	8b 40 08             	mov    0x8(%eax),%eax
  108517:	8b 40 04             	mov    0x4(%eax),%eax
  10851a:	66 89 45 f2          	mov    %ax,-0xe(%ebp)
	switch (access_op) {
  10851e:	74 0d                	je     10852d <gpio_pcal9535a_config+0x53>
		ret = -ENOTSUP;
  108520:	b8 dd ff ff ff       	mov    $0xffffffdd,%eax
	switch (access_op) {
  108525:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
  108529:	75 50                	jne    10857b <gpio_pcal9535a_config+0xa1>
  10852b:	eb 24                	jmp    108551 <gpio_pcal9535a_config+0x77>
		bit_mask = 1 << pin;
  10852d:	8a 4d 10             	mov    0x10(%ebp),%cl
  108530:	b8 01 00 00 00       	mov    $0x1,%eax
  108535:	d3 e0                	shl    %cl,%eax
		if ((flags & GPIO_DIR_MASK) == GPIO_DIR_IN) {
  108537:	89 c1                	mov    %eax,%ecx
  108539:	f7 c7 01 00 00 00    	test   $0x1,%edi
  10853f:	74 02                	je     108543 <gpio_pcal9535a_config+0x69>
  108541:	31 c9                	xor    %ecx,%ecx
		port->all &= ~bit_mask;
  108543:	f7 d0                	not    %eax
  108545:	66 23 42 0c          	and    0xc(%edx),%ax
		port->all |= new_value;
  108549:	09 c8                	or     %ecx,%eax
  10854b:	66 89 42 0c          	mov    %ax,0xc(%edx)
		break;
  10854f:	eb 16                	jmp    108567 <gpio_pcal9535a_config+0x8d>
		if ((flags & GPIO_DIR_MASK) == GPIO_DIR_IN) {
  108551:	f7 c7 01 00 00 00    	test   $0x1,%edi
  108557:	75 08                	jne    108561 <gpio_pcal9535a_config+0x87>
			port->all = 0xFFFF;
  108559:	66 c7 42 0c ff ff    	movw   $0xffff,0xc(%edx)
  10855f:	eb 06                	jmp    108567 <gpio_pcal9535a_config+0x8d>
			port->all = 0x0;
  108561:	66 c7 42 0c 00 00    	movw   $0x0,0xc(%edx)
	union gpio_pcal9535a_port_data *port = &drv_data->reg_cache.dir;
  108567:	8d 4a 0c             	lea    0xc(%edx),%ecx
	ret = write_port_regs(dev, REG_CONF_PORT0, port);
  10856a:	8b 45 08             	mov    0x8(%ebp),%eax
  10856d:	ba 06 00 00 00       	mov    $0x6,%edx
  108572:	e8 6b fe ff ff       	call   1083e2 <write_port_regs>
	if (ret) {
  108577:	85 c0                	test   %eax,%eax
  108579:	74 35                	je     1085b0 <gpio_pcal9535a_config+0xd6>
		LOG_ERR("PCAL9535A[0x%X]: error setting pin direction (%d)",
  10857b:	f6 05 04 34 11 00 07 	testb  $0x7,0x113404
  108582:	0f 84 d7 01 00 00    	je     10875f <gpio_pcal9535a_config+0x285>
  108588:	ba e0 b9 10 00       	mov    $0x10b9e0,%edx
  10858d:	89 45 ec             	mov    %eax,-0x14(%ebp)
  108590:	81 ea e0 b9 10 00    	sub    $0x10b9e0,%edx
  108596:	c1 ea 03             	shr    $0x3,%edx
  108599:	c1 e2 06             	shl    $0x6,%edx
  10859c:	83 ca 01             	or     $0x1,%edx
  10859f:	52                   	push   %edx
  1085a0:	0f b7 55 f2          	movzwl -0xe(%ebp),%edx
  1085a4:	50                   	push   %eax
  1085a5:	52                   	push   %edx
  1085a6:	68 93 ee 10 00       	push   $0x10ee93
  1085ab:	e9 a4 01 00 00       	jmp    108754 <gpio_pcal9535a_config+0x27a>
	struct gpio_pcal9535a_drv_data * const drv_data =
  1085b0:	8b 45 08             	mov    0x8(%ebp),%eax
	switch (access_op) {
  1085b3:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
	struct gpio_pcal9535a_drv_data * const drv_data =
  1085b7:	8b 58 08             	mov    0x8(%eax),%ebx
	switch (access_op) {
  1085ba:	74 0d                	je     1085c9 <gpio_pcal9535a_config+0xef>
		ret = -ENOTSUP;
  1085bc:	b8 dd ff ff ff       	mov    $0xffffffdd,%eax
	switch (access_op) {
  1085c1:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
  1085c5:	75 6c                	jne    108633 <gpio_pcal9535a_config+0x159>
  1085c7:	eb 24                	jmp    1085ed <gpio_pcal9535a_config+0x113>
		bit_mask = BIT(pin);
  1085c9:	b8 01 00 00 00       	mov    $0x1,%eax
  1085ce:	8a 4d 10             	mov    0x10(%ebp),%cl
  1085d1:	d3 e0                	shl    %cl,%eax
		if ((flags & GPIO_POL_MASK) == GPIO_POL_INV) {
  1085d3:	89 c2                	mov    %eax,%edx
  1085d5:	f7 c7 80 00 00 00    	test   $0x80,%edi
  1085db:	75 02                	jne    1085df <gpio_pcal9535a_config+0x105>
  1085dd:	31 d2                	xor    %edx,%edx
		port->all &= ~bit_mask;
  1085df:	f7 d0                	not    %eax
  1085e1:	66 23 43 0a          	and    0xa(%ebx),%ax
		port->all |= new_value;
  1085e5:	09 d0                	or     %edx,%eax
  1085e7:	66 89 43 0a          	mov    %ax,0xa(%ebx)
		break;
  1085eb:	eb 16                	jmp    108603 <gpio_pcal9535a_config+0x129>
		if ((flags & GPIO_POL_MASK) == GPIO_POL_INV) {
  1085ed:	f7 c7 80 00 00 00    	test   $0x80,%edi
  1085f3:	74 08                	je     1085fd <gpio_pcal9535a_config+0x123>
			port->all = 0xFFFF;
  1085f5:	66 c7 43 0a ff ff    	movw   $0xffff,0xa(%ebx)
  1085fb:	eb 06                	jmp    108603 <gpio_pcal9535a_config+0x129>
			port->all = 0x0;
  1085fd:	66 c7 43 0a 00 00    	movw   $0x0,0xa(%ebx)
	union gpio_pcal9535a_port_data *port = &drv_data->reg_cache.pol_inv;
  108603:	8d 4b 0a             	lea    0xa(%ebx),%ecx
	ret = write_port_regs(dev, REG_POL_INV_PORT0, port);
  108606:	ba 04 00 00 00       	mov    $0x4,%edx
  10860b:	8b 45 08             	mov    0x8(%ebp),%eax
  10860e:	e8 cf fd ff ff       	call   1083e2 <write_port_regs>
	if (!ret) {
  108613:	85 c0                	test   %eax,%eax
  108615:	75 1c                	jne    108633 <gpio_pcal9535a_config+0x159>
		drv_data->out_pol_inv = port->all;
  108617:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  10861b:	89 43 04             	mov    %eax,0x4(%ebx)
	struct gpio_pcal9535a_drv_data * const drv_data =
  10861e:	8b 45 08             	mov    0x8(%ebp),%eax
	if ((flags & GPIO_PUD_MASK) == GPIO_PUD_NORMAL) {
  108621:	89 fb                	mov    %edi,%ebx
  108623:	81 e3 00 03 00 00    	and    $0x300,%ebx
	struct gpio_pcal9535a_drv_data * const drv_data =
  108629:	8b 70 08             	mov    0x8(%eax),%esi
	if ((flags & GPIO_PUD_MASK) == GPIO_PUD_NORMAL) {
  10862c:	75 3a                	jne    108668 <gpio_pcal9535a_config+0x18e>
  10862e:	e9 9f 00 00 00       	jmp    1086d2 <gpio_pcal9535a_config+0x1f8>
		LOG_ERR("PCAL9535A[0x%X]: error setting pin polarity (%d)",
  108633:	f6 05 04 34 11 00 07 	testb  $0x7,0x113404
  10863a:	0f 84 1f 01 00 00    	je     10875f <gpio_pcal9535a_config+0x285>
  108640:	ba e0 b9 10 00       	mov    $0x10b9e0,%edx
  108645:	89 45 ec             	mov    %eax,-0x14(%ebp)
  108648:	81 ea e0 b9 10 00    	sub    $0x10b9e0,%edx
  10864e:	c1 ea 03             	shr    $0x3,%edx
  108651:	c1 e2 06             	shl    $0x6,%edx
  108654:	83 ca 01             	or     $0x1,%edx
  108657:	52                   	push   %edx
  108658:	0f b7 55 f2          	movzwl -0xe(%ebp),%edx
  10865c:	50                   	push   %eax
  10865d:	52                   	push   %edx
  10865e:	68 c5 ee 10 00       	push   $0x10eec5
  108663:	e9 ec 00 00 00       	jmp    108754 <gpio_pcal9535a_config+0x27a>
	switch (access_op) {
  108668:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  10866c:	74 10                	je     10867e <gpio_pcal9535a_config+0x1a4>
  10866e:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
  108672:	74 30                	je     1086a4 <gpio_pcal9535a_config+0x1ca>
		ret = -ENOTSUP;
  108674:	b8 dd ff ff ff       	mov    $0xffffffdd,%eax
  108679:	e9 aa 00 00 00       	jmp    108728 <gpio_pcal9535a_config+0x24e>
		bit_mask = 1 << pin;
  10867e:	b8 01 00 00 00       	mov    $0x1,%eax
  108683:	8a 4d 10             	mov    0x10(%ebp),%cl
  108686:	d3 e0                	shl    %cl,%eax
		if ((flags & GPIO_PUD_MASK) == GPIO_PUD_PULL_UP) {
  108688:	89 c2                	mov    %eax,%edx
  10868a:	81 fb 00 01 00 00    	cmp    $0x100,%ebx
  108690:	74 02                	je     108694 <gpio_pcal9535a_config+0x1ba>
  108692:	31 d2                	xor    %edx,%edx
		port->all &= ~bit_mask;
  108694:	f7 d0                	not    %eax
  108696:	66 23 46 10          	and    0x10(%esi),%ax
  10869a:	89 d7                	mov    %edx,%edi
		port->all |= new_value;
  10869c:	09 d0                	or     %edx,%eax
  10869e:	66 89 46 10          	mov    %ax,0x10(%esi)
		break;
  1086a2:	eb 18                	jmp    1086bc <gpio_pcal9535a_config+0x1e2>
		if ((flags & GPIO_PUD_MASK) == GPIO_PUD_PULL_UP) {
  1086a4:	81 fb 00 01 00 00    	cmp    $0x100,%ebx
  1086aa:	75 08                	jne    1086b4 <gpio_pcal9535a_config+0x1da>
			port->all = 0xFFFF;
  1086ac:	66 c7 46 10 ff ff    	movw   $0xffff,0x10(%esi)
  1086b2:	eb 06                	jmp    1086ba <gpio_pcal9535a_config+0x1e0>
			port->all = 0x0;
  1086b4:	66 c7 46 10 00 00    	movw   $0x0,0x10(%esi)
	u16_t new_value = 0U;
  1086ba:	31 ff                	xor    %edi,%edi
	port = &drv_data->reg_cache.pud_sel;
  1086bc:	8d 4e 10             	lea    0x10(%esi),%ecx
	ret = write_port_regs(dev, REG_PUD_SEL_PORT0, port);
  1086bf:	ba 48 00 00 00       	mov    $0x48,%edx
  1086c4:	8b 45 08             	mov    0x8(%ebp),%eax
  1086c7:	e8 16 fd ff ff       	call   1083e2 <write_port_regs>
	if (ret) {
  1086cc:	85 c0                	test   %eax,%eax
  1086ce:	74 04                	je     1086d4 <gpio_pcal9535a_config+0x1fa>
  1086d0:	eb 56                	jmp    108728 <gpio_pcal9535a_config+0x24e>
	u16_t new_value = 0U;
  1086d2:	31 ff                	xor    %edi,%edi
	port = &drv_data->reg_cache.pud_en;
  1086d4:	8d 56 0e             	lea    0xe(%esi),%edx
	switch (access_op) {
  1086d7:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  1086db:	74 08                	je     1086e5 <gpio_pcal9535a_config+0x20b>
  1086dd:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
  1086e1:	74 20                	je     108703 <gpio_pcal9535a_config+0x229>
  1086e3:	eb 8f                	jmp    108674 <gpio_pcal9535a_config+0x19a>
		bit_mask = 1 << pin;
  1086e5:	b8 01 00 00 00       	mov    $0x1,%eax
  1086ea:	8a 4d 10             	mov    0x10(%ebp),%cl
  1086ed:	d3 e0                	shl    %cl,%eax
		if ((flags & GPIO_PUD_MASK) != GPIO_PUD_NORMAL) {
  1086ef:	85 db                	test   %ebx,%ebx
  1086f1:	74 02                	je     1086f5 <gpio_pcal9535a_config+0x21b>
		bit_mask = 1 << pin;
  1086f3:	89 c7                	mov    %eax,%edi
		port->all &= ~bit_mask;
  1086f5:	f7 d0                	not    %eax
  1086f7:	66 23 46 0e          	and    0xe(%esi),%ax
		port->all |= new_value;
  1086fb:	09 c7                	or     %eax,%edi
  1086fd:	66 89 7e 0e          	mov    %di,0xe(%esi)
		break;
  108701:	eb 12                	jmp    108715 <gpio_pcal9535a_config+0x23b>
		if ((flags & GPIO_PUD_MASK) != GPIO_PUD_NORMAL) {
  108703:	85 db                	test   %ebx,%ebx
  108705:	74 08                	je     10870f <gpio_pcal9535a_config+0x235>
			port->all = 0xFFFF;
  108707:	66 c7 46 0e ff ff    	movw   $0xffff,0xe(%esi)
  10870d:	eb 06                	jmp    108715 <gpio_pcal9535a_config+0x23b>
			port->all = 0x0;
  10870f:	66 c7 46 0e 00 00    	movw   $0x0,0xe(%esi)
	ret = write_port_regs(dev, REG_PUD_EN_PORT0, port);
  108715:	89 d1                	mov    %edx,%ecx
  108717:	8b 45 08             	mov    0x8(%ebp),%eax
  10871a:	ba 46 00 00 00       	mov    $0x46,%edx
  10871f:	e8 be fc ff ff       	call   1083e2 <write_port_regs>
	if (ret) {
  108724:	85 c0                	test   %eax,%eax
  108726:	74 37                	je     10875f <gpio_pcal9535a_config+0x285>
		LOG_ERR("PCAL9535A[0x%X]: error setting pin pull up/down "
  108728:	f6 05 04 34 11 00 07 	testb  $0x7,0x113404
  10872f:	74 2e                	je     10875f <gpio_pcal9535a_config+0x285>
  108731:	ba e0 b9 10 00       	mov    $0x10b9e0,%edx
  108736:	89 45 ec             	mov    %eax,-0x14(%ebp)
  108739:	81 ea e0 b9 10 00    	sub    $0x10b9e0,%edx
  10873f:	c1 ea 03             	shr    $0x3,%edx
  108742:	c1 e2 06             	shl    $0x6,%edx
  108745:	83 ca 01             	or     $0x1,%edx
  108748:	52                   	push   %edx
  108749:	0f b7 55 f2          	movzwl -0xe(%ebp),%edx
  10874d:	50                   	push   %eax
  10874e:	52                   	push   %edx
  10874f:	68 f6 ee 10 00       	push   $0x10eef6
  108754:	e8 d2 8a ff ff       	call   10122b <log_2>
  108759:	83 c4 10             	add    $0x10,%esp
  10875c:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
  10875f:	8d 65 f4             	lea    -0xc(%ebp),%esp
  108762:	5b                   	pop    %ebx
  108763:	5e                   	pop    %esi
  108764:	5f                   	pop    %edi
  108765:	5d                   	pop    %ebp
  108766:	c3                   	ret    

00108767 <gpio_sch_read>:
	return 0;
}

static int gpio_sch_read(struct device *dev,
			 int access_op, u32_t pin, u32_t *value)
{
  108767:	55                   	push   %ebp
  108768:	89 e5                	mov    %esp,%ebp
  10876a:	57                   	push   %edi
  10876b:	56                   	push   %esi
	const struct gpio_sch_config *info = dev->config->config_info;
  10876c:	8b 45 08             	mov    0x8(%ebp),%eax
{
  10876f:	53                   	push   %ebx
  108770:	8b 4d 10             	mov    0x10(%ebp),%ecx
  108773:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	const struct gpio_sch_config *info = dev->config->config_info;
  108776:	8b 00                	mov    (%eax),%eax
{
  108778:	8b 75 14             	mov    0x14(%ebp),%esi
	const struct gpio_sch_config *info = dev->config->config_info;
  10877b:	8b 78 08             	mov    0x8(%eax),%edi
DEFINE_MM_REG_READ(glvl, GPIO_SCH_REG_GLVL)
  10877e:	8b 07                	mov    (%edi),%eax
  108780:	8d 50 08             	lea    0x8(%eax),%edx
	__asm__ volatile("inl	%w1, %0;\n\t"
  108783:	ed                   	in     (%dx),%eax

	*value = z_read_glvl(info->regs);
  108784:	89 06                	mov    %eax,(%esi)

	if (access_op == GPIO_ACCESS_BY_PIN) {
  108786:	85 db                	test   %ebx,%ebx
  108788:	75 11                	jne    10879b <gpio_sch_read+0x34>
		if (pin >= info->bits) {
  10878a:	0f b6 57 04          	movzbl 0x4(%edi),%edx
  10878e:	39 ca                	cmp    %ecx,%edx
  108790:	76 0d                	jbe    10879f <gpio_sch_read+0x38>
			return -ENOTSUP;
		}

		*value = !!(*value & BIT(pin));
  108792:	d3 e8                	shr    %cl,%eax
  108794:	83 e0 01             	and    $0x1,%eax
  108797:	89 06                	mov    %eax,(%esi)
  108799:	eb 09                	jmp    1087a4 <gpio_sch_read+0x3d>
	}

	return 0;
  10879b:	31 db                	xor    %ebx,%ebx
  10879d:	eb 05                	jmp    1087a4 <gpio_sch_read+0x3d>
			return -ENOTSUP;
  10879f:	bb dd ff ff ff       	mov    $0xffffffdd,%ebx
}
  1087a4:	89 d8                	mov    %ebx,%eax
  1087a6:	5b                   	pop    %ebx
  1087a7:	5e                   	pop    %esi
  1087a8:	5f                   	pop    %edi
  1087a9:	5d                   	pop    %ebp
  1087aa:	c3                   	ret    

001087ab <gpio_sch_init>:
	.enable_callback = gpio_sch_enable_callback,
	.disable_callback = gpio_sch_disable_callback,
};

static int gpio_sch_init(struct device *dev)
{
  1087ab:	55                   	push   %ebp
  1087ac:	89 e5                	mov    %esp,%ebp
	struct gpio_sch_data *gpio = dev->driver_data;

	k_timer_init(&gpio->poll_timer, NULL, NULL);
  1087ae:	6a 00                	push   $0x0
  1087b0:	6a 00                	push   $0x0
  1087b2:	8b 45 08             	mov    0x8(%ebp),%eax
  1087b5:	8b 40 08             	mov    0x8(%eax),%eax
  1087b8:	05 78 04 00 00       	add    $0x478,%eax
  1087bd:	50                   	push   %eax
  1087be:	e8 25 2b 00 00       	call   10b2e8 <k_timer_init>
  1087c3:	83 c4 0c             	add    $0xc,%esp

	LOG_DBG("SCH GPIO Intel Driver initialized on device: %p", dev);

	return 0;
}
  1087c6:	31 c0                	xor    %eax,%eax
  1087c8:	c9                   	leave  
  1087c9:	c3                   	ret    

001087ca <set_bit>:
{
  1087ca:	55                   	push   %ebp
  1087cb:	89 e5                	mov    %esp,%ebp
  1087cd:	56                   	push   %esi
  1087ce:	53                   	push   %ebx
  1087cf:	89 c3                	mov    %eax,%ebx
  1087d1:	89 d6                	mov    %edx,%esi
	__asm__ volatile("inl	%w1, %0;\n\t"
  1087d3:	31 c0                	xor    %eax,%eax
  1087d5:	89 da                	mov    %ebx,%edx
	if (!set) {
  1087d7:	84 c9                	test   %cl,%cl
  1087d9:	75 07                	jne    1087e2 <set_bit+0x18>
  1087db:	ed                   	in     (%dx),%eax
  1087dc:	0f b3 f0             	btr    %esi,%eax
  1087df:	ef                   	out    %eax,(%dx)
  1087e0:	eb 05                	jmp    1087e7 <set_bit+0x1d>
	__asm__ volatile("inl	%w1, %0;\n\t"
  1087e2:	ed                   	in     (%dx),%eax
  1087e3:	0f ab f0             	bts    %esi,%eax
  1087e6:	ef                   	out    %eax,(%dx)
}
  1087e7:	5b                   	pop    %ebx
  1087e8:	5e                   	pop    %esi
  1087e9:	5d                   	pop    %ebp
  1087ea:	c3                   	ret    

001087eb <gpio_sch_write>:
{
  1087eb:	55                   	push   %ebp
  1087ec:	89 e5                	mov    %esp,%ebp
  1087ee:	56                   	push   %esi
  1087ef:	53                   	push   %ebx
	const struct gpio_sch_config *info = dev->config->config_info;
  1087f0:	8b 45 08             	mov    0x8(%ebp),%eax
{
  1087f3:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  1087f6:	8b 55 10             	mov    0x10(%ebp),%edx
  1087f9:	8b 4d 14             	mov    0x14(%ebp),%ecx
	const struct gpio_sch_config *info = dev->config->config_info;
  1087fc:	8b 00                	mov    (%eax),%eax
	if (access_op == GPIO_ACCESS_BY_PIN) {
  1087fe:	85 db                	test   %ebx,%ebx
	const struct gpio_sch_config *info = dev->config->config_info;
  108800:	8b 40 08             	mov    0x8(%eax),%eax
	if (access_op == GPIO_ACCESS_BY_PIN) {
  108803:	75 17                	jne    10881c <gpio_sch_write+0x31>
		if (pin >= info->bits) {
  108805:	0f b6 70 04          	movzbl 0x4(%eax),%esi
  108809:	39 d6                	cmp    %edx,%esi
  10880b:	76 19                	jbe    108826 <gpio_sch_write+0x3b>
DEFINE_MM_REG_SET_BIT(glvl, GPIO_SCH_REG_GLVL)
  10880d:	8b 00                	mov    (%eax),%eax
		z_set_bit_glvl(info->regs, pin, value);
  10880f:	0f b6 c9             	movzbl %cl,%ecx
DEFINE_MM_REG_SET_BIT(glvl, GPIO_SCH_REG_GLVL)
  108812:	83 c0 08             	add    $0x8,%eax
  108815:	e8 b0 ff ff ff       	call   1087ca <set_bit>
  10881a:	eb 0f                	jmp    10882b <gpio_sch_write+0x40>
	__asm__ volatile("outl	%0, %w1;\n\t"
  10881c:	8b 00                	mov    (%eax),%eax
DEFINE_MM_REG_WRITE(glvl, GPIO_SCH_REG_GLVL)
  10881e:	8d 51 08             	lea    0x8(%ecx),%edx
  108821:	ef                   	out    %eax,(%dx)
	return 0;
  108822:	31 db                	xor    %ebx,%ebx
  108824:	eb 05                	jmp    10882b <gpio_sch_write+0x40>
			return -ENOTSUP;
  108826:	bb dd ff ff ff       	mov    $0xffffffdd,%ebx
}
  10882b:	89 d8                	mov    %ebx,%eax
  10882d:	5b                   	pop    %ebx
  10882e:	5e                   	pop    %esi
  10882f:	5d                   	pop    %ebp
  108830:	c3                   	ret    

00108831 <_gpio_sch_manage_callback>:
	struct gpio_sch_data *gpio = dev->driver_data;
  108831:	8b 50 08             	mov    0x8(%eax),%edx
	if (!sys_slist_is_empty(&gpio->callbacks) && gpio->cb_enabled) {
  108834:	83 ba 70 04 00 00 00 	cmpl   $0x0,0x470(%edx)
  10883b:	74 43                	je     108880 <_gpio_sch_manage_callback+0x4f>
  10883d:	83 ba ac 04 00 00 00 	cmpl   $0x0,0x4ac(%edx)
  108844:	74 3a                	je     108880 <_gpio_sch_manage_callback+0x4f>
		if (!gpio->poll) {
  108846:	80 ba b0 04 00 00 00 	cmpb   $0x0,0x4b0(%edx)
  10884d:	75 39                	jne    108888 <_gpio_sch_manage_callback+0x57>
{
  10884f:	55                   	push   %ebp
			gpio->poll = 1U;
  108850:	c6 82 b0 04 00 00 01 	movb   $0x1,0x4b0(%edx)
{
  108857:	89 e5                	mov    %esp,%ebp
K_SYSCALL_DECLARE10(K_SYSCALL_K_THREAD_CREATE, k_thread_create, k_tid_t, struct k_thread *, new_thread, k_thread_stack_t *, stack, size_t, stack_size, k_thread_entry_t, entry, void *, p1, void *, p2, void *, p3, int, prio, u32_t, options, s32_t, delay)
  108859:	6a 00                	push   $0x0
  10885b:	6a 00                	push   $0x0
  10885d:	6a f1                	push   $0xfffffff1
  10885f:	6a 00                	push   $0x0
  108861:	6a 00                	push   $0x0
  108863:	50                   	push   %eax
  108864:	68 d1 89 10 00       	push   $0x1089d1
  108869:	68 00 04 00 00       	push   $0x400
  10886e:	52                   	push   %edx
			k_thread_create(&gpio->polling_thread,
  10886f:	81 c2 00 04 00 00    	add    $0x400,%edx
  108875:	52                   	push   %edx
  108876:	e8 97 25 00 00       	call   10ae12 <z_impl_k_thread_create>
  10887b:	83 c4 28             	add    $0x28,%esp
}
  10887e:	c9                   	leave  
  10887f:	c3                   	ret    
		gpio->poll = 0U;
  108880:	c6 82 b0 04 00 00 00 	movb   $0x0,0x4b0(%edx)
}
  108887:	c3                   	ret    
  108888:	c3                   	ret    

00108889 <gpio_sch_enable_callback>:
{
  108889:	55                   	push   %ebp
  10888a:	89 e5                	mov    %esp,%ebp
  10888c:	57                   	push   %edi
  10888d:	56                   	push   %esi
  10888e:	53                   	push   %ebx
  10888f:	51                   	push   %ecx
	const struct gpio_sch_config *info = dev->config->config_info;
  108890:	8b 45 08             	mov    0x8(%ebp),%eax
	if (access_op == GPIO_ACCESS_BY_PIN) {
  108893:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
	const struct gpio_sch_config *info = dev->config->config_info;
  108897:	8b 00                	mov    (%eax),%eax
  108899:	8b 78 08             	mov    0x8(%eax),%edi
	struct gpio_sch_data *gpio = dev->driver_data;
  10889c:	8b 45 08             	mov    0x8(%ebp),%eax
  10889f:	8b 58 08             	mov    0x8(%eax),%ebx
	if (access_op == GPIO_ACCESS_BY_PIN) {
  1088a2:	8a 47 04             	mov    0x4(%edi),%al
  1088a5:	88 45 f3             	mov    %al,-0xd(%ebp)
  1088a8:	75 4f                	jne    1088f9 <gpio_sch_enable_callback+0x70>
		if (pin >= info->bits) {
  1088aa:	0f b6 d0             	movzbl %al,%edx
		u32_t bits = BIT(pin);
  1088ad:	be 01 00 00 00       	mov    $0x1,%esi
  1088b2:	8a 4d 10             	mov    0x10(%ebp),%cl
  1088b5:	d3 e6                	shl    %cl,%esi
			return -ENOTSUP;
  1088b7:	b8 dd ff ff ff       	mov    $0xffffffdd,%eax
		if (pin >= info->bits) {
  1088bc:	3b 55 10             	cmp    0x10(%ebp),%edx
  1088bf:	76 69                	jbe    10892a <gpio_sch_enable_callback+0xa1>
		z_set_bit_gtpe(info->regs, pin, !!(bits & gpio->int_regs.gtpe));
  1088c1:	31 c9                	xor    %ecx,%ecx
DEFINE_MM_REG_SET_BIT(gtpe, GPIO_SCH_REG_GTPE)
  1088c3:	8b 07                	mov    (%edi),%eax
		z_set_bit_gtpe(info->regs, pin, !!(bits & gpio->int_regs.gtpe));
  1088c5:	85 b3 a4 04 00 00    	test   %esi,0x4a4(%ebx)
DEFINE_MM_REG_SET_BIT(gtpe, GPIO_SCH_REG_GTPE)
  1088cb:	8b 55 10             	mov    0x10(%ebp),%edx
		z_set_bit_gtpe(info->regs, pin, !!(bits & gpio->int_regs.gtpe));
  1088ce:	0f 95 c1             	setne  %cl
DEFINE_MM_REG_SET_BIT(gtpe, GPIO_SCH_REG_GTPE)
  1088d1:	83 c0 0c             	add    $0xc,%eax
  1088d4:	e8 f1 fe ff ff       	call   1087ca <set_bit>
		z_set_bit_gtne(info->regs, pin, !!(bits & gpio->int_regs.gtne));
  1088d9:	31 c9                	xor    %ecx,%ecx
DEFINE_MM_REG_SET_BIT(gtne, GPIO_SCH_REG_GTNE)
  1088db:	8b 07                	mov    (%edi),%eax
		z_set_bit_gtne(info->regs, pin, !!(bits & gpio->int_regs.gtne));
  1088dd:	85 b3 a8 04 00 00    	test   %esi,0x4a8(%ebx)
DEFINE_MM_REG_SET_BIT(gtne, GPIO_SCH_REG_GTNE)
  1088e3:	8b 55 10             	mov    0x10(%ebp),%edx
		z_set_bit_gtne(info->regs, pin, !!(bits & gpio->int_regs.gtne));
  1088e6:	0f 95 c1             	setne  %cl
DEFINE_MM_REG_SET_BIT(gtne, GPIO_SCH_REG_GTNE)
  1088e9:	83 c0 10             	add    $0x10,%eax
  1088ec:	e8 d9 fe ff ff       	call   1087ca <set_bit>
		gpio->cb_enabled |= bits;
  1088f1:	09 b3 ac 04 00 00    	or     %esi,0x4ac(%ebx)
  1088f7:	eb 27                	jmp    108920 <gpio_sch_enable_callback+0x97>
		z_write_gtpe(gpio->int_regs.gtpe, info->regs);
  1088f9:	8b 0f                	mov    (%edi),%ecx
  1088fb:	8b 83 a4 04 00 00    	mov    0x4a4(%ebx),%eax
DEFINE_MM_REG_WRITE(gtpe, GPIO_SCH_REG_GTPE)
  108901:	8d 51 0c             	lea    0xc(%ecx),%edx
  108904:	ef                   	out    %eax,(%dx)
  108905:	8b 83 a8 04 00 00    	mov    0x4a8(%ebx),%eax
DEFINE_MM_REG_WRITE(gtne, GPIO_SCH_REG_GTNE)
  10890b:	8d 51 10             	lea    0x10(%ecx),%edx
  10890e:	ef                   	out    %eax,(%dx)
		gpio->cb_enabled = BIT_MASK(info->bits);
  10890f:	b8 01 00 00 00       	mov    $0x1,%eax
  108914:	8a 4d f3             	mov    -0xd(%ebp),%cl
  108917:	d3 e0                	shl    %cl,%eax
  108919:	48                   	dec    %eax
  10891a:	89 83 ac 04 00 00    	mov    %eax,0x4ac(%ebx)
	_gpio_sch_manage_callback(dev);
  108920:	8b 45 08             	mov    0x8(%ebp),%eax
  108923:	e8 09 ff ff ff       	call   108831 <_gpio_sch_manage_callback>
	return 0;
  108928:	31 c0                	xor    %eax,%eax
}
  10892a:	5a                   	pop    %edx
  10892b:	5b                   	pop    %ebx
  10892c:	5e                   	pop    %esi
  10892d:	5f                   	pop    %edi
  10892e:	5d                   	pop    %ebp
  10892f:	c3                   	ret    

00108930 <gpio_sch_manage_callback>:
{
  108930:	55                   	push   %ebp
  108931:	89 e5                	mov    %esp,%ebp
  108933:	57                   	push   %edi
  108934:	56                   	push   %esi
	struct gpio_sch_data *gpio = dev->driver_data;
  108935:	8b 45 08             	mov    0x8(%ebp),%eax
{
  108938:	53                   	push   %ebx
  108939:	8b 4d 0c             	mov    0xc(%ebp),%ecx
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
  10893c:	31 db                	xor    %ebx,%ebx
	struct gpio_sch_data *gpio = dev->driver_data;
  10893e:	8b 50 08             	mov    0x8(%eax),%edx
{
  108941:	8b 75 10             	mov    0x10(%ebp),%esi
Z_GENLIST_IS_EMPTY(slist)
  108944:	8b 82 70 04 00 00    	mov    0x470(%edx),%eax
	if (!sys_slist_is_empty(callbacks)) {
  10894a:	85 c0                	test   %eax,%eax
  10894c:	74 6e                	je     1089bc <gpio_sch_manage_callback+0x8c>
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
  10894e:	39 c1                	cmp    %eax,%ecx
  108950:	75 34                	jne    108986 <gpio_sch_manage_callback+0x56>
Z_GENLIST_REMOVE(slist, snode)
  108952:	8b 01                	mov    (%ecx),%eax
  108954:	85 db                	test   %ebx,%ebx
  108956:	75 16                	jne    10896e <gpio_sch_manage_callback+0x3e>
	list->head = node;
  108958:	89 82 70 04 00 00    	mov    %eax,0x470(%edx)
Z_GENLIST_REMOVE(slist, snode)
  10895e:	3b 8a 74 04 00 00    	cmp    0x474(%edx),%ecx
  108964:	75 18                	jne    10897e <gpio_sch_manage_callback+0x4e>
	list->tail = node;
  108966:	89 82 74 04 00 00    	mov    %eax,0x474(%edx)
  10896c:	eb 10                	jmp    10897e <gpio_sch_manage_callback+0x4e>
	parent->next = child;
  10896e:	89 03                	mov    %eax,(%ebx)
Z_GENLIST_REMOVE(slist, snode)
  108970:	3b 8a 74 04 00 00    	cmp    0x474(%edx),%ecx
  108976:	75 06                	jne    10897e <gpio_sch_manage_callback+0x4e>
	list->tail = node;
  108978:	89 9a 74 04 00 00    	mov    %ebx,0x474(%edx)
	parent->next = child;
  10897e:	c7 01 00 00 00 00    	movl   $0x0,(%ecx)
  108984:	eb 36                	jmp    1089bc <gpio_sch_manage_callback+0x8c>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
  108986:	8b 38                	mov    (%eax),%edi
	return node->next;
  108988:	89 c3                	mov    %eax,%ebx
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
  10898a:	85 ff                	test   %edi,%edi
  10898c:	74 04                	je     108992 <gpio_sch_manage_callback+0x62>
  10898e:	89 f8                	mov    %edi,%eax
  108990:	eb bc                	jmp    10894e <gpio_sch_manage_callback+0x1e>
			if (!set) {
  108992:	89 f3                	mov    %esi,%ebx
		return -EINVAL;
  108994:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
  108999:	84 db                	test   %bl,%bl
  10899b:	74 2f                	je     1089cc <gpio_sch_manage_callback+0x9c>
Z_GENLIST_PREPEND(slist, snode)
  10899d:	8b 82 70 04 00 00    	mov    0x470(%edx),%eax
	parent->next = child;
  1089a3:	89 01                	mov    %eax,(%ecx)
	list->head = node;
  1089a5:	89 8a 70 04 00 00    	mov    %ecx,0x470(%edx)
Z_GENLIST_PREPEND(slist, snode)
  1089ab:	83 ba 74 04 00 00 00 	cmpl   $0x0,0x474(%edx)
  1089b2:	75 0e                	jne    1089c2 <gpio_sch_manage_callback+0x92>
	list->tail = node;
  1089b4:	89 8a 74 04 00 00    	mov    %ecx,0x474(%edx)
  1089ba:	eb 06                	jmp    1089c2 <gpio_sch_manage_callback+0x92>
	if (set) {
  1089bc:	89 f0                	mov    %esi,%eax
  1089be:	84 c0                	test   %al,%al
  1089c0:	75 db                	jne    10899d <gpio_sch_manage_callback+0x6d>
	_gpio_sch_manage_callback(dev);
  1089c2:	8b 45 08             	mov    0x8(%ebp),%eax
  1089c5:	e8 67 fe ff ff       	call   108831 <_gpio_sch_manage_callback>
	return 0;
  1089ca:	31 c0                	xor    %eax,%eax
}
  1089cc:	5b                   	pop    %ebx
  1089cd:	5e                   	pop    %esi
  1089ce:	5f                   	pop    %edi
  1089cf:	5d                   	pop    %ebp
  1089d0:	c3                   	ret    

001089d1 <gpio_sch_poll_status>:
{
  1089d1:	55                   	push   %ebp
  1089d2:	89 e5                	mov    %esp,%ebp
  1089d4:	57                   	push   %edi
  1089d5:	56                   	push   %esi
  1089d6:	53                   	push   %ebx
  1089d7:	83 ec 08             	sub    $0x8,%esp
  1089da:	8b 75 08             	mov    0x8(%ebp),%esi
	const struct gpio_sch_config *info = dev->config->config_info;
  1089dd:	8b 06                	mov    (%esi),%eax
	struct gpio_sch_data *gpio = dev->driver_data;
  1089df:	8b 5e 08             	mov    0x8(%esi),%ebx
	const struct gpio_sch_config *info = dev->config->config_info;
  1089e2:	8b 78 08             	mov    0x8(%eax),%edi
DEFINE_MM_REG_READ(gts, GPIO_SCH_REG_GTS)
  1089e5:	8b 07                	mov    (%edi),%eax
  1089e7:	8d 50 1c             	lea    0x1c(%eax),%edx
	__asm__ volatile("inl	%w1, %0;\n\t"
  1089ea:	ed                   	in     (%dx),%eax
	__asm__ volatile("outl	%0, %w1;\n\t"
  1089eb:	ef                   	out    %eax,(%dx)
	while (gpio->poll) {
  1089ec:	80 bb b0 04 00 00 00 	cmpb   $0x0,0x4b0(%ebx)
  1089f3:	74 67                	je     108a5c <gpio_sch_poll_status+0x8b>
DEFINE_MM_REG_READ(gts, GPIO_SCH_REG_GTS)
  1089f5:	8b 07                	mov    (%edi),%eax
  1089f7:	8d 50 1c             	lea    0x1c(%eax),%edx
	__asm__ volatile("inl	%w1, %0;\n\t"
  1089fa:	ed                   	in     (%dx),%eax
		if (!status) {
  1089fb:	85 c0                	test   %eax,%eax
  1089fd:	74 38                	je     108a37 <gpio_sch_poll_status+0x66>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(list, cb, tmp, node) {
  1089ff:	8b 93 70 04 00 00    	mov    0x470(%ebx),%edx
  108a05:	85 d2                	test   %edx,%edx
  108a07:	75 08                	jne    108a11 <gpio_sch_poll_status+0x40>
DEFINE_MM_REG_WRITE(gts, GPIO_SCH_REG_GTS)
  108a09:	8b 0f                	mov    (%edi),%ecx
  108a0b:	8d 51 1c             	lea    0x1c(%ecx),%edx
	__asm__ volatile("outl	%0, %w1;\n\t"
  108a0e:	ef                   	out    %eax,(%dx)
  108a0f:	eb 26                	jmp    108a37 <gpio_sch_poll_status+0x66>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
  108a11:	8b 0a                	mov    (%edx),%ecx
		if (cb->pin_mask & pins) {
  108a13:	85 42 08             	test   %eax,0x8(%edx)
  108a16:	74 15                	je     108a2d <gpio_sch_poll_status+0x5c>
			cb->handler(port, cb, pins);
  108a18:	50                   	push   %eax
  108a19:	89 4d ec             	mov    %ecx,-0x14(%ebp)
  108a1c:	52                   	push   %edx
  108a1d:	89 45 f0             	mov    %eax,-0x10(%ebp)
  108a20:	56                   	push   %esi
  108a21:	ff 52 04             	call   *0x4(%edx)
  108a24:	83 c4 0c             	add    $0xc,%esp
  108a27:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  108a2a:	8b 45 f0             	mov    -0x10(%ebp),%eax
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(list, cb, tmp, node) {
  108a2d:	85 c9                	test   %ecx,%ecx
  108a2f:	74 d8                	je     108a09 <gpio_sch_poll_status+0x38>
  108a31:	89 ca                	mov    %ecx,%edx
  108a33:	8b 09                	mov    (%ecx),%ecx
  108a35:	eb dc                	jmp    108a13 <gpio_sch_poll_status+0x42>
K_SYSCALL_DECLARE3_VOID(K_SYSCALL_K_TIMER_START, k_timer_start, struct k_timer *, timer, s32_t, duration, s32_t, period)
  108a37:	6a 00                	push   $0x0
		k_timer_start(&gpio->poll_timer, GPIO_SCH_POLLING_MSEC, 0);
  108a39:	8d 83 78 04 00 00    	lea    0x478(%ebx),%eax
  108a3f:	68 c8 00 00 00       	push   $0xc8
  108a44:	89 45 f0             	mov    %eax,-0x10(%ebp)
  108a47:	50                   	push   %eax
  108a48:	e8 d3 28 00 00       	call   10b320 <z_impl_k_timer_start>
  108a4d:	83 c4 0c             	add    $0xc,%esp
K_SYSCALL_DECLARE1(K_SYSCALL_K_TIMER_STATUS_SYNC, k_timer_status_sync, u32_t, struct k_timer *, timer)
  108a50:	8b 45 f0             	mov    -0x10(%ebp),%eax
  108a53:	50                   	push   %eax
  108a54:	e8 67 29 00 00       	call   10b3c0 <z_impl_k_timer_status_sync>
  108a59:	58                   	pop    %eax
  108a5a:	eb 90                	jmp    1089ec <gpio_sch_poll_status+0x1b>
}
  108a5c:	8d 65 f4             	lea    -0xc(%ebp),%esp
  108a5f:	5b                   	pop    %ebx
  108a60:	5e                   	pop    %esi
  108a61:	5f                   	pop    %edi
  108a62:	5d                   	pop    %ebp
  108a63:	c3                   	ret    

00108a64 <gpio_pin_config>:
{
  108a64:	55                   	push   %ebp
  108a65:	89 e5                	mov    %esp,%ebp
  108a67:	57                   	push   %edi
  108a68:	56                   	push   %esi
  108a69:	53                   	push   %ebx
  108a6a:	53                   	push   %ebx
  108a6b:	89 55 f0             	mov    %edx,-0x10(%ebp)
	const struct gpio_sch_config *info = dev->config->config_info;
  108a6e:	8b 10                	mov    (%eax),%edx
{
  108a70:	89 cb                	mov    %ecx,%ebx
	struct gpio_sch_data *gpio = dev->driver_data;
  108a72:	8b 70 08             	mov    0x8(%eax),%esi
DEFINE_MM_REG_SET_BIT(gen, GPIO_SCH_REG_GEN)
  108a75:	b9 01 00 00 00       	mov    $0x1,%ecx
	const struct gpio_sch_config *info = dev->config->config_info;
  108a7a:	8b 7a 08             	mov    0x8(%edx),%edi
DEFINE_MM_REG_SET_BIT(gen, GPIO_SCH_REG_GEN)
  108a7d:	8b 55 f0             	mov    -0x10(%ebp),%edx
  108a80:	8b 07                	mov    (%edi),%eax
  108a82:	e8 43 fd ff ff       	call   1087ca <set_bit>
DEFINE_MM_REG_SET_BIT(gio, GPIO_SCH_REG_GIO)
  108a87:	89 d9                	mov    %ebx,%ecx
  108a89:	8b 07                	mov    (%edi),%eax
  108a8b:	8b 55 f0             	mov    -0x10(%ebp),%edx
  108a8e:	f7 d1                	not    %ecx
  108a90:	83 e1 01             	and    $0x1,%ecx
  108a93:	83 c0 04             	add    $0x4,%eax
  108a96:	e8 2f fd ff ff       	call   1087ca <set_bit>
	if (flags & GPIO_INT) {
  108a9b:	f6 c3 02             	test   $0x2,%bl
  108a9e:	74 13                	je     108ab3 <gpio_pin_config+0x4f>
		if (flags & GPIO_INT_DOUBLE_EDGE) {
  108aa0:	f6 c3 40             	test   $0x40,%bl
  108aa3:	75 14                	jne    108ab9 <gpio_pin_config+0x55>
		} else if (flags & GPIO_INT_ACTIVE_HIGH) {
  108aa5:	83 e3 04             	and    $0x4,%ebx
			active_low = 1U;
  108aa8:	83 fb 01             	cmp    $0x1,%ebx
  108aab:	0f 92 c2             	setb   %dl
  108aae:	19 c0                	sbb    %eax,%eax
  108ab0:	40                   	inc    %eax
  108ab1:	eb 0a                	jmp    108abd <gpio_pin_config+0x59>
	u8_t active_low = 0U;
  108ab3:	31 d2                	xor    %edx,%edx
	u8_t active_high = 0U;
  108ab5:	31 c0                	xor    %eax,%eax
  108ab7:	eb 04                	jmp    108abd <gpio_pin_config+0x59>
			active_low = 1U;
  108ab9:	b2 01                	mov    $0x1,%dl
			active_high = 1U;
  108abb:	b0 01                	mov    $0x1,%al
	set_data_reg(&gpio->int_regs.gtpe, pin, active_high);
  108abd:	0f b6 4d f0          	movzbl -0x10(%ebp),%ecx
  108ac1:	0f b6 c0             	movzbl %al,%eax
	*reg &= ~(BIT(pin));
  108ac4:	8b be a4 04 00 00    	mov    0x4a4(%esi),%edi
  108aca:	bb 01 00 00 00       	mov    $0x1,%ebx
	*reg |= (set << pin) & BIT(pin);
  108acf:	d3 e0                	shl    %cl,%eax
	*reg &= ~(BIT(pin));
  108ad1:	d3 e3                	shl    %cl,%ebx
	*reg |= (set << pin) & BIT(pin);
  108ad3:	31 f8                	xor    %edi,%eax
  108ad5:	21 d8                	and    %ebx,%eax
	set_data_reg(&gpio->int_regs.gtne, pin, active_low);
  108ad7:	0f b6 d2             	movzbl %dl,%edx
	*reg |= (set << pin) & BIT(pin);
  108ada:	31 c7                	xor    %eax,%edi
	*reg &= ~(BIT(pin));
  108adc:	8b 86 a8 04 00 00    	mov    0x4a8(%esi),%eax
	*reg |= (set << pin) & BIT(pin);
  108ae2:	d3 e2                	shl    %cl,%edx
  108ae4:	31 c2                	xor    %eax,%edx
  108ae6:	89 be a4 04 00 00    	mov    %edi,0x4a4(%esi)
  108aec:	21 da                	and    %ebx,%edx
  108aee:	31 c2                	xor    %eax,%edx
  108af0:	89 96 a8 04 00 00    	mov    %edx,0x4a8(%esi)
}
  108af6:	58                   	pop    %eax
  108af7:	5b                   	pop    %ebx
  108af8:	5e                   	pop    %esi
  108af9:	5f                   	pop    %edi
  108afa:	5d                   	pop    %ebp
  108afb:	c3                   	ret    

00108afc <gpio_sch_config>:
{
  108afc:	55                   	push   %ebp
  108afd:	89 e5                	mov    %esp,%ebp
  108aff:	57                   	push   %edi
  108b00:	56                   	push   %esi
  108b01:	8b 75 08             	mov    0x8(%ebp),%esi
  108b04:	53                   	push   %ebx
  108b05:	8b 55 10             	mov    0x10(%ebp),%edx
  108b08:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	const struct gpio_sch_config *info = dev->config->config_info;
  108b0b:	8b 06                	mov    (%esi),%eax
	if (flags & GPIO_INT) {
  108b0d:	f6 45 14 02          	testb  $0x2,0x14(%ebp)
	const struct gpio_sch_config *info = dev->config->config_info;
  108b11:	8b 78 08             	mov    0x8(%eax),%edi
	if (flags & GPIO_INT) {
  108b14:	74 06                	je     108b1c <gpio_sch_config+0x20>
		if (!(flags & GPIO_INT_EDGE)) {
  108b16:	f6 45 14 20          	testb  $0x20,0x14(%ebp)
  108b1a:	74 35                	je     108b51 <gpio_sch_config+0x55>
	if (access_op == GPIO_ACCESS_BY_PIN) {
  108b1c:	85 db                	test   %ebx,%ebx
  108b1e:	75 14                	jne    108b34 <gpio_sch_config+0x38>
		if (pin >= info->bits) {
  108b20:	0f b6 47 04          	movzbl 0x4(%edi),%eax
  108b24:	39 d0                	cmp    %edx,%eax
  108b26:	76 29                	jbe    108b51 <gpio_sch_config+0x55>
		gpio_pin_config(dev, pin, flags);
  108b28:	8b 4d 14             	mov    0x14(%ebp),%ecx
  108b2b:	89 f0                	mov    %esi,%eax
  108b2d:	e8 32 ff ff ff       	call   108a64 <gpio_pin_config>
  108b32:	eb 22                	jmp    108b56 <gpio_sch_config+0x5a>
	for (pin = 0; pin < info->bits; pin++) {
  108b34:	31 db                	xor    %ebx,%ebx
  108b36:	0f b6 47 04          	movzbl 0x4(%edi),%eax
  108b3a:	39 c3                	cmp    %eax,%ebx
  108b3c:	7d 0f                	jge    108b4d <gpio_sch_config+0x51>
		gpio_pin_config(dev, pin, flags);
  108b3e:	89 da                	mov    %ebx,%edx
  108b40:	8b 4d 14             	mov    0x14(%ebp),%ecx
  108b43:	89 f0                	mov    %esi,%eax
	for (pin = 0; pin < info->bits; pin++) {
  108b45:	43                   	inc    %ebx
		gpio_pin_config(dev, pin, flags);
  108b46:	e8 19 ff ff ff       	call   108a64 <gpio_pin_config>
  108b4b:	eb e9                	jmp    108b36 <gpio_sch_config+0x3a>
	return 0;
  108b4d:	31 db                	xor    %ebx,%ebx
  108b4f:	eb 05                	jmp    108b56 <gpio_sch_config+0x5a>
			return -EINVAL;
  108b51:	bb ea ff ff ff       	mov    $0xffffffea,%ebx
}
  108b56:	89 d8                	mov    %ebx,%eax
  108b58:	5b                   	pop    %ebx
  108b59:	5e                   	pop    %esi
  108b5a:	5f                   	pop    %edi
  108b5b:	5d                   	pop    %ebp
  108b5c:	c3                   	ret    

00108b5d <gpio_sch_disable_callback>:
{
  108b5d:	55                   	push   %ebp
  108b5e:	89 e5                	mov    %esp,%ebp
  108b60:	57                   	push   %edi
  108b61:	56                   	push   %esi
  108b62:	8b 75 08             	mov    0x8(%ebp),%esi
  108b65:	53                   	push   %ebx
	if (access_op == GPIO_ACCESS_BY_PIN) {
  108b66:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
	const struct gpio_sch_config *info = dev->config->config_info;
  108b6a:	8b 06                	mov    (%esi),%eax
	struct gpio_sch_data *gpio = dev->driver_data;
  108b6c:	8b 7e 08             	mov    0x8(%esi),%edi
	const struct gpio_sch_config *info = dev->config->config_info;
  108b6f:	8b 58 08             	mov    0x8(%eax),%ebx
	if (access_op == GPIO_ACCESS_BY_PIN) {
  108b72:	75 3e                	jne    108bb2 <gpio_sch_disable_callback+0x55>
		if (pin >= info->bits) {
  108b74:	0f b6 53 04          	movzbl 0x4(%ebx),%edx
			return -ENOTSUP;
  108b78:	b8 dd ff ff ff       	mov    $0xffffffdd,%eax
		if (pin >= info->bits) {
  108b7d:	3b 55 10             	cmp    0x10(%ebp),%edx
  108b80:	76 4f                	jbe    108bd1 <gpio_sch_disable_callback+0x74>
DEFINE_MM_REG_SET_BIT(gtpe, GPIO_SCH_REG_GTPE)
  108b82:	8b 03                	mov    (%ebx),%eax
  108b84:	31 c9                	xor    %ecx,%ecx
  108b86:	83 c0 0c             	add    $0xc,%eax
  108b89:	8b 55 10             	mov    0x10(%ebp),%edx
  108b8c:	e8 39 fc ff ff       	call   1087ca <set_bit>
DEFINE_MM_REG_SET_BIT(gtne, GPIO_SCH_REG_GTNE)
  108b91:	8b 03                	mov    (%ebx),%eax
  108b93:	83 c0 10             	add    $0x10,%eax
  108b96:	31 c9                	xor    %ecx,%ecx
  108b98:	8b 55 10             	mov    0x10(%ebp),%edx
  108b9b:	e8 2a fc ff ff       	call   1087ca <set_bit>
		gpio->cb_enabled &= ~BIT(pin);
  108ba0:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  108ba5:	8a 4d 10             	mov    0x10(%ebp),%cl
  108ba8:	d3 c0                	rol    %cl,%eax
  108baa:	21 87 ac 04 00 00    	and    %eax,0x4ac(%edi)
  108bb0:	eb 16                	jmp    108bc8 <gpio_sch_disable_callback+0x6b>
		z_write_gtpe(0, info->regs);
  108bb2:	8b 0b                	mov    (%ebx),%ecx
  108bb4:	31 c0                	xor    %eax,%eax
DEFINE_MM_REG_WRITE(gtpe, GPIO_SCH_REG_GTPE)
  108bb6:	8d 51 0c             	lea    0xc(%ecx),%edx
  108bb9:	ef                   	out    %eax,(%dx)
DEFINE_MM_REG_WRITE(gtne, GPIO_SCH_REG_GTNE)
  108bba:	8d 51 10             	lea    0x10(%ecx),%edx
  108bbd:	ef                   	out    %eax,(%dx)
		gpio->cb_enabled = 0U;
  108bbe:	c7 87 ac 04 00 00 00 	movl   $0x0,0x4ac(%edi)
  108bc5:	00 00 00 
	_gpio_sch_manage_callback(dev);
  108bc8:	89 f0                	mov    %esi,%eax
  108bca:	e8 62 fc ff ff       	call   108831 <_gpio_sch_manage_callback>
	return 0;
  108bcf:	31 c0                	xor    %eax,%eax
}
  108bd1:	5b                   	pop    %ebx
  108bd2:	5e                   	pop    %esi
  108bd3:	5f                   	pop    %edi
  108bd4:	5d                   	pop    %ebp
  108bd5:	c3                   	ret    

00108bd6 <i2c_dw_runtime_configure>:

	return ret;
}

static int i2c_dw_runtime_configure(struct device *dev, u32_t config)
{
  108bd6:	55                   	push   %ebp
  108bd7:	89 e5                	mov    %esp,%ebp
  108bd9:	56                   	push   %esi
  108bda:	53                   	push   %ebx
	struct i2c_dw_dev_config * const dw = dev->driver_data;
  108bdb:	8b 45 08             	mov    0x8(%ebp),%eax
{
  108bde:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	struct i2c_dw_dev_config * const dw = dev->driver_data;
  108be1:	8b 48 08             	mov    0x8(%eax),%ecx

	dw->app_config = config;

	/* Make sure we have a supported speed for the DesignWare model */
	/* and have setup the clock frequency and speed mode */
	switch (I2C_SPEED_GET(dw->app_config)) {
  108be4:	89 d8                	mov    %ebx,%eax
  108be6:	d1 e8                	shr    %eax
  108be8:	83 e0 07             	and    $0x7,%eax
	volatile struct i2c_dw_registers * const regs =
  108beb:	8b 11                	mov    (%ecx),%edx
	dw->app_config = config;
  108bed:	89 59 1c             	mov    %ebx,0x1c(%ecx)
	switch (I2C_SPEED_GET(dw->app_config)) {
  108bf0:	83 f8 03             	cmp    $0x3,%eax
  108bf3:	77 12                	ja     108c07 <i2c_dw_runtime_configure+0x31>
  108bf5:	83 f8 02             	cmp    $0x2,%eax
  108bf8:	73 4f                	jae    108c49 <i2c_dw_runtime_configure+0x73>
  108bfa:	48                   	dec    %eax
			rc = -EINVAL;
		}
		break;
	default:
		/* TODO change */
		rc = -EINVAL;
  108bfb:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
	switch (I2C_SPEED_GET(dw->app_config)) {
  108c00:	74 14                	je     108c16 <i2c_dw_runtime_configure+0x40>
  108c02:	e9 c5 00 00 00       	jmp    108ccc <i2c_dw_runtime_configure+0xf6>
  108c07:	83 f8 04             	cmp    $0x4,%eax
		rc = -EINVAL;
  108c0a:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
	switch (I2C_SPEED_GET(dw->app_config)) {
  108c0f:	74 73                	je     108c84 <i2c_dw_runtime_configure+0xae>
  108c11:	e9 b6 00 00 00       	jmp    108ccc <i2c_dw_runtime_configure+0xf6>
		if (I2C_STD_LCNT <= (regs->ic_fs_spklen + 7)) {
  108c16:	8b b2 a0 00 00 00    	mov    0xa0(%edx),%esi
			value = I2C_STD_LCNT;
  108c1c:	b8 7d 00 00 00       	mov    $0x7d,%eax
		if (I2C_STD_LCNT <= (regs->ic_fs_spklen + 7)) {
  108c21:	83 c6 07             	add    $0x7,%esi
  108c24:	83 fe 7c             	cmp    $0x7c,%esi
  108c27:	76 09                	jbe    108c32 <i2c_dw_runtime_configure+0x5c>
			value = regs->ic_fs_spklen + 8;
  108c29:	8b 82 a0 00 00 00    	mov    0xa0(%edx),%eax
  108c2f:	83 c0 08             	add    $0x8,%eax
		if (I2C_STD_HCNT <= (regs->ic_fs_spklen + 5)) {
  108c32:	8b b2 a0 00 00 00    	mov    0xa0(%edx),%esi
		dw->lcnt = value;
  108c38:	66 89 41 2e          	mov    %ax,0x2e(%ecx)
		if (I2C_STD_HCNT <= (regs->ic_fs_spklen + 5)) {
  108c3c:	83 c6 05             	add    $0x5,%esi
			value = I2C_STD_HCNT;
  108c3f:	b8 64 00 00 00       	mov    $0x64,%eax
		if (I2C_STD_HCNT <= (regs->ic_fs_spklen + 5)) {
  108c44:	83 fe 63             	cmp    $0x63,%esi
  108c47:	eb 31                	jmp    108c7a <i2c_dw_runtime_configure+0xa4>
		if (I2C_FS_LCNT <= (regs->ic_fs_spklen + 7)) {
  108c49:	8b b2 a0 00 00 00    	mov    0xa0(%edx),%esi
			value = I2C_FS_LCNT;
  108c4f:	b8 15 00 00 00       	mov    $0x15,%eax
		if (I2C_FS_LCNT <= (regs->ic_fs_spklen + 7)) {
  108c54:	83 c6 07             	add    $0x7,%esi
  108c57:	83 fe 14             	cmp    $0x14,%esi
  108c5a:	76 09                	jbe    108c65 <i2c_dw_runtime_configure+0x8f>
			value = regs->ic_fs_spklen + 8;
  108c5c:	8b 82 a0 00 00 00    	mov    0xa0(%edx),%eax
  108c62:	83 c0 08             	add    $0x8,%eax
		if (I2C_FS_HCNT <= (regs->ic_fs_spklen + 5)) {
  108c65:	8b b2 a0 00 00 00    	mov    0xa0(%edx),%esi
		dw->lcnt = value;
  108c6b:	66 89 41 2e          	mov    %ax,0x2e(%ecx)
		if (I2C_FS_HCNT <= (regs->ic_fs_spklen + 5)) {
  108c6f:	83 c6 05             	add    $0x5,%esi
			value = I2C_FS_HCNT;
  108c72:	b8 12 00 00 00       	mov    $0x12,%eax
		if (I2C_FS_HCNT <= (regs->ic_fs_spklen + 5)) {
  108c77:	83 fe 11             	cmp    $0x11,%esi
  108c7a:	76 4a                	jbe    108cc6 <i2c_dw_runtime_configure+0xf0>
			value = regs->ic_fs_spklen + 6;
  108c7c:	8b 82 a0 00 00 00    	mov    0xa0(%edx),%eax
  108c82:	eb 3f                	jmp    108cc3 <i2c_dw_runtime_configure+0xed>
		if (dw->support_hs_mode) {
  108c84:	80 79 33 00          	cmpb   $0x0,0x33(%ecx)
  108c88:	74 42                	je     108ccc <i2c_dw_runtime_configure+0xf6>
			if (I2C_HS_LCNT <= (regs->ic_hs_spklen + 7)) {
  108c8a:	8b b2 a4 00 00 00    	mov    0xa4(%edx),%esi
				value = I2C_HS_LCNT;
  108c90:	b8 15 00 00 00       	mov    $0x15,%eax
			if (I2C_HS_LCNT <= (regs->ic_hs_spklen + 7)) {
  108c95:	83 c6 07             	add    $0x7,%esi
  108c98:	83 fe 14             	cmp    $0x14,%esi
  108c9b:	76 09                	jbe    108ca6 <i2c_dw_runtime_configure+0xd0>
				value = regs->ic_hs_spklen + 8;
  108c9d:	8b 82 a4 00 00 00    	mov    0xa4(%edx),%eax
  108ca3:	83 c0 08             	add    $0x8,%eax
			if (I2C_HS_HCNT <= (regs->ic_hs_spklen + 5)) {
  108ca6:	8b b2 a4 00 00 00    	mov    0xa4(%edx),%esi
			dw->lcnt = value;
  108cac:	66 89 41 2e          	mov    %ax,0x2e(%ecx)
			if (I2C_HS_HCNT <= (regs->ic_hs_spklen + 5)) {
  108cb0:	83 c6 05             	add    $0x5,%esi
				value = I2C_HS_HCNT;
  108cb3:	b8 12 00 00 00       	mov    $0x12,%eax
			if (I2C_HS_HCNT <= (regs->ic_hs_spklen + 5)) {
  108cb8:	83 fe 11             	cmp    $0x11,%esi
  108cbb:	76 09                	jbe    108cc6 <i2c_dw_runtime_configure+0xf0>
				value = regs->ic_hs_spklen + 6;
  108cbd:	8b 82 a4 00 00 00    	mov    0xa4(%edx),%eax
  108cc3:	83 c0 06             	add    $0x6,%eax
			dw->hcnt = value;
  108cc6:	66 89 41 2c          	mov    %ax,0x2c(%ecx)
	u32_t	rc = 0U;
  108cca:	31 c0                	xor    %eax,%eax
	/*
	 * TEMPORARY HACK - The I2C does not work in any mode other than Master
	 * currently.  This "hack" forces us to always be configured for master
	 * mode, until we can verify that Slave mode works correctly.
	 */
	dw->app_config |= I2C_MODE_MASTER;
  108ccc:	83 cb 10             	or     $0x10,%ebx
	value = regs->ic_clr_intr;
  108ccf:	66 8b 52 40          	mov    0x40(%edx),%dx
	dw->app_config |= I2C_MODE_MASTER;
  108cd3:	89 59 1c             	mov    %ebx,0x1c(%ecx)

	return rc;
}
  108cd6:	5b                   	pop    %ebx
  108cd7:	5e                   	pop    %esi
  108cd8:	5d                   	pop    %ebp
  108cd9:	c3                   	ret    

00108cda <i2c_dw_isr>:
{
  108cda:	55                   	push   %ebp
  108cdb:	89 e5                	mov    %esp,%ebp
  108cdd:	57                   	push   %edi
  108cde:	56                   	push   %esi
  108cdf:	53                   	push   %ebx
  108ce0:	83 ec 14             	sub    $0x14,%esp
  108ce3:	8b 45 08             	mov    0x8(%ebp),%eax
  108ce6:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	struct i2c_dw_dev_config * const dw = port->driver_data;
  108ce9:	8b 50 08             	mov    0x8(%eax),%edx
	volatile struct i2c_dw_registers * const regs =
  108cec:	8b 02                	mov    (%edx),%eax
  108cee:	89 45 e8             	mov    %eax,-0x18(%ebp)
	intr_stat.raw = regs->ic_intr_stat.raw;
  108cf1:	66 8b 40 2c          	mov    0x2c(%eax),%ax
	if (!intr_stat.raw) {
  108cf5:	66 85 c0             	test   %ax,%ax
	intr_stat.raw = regs->ic_intr_stat.raw;
  108cf8:	66 89 45 ee          	mov    %ax,-0x12(%ebp)
	if (!intr_stat.raw) {
  108cfc:	0f 84 19 02 00 00    	je     108f1b <i2c_dw_isr+0x241>
	if (regs->ic_con.bits.master_mode) {
  108d02:	8b 45 e8             	mov    -0x18(%ebp),%eax
  108d05:	8b 00                	mov    (%eax),%eax
  108d07:	a8 01                	test   $0x1,%al
  108d09:	75 18                	jne    108d23 <i2c_dw_isr+0x49>
	if (intr_stat.bits.stop_det) {
  108d0b:	66 f7 45 ee 00 02    	testw  $0x200,-0x12(%ebp)
  108d11:	0f 84 04 02 00 00    	je     108f1b <i2c_dw_isr+0x241>
		value = regs->ic_clr_stop_det;
  108d17:	8b 45 e8             	mov    -0x18(%ebp),%eax
  108d1a:	66 8b 40 60          	mov    0x60(%eax),%ax
		goto done;
  108d1e:	e9 c5 01 00 00       	jmp    108ee8 <i2c_dw_isr+0x20e>
		if ((DW_INTR_STAT_TX_ABRT | DW_INTR_STAT_TX_OVER |
  108d23:	f6 45 ee 4b          	testb  $0x4b,-0x12(%ebp)
  108d27:	74 09                	je     108d32 <i2c_dw_isr+0x58>
			dw->state = I2C_DW_CMD_ERROR;
  108d29:	c6 42 30 04          	movb   $0x4,0x30(%edx)
			goto done;
  108d2d:	e9 b6 01 00 00       	jmp    108ee8 <i2c_dw_isr+0x20e>
		if (intr_stat.bits.rx_full) {
  108d32:	f6 45 ee 04          	testb  $0x4,-0x12(%ebp)
  108d36:	74 40                	je     108d78 <i2c_dw_isr+0x9e>
	while (regs->ic_status.bits.rfne && (dw->xfr_len > 0)) {
  108d38:	8b 45 e8             	mov    -0x18(%ebp),%eax
  108d3b:	8b 48 70             	mov    0x70(%eax),%ecx
  108d3e:	8b 42 24             	mov    0x24(%edx),%eax
  108d41:	80 e1 08             	and    $0x8,%cl
  108d44:	74 2a                	je     108d70 <i2c_dw_isr+0x96>
  108d46:	85 c0                	test   %eax,%eax
  108d48:	0f 84 bf 01 00 00    	je     108f0d <i2c_dw_isr+0x233>
		dw->xfr_buf[0] = regs->ic_data_cmd.raw;
  108d4e:	8b 45 e8             	mov    -0x18(%ebp),%eax
  108d51:	66 8b 48 10          	mov    0x10(%eax),%cx
  108d55:	8b 42 20             	mov    0x20(%edx),%eax
  108d58:	88 08                	mov    %cl,(%eax)
		dw->xfr_len--;
  108d5a:	8b 42 24             	mov    0x24(%edx),%eax
		dw->xfr_buf++;
  108d5d:	ff 42 20             	incl   0x20(%edx)
		dw->xfr_len--;
  108d60:	48                   	dec    %eax
		dw->rx_pending--;
  108d61:	ff 4a 28             	decl   0x28(%edx)
		dw->xfr_len--;
  108d64:	89 42 24             	mov    %eax,0x24(%edx)
		if (dw->xfr_len == 0U) {
  108d67:	85 c0                	test   %eax,%eax
  108d69:	75 cd                	jne    108d38 <i2c_dw_isr+0x5e>
  108d6b:	e9 9d 01 00 00       	jmp    108f0d <i2c_dw_isr+0x233>
	if (dw->xfr_len == 0U) {
  108d70:	85 c0                	test   %eax,%eax
  108d72:	0f 84 95 01 00 00    	je     108f0d <i2c_dw_isr+0x233>
		if (intr_stat.bits.tx_empty) {
  108d78:	f6 45 ee 10          	testb  $0x10,-0x12(%ebp)
  108d7c:	74 8d                	je     108d0b <i2c_dw_isr+0x31>
			if ((dw->xfr_flags & I2C_MSG_RW_MASK)
  108d7e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  108d81:	f6 42 32 01          	testb  $0x1,0x32(%edx)
  108d85:	8b 40 08             	mov    0x8(%eax),%eax
  108d88:	8b 38                	mov    (%eax),%edi
  108d8a:	89 7d f0             	mov    %edi,-0x10(%ebp)
  108d8d:	0f 85 89 00 00 00    	jne    108e1c <i2c_dw_isr+0x142>
	if (dw->xfr_len == 0U) {
  108d93:	83 78 24 00          	cmpl   $0x0,0x24(%eax)
  108d97:	75 19                	jne    108db2 <i2c_dw_isr+0xd8>
		regs->ic_intr_mask.bits.tx_empty = 0U;
  108d99:	66 8b 5f 30          	mov    0x30(%edi),%bx
  108d9d:	83 e3 ef             	and    $0xffffffef,%ebx
  108da0:	66 89 5f 30          	mov    %bx,0x30(%edi)
		dw->state &= ~I2C_DW_CMD_SEND;
  108da4:	8a 48 30             	mov    0x30(%eax),%cl
  108da7:	83 e1 fe             	and    $0xfffffffe,%ecx
  108daa:	88 48 30             	mov    %cl,0x30(%eax)
		return 0;
  108dad:	e9 85 00 00 00       	jmp    108e37 <i2c_dw_isr+0x15d>
	while (regs->ic_status.bits.tfnf && (dw->xfr_len > 0)) {
  108db2:	8b 75 f0             	mov    -0x10(%ebp),%esi
  108db5:	8b 5e 70             	mov    0x70(%esi),%ebx
  108db8:	80 e3 02             	and    $0x2,%bl
  108dbb:	74 7a                	je     108e37 <i2c_dw_isr+0x15d>
  108dbd:	8b 58 24             	mov    0x24(%eax),%ebx
  108dc0:	85 db                	test   %ebx,%ebx
  108dc2:	74 73                	je     108e37 <i2c_dw_isr+0x15d>
		data = dw->xfr_buf[0];
  108dc4:	8b 78 20             	mov    0x20(%eax),%edi
  108dc7:	89 7d e0             	mov    %edi,-0x20(%ebp)
  108dca:	0f b6 37             	movzbl (%edi),%esi
		if (dw->xfr_flags & I2C_MSG_RESTART) {
  108dcd:	0f b6 78 32          	movzbl 0x32(%eax),%edi
  108dd1:	f7 c7 04 00 00 00    	test   $0x4,%edi
  108dd7:	74 0e                	je     108de7 <i2c_dw_isr+0x10d>
			dw->xfr_flags &= ~(I2C_MSG_RESTART);
  108dd9:	83 e7 fb             	and    $0xfffffffb,%edi
			data |= IC_DATA_CMD_RESTART;
  108ddc:	81 ce 00 04 00 00    	or     $0x400,%esi
			dw->xfr_flags &= ~(I2C_MSG_RESTART);
  108de2:	89 f9                	mov    %edi,%ecx
  108de4:	88 48 32             	mov    %cl,0x32(%eax)
		if ((dw->xfr_len == 1U) && (dw->xfr_flags & I2C_MSG_STOP)) {
  108de7:	83 fb 01             	cmp    $0x1,%ebx
  108dea:	75 0c                	jne    108df8 <i2c_dw_isr+0x11e>
  108dec:	f6 40 32 02          	testb  $0x2,0x32(%eax)
  108df0:	74 06                	je     108df8 <i2c_dw_isr+0x11e>
			data |= IC_DATA_CMD_STOP;
  108df2:	81 ce 00 02 00 00    	or     $0x200,%esi
		regs->ic_data_cmd.raw = data;
  108df8:	8b 7d f0             	mov    -0x10(%ebp),%edi
		dw->xfr_len--;
  108dfb:	4b                   	dec    %ebx
		regs->ic_data_cmd.raw = data;
  108dfc:	66 89 77 10          	mov    %si,0x10(%edi)
		dw->xfr_len--;
  108e00:	89 58 24             	mov    %ebx,0x24(%eax)
		dw->xfr_buf++;
  108e03:	8b 5d e0             	mov    -0x20(%ebp),%ebx
  108e06:	43                   	inc    %ebx
  108e07:	89 58 20             	mov    %ebx,0x20(%eax)
		if (regs->ic_intr_stat.bits.tx_abrt) {
  108e0a:	8b 5f 2c             	mov    0x2c(%edi),%ebx
  108e0d:	80 e3 40             	and    $0x40,%bl
  108e10:	74 a0                	je     108db2 <i2c_dw_isr+0xd8>
			return -EIO;
  108e12:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
  108e17:	e9 b8 00 00 00       	jmp    108ed4 <i2c_dw_isr+0x1fa>
	if (dw->request_bytes == 0U) {
  108e1c:	0f b6 70 31          	movzbl 0x31(%eax),%esi
  108e20:	89 f1                	mov    %esi,%ecx
  108e22:	84 c9                	test   %cl,%cl
  108e24:	75 18                	jne    108e3e <i2c_dw_isr+0x164>
		regs->ic_intr_mask.bits.tx_empty = 0U;
  108e26:	8b 45 f0             	mov    -0x10(%ebp),%eax
  108e29:	8b 75 f0             	mov    -0x10(%ebp),%esi
  108e2c:	66 8b 40 30          	mov    0x30(%eax),%ax
  108e30:	83 e0 ef             	and    $0xffffffef,%eax
  108e33:	66 89 46 30          	mov    %ax,0x30(%esi)
	int ret = 0;
  108e37:	31 c0                	xor    %eax,%eax
  108e39:	e9 96 00 00 00       	jmp    108ed4 <i2c_dw_isr+0x1fa>
	rx_empty = (I2C_DW_FIFO_DEPTH - regs->ic_rxflr) - dw->rx_pending;
  108e3e:	8b 7d f0             	mov    -0x10(%ebp),%edi
  108e41:	b3 10                	mov    $0x10,%bl
  108e43:	2b 58 28             	sub    0x28(%eax),%ebx
  108e46:	8b 7f 78             	mov    0x78(%edi),%edi
	if (rx_empty < 0) {
  108e49:	89 f9                	mov    %edi,%ecx
  108e4b:	28 cb                	sub    %cl,%bl
  108e4d:	88 5d e0             	mov    %bl,-0x20(%ebp)
  108e50:	78 e5                	js     108e37 <i2c_dw_isr+0x15d>
	tx_empty = I2C_DW_FIFO_DEPTH - regs->ic_txflr;
  108e52:	8b 7d f0             	mov    -0x10(%ebp),%edi
	cnt = MIN(I2C_DW_FIFO_DEPTH, dw->request_bytes);
  108e55:	89 f1                	mov    %esi,%ecx
  108e57:	80 f9 10             	cmp    $0x10,%cl
	tx_empty = I2C_DW_FIFO_DEPTH - regs->ic_txflr;
  108e5a:	8b 7f 74             	mov    0x74(%edi),%edi
	cnt = MIN(I2C_DW_FIFO_DEPTH, dw->request_bytes);
  108e5d:	76 05                	jbe    108e64 <i2c_dw_isr+0x18a>
  108e5f:	be 10 00 00 00       	mov    $0x10,%esi
	tx_empty = I2C_DW_FIFO_DEPTH - regs->ic_txflr;
  108e64:	89 f9                	mov    %edi,%ecx
  108e66:	b3 10                	mov    $0x10,%bl
  108e68:	29 cb                	sub    %ecx,%ebx
	cnt = MIN(MIN(tx_empty, rx_empty), cnt);
  108e6a:	89 f1                	mov    %esi,%ecx
  108e6c:	0f b6 fb             	movzbl %bl,%edi
  108e6f:	0f b6 d9             	movzbl %cl,%ebx
  108e72:	39 fb                	cmp    %edi,%ebx
  108e74:	7e 02                	jle    108e78 <i2c_dw_isr+0x19e>
  108e76:	89 fb                	mov    %edi,%ebx
  108e78:	0f be 7d e0          	movsbl -0x20(%ebp),%edi
  108e7c:	39 fb                	cmp    %edi,%ebx
  108e7e:	7e 3d                	jle    108ebd <i2c_dw_isr+0x1e3>
  108e80:	89 fb                	mov    %edi,%ebx
	while (cnt > 0) {
  108e82:	eb 39                	jmp    108ebd <i2c_dw_isr+0x1e3>
		if (dw->xfr_flags & I2C_MSG_RESTART) {
  108e84:	0f b6 70 32          	movzbl 0x32(%eax),%esi
		data = IC_DATA_CMD_CMD;
  108e88:	bf 00 01 00 00       	mov    $0x100,%edi
		if (dw->xfr_flags & I2C_MSG_RESTART) {
  108e8d:	f7 c6 04 00 00 00    	test   $0x4,%esi
  108e93:	74 0d                	je     108ea2 <i2c_dw_isr+0x1c8>
			dw->xfr_flags &= ~(I2C_MSG_RESTART);
  108e95:	83 e6 fb             	and    $0xfffffffb,%esi
			data |= IC_DATA_CMD_RESTART;
  108e98:	bf 00 05 00 00       	mov    $0x500,%edi
			dw->xfr_flags &= ~(I2C_MSG_RESTART);
  108e9d:	89 f1                	mov    %esi,%ecx
  108e9f:	88 48 32             	mov    %cl,0x32(%eax)
		if ((dw->xfr_flags & I2C_MSG_STOP)
  108ea2:	0f b6 70 31          	movzbl 0x31(%eax),%esi
  108ea6:	f6 40 32 02          	testb  $0x2,0x32(%eax)
  108eaa:	75 1a                	jne    108ec6 <i2c_dw_isr+0x1ec>
		regs->ic_data_cmd.raw = data;
  108eac:	8b 4d f0             	mov    -0x10(%ebp),%ecx
		dw->request_bytes--;
  108eaf:	4e                   	dec    %esi
		cnt--;
  108eb0:	4b                   	dec    %ebx
		regs->ic_data_cmd.raw = data;
  108eb1:	66 89 79 10          	mov    %di,0x10(%ecx)
		dw->rx_pending++;
  108eb5:	ff 40 28             	incl   0x28(%eax)
		dw->request_bytes--;
  108eb8:	89 f1                	mov    %esi,%ecx
  108eba:	88 48 31             	mov    %cl,0x31(%eax)
	while (cnt > 0) {
  108ebd:	84 db                	test   %bl,%bl
  108ebf:	75 c3                	jne    108e84 <i2c_dw_isr+0x1aa>
  108ec1:	e9 71 ff ff ff       	jmp    108e37 <i2c_dw_isr+0x15d>
		    && (dw->request_bytes == 1U)) {
  108ec6:	89 f1                	mov    %esi,%ecx
  108ec8:	fe c9                	dec    %cl
  108eca:	75 e0                	jne    108eac <i2c_dw_isr+0x1d2>
			data |= IC_DATA_CMD_STOP;
  108ecc:	81 cf 00 02 00 00    	or     $0x200,%edi
  108ed2:	eb d8                	jmp    108eac <i2c_dw_isr+0x1d2>
			if (((dw->xfr_len == 0U)
  108ed4:	83 7a 24 00          	cmpl   $0x0,0x24(%edx)
  108ed8:	75 06                	jne    108ee0 <i2c_dw_isr+0x206>
			     && !(dw->xfr_flags & I2C_MSG_STOP))
  108eda:	f6 42 32 02          	testb  $0x2,0x32(%edx)
  108ede:	74 08                	je     108ee8 <i2c_dw_isr+0x20e>
			    || (ret != 0)) {
  108ee0:	85 c0                	test   %eax,%eax
  108ee2:	0f 84 23 fe ff ff    	je     108d0b <i2c_dw_isr+0x31>
	i2c_dw_transfer_complete(port);
  108ee8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  108eeb:	8b 40 08             	mov    0x8(%eax),%eax
	k_sem_give(&dw->device_sync_sem);
  108eee:	83 c0 04             	add    $0x4,%eax
	volatile struct i2c_dw_registers * const regs =
  108ef1:	8b 50 fc             	mov    -0x4(%eax),%edx
	regs->ic_intr_mask.raw = DW_DISABLE_ALL_I2C_INT;
  108ef4:	66 c7 42 30 00 00    	movw   $0x0,0x30(%edx)
	value = regs->ic_clr_intr;
  108efa:	66 8b 52 40          	mov    0x40(%edx),%dx
	k_sem_give(&dw->device_sync_sem);
  108efe:	89 45 08             	mov    %eax,0x8(%ebp)
}
  108f01:	83 c4 14             	add    $0x14,%esp
  108f04:	5b                   	pop    %ebx
  108f05:	5e                   	pop    %esi
  108f06:	5f                   	pop    %edi
  108f07:	5d                   	pop    %ebp
K_SYSCALL_DECLARE1_VOID(K_SYSCALL_K_SEM_GIVE, k_sem_give, struct k_sem *, sem)
  108f08:	e9 3e 1c 00 00       	jmp    10ab4b <z_impl_k_sem_give>
		dw->state &= ~I2C_DW_CMD_RECV;
  108f0d:	8a 42 30             	mov    0x30(%edx),%al
  108f10:	83 e0 fd             	and    $0xfffffffd,%eax
  108f13:	88 42 30             	mov    %al,0x30(%edx)
		return;
  108f16:	e9 5d fe ff ff       	jmp    108d78 <i2c_dw_isr+0x9e>
}
  108f1b:	83 c4 14             	add    $0x14,%esp
  108f1e:	5b                   	pop    %ebx
  108f1f:	5e                   	pop    %esi
  108f20:	5f                   	pop    %edi
  108f21:	5d                   	pop    %ebp
  108f22:	c3                   	ret    

00108f23 <i2c_dw_initialize>:
#else
#define i2c_dw_pci_setup(_unused_) (1)
#endif /* CONFIG_PCI */

static int i2c_dw_initialize(struct device *dev)
{
  108f23:	55                   	push   %ebp
  108f24:	89 e5                	mov    %esp,%ebp
  108f26:	57                   	push   %edi
  108f27:	56                   	push   %esi
  108f28:	53                   	push   %ebx
  108f29:	50                   	push   %eax
  108f2a:	8b 75 08             	mov    0x8(%ebp),%esi
	const struct i2c_dw_rom_config * const rom = dev->config->config_info;
  108f2d:	8b 06                	mov    (%esi),%eax
	struct i2c_dw_dev_config * const dw = dev->driver_data;
  108f2f:	8b 5e 08             	mov    0x8(%esi),%ebx
	const struct i2c_dw_rom_config * const rom = dev->config->config_info;
  108f32:	8b 78 08             	mov    0x8(%eax),%edi
	pci_bus_scan_init();
  108f35:	e8 36 ce ff ff       	call   105d70 <pci_bus_scan_init>
	if (!pci_bus_scan(&dw->pci_dev)) {
  108f3a:	8d 53 34             	lea    0x34(%ebx),%edx
  108f3d:	52                   	push   %edx
  108f3e:	89 55 f0             	mov    %edx,-0x10(%ebp)
  108f41:	e8 5d ce ff ff       	call   105da3 <pci_bus_scan>
  108f46:	5a                   	pop    %edx
  108f47:	85 c0                	test   %eax,%eax
  108f49:	8b 55 f0             	mov    -0x10(%ebp),%edx
  108f4c:	75 0c                	jne    108f5a <i2c_dw_initialize+0x37>
	volatile struct i2c_dw_registers *regs;

	if (!i2c_dw_pci_setup(dev)) {
		dev->driver_api = NULL;
  108f4e:	c7 46 04 00 00 00 00 	movl   $0x0,0x4(%esi)
		return -EIO;
  108f55:	e9 ca 00 00 00       	jmp    109024 <i2c_dw_initialize+0x101>
	dw->base_address = dw->pci_dev.addr;
  108f5a:	8b 43 34             	mov    0x34(%ebx),%eax
  108f5d:	89 03                	mov    %eax,(%ebx)
	pci_enable_regs(&dw->pci_dev);
  108f5f:	52                   	push   %edx
  108f60:	e8 0b d4 ff ff       	call   106370 <pci_enable_regs>
K_SYSCALL_DECLARE3_VOID(K_SYSCALL_K_SEM_INIT, k_sem_init, struct k_sem *, sem, unsigned int, initial_count, unsigned int, limit)
  108f65:	c7 04 24 ff ff ff ff 	movl   $0xffffffff,(%esp)
	}

	k_sem_init(&dw->device_sync_sem, 0, UINT_MAX);
  108f6c:	8d 43 04             	lea    0x4(%ebx),%eax
  108f6f:	6a 00                	push   $0x0
  108f71:	50                   	push   %eax
  108f72:	e8 b2 1b 00 00       	call   10ab29 <z_impl_k_sem_init>

	regs = (struct i2c_dw_registers *) dw->base_address;
  108f77:	8b 03                	mov    (%ebx),%eax
  108f79:	83 c4 0c             	add    $0xc,%esp

	/* verify that we have a valid DesignWare register first */
	if (regs->ic_comp_type != I2C_DW_MAGIC_KEY) {
  108f7c:	8b 90 fc 00 00 00    	mov    0xfc(%eax),%edx
  108f82:	81 fa 40 01 57 44    	cmp    $0x44570140,%edx
  108f88:	75 c4                	jne    108f4e <i2c_dw_initialize+0x2b>
	/*
	 * grab the default value on initialization.  This should be set to the
	 * IC_MAX_SPEED_MODE in the hardware.  If it does support high speed we
	 * can move provide support for it
	 */
	if (regs->ic_con.bits.speed == I2C_DW_SPEED_HIGH) {
  108f8a:	8b 00                	mov    (%eax),%eax
  108f8c:	83 f0 06             	xor    $0x6,%eax
  108f8f:	a8 06                	test   $0x6,%al
  108f91:	0f 94 43 33          	sete   0x33(%ebx)
	} else {
		LOG_DBG("I2C: high speed NOT supported");
		dw->support_hs_mode = false;
	}

	rom->config_func(dev);
  108f95:	56                   	push   %esi
  108f96:	ff 17                	call   *(%edi)

	dw->app_config = I2C_MODE_MASTER | i2c_map_dt_bitrate(rom->bitrate);
  108f98:	8b 57 08             	mov    0x8(%edi),%edx
	rom->config_func(dev);
  108f9b:	58                   	pop    %eax
#include <dt-bindings/i2c/i2c.h>
#include <logging/log.h>

static inline u32_t i2c_map_dt_bitrate(u32_t bitrate)
{
	switch (bitrate) {
  108f9c:	81 fa 40 42 0f 00    	cmp    $0xf4240,%edx
	case I2C_BITRATE_STANDARD:
		return I2C_SPEED_STANDARD << I2C_SPEED_SHIFT;
	case I2C_BITRATE_FAST:
		return I2C_SPEED_FAST << I2C_SPEED_SHIFT;
	case I2C_BITRATE_FAST_PLUS:
		return I2C_SPEED_FAST_PLUS << I2C_SPEED_SHIFT;
  108fa2:	b8 06 00 00 00       	mov    $0x6,%eax
	switch (bitrate) {
  108fa7:	74 62                	je     10900b <i2c_dw_initialize+0xe8>
  108fa9:	77 1a                	ja     108fc5 <i2c_dw_initialize+0xa2>
		return I2C_SPEED_STANDARD << I2C_SPEED_SHIFT;
  108fab:	b8 02 00 00 00       	mov    $0x2,%eax
	switch (bitrate) {
  108fb0:	81 fa a0 86 01 00    	cmp    $0x186a0,%edx
  108fb6:	74 53                	je     10900b <i2c_dw_initialize+0xe8>
		return I2C_SPEED_FAST << I2C_SPEED_SHIFT;
  108fb8:	b8 04 00 00 00       	mov    $0x4,%eax
	switch (bitrate) {
  108fbd:	81 fa 80 1a 06 00    	cmp    $0x61a80,%edx
  108fc3:	eb 18                	jmp    108fdd <i2c_dw_initialize+0xba>
	case I2C_BITRATE_HIGH:
		return I2C_SPEED_HIGH << I2C_SPEED_SHIFT;
  108fc5:	b8 08 00 00 00       	mov    $0x8,%eax
	switch (bitrate) {
  108fca:	81 fa 40 e1 33 00    	cmp    $0x33e140,%edx
  108fd0:	74 39                	je     10900b <i2c_dw_initialize+0xe8>
	case I2C_BITRATE_ULTRA:
		return I2C_SPEED_ULTRA << I2C_SPEED_SHIFT;
  108fd2:	b8 0a 00 00 00       	mov    $0xa,%eax
	switch (bitrate) {
  108fd7:	81 fa 40 4b 4c 00    	cmp    $0x4c4b40,%edx
  108fdd:	74 2c                	je     10900b <i2c_dw_initialize+0xe8>
	}

	LOG_ERR("Invalid I2C bit rate value");
  108fdf:	a1 0c 34 11 00       	mov    0x11340c,%eax
  108fe4:	83 e0 07             	and    $0x7,%eax
  108fe7:	74 22                	je     10900b <i2c_dw_initialize+0xe8>
  108fe9:	b8 f0 b9 10 00       	mov    $0x10b9f0,%eax
  108fee:	2d e0 b9 10 00       	sub    $0x10b9e0,%eax
  108ff3:	c1 e8 03             	shr    $0x3,%eax
  108ff6:	c1 e0 06             	shl    $0x6,%eax
  108ff9:	83 c8 01             	or     $0x1,%eax
  108ffc:	50                   	push   %eax
  108ffd:	68 49 ef 10 00       	push   $0x10ef49
  109002:	e8 ff 81 ff ff       	call   101206 <log_0>
  109007:	5f                   	pop    %edi
  109008:	58                   	pop    %eax

	return 0;
  109009:	31 c0                	xor    %eax,%eax
	dw->app_config = I2C_MODE_MASTER | i2c_map_dt_bitrate(rom->bitrate);
  10900b:	83 c8 10             	or     $0x10,%eax
  10900e:	89 43 1c             	mov    %eax,0x1c(%ebx)

	if (i2c_dw_runtime_configure(dev, dw->app_config) != 0) {
  109011:	50                   	push   %eax
  109012:	56                   	push   %esi
  109013:	e8 be fb ff ff       	call   108bd6 <i2c_dw_runtime_configure>
  109018:	5a                   	pop    %edx
  109019:	85 c0                	test   %eax,%eax
  10901b:	59                   	pop    %ecx
  10901c:	75 06                	jne    109024 <i2c_dw_initialize+0x101>
		LOG_DBG("I2C: Cannot set default configuration");
		return -EIO;
	}

	dw->state = I2C_DW_STATE_READY;
  10901e:	c6 43 30 00          	movb   $0x0,0x30(%ebx)

	return 0;
  109022:	eb 05                	jmp    109029 <i2c_dw_initialize+0x106>
		return -EIO;
  109024:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
}
  109029:	8d 65 f4             	lea    -0xc(%ebp),%esp
  10902c:	5b                   	pop    %ebx
  10902d:	5e                   	pop    %esi
  10902e:	5f                   	pop    %edi
  10902f:	5d                   	pop    %ebp
  109030:	c3                   	ret    

00109031 <i2c_config_0>:

#ifndef DT_SNPS_DESIGNWARE_I2C_0_IRQ_0_SENSE
#define DT_SNPS_DESIGNWARE_I2C_0_IRQ_0_SENSE 0
#endif
static void i2c_config_0(struct device *port)
{
  109031:	55                   	push   %ebp
  109032:	89 e5                	mov    %esp,%ebp
  109034:	56                   	push   %esi
  109035:	53                   	push   %ebx
  109036:	8b 75 08             	mov    0x8(%ebp),%esi
#if defined(CONFIG_I2C_DW_0_IRQ_DIRECT)
	IRQ_CONNECT(DT_SNPS_DESIGNWARE_I2C_0_IRQ_0, DT_SNPS_DESIGNWARE_I2C_0_IRQ_0_PRIORITY,
		    i2c_dw_isr, DEVICE_GET(i2c_0), DT_SNPS_DESIGNWARE_I2C_0_IRQ_0_SENSE);
	irq_enable(DT_SNPS_DESIGNWARE_I2C_0_IRQ_0);
#elif defined(CONFIG_I2C_DW_0_IRQ_SHARED)
	const struct i2c_dw_rom_config * const config =
  109039:	8b 06                	mov    (%esi),%eax
		port->config->config_info;
	struct device *shared_irq_dev;

	shared_irq_dev = device_get_binding(config->shared_irq_dev_name);
  10903b:	8b 40 08             	mov    0x8(%eax),%eax
  10903e:	ff 70 04             	pushl  0x4(%eax)
  109041:	e8 b8 0c 00 00       	call   109cfe <z_impl_device_get_binding>
  109046:	89 c3                	mov    %eax,%ebx
	return api->isr_register(dev, isr_func, isr_dev);
  109048:	8b 40 04             	mov    0x4(%eax),%eax
  10904b:	89 34 24             	mov    %esi,(%esp)
  10904e:	68 da 8c 10 00       	push   $0x108cda
  109053:	53                   	push   %ebx
  109054:	ff 10                	call   *(%eax)
  109056:	83 c4 0c             	add    $0xc,%esp
	return api->enable(dev, isr_dev);
  109059:	8b 43 04             	mov    0x4(%ebx),%eax
  10905c:	56                   	push   %esi
  10905d:	53                   	push   %ebx
  10905e:	ff 50 04             	call   *0x4(%eax)
  109061:	58                   	pop    %eax
  109062:	5a                   	pop    %edx
	shared_irq_isr_register(shared_irq_dev, (isr_t)i2c_dw_isr, port);
	shared_irq_enable(shared_irq_dev, port);
#endif
}
  109063:	8d 65 f8             	lea    -0x8(%ebp),%esp
  109066:	5b                   	pop    %ebx
  109067:	5e                   	pop    %esi
  109068:	5d                   	pop    %ebp
  109069:	c3                   	ret    

0010906a <i2c_dw_transfer>:
{
  10906a:	55                   	push   %ebp
  10906b:	89 e5                	mov    %esp,%ebp
  10906d:	57                   	push   %edi
  10906e:	56                   	push   %esi
  10906f:	53                   	push   %ebx
  109070:	83 ec 08             	sub    $0x8,%esp
  109073:	8b 55 10             	mov    0x10(%ebp),%edx
  109076:	8b 45 14             	mov    0x14(%ebp),%eax
  109079:	89 45 ec             	mov    %eax,-0x14(%ebp)
  10907c:	8b 7d 0c             	mov    0xc(%ebp),%edi
		return 0;
  10907f:	31 c0                	xor    %eax,%eax
{
  109081:	88 55 f0             	mov    %dl,-0x10(%ebp)
	if (!num_msgs) {
  109084:	84 d2                	test   %dl,%dl
  109086:	0f 84 e4 01 00 00    	je     109270 <i2c_dw_transfer+0x206>
	struct i2c_dw_dev_config * const dw = dev->driver_data;
  10908c:	8b 45 08             	mov    0x8(%ebp),%eax
  10908f:	8b 58 08             	mov    0x8(%eax),%ebx
		return -EIO;
  109092:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
	volatile struct i2c_dw_registers * const regs =
  109097:	8b 33                	mov    (%ebx),%esi
	if ((regs->ic_status.bits.activity) || (dw->state & I2C_DW_BUSY)) {
  109099:	8b 56 70             	mov    0x70(%esi),%edx
  10909c:	80 e2 01             	and    $0x1,%dl
  10909f:	0f 85 cb 01 00 00    	jne    109270 <i2c_dw_transfer+0x206>
  1090a5:	8a 53 30             	mov    0x30(%ebx),%dl
  1090a8:	80 e2 08             	and    $0x8,%dl
  1090ab:	0f 85 bf 01 00 00    	jne    109270 <i2c_dw_transfer+0x206>
	dw->state |= I2C_DW_BUSY;
  1090b1:	8a 43 30             	mov    0x30(%ebx),%al
  1090b4:	83 c8 08             	or     $0x8,%eax
  1090b7:	88 43 30             	mov    %al,0x30(%ebx)
	ic_con.raw = 0U;
  1090ba:	31 c0                	xor    %eax,%eax
	regs->ic_enable.bits.enable = 0U;
  1090bc:	66 8b 56 6c          	mov    0x6c(%esi),%dx
  1090c0:	83 e2 fe             	and    $0xfffffffe,%edx
  1090c3:	66 89 56 6c          	mov    %dx,0x6c(%esi)
	regs->ic_intr_mask.raw = 0U;
  1090c7:	66 c7 46 30 00 00    	movw   $0x0,0x30(%esi)
	value = regs->ic_clr_intr;
  1090cd:	66 8b 56 40          	mov    0x40(%esi),%dx
	if (I2C_MODE_MASTER & dw->app_config) {
  1090d1:	8b 53 1c             	mov    0x1c(%ebx),%edx
  1090d4:	f6 c2 10             	test   $0x10,%dl
  1090d7:	0f 84 d6 00 00 00    	je     1091b3 <i2c_dw_transfer+0x149>
	if (I2C_ADDR_10_BITS & dw->app_config) {
  1090dd:	89 d1                	mov    %edx,%ecx
		ic_con.bits.master_mode = 1U;
  1090df:	b0 61                	mov    $0x61,%al
	if (I2C_ADDR_10_BITS & dw->app_config) {
  1090e1:	83 e1 01             	and    $0x1,%ecx
  1090e4:	74 02                	je     1090e8 <i2c_dw_transfer+0x7e>
		ic_con.bits.addr_slave_10bit = 1U;
  1090e6:	0c 18                	or     $0x18,%al
	switch (I2C_SPEED_GET(dw->app_config)) {
  1090e8:	d1 ea                	shr    %edx
  1090ea:	83 e2 07             	and    $0x7,%edx
  1090ed:	83 fa 03             	cmp    $0x3,%edx
  1090f0:	77 23                	ja     109115 <i2c_dw_transfer+0xab>
  1090f2:	83 fa 02             	cmp    $0x2,%edx
  1090f5:	73 28                	jae    10911f <i2c_dw_transfer+0xb5>
  1090f7:	4a                   	dec    %edx
  1090f8:	0f 85 b5 00 00 00    	jne    1091b3 <i2c_dw_transfer+0x149>
		regs->ic_ss_scl_lcnt = dw->lcnt;
  1090fe:	66 8b 53 2e          	mov    0x2e(%ebx),%dx
		ic_con.bits.speed = I2C_DW_SPEED_STANDARD;
  109102:	83 e0 f9             	and    $0xfffffff9,%eax
		regs->ic_ss_scl_lcnt = dw->lcnt;
  109105:	66 89 56 18          	mov    %dx,0x18(%esi)
		regs->ic_ss_scl_hcnt = dw->hcnt;
  109109:	8b 53 2c             	mov    0x2c(%ebx),%edx
  10910c:	66 89 56 14          	mov    %dx,0x14(%esi)
		ic_con.bits.speed = I2C_DW_SPEED_STANDARD;
  109110:	83 c8 02             	or     $0x2,%eax
		break;
  109113:	eb 39                	jmp    10914e <i2c_dw_transfer+0xe4>
	switch (I2C_SPEED_GET(dw->app_config)) {
  109115:	83 fa 04             	cmp    $0x4,%edx
  109118:	74 1c                	je     109136 <i2c_dw_transfer+0xcc>
  10911a:	e9 94 00 00 00       	jmp    1091b3 <i2c_dw_transfer+0x149>
		regs->ic_fs_scl_lcnt = dw->lcnt;
  10911f:	66 8b 53 2e          	mov    0x2e(%ebx),%dx
		ic_con.bits.speed = I2C_DW_SPEED_FAST;
  109123:	83 e0 f9             	and    $0xfffffff9,%eax
		regs->ic_fs_scl_lcnt = dw->lcnt;
  109126:	66 89 56 20          	mov    %dx,0x20(%esi)
		regs->ic_fs_scl_hcnt = dw->hcnt;
  10912a:	8b 53 2c             	mov    0x2c(%ebx),%edx
  10912d:	66 89 56 1c          	mov    %dx,0x1c(%esi)
		ic_con.bits.speed = I2C_DW_SPEED_FAST;
  109131:	83 c8 04             	or     $0x4,%eax
		break;
  109134:	eb 18                	jmp    10914e <i2c_dw_transfer+0xe4>
		if (!dw->support_hs_mode) {
  109136:	80 7b 33 00          	cmpb   $0x0,0x33(%ebx)
  10913a:	74 77                	je     1091b3 <i2c_dw_transfer+0x149>
		regs->ic_hs_scl_lcnt = dw->lcnt;
  10913c:	66 8b 53 2e          	mov    0x2e(%ebx),%dx
		ic_con.bits.speed = I2C_DW_SPEED_HIGH;
  109140:	83 c8 06             	or     $0x6,%eax
		regs->ic_hs_scl_lcnt = dw->lcnt;
  109143:	66 89 56 28          	mov    %dx,0x28(%esi)
		regs->ic_hs_scl_hcnt = dw->hcnt;
  109147:	8b 53 2c             	mov    0x2c(%ebx),%edx
  10914a:	66 89 56 24          	mov    %dx,0x24(%esi)
	regs->ic_con = ic_con;
  10914e:	66 89 06             	mov    %ax,(%esi)
	regs->ic_rx_tl = 0U;
  109151:	66 c7 46 38 00 00    	movw   $0x0,0x38(%esi)
	regs->ic_tx_tl = 0U;
  109157:	66 c7 46 3c 00 00    	movw   $0x0,0x3c(%esi)
	if (regs->ic_con.bits.master_mode) {
  10915d:	8b 55 ec             	mov    -0x14(%ebp),%edx
  109160:	66 81 e2 ff 03       	and    $0x3ff,%dx
  109165:	8b 06                	mov    (%esi),%eax
  109167:	a8 01                	test   $0x1,%al
  109169:	74 10                	je     10917b <i2c_dw_transfer+0x111>
		regs->ic_tar.bits.ic_tar = slave_address;
  10916b:	66 8b 46 04          	mov    0x4(%esi),%ax
  10916f:	66 25 00 fc          	and    $0xfc00,%ax
  109173:	09 d0                	or     %edx,%eax
  109175:	66 89 46 04          	mov    %ax,0x4(%esi)
  109179:	eb 0e                	jmp    109189 <i2c_dw_transfer+0x11f>
		regs->ic_sar.bits.ic_sar = slave_address;
  10917b:	66 8b 46 08          	mov    0x8(%esi),%ax
  10917f:	66 25 00 fc          	and    $0xfc00,%ax
  109183:	09 d0                	or     %edx,%eax
  109185:	66 89 46 08          	mov    %ax,0x8(%esi)
			regs->ic_tar.bits.ic_10bitaddr_master = 1U;
  109189:	66 8b 46 04          	mov    0x4(%esi),%ax
		if (I2C_ADDR_10_BITS & dw->app_config) {
  10918d:	85 c9                	test   %ecx,%ecx
  10918f:	74 05                	je     109196 <i2c_dw_transfer+0x12c>
			regs->ic_tar.bits.ic_10bitaddr_master = 1U;
  109191:	80 cc 10             	or     $0x10,%ah
  109194:	eb 03                	jmp    109199 <i2c_dw_transfer+0x12f>
			regs->ic_tar.bits.ic_10bitaddr_master = 0U;
  109196:	80 e4 ef             	and    $0xef,%ah
  109199:	66 89 46 04          	mov    %ax,0x4(%esi)
	regs->ic_enable.bits.enable = 1U;
  10919d:	66 8b 46 6c          	mov    0x6c(%esi),%ax
  1091a1:	83 c8 01             	or     $0x1,%eax
  1091a4:	66 89 46 6c          	mov    %ax,0x6c(%esi)
	device_busy_set(dev);
  1091a8:	ff 75 08             	pushl  0x8(%ebp)
  1091ab:	e8 a9 0b 00 00       	call   109d59 <device_busy_set>
  1091b0:	58                   	pop    %eax
	while (msg_left > 0) {
  1091b1:	eb 0e                	jmp    1091c1 <i2c_dw_transfer+0x157>
		dw->state = I2C_DW_STATE_READY;
  1091b3:	c6 43 30 00          	movb   $0x0,0x30(%ebx)
		return ret;
  1091b7:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
  1091bc:	e9 af 00 00 00       	jmp    109270 <i2c_dw_transfer+0x206>
		dw->xfr_buf = cur_msg->buf;
  1091c1:	8b 07                	mov    (%edi),%eax
		dw->xfr_len = cur_msg->len;
  1091c3:	8b 4f 04             	mov    0x4(%edi),%ecx
		dw->xfr_buf = cur_msg->buf;
  1091c6:	89 43 20             	mov    %eax,0x20(%ebx)
		dw->xfr_len = cur_msg->len;
  1091c9:	89 4b 24             	mov    %ecx,0x24(%ebx)
		dw->xfr_flags = cur_msg->flags;
  1091cc:	8a 47 08             	mov    0x8(%edi),%al
		pflags = dw->xfr_flags;
  1091cf:	8a 53 32             	mov    0x32(%ebx),%dl
		    != (dw->xfr_flags & I2C_MSG_RW_MASK)) {
  1091d2:	31 c2                	xor    %eax,%edx
		dw->xfr_flags = cur_msg->flags;
  1091d4:	88 43 32             	mov    %al,0x32(%ebx)
		dw->rx_pending = 0U;
  1091d7:	c7 43 28 00 00 00 00 	movl   $0x0,0x28(%ebx)
		if ((pflags & I2C_MSG_RW_MASK)
  1091de:	80 e2 01             	and    $0x1,%dl
  1091e1:	74 06                	je     1091e9 <i2c_dw_transfer+0x17f>
			dw->xfr_flags |= I2C_MSG_RESTART;
  1091e3:	83 c8 04             	or     $0x4,%eax
  1091e6:	88 43 32             	mov    %al,0x32(%ebx)
		if (msg_left == 1U) {
  1091e9:	80 7d f0 01          	cmpb   $0x1,-0x10(%ebp)
  1091ed:	75 04                	jne    1091f3 <i2c_dw_transfer+0x189>
			dw->xfr_flags |= I2C_MSG_STOP;
  1091ef:	80 4b 32 02          	orb    $0x2,0x32(%ebx)
		dw->state &= ~(I2C_DW_CMD_SEND | I2C_DW_CMD_RECV);
  1091f3:	8a 43 30             	mov    0x30(%ebx),%al
  1091f6:	83 e0 fc             	and    $0xfffffffc,%eax
		if ((dw->xfr_flags & I2C_MSG_RW_MASK) == I2C_MSG_WRITE) {
  1091f9:	f6 43 32 01          	testb  $0x1,0x32(%ebx)
		dw->state &= ~(I2C_DW_CMD_SEND | I2C_DW_CMD_RECV);
  1091fd:	88 43 30             	mov    %al,0x30(%ebx)
			dw->state |= I2C_DW_CMD_SEND;
  109200:	8a 43 30             	mov    0x30(%ebx),%al
		if ((dw->xfr_flags & I2C_MSG_RW_MASK) == I2C_MSG_WRITE) {
  109203:	75 0c                	jne    109211 <i2c_dw_transfer+0x1a7>
			dw->state |= I2C_DW_CMD_SEND;
  109205:	83 c8 01             	or     $0x1,%eax
			dw->request_bytes = 0U;
  109208:	c6 43 31 00          	movb   $0x0,0x31(%ebx)
			dw->state |= I2C_DW_CMD_SEND;
  10920c:	88 43 30             	mov    %al,0x30(%ebx)
			dw->request_bytes = 0U;
  10920f:	eb 09                	jmp    10921a <i2c_dw_transfer+0x1b0>
			dw->state |= I2C_DW_CMD_RECV;
  109211:	83 c8 02             	or     $0x2,%eax
			dw->request_bytes = dw->xfr_len;
  109214:	88 4b 31             	mov    %cl,0x31(%ebx)
			dw->state |= I2C_DW_CMD_RECV;
  109217:	88 43 30             	mov    %al,0x30(%ebx)
		if (regs->ic_con.bits.master_mode) {
  10921a:	8b 06                	mov    (%esi),%eax
  10921c:	a8 01                	test   $0x1,%al
  10921e:	74 08                	je     109228 <i2c_dw_transfer+0x1be>
			regs->ic_intr_mask.raw = (DW_ENABLE_TX_INT_I2C_MASTER |
  109220:	66 c7 46 30 5f 02    	movw   $0x25f,0x30(%esi)
  109226:	eb 06                	jmp    10922e <i2c_dw_transfer+0x1c4>
			regs->ic_intr_mask.raw = DW_ENABLE_TX_INT_I2C_SLAVE;
  109228:	66 c7 46 30 60 02    	movw   $0x260,0x30(%esi)
K_SYSCALL_DECLARE2(K_SYSCALL_K_SEM_TAKE, k_sem_take, int, struct k_sem *, sem, s32_t, timeout)
  10922e:	6a ff                	push   $0xffffffff
		k_sem_take(&dw->device_sync_sem, K_FOREVER);
  109230:	8d 43 04             	lea    0x4(%ebx),%eax
  109233:	50                   	push   %eax
  109234:	e8 7b 19 00 00       	call   10abb4 <z_impl_k_sem_take>
  109239:	5a                   	pop    %edx
		if (dw->state & I2C_DW_CMD_ERROR) {
  10923a:	8a 43 30             	mov    0x30(%ebx),%al
  10923d:	59                   	pop    %ecx
  10923e:	a8 04                	test   $0x4,%al
  109240:	75 16                	jne    109258 <i2c_dw_transfer+0x1ee>
		if (dw->xfr_len > 0) {
  109242:	83 7b 24 00          	cmpl   $0x0,0x24(%ebx)
  109246:	75 10                	jne    109258 <i2c_dw_transfer+0x1ee>
		cur_msg++;
  109248:	83 c7 0c             	add    $0xc,%edi
	while (msg_left > 0) {
  10924b:	fe 4d f0             	decb   -0x10(%ebp)
  10924e:	0f 85 6d ff ff ff    	jne    1091c1 <i2c_dw_transfer+0x157>
	ret = i2c_dw_setup(dev, slave_address);
  109254:	31 c0                	xor    %eax,%eax
  109256:	eb 05                	jmp    10925d <i2c_dw_transfer+0x1f3>
			ret = -EIO;
  109258:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
	device_busy_clear(dev);
  10925d:	ff 75 08             	pushl  0x8(%ebp)
  109260:	89 45 f0             	mov    %eax,-0x10(%ebp)
  109263:	e8 f2 0a 00 00       	call   109d5a <device_busy_clear>
  109268:	58                   	pop    %eax
	dw->state = I2C_DW_STATE_READY;
  109269:	c6 43 30 00          	movb   $0x0,0x30(%ebx)
  10926d:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
  109270:	8d 65 f4             	lea    -0xc(%ebp),%esp
  109273:	5b                   	pop    %ebx
  109274:	5e                   	pop    %esi
  109275:	5f                   	pop    %edi
  109276:	5d                   	pop    %ebp
  109277:	c3                   	ret    

00109278 <pwm_pca9685_pin_set_cycles>:
 * period_count is always taken as 4095. To control the on period send
 * value to pulse_count
 */
static int pwm_pca9685_pin_set_cycles(struct device *dev, u32_t pwm,
				      u32_t period_count, u32_t pulse_count)
{
  109278:	55                   	push   %ebp
		dev->config->config_info;
	struct pwm_pca9685_drv_data * const drv_data =
		(struct pwm_pca9685_drv_data * const)dev->driver_data;
	struct device * const i2c_master = drv_data->i2c_master;
	u16_t i2c_addr = config->i2c_slave_addr;
	u8_t buf[] = { 0, 0, 0, 0, 0};
  109279:	b9 05 00 00 00       	mov    $0x5,%ecx
{
  10927e:	89 e5                	mov    %esp,%ebp
  109280:	57                   	push   %edi
  109281:	56                   	push   %esi
  109282:	53                   	push   %ebx
	u8_t buf[] = { 0, 0, 0, 0, 0};
  109283:	8d 7d e3             	lea    -0x1d(%ebp),%edi
{
  109286:	83 ec 18             	sub    $0x18,%esp
  109289:	8b 45 08             	mov    0x8(%ebp),%eax
  10928c:	8b 75 14             	mov    0x14(%ebp),%esi
	struct pwm_pca9685_drv_data * const drv_data =
  10928f:	8b 50 08             	mov    0x8(%eax),%edx
	const struct pwm_pca9685_config * const config =
  109292:	8b 00                	mov    (%eax),%eax
	u16_t i2c_addr = config->i2c_slave_addr;
  109294:	8b 40 08             	mov    0x8(%eax),%eax
	struct device * const i2c_master = drv_data->i2c_master;
  109297:	8b 1a                	mov    (%edx),%ebx
	u16_t i2c_addr = config->i2c_slave_addr;
  109299:	8b 40 04             	mov    0x4(%eax),%eax
  10929c:	66 89 45 de          	mov    %ax,-0x22(%ebp)
	u8_t buf[] = { 0, 0, 0, 0, 0};
  1092a0:	31 c0                	xor    %eax,%eax
  1092a2:	f3 aa                	rep stos %al,%es:(%edi)

	if (!has_i2c_master(dev)) {
		return -EINVAL;
	}

	if (pwm > MAX_PWM_OUT) {
  1092a4:	83 3a 00             	cmpl   $0x0,(%edx)
  1092a7:	74 7a                	je     109323 <pwm_pca9685_pin_set_cycles+0xab>
  1092a9:	83 7d 0c 10          	cmpl   $0x10,0xc(%ebp)
  1092ad:	77 74                	ja     109323 <pwm_pca9685_pin_set_cycles+0xab>
		return -EINVAL;
	}
	buf[0] = REG_LED_ON_L(pwm);
  1092af:	8a 45 0c             	mov    0xc(%ebp),%al

	/* If either pulse_count > max ticks, treat PWM as 100%.
	 * If pulse_count value == 0, treat it as 0%.
	 * Otherwise, populate registers accordingly.
	 */
	if (pulse_count >= PWM_ONE_PERIOD_TICKS) {	// always high
  1092b2:	81 fe ff 0f 00 00    	cmp    $0xfff,%esi
	buf[0] = REG_LED_ON_L(pwm);
  1092b8:	8d 04 85 06 00 00 00 	lea    0x6(,%eax,4),%eax
  1092bf:	88 45 e3             	mov    %al,-0x1d(%ebp)
	if (pulse_count >= PWM_ONE_PERIOD_TICKS) {	// always high
  1092c2:	76 06                	jbe    1092ca <pwm_pca9685_pin_set_cycles+0x52>
		buf[1] = 0x0;
		buf[2] = (1 << 4);
  1092c4:	c6 45 e5 10          	movb   $0x10,-0x1b(%ebp)
		buf[3] = 0x0;
		buf[4] = 0x0;
  1092c8:	eb 31                	jmp    1092fb <pwm_pca9685_pin_set_cycles+0x83>
	} else if (pulse_count == 0U) {		// always low
  1092ca:	85 f6                	test   %esi,%esi
  1092cc:	75 06                	jne    1092d4 <pwm_pca9685_pin_set_cycles+0x5c>
		buf[1] = 0x0;
		buf[2] = 0x0;
		buf[3] = 0x0;
		buf[4] = (1 << 4);
  1092ce:	c6 45 e7 10          	movb   $0x10,-0x19(%ebp)
  1092d2:	eb 27                	jmp    1092fb <pwm_pca9685_pin_set_cycles+0x83>
	} else if (pulse_count==period_count) {	
  1092d4:	3b 75 10             	cmp    0x10(%ebp),%esi
  1092d7:	74 eb                	je     1092c4 <pwm_pca9685_pin_set_cycles+0x4c>
		buf[1] = 0x0;
		buf[2] = (1 << 4);		// always HIGH
		buf[3] = 0x0;
		buf[4] = 0x0;
	} else { 	// on and off ticks
		buf[1] = (period_count & 0xFF);
  1092d9:	8a 45 10             	mov    0x10(%ebp),%al
  1092dc:	88 45 e4             	mov    %al,-0x1c(%ebp)
		buf[2] = ((period_count >> 8) & 0x0F);
  1092df:	8b 45 10             	mov    0x10(%ebp),%eax
  1092e2:	c1 e8 08             	shr    $0x8,%eax
  1092e5:	83 e0 0f             	and    $0xf,%eax
  1092e8:	88 45 e5             	mov    %al,-0x1b(%ebp)
		buf[3] = (pulse_count & 0xFF);
  1092eb:	89 f0                	mov    %esi,%eax
		buf[4] = ((pulse_count >> 8) & 0x0F);
  1092ed:	c1 ee 08             	shr    $0x8,%esi
		buf[3] = (pulse_count & 0xFF);
  1092f0:	88 45 e6             	mov    %al,-0x1a(%ebp)
		buf[4] = ((pulse_count >> 8) & 0x0F);
  1092f3:	89 f0                	mov    %esi,%eax
  1092f5:	83 e0 0f             	and    $0xf,%eax
  1092f8:	88 45 e7             	mov    %al,-0x19(%ebp)
	msg.buf = (u8_t *)buf;
  1092fb:	8d 45 e3             	lea    -0x1d(%ebp),%eax
	msg.flags = I2C_MSG_WRITE | I2C_MSG_STOP;
  1092fe:	c6 45 f0 02          	movb   $0x2,-0x10(%ebp)
	msg.buf = (u8_t *)buf;
  109302:	89 45 e8             	mov    %eax,-0x18(%ebp)
	return api->transfer(dev, msgs, num_msgs, addr);
  109305:	8b 53 04             	mov    0x4(%ebx),%edx
	}

//	printk("send I2c msg: %x %x %x %x %x -- i2c_addr %x\n", buf[0], buf[1], buf[2], buf[3], buf[4], i2c_addr);

	return i2c_write(i2c_master, buf, sizeof(buf), i2c_addr);
  109308:	0f b7 45 de          	movzwl -0x22(%ebp),%eax
  10930c:	50                   	push   %eax
  10930d:	8d 45 e8             	lea    -0x18(%ebp),%eax
  109310:	6a 01                	push   $0x1
	msg.len = num_bytes;
  109312:	c7 45 ec 05 00 00 00 	movl   $0x5,-0x14(%ebp)
	return api->transfer(dev, msgs, num_msgs, addr);
  109319:	50                   	push   %eax
  10931a:	53                   	push   %ebx
  10931b:	ff 52 04             	call   *0x4(%edx)
  10931e:	83 c4 10             	add    $0x10,%esp
  109321:	eb 05                	jmp    109328 <pwm_pca9685_pin_set_cycles+0xb0>
		return -EINVAL;
  109323:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
}
  109328:	8d 65 f4             	lea    -0xc(%ebp),%esp
  10932b:	5b                   	pop    %ebx
  10932c:	5e                   	pop    %esi
  10932d:	5f                   	pop    %edi
  10932e:	5d                   	pop    %ebp
  10932f:	c3                   	ret    

00109330 <pwm_pca9685_init>:
 *
 * @param dev Device struct
 * @return 0 if successful, failed otherwise.
 */
int pwm_pca9685_init(struct device *dev)
{
  109330:	55                   	push   %ebp
  109331:	89 e5                	mov    %esp,%ebp
  109333:	56                   	push   %esi
  109334:	53                   	push   %ebx
  109335:	83 ec 10             	sub    $0x10,%esp
	const struct pwm_pca9685_config * const config =
		dev->config->config_info;
	struct pwm_pca9685_drv_data * const drv_data =
		(struct pwm_pca9685_drv_data * const)dev->driver_data;
	struct device *i2c_master;
	u8_t buf[] = {0, 0};
  109338:	66 c7 45 ea 00 00    	movw   $0x0,-0x16(%ebp)
{
  10933e:	8b 45 08             	mov    0x8(%ebp),%eax
	const struct pwm_pca9685_config * const config =
  109341:	8b 10                	mov    (%eax),%edx
	struct pwm_pca9685_drv_data * const drv_data =
  109343:	8b 70 08             	mov    0x8(%eax),%esi
	const struct pwm_pca9685_config * const config =
  109346:	8b 5a 08             	mov    0x8(%edx),%ebx
  109349:	ff 33                	pushl  (%ebx)
  10934b:	e8 ae 09 00 00       	call   109cfe <z_impl_device_get_binding>
  109350:	5a                   	pop    %edx
	int ret;

	/* Find out the device struct of the I2C master */
	i2c_master = device_get_binding((char *)config->i2c_master_dev_name);
	if (!i2c_master) {
  109351:	85 c0                	test   %eax,%eax
  109353:	ba ea ff ff ff       	mov    $0xffffffea,%edx
  109358:	74 37                	je     109391 <pwm_pca9685_init+0x61>
	/* MODE1 register */

	buf[0] = REG_MODE1;
	buf[1] = (1 << 5); /* register addr auto increment */

	ret = i2c_write(i2c_master, buf, 2, config->i2c_slave_addr);
  10935a:	0f b7 4b 04          	movzwl 0x4(%ebx),%ecx
	drv_data->i2c_master = i2c_master;
  10935e:	89 06                	mov    %eax,(%esi)
	msg.buf = (u8_t *)buf;
  109360:	8d 55 ea             	lea    -0x16(%ebp),%edx
	msg.flags = I2C_MSG_WRITE | I2C_MSG_STOP;
  109363:	c6 45 f4 02          	movb   $0x2,-0xc(%ebp)
	msg.buf = (u8_t *)buf;
  109367:	89 55 ec             	mov    %edx,-0x14(%ebp)
	return api->transfer(dev, msgs, num_msgs, addr);
  10936a:	8b 50 04             	mov    0x4(%eax),%edx
  10936d:	51                   	push   %ecx
  10936e:	6a 01                	push   $0x1
  109370:	8d 4d ec             	lea    -0x14(%ebp),%ecx
  109373:	51                   	push   %ecx
	buf[0] = REG_MODE1;
  109374:	66 c7 45 ea 00 20    	movw   $0x2000,-0x16(%ebp)
	msg.len = num_bytes;
  10937a:	c7 45 f0 02 00 00 00 	movl   $0x2,-0x10(%ebp)
	return api->transfer(dev, msgs, num_msgs, addr);
  109381:	50                   	push   %eax
  109382:	ff 52 04             	call   *0x4(%edx)
	if (ret != 0) {
  109385:	31 d2                	xor    %edx,%edx
  109387:	83 c4 10             	add    $0x10,%esp
  10938a:	85 c0                	test   %eax,%eax
  10938c:	0f 95 c2             	setne  %dl
  10938f:	f7 da                	neg    %edx
		return -EPERM;
	}

	return 0;
}
  109391:	8d 65 f8             	lea    -0x8(%ebp),%esp
  109394:	89 d0                	mov    %edx,%eax
  109396:	5b                   	pop    %ebx
  109397:	5e                   	pop    %esi
  109398:	5d                   	pop    %ebp
  109399:	c3                   	ret    

0010939a <HCSR1_init>:
	// if(ret<0){
	// 	DPRINTK("Error Enabling callback for %d PIN during HCSR1 initialization.\n", e_Pin);
	// 	return -1;
	// }
	return 0;
}
  10939a:	31 c0                	xor    %eax,%eax
  10939c:	c3                   	ret    

0010939d <hcsr04_sample_fetch>:
	// 	return -1;
	// }
	// // k_sleep(SLEEP_TIME);
	// // k_sem_take(&triggerEcho_sem,K_FOREVER);
	return 0;
}
  10939d:	31 c0                	xor    %eax,%eax
  10939f:	c3                   	ret    

001093a0 <hcsr04_channel_get>:

	// printk("%lld \n", dev_data->data1);
	// printk("%lld \n", dev_data->data2);
	// printk("-----------------------\n");
	return 0;
}
  1093a0:	31 c0                	xor    %eax,%eax
  1093a2:	c3                   	ret    

001093a3 <hcsr04_attr_set>:

static inline int  hcsr04_attr_set(struct device *dev, enum sensor_channel chan, enum sensor_attribute sensorAttr, const struct sensor_value *val){
  1093a3:	55                   	push   %ebp
  1093a4:	89 e5                	mov    %esp,%ebp
	printk("attr_set was called\n");
  1093a6:	68 6b ef 10 00       	push   $0x10ef6b
  1093ab:	e8 61 75 ff ff       	call   100911 <printk>
  1093b0:	58                   	pop    %eax
	return 0;
}
  1093b1:	31 c0                	xor    %eax,%eax
  1093b3:	c9                   	leave  
  1093b4:	c3                   	ret    

001093b5 <HCSR0_init>:
{	
  1093b5:	55                   	push   %ebp
  1093b6:	89 e5                	mov    %esp,%ebp
  1093b8:	53                   	push   %ebx
	struct device_config* dev_Config=dev->config;
  1093b9:	8b 45 08             	mov    0x8(%ebp),%eax
  1093bc:	8b 00                	mov    (%eax),%eax
	struct hcsr_config_data* dev_config_info=dev_Config->config_info;
  1093be:	8b 58 08             	mov    0x8(%eax),%ebx
  1093c1:	68 20 ee 10 00       	push   $0x10ee20
  1093c6:	e8 33 09 00 00       	call   109cfe <z_impl_device_get_binding>
	struct device *gpiob=dev_test->gpio_dw;
  1093cb:	8b 40 08             	mov    0x8(%eax),%eax
  1093ce:	8b 40 10             	mov    0x10(%eax),%eax
	dev_config_info->gpiob_trigger=gpiob;
  1093d1:	89 43 08             	mov    %eax,0x8(%ebx)
	u32_t e_Pin=dev_config_info->echoPin;		
  1093d4:	8b 5b 04             	mov    0x4(%ebx),%ebx
	return api->config(port, access_op, pin, flags);
  1093d7:	8b 50 04             	mov    0x4(%eax),%edx
  1093da:	c7 04 24 26 00 00 00 	movl   $0x26,(%esp)
  1093e1:	53                   	push   %ebx
  1093e2:	6a 00                	push   $0x0
  1093e4:	50                   	push   %eax
  1093e5:	ff 12                	call   *(%edx)
  1093e7:	83 c4 10             	add    $0x10,%esp
	if(ret<0){
  1093ea:	31 d2                	xor    %edx,%edx
  1093ec:	85 c0                	test   %eax,%eax
  1093ee:	79 1b                	jns    10940b <HCSR0_init+0x56>
		DPRINTK("Failed to Configure %d GPIO PIN during HCSR0 initialization.\n", e_Pin);
  1093f0:	53                   	push   %ebx
  1093f1:	68 98 00 00 00       	push   $0x98
  1093f6:	68 c0 dd 10 00       	push   $0x10ddc0
  1093fb:	68 c4 ef 10 00       	push   $0x10efc4
  109400:	e8 0c 75 ff ff       	call   100911 <printk>
  109405:	83 c4 10             	add    $0x10,%esp
		return -1;
  109408:	83 ca ff             	or     $0xffffffff,%edx
}
  10940b:	89 d0                	mov    %edx,%eax
  10940d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  109410:	c9                   	leave  
  109411:	c3                   	ret    

00109412 <spi_config_0_irq>:
	      spi_intel_device_ctrl, &spi_intel_data_port_0,
	      &spi_intel_config_0, POST_KERNEL, CONFIG_SPI_INIT_PRIORITY,
	      &intel_spi_api);

void spi_config_0_irq(void)
{
  109412:	55                   	push   %ebp
  109413:	89 e5                	mov    %esp,%ebp
	IRQ_CONNECT(DT_SPI_0_IRQ, DT_SPI_0_IRQ_PRI,
  109415:	0f b6 05 88 f8 10 00 	movzbl 0x10f888,%eax
	__irq_controller_irq_config(vector, irq, flags);
  10941c:	6a 00                	push   $0x0
  10941e:	6a 10                	push   $0x10
  109420:	50                   	push   %eax
  109421:	e8 43 c7 ff ff       	call   105b69 <__irq_controller_irq_config>
  109426:	83 c4 0c             	add    $0xc,%esp
		    spi_intel_isr, DEVICE_GET(spi_intel_port_0),
		    DT_SPI_0_IRQ_FLAGS);
}
  109429:	c9                   	leave  
  10942a:	c3                   	ret    

0010942b <spi_intel_isr_irq16_stub>:
  10942b:	68 f8 33 11 00       	push   $0x1133f8
  109430:	68 14 95 10 00       	push   $0x109514
  109435:	e9 f2 d3 ff ff       	jmp    10682c <_interrupt_enter>

0010943a <spi_intel_init>:
{
  10943a:	55                   	push   %ebp
  10943b:	89 e5                	mov    %esp,%ebp
  10943d:	57                   	push   %edi
  10943e:	56                   	push   %esi
  10943f:	8b 45 08             	mov    0x8(%ebp),%eax
  109442:	53                   	push   %ebx
	if (!spi_intel_setup(dev)) {
  109443:	8b 58 08             	mov    0x8(%eax),%ebx
	const struct spi_intel_config *info = dev->config->config_info;
  109446:	8b 10                	mov    (%eax),%edx
	if (!pci_bus_scan(&spi->pci_dev)) {
  109448:	8d 7b 5c             	lea    0x5c(%ebx),%edi
	const struct spi_intel_config *info = dev->config->config_info;
  10944b:	8b 72 08             	mov    0x8(%edx),%esi
	pci_bus_scan_init();
  10944e:	e8 1d c9 ff ff       	call   105d70 <pci_bus_scan_init>
	if (!pci_bus_scan(&spi->pci_dev)) {
  109453:	57                   	push   %edi
  109454:	e8 4a c9 ff ff       	call   105da3 <pci_bus_scan>
  109459:	83 ca ff             	or     $0xffffffff,%edx
  10945c:	59                   	pop    %ecx
  10945d:	85 c0                	test   %eax,%eax
  10945f:	74 1a                	je     10947b <spi_intel_init+0x41>
	spi->regs = spi->pci_dev.addr;
  109461:	8b 43 5c             	mov    0x5c(%ebx),%eax
  109464:	89 43 58             	mov    %eax,0x58(%ebx)
	pci_enable_regs(&spi->pci_dev);
  109467:	57                   	push   %edi
  109468:	e8 03 cf ff ff       	call   106370 <pci_enable_regs>
  10946d:	58                   	pop    %eax
	info->config_func();
  10946e:	ff 56 04             	call   *0x4(%esi)
	irq_enable(info->irq);
  109471:	ff 36                	pushl  (%esi)
  109473:	e8 17 c7 ff ff       	call   105b8f <z_arch_irq_enable>
  109478:	5a                   	pop    %edx
	return 0;
  109479:	31 d2                	xor    %edx,%edx
}
  10947b:	8d 65 f4             	lea    -0xc(%ebp),%esp
  10947e:	89 d0                	mov    %edx,%eax
  109480:	5b                   	pop    %ebx
  109481:	5e                   	pop    %esi
  109482:	5f                   	pop    %edi
  109483:	5d                   	pop    %ebp
  109484:	c3                   	ret    

00109485 <gpio_pin_write>:
{
  109485:	55                   	push   %ebp
  109486:	89 e5                	mov    %esp,%ebp
  109488:	53                   	push   %ebx
	return api->write(port, access_op, pin, value);
  109489:	8b 58 04             	mov    0x4(%eax),%ebx
  10948c:	51                   	push   %ecx
  10948d:	52                   	push   %edx
  10948e:	6a 00                	push   $0x0
  109490:	50                   	push   %eax
  109491:	ff 53 04             	call   *0x4(%ebx)
  109494:	83 c4 10             	add    $0x10,%esp
}
  109497:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  10949a:	c9                   	leave  
  10949b:	c3                   	ret    

0010949c <_spi_context_cs_control>:
	}
}

static inline void _spi_context_cs_control(struct spi_context *ctx,
					   bool on, bool force_off)
{
  10949c:	55                   	push   %ebp
  10949d:	89 e5                	mov    %esp,%ebp
  10949f:	57                   	push   %edi
  1094a0:	56                   	push   %esi
  1094a1:	53                   	push   %ebx
	if (ctx->config && ctx->config->cs && ctx->config->cs->gpio_dev) {
  1094a2:	8b 38                	mov    (%eax),%edi
  1094a4:	85 ff                	test   %edi,%edi
  1094a6:	74 64                	je     10950c <_spi_context_cs_control+0x70>
  1094a8:	8b 77 08             	mov    0x8(%edi),%esi
  1094ab:	85 f6                	test   %esi,%esi
  1094ad:	74 5d                	je     10950c <_spi_context_cs_control+0x70>
  1094af:	89 c3                	mov    %eax,%ebx
  1094b1:	8b 06                	mov    (%esi),%eax
  1094b3:	85 c0                	test   %eax,%eax
  1094b5:	74 55                	je     10950c <_spi_context_cs_control+0x70>
		if (on) {
  1094b7:	84 d2                	test   %dl,%dl
  1094b9:	74 1f                	je     1094da <_spi_context_cs_control+0x3e>
	if (ctx->config->operation & SPI_CS_ACTIVE_HIGH) {
  1094bb:	0f bf 4f 04          	movswl 0x4(%edi),%ecx
  1094bf:	c1 e9 1f             	shr    $0x1f,%ecx
			gpio_pin_write(ctx->config->cs->gpio_dev,
  1094c2:	8b 56 04             	mov    0x4(%esi),%edx
  1094c5:	e8 bb ff ff ff       	call   109485 <gpio_pin_write>
				       ctx->config->cs->gpio_pin,
				       spi_context_cs_active_value(ctx));
			k_busy_wait(ctx->config->cs->delay);
  1094ca:	8b 03                	mov    (%ebx),%eax
  1094cc:	8b 40 08             	mov    0x8(%eax),%eax
K_SYSCALL_DECLARE1_VOID(K_SYSCALL_K_BUSY_WAIT, k_busy_wait, u32_t, usec_to_wait)
  1094cf:	ff 70 08             	pushl  0x8(%eax)
  1094d2:	e8 c2 17 00 00       	call   10ac99 <z_impl_k_busy_wait>
  1094d7:	5a                   	pop    %edx
  1094d8:	eb 32                	jmp    10950c <_spi_context_cs_control+0x70>
		} else {
			if (!force_off &&
  1094da:	84 c9                	test   %cl,%cl
  1094dc:	75 06                	jne    1094e4 <_spi_context_cs_control+0x48>
  1094de:	f6 47 05 20          	testb  $0x20,0x5(%edi)
  1094e2:	75 28                	jne    10950c <_spi_context_cs_control+0x70>
  1094e4:	ff 76 08             	pushl  0x8(%esi)
  1094e7:	e8 ad 17 00 00       	call   10ac99 <z_impl_k_busy_wait>
			}

			k_busy_wait(ctx->config->cs->delay);
			gpio_pin_write(ctx->config->cs->gpio_dev,
				       ctx->config->cs->gpio_pin,
				       spi_context_cs_inactive_value(ctx));
  1094ec:	8b 13                	mov    (%ebx),%edx
  1094ee:	58                   	pop    %eax
				       ctx->config->cs->gpio_pin,
  1094ef:	8b 42 08             	mov    0x8(%edx),%eax
	if (ctx->config->operation & SPI_CS_ACTIVE_HIGH) {
  1094f2:	0f bf 4a 04          	movswl 0x4(%edx),%ecx
			gpio_pin_write(ctx->config->cs->gpio_dev,
  1094f6:	8b 50 04             	mov    0x4(%eax),%edx
  1094f9:	8b 00                	mov    (%eax),%eax
		}
	}
}
  1094fb:	8d 65 f4             	lea    -0xc(%ebp),%esp
	if (ctx->config->operation & SPI_CS_ACTIVE_HIGH) {
  1094fe:	f7 d1                	not    %ecx
  109500:	c1 e9 1f             	shr    $0x1f,%ecx
}
  109503:	5b                   	pop    %ebx
  109504:	5e                   	pop    %esi
  109505:	5f                   	pop    %edi
  109506:	5d                   	pop    %ebp
			gpio_pin_write(ctx->config->cs->gpio_dev,
  109507:	e9 79 ff ff ff       	jmp    109485 <gpio_pin_write>
}
  10950c:	8d 65 f4             	lea    -0xc(%ebp),%esp
  10950f:	5b                   	pop    %ebx
  109510:	5e                   	pop    %esi
  109511:	5f                   	pop    %edi
  109512:	5d                   	pop    %ebp
  109513:	c3                   	ret    

00109514 <spi_intel_isr>:
{
  109514:	55                   	push   %ebp
  109515:	89 e5                	mov    %esp,%ebp
  109517:	57                   	push   %edi
  109518:	56                   	push   %esi
  109519:	53                   	push   %ebx
  10951a:	83 ec 0c             	sub    $0xc,%esp
  10951d:	8b 45 08             	mov    0x8(%ebp),%eax
  109520:	89 45 f0             	mov    %eax,-0x10(%ebp)
	struct spi_intel_data *spi = dev->driver_data;
  109523:	8b 70 08             	mov    0x8(%eax),%esi
		sys_write##__sz(data, addr + __off);			\
	}

DEFINE_MM_REG_WRITE(sscr0, INTEL_SPI_REG_SSCR0, 32)
DEFINE_MM_REG_WRITE(sscr1, INTEL_SPI_REG_SSCR1, 32)
DEFINE_MM_REG_READ(sssr, INTEL_SPI_REG_SSSR, 32)
  109526:	8b 46 58             	mov    0x58(%esi),%eax
	__asm__ volatile("movl	%1, %0;\n\t"
  109529:	8b 40 08             	mov    0x8(%eax),%eax
  10952c:	89 45 ec             	mov    %eax,-0x14(%ebp)
	if (status & INTEL_SPI_SSSR_ROR) {
  10952f:	a8 80                	test   $0x80,%al
  109531:	8b 45 f0             	mov    -0x10(%ebp),%eax
  109534:	8b 48 08             	mov    0x8(%eax),%ecx
  109537:	74 14                	je     10954d <spi_intel_isr+0x39>
DEFINE_CLEAR_BIT_OP(sscr0_sse, INTEL_SPI_REG_SSCR0, INTEL_SPI_SSCR0_SSE_BIT)
DEFINE_TEST_BIT_OP(sscr0_sse, INTEL_SPI_REG_SSCR0, INTEL_SPI_SSCR0_SSE_BIT)
DEFINE_TEST_BIT_OP(sssr_bsy, INTEL_SPI_REG_SSSR, INTEL_SPI_SSSR_BSY_BIT)
DEFINE_CLEAR_BIT_OP(sscr1_tie, INTEL_SPI_REG_SSCR1, INTEL_SPI_SSCR1_TIE_BIT)
DEFINE_TEST_BIT_OP(sscr1_tie, INTEL_SPI_REG_SSCR1, INTEL_SPI_SSCR1_TIE_BIT)
DEFINE_CLEAR_BIT_OP(sssr_ror, INTEL_SPI_REG_SSSR, INTEL_SPI_SSSR_ROR_BIT)
  109539:	8b 46 58             	mov    0x58(%esi),%eax
	__asm__ volatile("btrl	%1, %0;\n\t"
  10953c:	0f ba 70 08 07       	btrl   $0x7,0x8(%eax)
		error = 1U;
  109541:	bb 01 00 00 00       	mov    $0x1,%ebx
	completed(dev, error);
  109546:	89 ce                	mov    %ecx,%esi
	if (error) {
  109548:	e9 6e 01 00 00       	jmp    1096bb <spi_intel_isr+0x1a7>
	if (status & INTEL_SPI_SSSR_RFS) {
  10954d:	f6 45 ec 40          	testb  $0x40,-0x14(%ebp)
  109551:	75 2a                	jne    10957d <spi_intel_isr+0x69>
DEFINE_TEST_BIT_OP(sscr1_tie, INTEL_SPI_REG_SSCR1, INTEL_SPI_SSCR1_TIE_BIT)
  109553:	8b 46 58             	mov    0x58(%esi),%eax
static ALWAYS_INLINE
	int sys_test_bit(mem_addr_t addr, unsigned int bit)
{
	int ret;

	__asm__ volatile("btl	%2, %1;\n\t"
  109556:	0f ba 60 04 01       	btl    $0x1,0x4(%eax)
  10955b:	19 d2                	sbb    %edx,%edx
			 "sbb	%0, %0\n\t"
			 : "=r" (ret), "+m" (*(volatile u32_t *) (addr))
			 : "Ir" (bit));

	return ret;
  10955d:	8b 45 f0             	mov    -0x10(%ebp),%eax
	if (test_bit_sscr1_tie(spi->regs)) {
  109560:	85 d2                	test   %edx,%edx
  109562:	8b 78 08             	mov    0x8(%eax),%edi
  109565:	0f 85 81 00 00 00    	jne    1095ec <spi_intel_isr+0xd8>
  10956b:	e9 3c 01 00 00       	jmp    1096ac <spi_intel_isr+0x198>
DEFINE_MM_REG_READ(ssdr, INTEL_SPI_REG_SSDR, 32)
  109570:	8b 41 58             	mov    0x58(%ecx),%eax
	__asm__ volatile("movl	%1, %0;\n\t"
  109573:	8b 78 10             	mov    0x10(%eax),%edi
}

static ALWAYS_INLINE
bool spi_context_rx_buf_on(struct spi_context *ctx)
{
	return !!(ctx->rx_buf && ctx->rx_len);
  109576:	8b 51 50             	mov    0x50(%ecx),%edx
  109579:	85 d2                	test   %edx,%edx
  10957b:	75 0c                	jne    109589 <spi_intel_isr+0x75>
DEFINE_MM_REG_READ(sssr, INTEL_SPI_REG_SSSR, 32)
  10957d:	8b 41 58             	mov    0x58(%ecx),%eax
  109580:	8b 40 08             	mov    0x8(%eax),%eax
	while (read_sssr(spi->regs) & INTEL_SPI_SSSR_RNE) {
  109583:	a8 08                	test   $0x8,%al
  109585:	75 e9                	jne    109570 <spi_intel_isr+0x5c>
  109587:	eb ca                	jmp    109553 <spi_intel_isr+0x3f>
  109589:	8b 41 54             	mov    0x54(%ecx),%eax
  10958c:	89 45 e8             	mov    %eax,-0x18(%ebp)
  10958f:	85 c0                	test   %eax,%eax
  109591:	74 ea                	je     10957d <spi_intel_isr+0x69>
			switch (spi->dfs) {
  109593:	0f b6 41 78          	movzbl 0x78(%ecx),%eax
  109597:	3c 02                	cmp    $0x2,%al
  109599:	74 0e                	je     1095a9 <spi_intel_isr+0x95>
  10959b:	3c 04                	cmp    $0x4,%al
  10959d:	74 0f                	je     1095ae <spi_intel_isr+0x9a>
  10959f:	3c 01                	cmp    $0x1,%al
  1095a1:	75 0d                	jne    1095b0 <spi_intel_isr+0x9c>
				UNALIGNED_PUT(data, (u8_t *)spi->ctx.rx_buf);
  1095a3:	89 fb                	mov    %edi,%ebx
  1095a5:	88 1a                	mov    %bl,(%edx)
				break;
  1095a7:	eb 07                	jmp    1095b0 <spi_intel_isr+0x9c>
				UNALIGNED_PUT(data, (u16_t *)spi->ctx.rx_buf);
  1095a9:	66 89 3a             	mov    %di,(%edx)
				break;
  1095ac:	eb 02                	jmp    1095b0 <spi_intel_isr+0x9c>
				UNALIGNED_PUT(data, (u32_t *)spi->ctx.rx_buf);
  1095ae:	89 3a                	mov    %edi,(%edx)
	ctx->rx_len -= len;
  1095b0:	8b 7d e8             	mov    -0x18(%ebp),%edi
  1095b3:	4f                   	dec    %edi
  1095b4:	89 79 54             	mov    %edi,0x54(%ecx)
	if (!ctx->rx_len) {
  1095b7:	75 2c                	jne    1095e5 <spi_intel_isr+0xd1>
		if (ctx->rx_count) {
  1095b9:	ff 49 44             	decl   0x44(%ecx)
  1095bc:	74 1e                	je     1095dc <spi_intel_isr+0xc8>
			ctx->current_rx++;
  1095be:	8b 51 40             	mov    0x40(%ecx),%edx
  1095c1:	8d 7a 08             	lea    0x8(%edx),%edi
  1095c4:	89 79 40             	mov    %edi,0x40(%ecx)
			ctx->rx_buf = (u8_t *)ctx->current_rx->buf;
  1095c7:	8b 7a 08             	mov    0x8(%edx),%edi
  1095ca:	89 79 50             	mov    %edi,0x50(%ecx)
			ctx->rx_len = ctx->current_rx->len / dfs;
  1095cd:	0f b6 f8             	movzbl %al,%edi
  1095d0:	8b 42 0c             	mov    0xc(%edx),%eax
  1095d3:	31 d2                	xor    %edx,%edx
  1095d5:	f7 f7                	div    %edi
  1095d7:	89 41 54             	mov    %eax,0x54(%ecx)
  1095da:	eb a1                	jmp    10957d <spi_intel_isr+0x69>
			ctx->rx_buf = NULL;
  1095dc:	c7 41 50 00 00 00 00 	movl   $0x0,0x50(%ecx)
  1095e3:	eb 98                	jmp    10957d <spi_intel_isr+0x69>
		ctx->rx_buf += dfs * len;
  1095e5:	01 c2                	add    %eax,%edx
  1095e7:	89 51 50             	mov    %edx,0x50(%ecx)
  1095ea:	eb 91                	jmp    10957d <spi_intel_isr+0x69>
		if (status & INTEL_SPI_SSSR_TFS) {
  1095ec:	89 fe                	mov    %edi,%esi
  1095ee:	f6 45 ec 20          	testb  $0x20,-0x14(%ebp)
  1095f2:	0f 84 b6 00 00 00    	je     1096ae <spi_intel_isr+0x19a>
  1095f8:	8b 47 58             	mov    0x58(%edi),%eax
  1095fb:	8b 40 08             	mov    0x8(%eax),%eax
	while ((status = read_sssr(spi->regs)) & INTEL_SPI_SSSR_TNF) {
  1095fe:	a8 04                	test   $0x4,%al
  109600:	0f 84 8e 00 00 00    	je     109694 <spi_intel_isr+0x180>
		if (status & INTEL_SPI_SSSR_RFS) {
  109606:	83 e0 40             	and    $0x40,%eax
  109609:	0f 85 85 00 00 00    	jne    109694 <spi_intel_isr+0x180>
	return !!(ctx->tx_buf && ctx->tx_len);
  10960f:	8b 4f 48             	mov    0x48(%edi),%ecx
  109612:	85 c9                	test   %ecx,%ecx
  109614:	74 23                	je     109639 <spi_intel_isr+0x125>
  109616:	83 7f 4c 00          	cmpl   $0x0,0x4c(%edi)
  10961a:	74 1d                	je     109639 <spi_intel_isr+0x125>
			switch (spi->dfs) {
  10961c:	8a 57 78             	mov    0x78(%edi),%dl
  10961f:	80 fa 02             	cmp    $0x2,%dl
  109622:	74 0e                	je     109632 <spi_intel_isr+0x11e>
  109624:	80 fa 04             	cmp    $0x4,%dl
  109627:	74 0e                	je     109637 <spi_intel_isr+0x123>
  109629:	fe ca                	dec    %dl
  10962b:	75 0c                	jne    109639 <spi_intel_isr+0x125>
				data = UNALIGNED_GET((u8_t *)
  10962d:	0f b6 01             	movzbl (%ecx),%eax
				break;
  109630:	eb 07                	jmp    109639 <spi_intel_isr+0x125>
				data = UNALIGNED_GET((u16_t *)
  109632:	0f b7 01             	movzwl (%ecx),%eax
				break;
  109635:	eb 02                	jmp    109639 <spi_intel_isr+0x125>
				data = UNALIGNED_GET((u32_t *)
  109637:	8b 01                	mov    (%ecx),%eax
DEFINE_MM_REG_WRITE(ssdr, INTEL_SPI_REG_SSDR, 32)
  109639:	8b 57 58             	mov    0x58(%edi),%edx
	__asm__ volatile("movl	%0, %1;\n\t"
  10963c:	89 42 10             	mov    %eax,0x10(%edx)
	if (!ctx->tx_len) {
  10963f:	8b 57 4c             	mov    0x4c(%edi),%edx
  109642:	85 d2                	test   %edx,%edx
  109644:	74 b2                	je     1095f8 <spi_intel_isr+0xe4>
	ctx->tx_len -= len;
  109646:	4a                   	dec    %edx
		spi_context_update_tx(&spi->ctx, spi->dfs, 1);
  109647:	0f b6 47 78          	movzbl 0x78(%edi),%eax
  10964b:	89 57 4c             	mov    %edx,0x4c(%edi)
	if (!ctx->tx_len) {
  10964e:	75 2f                	jne    10967f <spi_intel_isr+0x16b>
		if (ctx->tx_count) {
  109650:	ff 4f 3c             	decl   0x3c(%edi)
  109653:	74 1e                	je     109673 <spi_intel_isr+0x15f>
			ctx->current_tx++;
  109655:	8b 57 38             	mov    0x38(%edi),%edx
  109658:	8d 4a 08             	lea    0x8(%edx),%ecx
  10965b:	89 4f 38             	mov    %ecx,0x38(%edi)
			ctx->tx_buf = (const u8_t *)ctx->current_tx->buf;
  10965e:	8b 4a 08             	mov    0x8(%edx),%ecx
  109661:	89 4f 48             	mov    %ecx,0x48(%edi)
			ctx->tx_len = ctx->current_tx->len / dfs;
  109664:	0f b6 c8             	movzbl %al,%ecx
  109667:	8b 42 0c             	mov    0xc(%edx),%eax
  10966a:	31 d2                	xor    %edx,%edx
  10966c:	f7 f1                	div    %ecx
  10966e:	89 47 4c             	mov    %eax,0x4c(%edi)
  109671:	eb 85                	jmp    1095f8 <spi_intel_isr+0xe4>
			ctx->tx_buf = NULL;
  109673:	c7 47 48 00 00 00 00 	movl   $0x0,0x48(%edi)
  10967a:	e9 79 ff ff ff       	jmp    1095f8 <spi_intel_isr+0xe4>
	} else if (ctx->tx_buf) {
  10967f:	8b 57 48             	mov    0x48(%edi),%edx
  109682:	85 d2                	test   %edx,%edx
  109684:	0f 84 6e ff ff ff    	je     1095f8 <spi_intel_isr+0xe4>
		ctx->tx_buf += dfs * len;
  10968a:	01 c2                	add    %eax,%edx
  10968c:	89 57 48             	mov    %edx,0x48(%edi)
  10968f:	e9 64 ff ff ff       	jmp    1095f8 <spi_intel_isr+0xe4>
	return !!(ctx->tx_len);
  109694:	8b 45 f0             	mov    -0x10(%ebp),%eax
	if (!spi_context_tx_on(&spi->ctx)) {
  109697:	83 7f 4c 00          	cmpl   $0x0,0x4c(%edi)
  10969b:	8b 48 08             	mov    0x8(%eax),%ecx
  10969e:	75 08                	jne    1096a8 <spi_intel_isr+0x194>
DEFINE_CLEAR_BIT_OP(sscr1_tie, INTEL_SPI_REG_SSCR1, INTEL_SPI_SSCR1_TIE_BIT)
  1096a0:	8b 47 58             	mov    0x58(%edi),%eax
	__asm__ volatile("btrl	%1, %0;\n\t"
  1096a3:	0f ba 70 04 01       	btrl   $0x1,0x4(%eax)
	completed(dev, error);
  1096a8:	89 ce                	mov    %ecx,%esi
	if (error) {
  1096aa:	eb 02                	jmp    1096ae <spi_intel_isr+0x19a>
	completed(dev, error);
  1096ac:	89 fe                	mov    %edi,%esi
	if (spi_context_tx_on(&spi->ctx) ||
  1096ae:	83 7e 4c 00          	cmpl   $0x0,0x4c(%esi)
  1096b2:	75 41                	jne    1096f5 <spi_intel_isr+0x1e1>
	return !!(ctx->rx_len);
  1096b4:	8b 5e 54             	mov    0x54(%esi),%ebx
  1096b7:	85 db                	test   %ebx,%ebx
  1096b9:	75 3a                	jne    1096f5 <spi_intel_isr+0x1e1>
	write_sscr1(spi->sscr1, spi->regs);
  1096bb:	8b 46 74             	mov    0x74(%esi),%eax
DEFINE_MM_REG_WRITE(sscr1, INTEL_SPI_REG_SSCR1, 32)
  1096be:	8b 56 58             	mov    0x58(%esi),%edx
	__asm__ volatile("movl	%0, %1;\n\t"
  1096c1:	89 42 04             	mov    %eax,0x4(%edx)
			 : "+m" (*(volatile u32_t *) (addr))
  1096c4:	8b 46 58             	mov    0x58(%esi),%eax
	__asm__ volatile("btrl	%1, %0;\n\t"
  1096c7:	0f ba 30 07          	btrl   $0x7,(%eax)
	_spi_context_cs_control(ctx, on, false);
  1096cb:	31 c9                	xor    %ecx,%ecx
  1096cd:	89 f0                	mov    %esi,%eax
  1096cf:	31 d2                	xor    %edx,%edx
  1096d1:	e8 c6 fd ff ff       	call   10949c <_spi_context_cs_control>
	spi_context_complete(&spi->ctx, error ? -EIO : 0);
  1096d6:	83 fb 01             	cmp    $0x1,%ebx
  1096d9:	19 c0                	sbb    %eax,%eax
	k_sem_give(&ctx->sync);
  1096db:	8d 4e 1c             	lea    0x1c(%esi),%ecx
  1096de:	f7 d0                	not    %eax
  1096e0:	83 e0 fb             	and    $0xfffffffb,%eax
	ctx->sync_status = status;
  1096e3:	89 46 34             	mov    %eax,0x34(%esi)
	k_sem_give(&ctx->sync);
  1096e6:	89 4d 08             	mov    %ecx,0x8(%ebp)
}
  1096e9:	83 c4 0c             	add    $0xc,%esp
  1096ec:	5b                   	pop    %ebx
  1096ed:	5e                   	pop    %esi
  1096ee:	5f                   	pop    %edi
  1096ef:	5d                   	pop    %ebp
K_SYSCALL_DECLARE1_VOID(K_SYSCALL_K_SEM_GIVE, k_sem_give, struct k_sem *, sem)
  1096f0:	e9 56 14 00 00       	jmp    10ab4b <z_impl_k_sem_give>
  1096f5:	83 c4 0c             	add    $0xc,%esp
  1096f8:	5b                   	pop    %ebx
  1096f9:	5e                   	pop    %esi
  1096fa:	5f                   	pop    %edi
  1096fb:	5d                   	pop    %ebp
  1096fc:	c3                   	ret    

001096fd <spi_intel_transceive>:
{
  1096fd:	55                   	push   %ebp
  1096fe:	89 e5                	mov    %esp,%ebp
  109700:	57                   	push   %edi
  109701:	56                   	push   %esi
  109702:	53                   	push   %ebx
  109703:	83 ec 08             	sub    $0x8,%esp
  109706:	8b 75 08             	mov    0x8(%ebp),%esi
  109709:	8b 7d 0c             	mov    0xc(%ebp),%edi
	struct spi_intel_data *spi = dev->driver_data;
  10970c:	8b 5e 08             	mov    0x8(%esi),%ebx
			 : "=r" (ret), "+m" (*(volatile u32_t *) (addr))
  10970f:	8b 43 58             	mov    0x58(%ebx),%eax
	__asm__ volatile("btl	%2, %1;\n\t"
  109712:	0f ba 20 07          	btl    $0x7,(%eax)
  109716:	19 d2                	sbb    %edx,%edx
	if (test_bit_sscr0_sse(spi->regs) && test_bit_sssr_bsy(spi->regs)) {
  109718:	85 d2                	test   %edx,%edx
  10971a:	75 1c                	jne    109738 <spi_intel_transceive+0x3b>
K_SYSCALL_DECLARE2(K_SYSCALL_K_SEM_TAKE, k_sem_take, int, struct k_sem *, sem, s32_t, timeout)
  10971c:	6a ff                	push   $0xffffffff
	k_sem_take(&ctx->lock, K_FOREVER);
  10971e:	8d 43 04             	lea    0x4(%ebx),%eax
  109721:	50                   	push   %eax
  109722:	89 45 f0             	mov    %eax,-0x10(%ebp)
  109725:	e8 8a 14 00 00       	call   10abb4 <z_impl_k_sem_take>
	ret = spi_intel_configure(dev, config);
  10972a:	8b 76 08             	mov    0x8(%esi),%esi
  10972d:	58                   	pop    %eax
	if (spi_context_configured(&spi->ctx, config)) {
  10972e:	3b 3e                	cmp    (%esi),%edi
  109730:	5a                   	pop    %edx
  109731:	75 1d                	jne    109750 <spi_intel_transceive+0x53>
  109733:	e9 01 01 00 00       	jmp    109839 <spi_intel_transceive+0x13c>
DEFINE_TEST_BIT_OP(sssr_bsy, INTEL_SPI_REG_SSSR, INTEL_SPI_SSSR_BSY_BIT)
  109738:	8b 43 58             	mov    0x58(%ebx),%eax
  10973b:	0f ba 60 08 04       	btl    $0x4,0x8(%eax)
  109740:	19 d2                	sbb    %edx,%edx
		return -EBUSY;
  109742:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
	if (test_bit_sscr0_sse(spi->regs) && test_bit_sssr_bsy(spi->regs)) {
  109747:	85 d2                	test   %edx,%edx
  109749:	74 d1                	je     10971c <spi_intel_transceive+0x1f>
  10974b:	e9 c2 01 00 00       	jmp    109912 <spi_intel_transceive+0x215>
	if (config->operation & (SPI_OP_MODE_SLAVE || SPI_TRANSFER_LSB
  109750:	0f b7 57 04          	movzwl 0x4(%edi),%edx
  109754:	89 d1                	mov    %edx,%ecx
		return -EINVAL;
  109756:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
	if (config->operation & (SPI_OP_MODE_SLAVE || SPI_TRANSFER_LSB
  10975b:	80 e1 01             	and    $0x1,%cl
  10975e:	0f 85 9f 01 00 00    	jne    109903 <spi_intel_transceive+0x206>
	spi->dfs = SPI_WS_TO_DFS(SPI_WORD_SIZE_GET(config->operation));
  109764:	89 d0                	mov    %edx,%eax
  109766:	c1 fa 05             	sar    $0x5,%edx
  109769:	c1 f8 08             	sar    $0x8,%eax
  10976c:	83 e2 07             	and    $0x7,%edx
  10976f:	83 e0 07             	and    $0x7,%eax
  109772:	83 fa 01             	cmp    $0x1,%edx
  109775:	1c ff                	sbb    $0xff,%al
			 : "r"(data), "m" (*(volatile u32_t *) addr)
  109777:	8b 56 58             	mov    0x58(%esi),%edx
  10977a:	88 46 78             	mov    %al,0x78(%esi)
	__asm__ volatile("movl	%0, %1;\n\t"
  10977d:	31 c0                	xor    %eax,%eax
  10977f:	89 02                	mov    %eax,(%edx)
DEFINE_MM_REG_WRITE(sscr1, INTEL_SPI_REG_SSCR1, 32)
  109781:	8b 56 58             	mov    0x58(%esi),%edx
  109784:	89 42 04             	mov    %eax,0x4(%edx)
	spi->sscr0 = INTEL_SPI_SSCR0_DSS(SPI_WORD_SIZE_GET(config->operation)) |
  109787:	0f b7 57 04          	movzwl 0x4(%edi),%edx
  10978b:	89 d0                	mov    %edx,%eax
  10978d:	89 d1                	mov    %edx,%ecx
  10978f:	c1 f8 05             	sar    $0x5,%eax
		INTEL_SPI_SSCR0_SCR(config->operation);
  109792:	c1 e2 08             	shl    $0x8,%edx
	spi->sscr0 = INTEL_SPI_SSCR0_DSS(SPI_WORD_SIZE_GET(config->operation)) |
  109795:	83 e0 3f             	and    $0x3f,%eax
  109798:	48                   	dec    %eax
		INTEL_SPI_SSCR0_SCR(config->operation);
  109799:	0f b7 d2             	movzwl %dx,%edx
	spi->sscr0 = INTEL_SPI_SSCR0_DSS(SPI_WORD_SIZE_GET(config->operation)) |
  10979c:	09 c2                	or     %eax,%edx
  10979e:	89 56 70             	mov    %edx,0x70(%esi)
	if (SPI_MODE_GET(config->operation) & SPI_MODE_CPOL) {
  1097a1:	f6 c1 02             	test   $0x2,%cl
  1097a4:	75 09                	jne    1097af <spi_intel_transceive+0xb2>
	spi->sscr1 = INTEL_SPI_SSCR1_TFT(INTEL_SPI_SSCR1_TFT_DFLT) |
  1097a6:	c7 46 74 c0 01 00 00 	movl   $0x1c0,0x74(%esi)
  1097ad:	eb 07                	jmp    1097b6 <spi_intel_transceive+0xb9>
		spi->sscr1 |= INTEL_SPI_SSCR1_SPO;
  1097af:	c7 46 74 c8 01 00 00 	movl   $0x1c8,0x74(%esi)
	if (SPI_MODE_GET(config->operation) & SPI_MODE_CPHA) {
  1097b6:	f6 c1 04             	test   $0x4,%cl
  1097b9:	74 04                	je     1097bf <spi_intel_transceive+0xc2>
		spi->sscr1 |= INTEL_SPI_SSCR1_SPH;
  1097bb:	83 4e 74 10          	orl    $0x10,0x74(%esi)
	if (SPI_MODE_GET(config->operation) & SPI_MODE_LOOP) {
  1097bf:	80 e1 08             	and    $0x8,%cl
  1097c2:	74 04                	je     1097c8 <spi_intel_transceive+0xcb>
		spi->sscr1 |= INTEL_SPI_SSCR1_LBM;
  1097c4:	83 4e 74 04          	orl    $0x4,0x74(%esi)
	write_dds_rate(INTEL_SPI_DSS_RATE(config->frequency), spi->regs);
  1097c8:	8b 07                	mov    (%edi),%eax
DEFINE_MM_REG_WRITE(dds_rate, INTEL_SPI_REG_DDS_RATE, 32)
  1097ca:	8b 56 58             	mov    0x58(%esi),%edx
  1097cd:	c1 e8 08             	shr    $0x8,%eax
  1097d0:	89 42 28             	mov    %eax,0x28(%edx)
	if (ctx->config->cs && ctx->config->cs->gpio_dev) {
  1097d3:	8b 06                	mov    (%esi),%eax
  1097d5:	8b 50 08             	mov    0x8(%eax),%edx
  1097d8:	85 d2                	test   %edx,%edx
  1097da:	74 30                	je     10980c <spi_intel_transceive+0x10f>
  1097dc:	8b 02                	mov    (%edx),%eax
  1097de:	85 c0                	test   %eax,%eax
  1097e0:	74 2a                	je     10980c <spi_intel_transceive+0x10f>
	return api->config(port, access_op, pin, flags);
  1097e2:	8b 48 04             	mov    0x4(%eax),%ecx
  1097e5:	6a 01                	push   $0x1
  1097e7:	ff 72 04             	pushl  0x4(%edx)
  1097ea:	6a 00                	push   $0x0
  1097ec:	50                   	push   %eax
  1097ed:	ff 11                	call   *(%ecx)
			       spi_context_cs_inactive_value(ctx));
  1097ef:	8b 16                	mov    (%esi),%edx
  1097f1:	83 c4 10             	add    $0x10,%esp
	if (ctx->config->operation & SPI_CS_ACTIVE_HIGH) {
  1097f4:	0f bf 4a 04          	movswl 0x4(%edx),%ecx
			       ctx->config->cs->gpio_pin,
  1097f8:	8b 42 08             	mov    0x8(%edx),%eax
	if (ctx->config->operation & SPI_CS_ACTIVE_HIGH) {
  1097fb:	f7 d1                	not    %ecx
  1097fd:	c1 e9 1f             	shr    $0x1f,%ecx
		gpio_pin_write(ctx->config->cs->gpio_dev,
  109800:	8b 50 04             	mov    0x4(%eax),%edx
  109803:	8b 00                	mov    (%eax),%eax
  109805:	e8 7b fc ff ff       	call   109485 <gpio_pin_write>
	if (ret) {
  10980a:	eb 2d                	jmp    109839 <spi_intel_transceive+0x13c>
		LOG_INF("CS control inhibited (no GPIO device)");
  10980c:	a1 1c 34 11 00       	mov    0x11341c,%eax
  109811:	83 e0 07             	and    $0x7,%eax
  109814:	83 f8 02             	cmp    $0x2,%eax
  109817:	76 20                	jbe    109839 <spi_intel_transceive+0x13c>
  109819:	b8 10 ba 10 00       	mov    $0x10ba10,%eax
  10981e:	2d e0 b9 10 00       	sub    $0x10b9e0,%eax
  109823:	c1 e8 03             	shr    $0x3,%eax
  109826:	c1 e0 06             	shl    $0x6,%eax
  109829:	83 c8 03             	or     $0x3,%eax
  10982c:	50                   	push   %eax
  10982d:	68 2a f0 10 00       	push   $0x10f02a
  109832:	e8 cf 79 ff ff       	call   101206 <log_0>
  109837:	5e                   	pop    %esi
  109838:	5f                   	pop    %edi
	spi_context_buffers_setup(&spi->ctx, tx_bufs, rx_bufs, spi->dfs);
  109839:	0f b6 4b 78          	movzbl 0x78(%ebx),%ecx
	if (tx_bufs) {
  10983d:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  109841:	74 25                	je     109868 <spi_intel_transceive+0x16b>
		ctx->current_tx = tx_bufs->buffers;
  109843:	8b 45 10             	mov    0x10(%ebp),%eax
		ctx->tx_count = tx_bufs->count;
  109846:	8b 7d 10             	mov    0x10(%ebp),%edi
		ctx->tx_len = ctx->current_tx->len / dfs;
  109849:	0f b6 f1             	movzbl %cl,%esi
		ctx->current_tx = tx_bufs->buffers;
  10984c:	8b 00                	mov    (%eax),%eax
		ctx->tx_count = tx_bufs->count;
  10984e:	8b 57 04             	mov    0x4(%edi),%edx
  109851:	89 53 3c             	mov    %edx,0x3c(%ebx)
		ctx->current_tx = tx_bufs->buffers;
  109854:	89 43 38             	mov    %eax,0x38(%ebx)
		ctx->tx_buf = (const u8_t *)ctx->current_tx->buf;
  109857:	8b 10                	mov    (%eax),%edx
		ctx->tx_len = ctx->current_tx->len / dfs;
  109859:	8b 40 04             	mov    0x4(%eax),%eax
		ctx->tx_buf = (const u8_t *)ctx->current_tx->buf;
  10985c:	89 53 48             	mov    %edx,0x48(%ebx)
		ctx->tx_len = ctx->current_tx->len / dfs;
  10985f:	31 d2                	xor    %edx,%edx
  109861:	f7 f6                	div    %esi
  109863:	89 43 4c             	mov    %eax,0x4c(%ebx)
  109866:	eb 1c                	jmp    109884 <spi_intel_transceive+0x187>
		ctx->current_tx = NULL;
  109868:	c7 43 38 00 00 00 00 	movl   $0x0,0x38(%ebx)
		ctx->tx_count = 0;
  10986f:	c7 43 3c 00 00 00 00 	movl   $0x0,0x3c(%ebx)
		ctx->tx_buf = NULL;
  109876:	c7 43 48 00 00 00 00 	movl   $0x0,0x48(%ebx)
		ctx->tx_len = 0;
  10987d:	c7 43 4c 00 00 00 00 	movl   $0x0,0x4c(%ebx)
	if (rx_bufs) {
  109884:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
  109888:	74 22                	je     1098ac <spi_intel_transceive+0x1af>
		ctx->current_rx = rx_bufs->buffers;
  10988a:	8b 45 14             	mov    0x14(%ebp),%eax
		ctx->rx_count = rx_bufs->count;
  10988d:	8b 7d 14             	mov    0x14(%ebp),%edi
		ctx->current_rx = rx_bufs->buffers;
  109890:	8b 00                	mov    (%eax),%eax
		ctx->rx_count = rx_bufs->count;
  109892:	8b 57 04             	mov    0x4(%edi),%edx
  109895:	89 53 44             	mov    %edx,0x44(%ebx)
		ctx->current_rx = rx_bufs->buffers;
  109898:	89 43 40             	mov    %eax,0x40(%ebx)
		ctx->rx_buf = (u8_t *)ctx->current_rx->buf;
  10989b:	8b 10                	mov    (%eax),%edx
		ctx->rx_len = ctx->current_rx->len / dfs;
  10989d:	8b 40 04             	mov    0x4(%eax),%eax
		ctx->rx_buf = (u8_t *)ctx->current_rx->buf;
  1098a0:	89 53 50             	mov    %edx,0x50(%ebx)
		ctx->rx_len = ctx->current_rx->len / dfs;
  1098a3:	31 d2                	xor    %edx,%edx
  1098a5:	f7 f1                	div    %ecx
  1098a7:	89 43 54             	mov    %eax,0x54(%ebx)
  1098aa:	eb 1c                	jmp    1098c8 <spi_intel_transceive+0x1cb>
		ctx->current_rx = NULL;
  1098ac:	c7 43 40 00 00 00 00 	movl   $0x0,0x40(%ebx)
		ctx->rx_count = 0;
  1098b3:	c7 43 44 00 00 00 00 	movl   $0x0,0x44(%ebx)
		ctx->rx_buf = NULL;
  1098ba:	c7 43 50 00 00 00 00 	movl   $0x0,0x50(%ebx)
		ctx->rx_len = 0;
  1098c1:	c7 43 54 00 00 00 00 	movl   $0x0,0x54(%ebx)
	_spi_context_cs_control(ctx, on, false);
  1098c8:	89 d8                	mov    %ebx,%eax
	ctx->sync_status = 0;
  1098ca:	c7 43 34 00 00 00 00 	movl   $0x0,0x34(%ebx)
	_spi_context_cs_control(ctx, on, false);
  1098d1:	31 c9                	xor    %ecx,%ecx
  1098d3:	ba 01 00 00 00       	mov    $0x1,%edx
  1098d8:	e8 bf fb ff ff       	call   10949c <_spi_context_cs_control>
	write_sscr0(spi->sscr0 | INTEL_SPI_SSCR0_SSE, spi->regs);
  1098dd:	8b 43 70             	mov    0x70(%ebx),%eax
  1098e0:	0c 80                	or     $0x80,%al
			 : "r"(data), "m" (*(volatile u32_t *) addr)
  1098e2:	8b 53 58             	mov    0x58(%ebx),%edx
	__asm__ volatile("movl	%0, %1;\n\t"
  1098e5:	89 02                	mov    %eax,(%edx)
	write_sscr1(spi->sscr1 | INTEL_SPI_SSCR1_RIE | INTEL_SPI_SSCR1_TIE,
  1098e7:	8b 43 74             	mov    0x74(%ebx),%eax
DEFINE_MM_REG_WRITE(sscr1, INTEL_SPI_REG_SSCR1, 32)
  1098ea:	8b 53 58             	mov    0x58(%ebx),%edx
  1098ed:	83 c8 03             	or     $0x3,%eax
  1098f0:	89 42 04             	mov    %eax,0x4(%edx)
  1098f3:	6a ff                	push   $0xffffffff
	k_sem_take(&ctx->sync, K_FOREVER);
  1098f5:	8d 43 1c             	lea    0x1c(%ebx),%eax
  1098f8:	50                   	push   %eax
  1098f9:	e8 b6 12 00 00       	call   10abb4 <z_impl_k_sem_take>
  1098fe:	5a                   	pop    %edx
	status = ctx->sync_status;
  1098ff:	8b 43 34             	mov    0x34(%ebx),%eax
  109902:	59                   	pop    %ecx
K_SYSCALL_DECLARE1_VOID(K_SYSCALL_K_SEM_GIVE, k_sem_give, struct k_sem *, sem)
  109903:	ff 75 f0             	pushl  -0x10(%ebp)
  109906:	89 45 ec             	mov    %eax,-0x14(%ebp)
  109909:	e8 3d 12 00 00       	call   10ab4b <z_impl_k_sem_give>
  10990e:	58                   	pop    %eax
  10990f:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
  109912:	8d 65 f4             	lea    -0xc(%ebp),%esp
  109915:	5b                   	pop    %ebx
  109916:	5e                   	pop    %esi
  109917:	5f                   	pop    %edi
  109918:	5d                   	pop    %ebp
  109919:	c3                   	ret    

0010991a <spi_intel_release>:
{
  10991a:	55                   	push   %ebp
  10991b:	89 e5                	mov    %esp,%ebp
  10991d:	53                   	push   %ebx
	struct spi_intel_data *spi = dev->driver_data;
  10991e:	8b 45 08             	mov    0x8(%ebp),%eax
  109921:	8b 58 08             	mov    0x8(%eax),%ebx
			 : "=r" (ret), "+m" (*(volatile u32_t *) (addr))
  109924:	8b 43 58             	mov    0x58(%ebx),%eax
	__asm__ volatile("btl	%2, %1;\n\t"
  109927:	0f ba 20 07          	btl    $0x7,(%eax)
  10992b:	19 d2                	sbb    %edx,%edx
	if (test_bit_sscr0_sse(spi->regs) && test_bit_sssr_bsy(spi->regs)) {
  10992d:	85 d2                	test   %edx,%edx
  10992f:	75 20                	jne    109951 <spi_intel_release+0x37>
	_spi_context_cs_control(ctx, false, true);
  109931:	31 d2                	xor    %edx,%edx
  109933:	b9 01 00 00 00       	mov    $0x1,%ecx
  109938:	89 d8                	mov    %ebx,%eax
  10993a:	e8 5d fb ff ff       	call   10949c <_spi_context_cs_control>
	if (!k_sem_count_get(&ctx->lock)) {
  10993f:	83 7b 0c 00          	cmpl   $0x0,0xc(%ebx)
  109943:	75 21                	jne    109966 <spi_intel_release+0x4c>
		k_sem_give(&ctx->lock);
  109945:	83 c3 04             	add    $0x4,%ebx
  109948:	53                   	push   %ebx
  109949:	e8 fd 11 00 00       	call   10ab4b <z_impl_k_sem_give>
  10994e:	58                   	pop    %eax
  10994f:	eb 15                	jmp    109966 <spi_intel_release+0x4c>
DEFINE_TEST_BIT_OP(sssr_bsy, INTEL_SPI_REG_SSSR, INTEL_SPI_SSSR_BSY_BIT)
  109951:	8b 43 58             	mov    0x58(%ebx),%eax
  109954:	0f ba 60 08 04       	btl    $0x4,0x8(%eax)
  109959:	19 d2                	sbb    %edx,%edx
		return -EBUSY;
  10995b:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
	if (test_bit_sscr0_sse(spi->regs) && test_bit_sssr_bsy(spi->regs)) {
  109960:	85 d2                	test   %edx,%edx
  109962:	74 cd                	je     109931 <spi_intel_release+0x17>
  109964:	eb 02                	jmp    109968 <spi_intel_release+0x4e>
	return 0;
  109966:	31 c0                	xor    %eax,%eax
}
  109968:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  10996b:	c9                   	leave  
  10996c:	c3                   	ret    

0010996d <uart_ns16550_poll_in>:
 * @param c Pointer to character
 *
 * @return 0 if a character arrived, -1 if the input buffer if empty.
 */
static int uart_ns16550_poll_in(struct device *dev, unsigned char *c)
{
  10996d:	55                   	push   %ebp
  10996e:	89 e5                	mov    %esp,%ebp
  109970:	8b 55 08             	mov    0x8(%ebp),%edx
	if ((INBYTE(LSR(dev)) & LSR_RXRDY) == 0x00)
  109973:	8b 42 08             	mov    0x8(%edx),%eax
  109976:	8b 00                	mov    (%eax),%eax
	__asm__ volatile("movb	%1, %0;\n\t"
  109978:	8a 48 14             	mov    0x14(%eax),%cl
  10997b:	80 e1 01             	and    $0x1,%cl
  10997e:	74 10                	je     109990 <uart_ns16550_poll_in+0x23>
		return (-1);

	/* got a character */
	*c = INBYTE(RDR(dev));
  109980:	8b 42 08             	mov    0x8(%edx),%eax
			 : "m" (*(volatile u8_t *) addr)
  109983:	8b 00                	mov    (%eax),%eax
	__asm__ volatile("movb	%1, %0;\n\t"
  109985:	8a 10                	mov    (%eax),%dl
  109987:	8b 45 0c             	mov    0xc(%ebp),%eax
  10998a:	88 10                	mov    %dl,(%eax)

	return 0;
  10998c:	31 c0                	xor    %eax,%eax
  10998e:	eb 03                	jmp    109993 <uart_ns16550_poll_in+0x26>
  109990:	83 c8 ff             	or     $0xffffffff,%eax
}
  109993:	5d                   	pop    %ebp
  109994:	c3                   	ret    

00109995 <uart_ns16550_poll_out>:
 * @param dev UART device struct
 * @param c Character to send
 */
static void uart_ns16550_poll_out(struct device *dev,
					   unsigned char c)
{
  109995:	55                   	push   %ebp
  109996:	89 e5                	mov    %esp,%ebp
  109998:	8b 45 08             	mov    0x8(%ebp),%eax
  10999b:	8b 55 0c             	mov    0xc(%ebp),%edx
	/* wait for transmitter to ready to accept a character */
	while ((INBYTE(LSR(dev)) & LSR_THRE) == 0)
  10999e:	8b 48 08             	mov    0x8(%eax),%ecx
  1099a1:	8b 09                	mov    (%ecx),%ecx
  1099a3:	8a 49 14             	mov    0x14(%ecx),%cl
  1099a6:	80 e1 20             	and    $0x20,%cl
  1099a9:	74 f3                	je     10999e <uart_ns16550_poll_out+0x9>
		;

	OUTBYTE(THR(dev), c);
  1099ab:	8b 40 08             	mov    0x8(%eax),%eax
			 : "q"(data), "m" (*(volatile u8_t *) addr)
  1099ae:	8b 00                	mov    (%eax),%eax
	__asm__ volatile("movb	%0, %1;\n\t"
  1099b0:	88 10                	mov    %dl,(%eax)
}
  1099b2:	5d                   	pop    %ebp
  1099b3:	c3                   	ret    

001099b4 <uart_ns16550_err_check>:
 *
 * @return one of UART_ERROR_OVERRUN, UART_ERROR_PARITY, UART_ERROR_FRAMING,
 * UART_ERROR_BREAK if an error was detected, 0 otherwise.
 */
static int uart_ns16550_err_check(struct device *dev)
{
  1099b4:	55                   	push   %ebp
  1099b5:	89 e5                	mov    %esp,%ebp
	return (INBYTE(LSR(dev)) & LSR_EOB_MASK) >> 1;
  1099b7:	8b 45 08             	mov    0x8(%ebp),%eax
  1099ba:	8b 40 08             	mov    0x8(%eax),%eax
  1099bd:	8b 00                	mov    (%eax),%eax
	__asm__ volatile("movb	%1, %0;\n\t"
  1099bf:	8a 40 14             	mov    0x14(%eax),%al
  1099c2:	d1 e8                	shr    %eax
}
  1099c4:	5d                   	pop    %ebp
	return (INBYTE(LSR(dev)) & LSR_EOB_MASK) >> 1;
  1099c5:	83 e0 0f             	and    $0xf,%eax
}
  1099c8:	c3                   	ret    

001099c9 <uart_ns16550_fifo_fill>:
 *
 * @return Number of bytes sent
 */
static int uart_ns16550_fifo_fill(struct device *dev, const u8_t *tx_data,
				  int size)
{
  1099c9:	55                   	push   %ebp
	int i;

	for (i = 0; i < size && (INBYTE(LSR(dev)) & LSR_THRE) != 0; i++) {
  1099ca:	31 c0                	xor    %eax,%eax
{
  1099cc:	89 e5                	mov    %esp,%ebp
  1099ce:	56                   	push   %esi
  1099cf:	53                   	push   %ebx
  1099d0:	8b 55 08             	mov    0x8(%ebp),%edx
  1099d3:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	for (i = 0; i < size && (INBYTE(LSR(dev)) & LSR_THRE) != 0; i++) {
  1099d6:	3b 45 10             	cmp    0x10(%ebp),%eax
  1099d9:	7d 1a                	jge    1099f5 <uart_ns16550_fifo_fill+0x2c>
  1099db:	8b 4a 08             	mov    0x8(%edx),%ecx
  1099de:	8b 09                	mov    (%ecx),%ecx
  1099e0:	8a 49 14             	mov    0x14(%ecx),%cl
  1099e3:	80 e1 20             	and    $0x20,%cl
  1099e6:	74 0d                	je     1099f5 <uart_ns16550_fifo_fill+0x2c>
		OUTBYTE(THR(dev), tx_data[i]);
  1099e8:	8b 72 08             	mov    0x8(%edx),%esi
  1099eb:	8a 0c 03             	mov    (%ebx,%eax,1),%cl
			 : "q"(data), "m" (*(volatile u8_t *) addr)
  1099ee:	8b 36                	mov    (%esi),%esi
	__asm__ volatile("movb	%0, %1;\n\t"
  1099f0:	88 0e                	mov    %cl,(%esi)
	for (i = 0; i < size && (INBYTE(LSR(dev)) & LSR_THRE) != 0; i++) {
  1099f2:	40                   	inc    %eax
  1099f3:	eb e1                	jmp    1099d6 <uart_ns16550_fifo_fill+0xd>
	}
	return i;
}
  1099f5:	5b                   	pop    %ebx
  1099f6:	5e                   	pop    %esi
  1099f7:	5d                   	pop    %ebp
  1099f8:	c3                   	ret    

001099f9 <uart_ns16550_fifo_read>:
 *
 * @return Number of bytes read
 */
static int uart_ns16550_fifo_read(struct device *dev, u8_t *rx_data,
				  const int size)
{
  1099f9:	55                   	push   %ebp
	int i;

	for (i = 0; i < size && (INBYTE(LSR(dev)) & LSR_RXRDY) != 0; i++) {
  1099fa:	31 c0                	xor    %eax,%eax
{
  1099fc:	89 e5                	mov    %esp,%ebp
  1099fe:	53                   	push   %ebx
  1099ff:	8b 55 08             	mov    0x8(%ebp),%edx
	for (i = 0; i < size && (INBYTE(LSR(dev)) & LSR_RXRDY) != 0; i++) {
  109a02:	3b 45 10             	cmp    0x10(%ebp),%eax
  109a05:	7d 1d                	jge    109a24 <uart_ns16550_fifo_read+0x2b>
  109a07:	8b 4a 08             	mov    0x8(%edx),%ecx
  109a0a:	8b 09                	mov    (%ecx),%ecx
	__asm__ volatile("movb	%1, %0;\n\t"
  109a0c:	8a 49 14             	mov    0x14(%ecx),%cl
  109a0f:	80 e1 01             	and    $0x1,%cl
  109a12:	74 10                	je     109a24 <uart_ns16550_fifo_read+0x2b>
		rx_data[i] = INBYTE(RDR(dev));
  109a14:	8b 4a 08             	mov    0x8(%edx),%ecx
			 : "m" (*(volatile u8_t *) addr)
  109a17:	8b 09                	mov    (%ecx),%ecx
	__asm__ volatile("movb	%1, %0;\n\t"
  109a19:	8a 09                	mov    (%ecx),%cl
  109a1b:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  109a1e:	88 0c 03             	mov    %cl,(%ebx,%eax,1)
	for (i = 0; i < size && (INBYTE(LSR(dev)) & LSR_RXRDY) != 0; i++) {
  109a21:	40                   	inc    %eax
  109a22:	eb de                	jmp    109a02 <uart_ns16550_fifo_read+0x9>
	}

	return i;
}
  109a24:	5b                   	pop    %ebx
  109a25:	5d                   	pop    %ebp
  109a26:	c3                   	ret    

00109a27 <uart_ns16550_irq_tx_enable>:
 * @param dev UART device struct
 *
 * @return N/A
 */
static void uart_ns16550_irq_tx_enable(struct device *dev)
{
  109a27:	55                   	push   %ebp
  109a28:	89 e5                	mov    %esp,%ebp
	OUTBYTE(IER(dev), INBYTE(IER(dev)) | IER_TBE);
  109a2a:	8b 45 08             	mov    0x8(%ebp),%eax
  109a2d:	8b 40 08             	mov    0x8(%eax),%eax
  109a30:	8b 10                	mov    (%eax),%edx
  109a32:	8a 42 04             	mov    0x4(%edx),%al
  109a35:	83 c8 02             	or     $0x2,%eax
	__asm__ volatile("movb	%0, %1;\n\t"
  109a38:	88 42 04             	mov    %al,0x4(%edx)
}
  109a3b:	5d                   	pop    %ebp
  109a3c:	c3                   	ret    

00109a3d <uart_ns16550_irq_tx_disable>:
 * @param dev UART device struct
 *
 * @return N/A
 */
static void uart_ns16550_irq_tx_disable(struct device *dev)
{
  109a3d:	55                   	push   %ebp
  109a3e:	89 e5                	mov    %esp,%ebp
	OUTBYTE(IER(dev), INBYTE(IER(dev)) & (~IER_TBE));
  109a40:	8b 45 08             	mov    0x8(%ebp),%eax
  109a43:	8b 40 08             	mov    0x8(%eax),%eax
  109a46:	8b 10                	mov    (%eax),%edx
	__asm__ volatile("movb	%1, %0;\n\t"
  109a48:	8a 42 04             	mov    0x4(%edx),%al
	return ret;
  109a4b:	83 e0 fd             	and    $0xfffffffd,%eax
	__asm__ volatile("movb	%0, %1;\n\t"
  109a4e:	88 42 04             	mov    %al,0x4(%edx)
}
  109a51:	5d                   	pop    %ebp
  109a52:	c3                   	ret    

00109a53 <uart_ns16550_irq_tx_ready>:
 * @param dev UART device struct
 *
 * @return 1 if an IRQ is ready, 0 otherwise
 */
static int uart_ns16550_irq_tx_ready(struct device *dev)
{
  109a53:	55                   	push   %ebp
  109a54:	89 e5                	mov    %esp,%ebp
	return ((IIRC(dev) & IIR_ID) == IIR_THRE);
  109a56:	8b 45 08             	mov    0x8(%ebp),%eax
}
  109a59:	5d                   	pop    %ebp
	return ((IIRC(dev) & IIR_ID) == IIR_THRE);
  109a5a:	8b 40 08             	mov    0x8(%eax),%eax
  109a5d:	8a 40 20             	mov    0x20(%eax),%al
  109a60:	83 e0 06             	and    $0x6,%eax
  109a63:	3c 02                	cmp    $0x2,%al
  109a65:	0f 94 c0             	sete   %al
  109a68:	0f b6 c0             	movzbl %al,%eax
}
  109a6b:	c3                   	ret    

00109a6c <uart_ns16550_irq_tx_complete>:
 * @param dev UART device struct
 *
 * @return 1 if nothing remains to be transmitted, 0 otherwise
 */
static int uart_ns16550_irq_tx_complete(struct device *dev)
{
  109a6c:	55                   	push   %ebp
  109a6d:	89 e5                	mov    %esp,%ebp
	return (INBYTE(LSR(dev)) & (LSR_TEMT | LSR_THRE)) == (LSR_TEMT | LSR_THRE);
  109a6f:	8b 45 08             	mov    0x8(%ebp),%eax
  109a72:	8b 40 08             	mov    0x8(%eax),%eax
  109a75:	8b 00                	mov    (%eax),%eax
	__asm__ volatile("movb	%1, %0;\n\t"
  109a77:	8a 40 14             	mov    0x14(%eax),%al
  109a7a:	83 e0 60             	and    $0x60,%eax
}
  109a7d:	5d                   	pop    %ebp
	return (INBYTE(LSR(dev)) & (LSR_TEMT | LSR_THRE)) == (LSR_TEMT | LSR_THRE);
  109a7e:	3c 60                	cmp    $0x60,%al
  109a80:	0f 94 c0             	sete   %al
  109a83:	0f b6 c0             	movzbl %al,%eax
}
  109a86:	c3                   	ret    

00109a87 <uart_ns16550_irq_rx_enable>:
 * @param dev UART device struct
 *
 * @return N/A
 */
static void uart_ns16550_irq_rx_enable(struct device *dev)
{
  109a87:	55                   	push   %ebp
  109a88:	89 e5                	mov    %esp,%ebp
	OUTBYTE(IER(dev), INBYTE(IER(dev)) | IER_RXRDY);
  109a8a:	8b 45 08             	mov    0x8(%ebp),%eax
  109a8d:	8b 40 08             	mov    0x8(%eax),%eax
  109a90:	8b 10                	mov    (%eax),%edx
  109a92:	8a 42 04             	mov    0x4(%edx),%al
  109a95:	83 c8 01             	or     $0x1,%eax
	__asm__ volatile("movb	%0, %1;\n\t"
  109a98:	88 42 04             	mov    %al,0x4(%edx)
}
  109a9b:	5d                   	pop    %ebp
  109a9c:	c3                   	ret    

00109a9d <uart_ns16550_irq_rx_disable>:
 * @param dev UART device struct
 *
 * @return N/A
 */
static void uart_ns16550_irq_rx_disable(struct device *dev)
{
  109a9d:	55                   	push   %ebp
  109a9e:	89 e5                	mov    %esp,%ebp
	OUTBYTE(IER(dev), INBYTE(IER(dev)) & (~IER_RXRDY));
  109aa0:	8b 45 08             	mov    0x8(%ebp),%eax
  109aa3:	8b 40 08             	mov    0x8(%eax),%eax
  109aa6:	8b 10                	mov    (%eax),%edx
	__asm__ volatile("movb	%1, %0;\n\t"
  109aa8:	8a 42 04             	mov    0x4(%edx),%al
	return ret;
  109aab:	83 e0 fe             	and    $0xfffffffe,%eax
	__asm__ volatile("movb	%0, %1;\n\t"
  109aae:	88 42 04             	mov    %al,0x4(%edx)
}
  109ab1:	5d                   	pop    %ebp
  109ab2:	c3                   	ret    

00109ab3 <uart_ns16550_irq_rx_ready>:
 * @param dev UART device struct
 *
 * @return 1 if an IRQ is ready, 0 otherwise
 */
static int uart_ns16550_irq_rx_ready(struct device *dev)
{
  109ab3:	55                   	push   %ebp
  109ab4:	89 e5                	mov    %esp,%ebp
	return ((IIRC(dev) & IIR_ID) == IIR_RBRF);
  109ab6:	8b 45 08             	mov    0x8(%ebp),%eax
}
  109ab9:	5d                   	pop    %ebp
	return ((IIRC(dev) & IIR_ID) == IIR_RBRF);
  109aba:	8b 40 08             	mov    0x8(%eax),%eax
  109abd:	8a 40 20             	mov    0x20(%eax),%al
  109ac0:	83 e0 06             	and    $0x6,%eax
  109ac3:	3c 04                	cmp    $0x4,%al
  109ac5:	0f 94 c0             	sete   %al
  109ac8:	0f b6 c0             	movzbl %al,%eax
}
  109acb:	c3                   	ret    

00109acc <uart_ns16550_irq_err_enable>:
 * @param dev UART device struct
 *
 * @return N/A
 */
static void uart_ns16550_irq_err_enable(struct device *dev)
{
  109acc:	55                   	push   %ebp
  109acd:	89 e5                	mov    %esp,%ebp
	OUTBYTE(IER(dev), INBYTE(IER(dev)) | IER_LSR);
  109acf:	8b 45 08             	mov    0x8(%ebp),%eax
  109ad2:	8b 40 08             	mov    0x8(%eax),%eax
  109ad5:	8b 10                	mov    (%eax),%edx
	__asm__ volatile("movb	%1, %0;\n\t"
  109ad7:	8a 42 04             	mov    0x4(%edx),%al
  109ada:	83 c8 04             	or     $0x4,%eax
	__asm__ volatile("movb	%0, %1;\n\t"
  109add:	88 42 04             	mov    %al,0x4(%edx)
}
  109ae0:	5d                   	pop    %ebp
  109ae1:	c3                   	ret    

00109ae2 <uart_ns16550_irq_err_disable>:
 * @param dev UART device struct
 *
 * @return 1 if an IRQ is ready, 0 otherwise
 */
static void uart_ns16550_irq_err_disable(struct device *dev)
{
  109ae2:	55                   	push   %ebp
  109ae3:	89 e5                	mov    %esp,%ebp
	OUTBYTE(IER(dev), INBYTE(IER(dev)) & (~IER_LSR));
  109ae5:	8b 45 08             	mov    0x8(%ebp),%eax
  109ae8:	8b 40 08             	mov    0x8(%eax),%eax
  109aeb:	8b 10                	mov    (%eax),%edx
	__asm__ volatile("movb	%1, %0;\n\t"
  109aed:	8a 42 04             	mov    0x4(%edx),%al
	return ret;
  109af0:	83 e0 fb             	and    $0xfffffffb,%eax
	__asm__ volatile("movb	%0, %1;\n\t"
  109af3:	88 42 04             	mov    %al,0x4(%edx)
}
  109af6:	5d                   	pop    %ebp
  109af7:	c3                   	ret    

00109af8 <uart_ns16550_irq_is_pending>:
 * @param dev UART device struct
 *
 * @return 1 if an IRQ is pending, 0 otherwise
 */
static int uart_ns16550_irq_is_pending(struct device *dev)
{
  109af8:	55                   	push   %ebp
  109af9:	89 e5                	mov    %esp,%ebp
	return (!(IIRC(dev) & IIR_NIP));
  109afb:	8b 45 08             	mov    0x8(%ebp),%eax
}
  109afe:	5d                   	pop    %ebp
	return (!(IIRC(dev) & IIR_NIP));
  109aff:	8b 40 08             	mov    0x8(%eax),%eax
  109b02:	8a 40 20             	mov    0x20(%eax),%al
  109b05:	f7 d0                	not    %eax
  109b07:	83 e0 01             	and    $0x1,%eax
}
  109b0a:	c3                   	ret    

00109b0b <uart_ns16550_irq_update>:
 * @param dev UART device struct
 *
 * @return Always 1
 */
static int uart_ns16550_irq_update(struct device *dev)
{
  109b0b:	55                   	push   %ebp
  109b0c:	89 e5                	mov    %esp,%ebp
	IIRC(dev) = INBYTE(IIR(dev));
  109b0e:	8b 45 08             	mov    0x8(%ebp),%eax
  109b11:	8b 40 08             	mov    0x8(%eax),%eax
  109b14:	8b 10                	mov    (%eax),%edx
	__asm__ volatile("movb	%1, %0;\n\t"
  109b16:	8a 52 08             	mov    0x8(%edx),%dl
  109b19:	88 50 20             	mov    %dl,0x20(%eax)

	return 1;
}
  109b1c:	b8 01 00 00 00       	mov    $0x1,%eax
  109b21:	5d                   	pop    %ebp
  109b22:	c3                   	ret    

00109b23 <uart_ns16550_irq_callback_set>:
 * @return N/A
 */
static void uart_ns16550_irq_callback_set(struct device *dev,
					  uart_irq_callback_user_data_t cb,
					  void *cb_data)
{
  109b23:	55                   	push   %ebp
  109b24:	89 e5                	mov    %esp,%ebp
	struct uart_ns16550_dev_data_t * const dev_data = DEV_DATA(dev);
  109b26:	8b 45 08             	mov    0x8(%ebp),%eax

	dev_data->cb = cb;
  109b29:	8b 55 0c             	mov    0xc(%ebp),%edx
	struct uart_ns16550_dev_data_t * const dev_data = DEV_DATA(dev);
  109b2c:	8b 40 08             	mov    0x8(%eax),%eax
	dev_data->cb = cb;
  109b2f:	89 50 24             	mov    %edx,0x24(%eax)
	dev_data->cb_data = cb_data;
  109b32:	8b 55 10             	mov    0x10(%ebp),%edx
  109b35:	89 50 28             	mov    %edx,0x28(%eax)
}
  109b38:	5d                   	pop    %ebp
  109b39:	c3                   	ret    

00109b3a <uart_ns16550_isr>:
 * @param arg Argument to ISR.
 *
 * @return N/A
 */
static void uart_ns16550_isr(void *arg)
{
  109b3a:	55                   	push   %ebp
  109b3b:	89 e5                	mov    %esp,%ebp
	struct device *dev = arg;
	struct uart_ns16550_dev_data_t * const dev_data = DEV_DATA(dev);
  109b3d:	8b 45 08             	mov    0x8(%ebp),%eax
  109b40:	8b 50 08             	mov    0x8(%eax),%edx

	if (dev_data->cb) {
  109b43:	8b 42 24             	mov    0x24(%edx),%eax
  109b46:	85 c0                	test   %eax,%eax
  109b48:	74 09                	je     109b53 <uart_ns16550_isr+0x19>
		dev_data->cb(dev_data->cb_data);
  109b4a:	8b 52 28             	mov    0x28(%edx),%edx
  109b4d:	89 55 08             	mov    %edx,0x8(%ebp)
	}
}
  109b50:	5d                   	pop    %ebp
		dev_data->cb(dev_data->cb_data);
  109b51:	ff e0                	jmp    *%eax
}
  109b53:	5d                   	pop    %ebp
  109b54:	c3                   	ret    

00109b55 <irq_config_func_0>:
		    PRE_KERNEL_1, CONFIG_KERNEL_INIT_PRIORITY_DEVICE,
		    &uart_ns16550_driver_api);

#ifdef CONFIG_UART_INTERRUPT_DRIVEN
static void irq_config_func_0(struct device *dev)
{
  109b55:	55                   	push   %ebp
  109b56:	89 e5                	mov    %esp,%ebp
	ARG_UNUSED(dev);

	IRQ_CONNECT(DT_UART_NS16550_PORT_0_IRQ,
  109b58:	0f b6 05 78 f8 10 00 	movzbl 0x10f878,%eax
  109b5f:	68 00 a0 00 00       	push   $0xa000
  109b64:	6a 00                	push   $0x0
  109b66:	50                   	push   %eax
  109b67:	e8 fd bf ff ff       	call   105b69 <__irq_controller_irq_config>
  109b6c:	83 c4 0c             	add    $0xc,%esp
		    DT_UART_NS16550_PORT_0_IRQ_PRI,
		    uart_ns16550_isr, DEVICE_GET(uart_ns16550_0),
		    DT_UART_NS16550_PORT_0_IRQ_FLAGS);
	irq_enable(DT_UART_NS16550_PORT_0_IRQ);
  109b6f:	c7 45 08 00 00 00 00 	movl   $0x0,0x8(%ebp)
}
  109b76:	c9                   	leave  
	irq_enable(DT_UART_NS16550_PORT_0_IRQ);
  109b77:	e9 13 c0 ff ff       	jmp    105b8f <z_arch_irq_enable>

00109b7c <uart_ns16550_isr_irq0_stub>:
  109b7c:	68 20 33 11 00       	push   $0x113320
  109b81:	68 3a 9b 10 00       	push   $0x109b3a
  109b86:	e9 a1 cc ff ff       	jmp    10682c <_interrupt_enter>

00109b8b <uart_ns16550_isr_irq17_stub>:
  109b8b:	68 14 33 11 00       	push   $0x113314
  109b90:	68 3a 9b 10 00       	push   $0x109b3a
  109b95:	e9 92 cc ff ff       	jmp    10682c <_interrupt_enter>

00109b9a <irq_config_func_1>:
		    PRE_KERNEL_1, CONFIG_KERNEL_INIT_PRIORITY_DEVICE,
		    &uart_ns16550_driver_api);

#ifdef CONFIG_UART_INTERRUPT_DRIVEN
static void irq_config_func_1(struct device *dev)
{
  109b9a:	55                   	push   %ebp
  109b9b:	89 e5                	mov    %esp,%ebp
	ARG_UNUSED(dev);

	IRQ_CONNECT(DT_UART_NS16550_PORT_1_IRQ,
  109b9d:	0f b6 05 89 f8 10 00 	movzbl 0x10f889,%eax
  109ba4:	68 00 a0 00 00       	push   $0xa000
  109ba9:	6a 11                	push   $0x11
  109bab:	50                   	push   %eax
  109bac:	e8 b8 bf ff ff       	call   105b69 <__irq_controller_irq_config>
  109bb1:	83 c4 0c             	add    $0xc,%esp
		    DT_UART_NS16550_PORT_1_IRQ_PRI,
		    uart_ns16550_isr, DEVICE_GET(uart_ns16550_1),
		    DT_UART_NS16550_PORT_1_IRQ_FLAGS);
	irq_enable(DT_UART_NS16550_PORT_1_IRQ);
  109bb4:	c7 45 08 11 00 00 00 	movl   $0x11,0x8(%ebp)
}
  109bbb:	c9                   	leave  
	irq_enable(DT_UART_NS16550_PORT_1_IRQ);
  109bbc:	e9 ce bf ff ff       	jmp    105b8f <z_arch_irq_enable>

00109bc1 <uart_ns16550_init>:
{
  109bc1:	55                   	push   %ebp
  109bc2:	89 e5                	mov    %esp,%ebp
  109bc4:	57                   	push   %edi
  109bc5:	56                   	push   %esi
  109bc6:	53                   	push   %ebx
  109bc7:	83 ec 0c             	sub    $0xc,%esp
  109bca:	8b 5d 08             	mov    0x8(%ebp),%ebx
	struct uart_ns16550_dev_data_t * const dev_data = DEV_DATA(dev);
  109bcd:	8b 73 08             	mov    0x8(%ebx),%esi
	if (dev_data->pci_dev.vendor_id == 0x0000) {
  109bd0:	66 83 7e 1c 00       	cmpw   $0x0,0x1c(%esi)
  109bd5:	74 32                	je     109c09 <uart_ns16550_init+0x48>
	if (!pci_bus_scan(&dev_data->pci_dev)) {
  109bd7:	8d 7e 0c             	lea    0xc(%esi),%edi
	pci_bus_scan_init();
  109bda:	e8 91 c1 ff ff       	call   105d70 <pci_bus_scan_init>
	if (!pci_bus_scan(&dev_data->pci_dev)) {
  109bdf:	57                   	push   %edi
  109be0:	e8 be c1 ff ff       	call   105da3 <pci_bus_scan>
  109be5:	59                   	pop    %ecx
  109be6:	85 c0                	test   %eax,%eax
  109be8:	74 0e                	je     109bf8 <uart_ns16550_init+0x37>
	dev_data->port = dev_data->pci_dev.addr;
  109bea:	8b 46 0c             	mov    0xc(%esi),%eax
  109bed:	89 06                	mov    %eax,(%esi)
	pci_enable_regs(&dev_data->pci_dev);
  109bef:	57                   	push   %edi
  109bf0:	e8 7b c7 ff ff       	call   106370 <pci_enable_regs>
  109bf5:	5a                   	pop    %edx
	return 1;
  109bf6:	eb 11                	jmp    109c09 <uart_ns16550_init+0x48>
		dev->driver_api = NULL;
  109bf8:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
		return -ENOTSUP;
  109bff:	b8 dd ff ff ff       	mov    $0xffffffdd,%eax
  109c04:	e9 b7 00 00 00       	jmp    109cc0 <uart_ns16550_init+0xff>
	dev_data->iir_cache = 0U;
  109c09:	c6 46 20 00          	movb   $0x0,0x20(%esi)
	__asm__ volatile (
  109c0d:	9c                   	pushf  
  109c0e:	fa                   	cli    
  109c0f:	8f 45 e8             	popl   -0x18(%ebp)
	set_baud_rate(dev, dev_data->baud_rate);
  109c12:	8b 4e 04             	mov    0x4(%esi),%ecx
	if ((baud_rate != 0U) && (dev_cfg->sys_clk_freq != 0U)) {
  109c15:	85 c9                	test   %ecx,%ecx
  109c17:	74 56                	je     109c6f <uart_ns16550_init+0xae>
	const struct uart_ns16550_device_config * const dev_cfg = DEV_CFG(dev);
  109c19:	8b 03                	mov    (%ebx),%eax
	if ((baud_rate != 0U) && (dev_cfg->sys_clk_freq != 0U)) {
  109c1b:	8b 40 08             	mov    0x8(%eax),%eax
  109c1e:	8b 00                	mov    (%eax),%eax
  109c20:	85 c0                	test   %eax,%eax
  109c22:	74 4b                	je     109c6f <uart_ns16550_init+0xae>
	struct uart_ns16550_dev_data_t * const dev_data = DEV_DATA(dev);
  109c24:	8b 7b 08             	mov    0x8(%ebx),%edi
		divisor = ((dev_cfg->sys_clk_freq + (baud_rate << 3))
  109c27:	8d 04 c8             	lea    (%eax,%ecx,8),%eax
					/ baud_rate) >> 4;
  109c2a:	31 d2                	xor    %edx,%edx
  109c2c:	f7 f1                	div    %ecx
  109c2e:	89 45 f0             	mov    %eax,-0x10(%ebp)
	__asm__ volatile("movb	%1, %0;\n\t"
  109c31:	8b 17                	mov    (%edi),%edx
  109c33:	8a 52 0c             	mov    0xc(%edx),%dl
  109c36:	88 55 ef             	mov    %dl,-0x11(%ebp)
		OUTBYTE(LCR(dev), LCR_DLAB | lcr_cache);
  109c39:	83 ca 80             	or     $0xffffff80,%edx
  109c3c:	88 d0                	mov    %dl,%al
  109c3e:	8b 53 08             	mov    0x8(%ebx),%edx
  109c41:	8b 12                	mov    (%edx),%edx
	__asm__ volatile("movb	%0, %1;\n\t"
  109c43:	88 42 0c             	mov    %al,0xc(%edx)
		OUTBYTE(BRDL(dev), (unsigned char)(divisor & 0xff));
  109c46:	8b 53 08             	mov    0x8(%ebx),%edx
		divisor = ((dev_cfg->sys_clk_freq + (baud_rate << 3))
  109c49:	8b 45 f0             	mov    -0x10(%ebp),%eax
  109c4c:	c1 e8 04             	shr    $0x4,%eax
			 : "q"(data), "m" (*(volatile u8_t *) addr)
  109c4f:	8b 12                	mov    (%edx),%edx
	__asm__ volatile("movb	%0, %1;\n\t"
  109c51:	88 02                	mov    %al,(%edx)
		OUTBYTE(BRDH(dev), (unsigned char)((divisor >> 8) & 0xff));
  109c53:	8b 53 08             	mov    0x8(%ebx),%edx
  109c56:	8b 45 f0             	mov    -0x10(%ebp),%eax
  109c59:	c1 e8 0c             	shr    $0xc,%eax
  109c5c:	8b 12                	mov    (%edx),%edx
  109c5e:	88 42 04             	mov    %al,0x4(%edx)
		OUTBYTE(LCR(dev), lcr_cache);
  109c61:	8b 43 08             	mov    0x8(%ebx),%eax
  109c64:	8a 55 ef             	mov    -0x11(%ebp),%dl
  109c67:	8b 00                	mov    (%eax),%eax
  109c69:	88 50 0c             	mov    %dl,0xc(%eax)
		dev_data->baud_rate = baud_rate;
  109c6c:	89 4f 04             	mov    %ecx,0x4(%edi)
	OUTBYTE(LCR(dev), LCR_CS8 | LCR_1_STB | LCR_PDIS);
  109c6f:	8b 43 08             	mov    0x8(%ebx),%eax
  109c72:	8b 10                	mov    (%eax),%edx
  109c74:	b0 03                	mov    $0x3,%al
  109c76:	88 42 0c             	mov    %al,0xc(%edx)
	if ((dev_data->options & UART_OPTION_AFCE) == UART_OPTION_AFCE)
  109c79:	8a 46 08             	mov    0x8(%esi),%al
	OUTBYTE(MDC(dev), mdc);
  109c7c:	8b 53 08             	mov    0x8(%ebx),%edx
	if ((dev_data->options & UART_OPTION_AFCE) == UART_OPTION_AFCE)
  109c7f:	83 e0 01             	and    $0x1,%eax
		mdc |= MCR_AFCE;
  109c82:	3c 01                	cmp    $0x1,%al
	OUTBYTE(MDC(dev), mdc);
  109c84:	8b 12                	mov    (%edx),%edx
		mdc |= MCR_AFCE;
  109c86:	19 c0                	sbb    %eax,%eax
  109c88:	83 e0 e0             	and    $0xffffffe0,%eax
  109c8b:	83 c0 2b             	add    $0x2b,%eax
  109c8e:	88 42 10             	mov    %al,0x10(%edx)
	OUTBYTE(FCR(dev),
  109c91:	8b 43 08             	mov    0x8(%ebx),%eax
  109c94:	8b 10                	mov    (%eax),%edx
  109c96:	b0 87                	mov    $0x87,%al
  109c98:	88 42 08             	mov    %al,0x8(%edx)
	INBYTE(RDR(dev));
  109c9b:	8b 43 08             	mov    0x8(%ebx),%eax
			 : "m" (*(volatile u8_t *) addr)
  109c9e:	8b 00                	mov    (%eax),%eax
	__asm__ volatile("movb	%1, %0;\n\t"
  109ca0:	8a 00                	mov    (%eax),%al
	OUTBYTE(IER(dev), 0x00);
  109ca2:	8b 43 08             	mov    0x8(%ebx),%eax
  109ca5:	8b 10                	mov    (%eax),%edx
	__asm__ volatile("movb	%0, %1;\n\t"
  109ca7:	31 c0                	xor    %eax,%eax
  109ca9:	88 42 04             	mov    %al,0x4(%edx)
  109cac:	0f ba 65 e8 09       	btl    $0x9,-0x18(%ebp)
  109cb1:	73 01                	jae    109cb4 <uart_ns16550_init+0xf3>
	__asm__ volatile (
  109cb3:	fb                   	sti    
	DEV_CFG(dev)->irq_config_func(dev);
  109cb4:	8b 03                	mov    (%ebx),%eax
  109cb6:	8b 40 08             	mov    0x8(%eax),%eax
  109cb9:	53                   	push   %ebx
  109cba:	ff 50 04             	call   *0x4(%eax)
  109cbd:	58                   	pop    %eax
	return 0;
  109cbe:	31 c0                	xor    %eax,%eax
}
  109cc0:	8d 65 f4             	lea    -0xc(%ebp),%esp
  109cc3:	5b                   	pop    %ebx
  109cc4:	5e                   	pop    %esi
  109cc5:	5f                   	pop    %edi
  109cc6:	5d                   	pop    %ebp
  109cc7:	c3                   	ret    

00109cc8 <z_sys_device_do_config_level>:
 * off and the next one begins.
 *
 * @param level init level to run.
 */
void z_sys_device_do_config_level(s32_t level)
{
  109cc8:	55                   	push   %ebp
  109cc9:	89 e5                	mov    %esp,%ebp
  109ccb:	56                   	push   %esi
  109ccc:	53                   	push   %ebx
  109ccd:	8b 75 08             	mov    0x8(%ebp),%esi
		__device_APPLICATION_start,
		/* End marker */
		__device_init_end,
	};

	for (info = config_levels[level]; info < config_levels[level+1];
  109cd0:	8b 1c b5 ec dd 10 00 	mov    0x10ddec(,%esi,4),%ebx
  109cd7:	39 1c b5 f0 dd 10 00 	cmp    %ebx,0x10ddf0(,%esi,4)
  109cde:	76 17                	jbe    109cf7 <z_sys_device_do_config_level+0x2f>
								info++) {
		int retval;
		struct device_config *device_conf = info->config;

		retval = device_conf->init(info);
  109ce0:	8b 03                	mov    (%ebx),%eax
  109ce2:	53                   	push   %ebx
  109ce3:	ff 50 04             	call   *0x4(%eax)
  109ce6:	5a                   	pop    %edx
		if (retval != 0) {
  109ce7:	85 c0                	test   %eax,%eax
  109ce9:	74 07                	je     109cf2 <z_sys_device_do_config_level+0x2a>
			/* Initialization failed. Clear the API struct so that
			 * device_get_binding() will not succeed for it.
			 */
			info->driver_api = NULL;
  109ceb:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
								info++) {
  109cf2:	83 c3 0c             	add    $0xc,%ebx
  109cf5:	eb e0                	jmp    109cd7 <z_sys_device_do_config_level+0xf>
		} else {
			z_object_init(info);
		}
	}
}
  109cf7:	8d 65 f8             	lea    -0x8(%ebp),%esp
  109cfa:	5b                   	pop    %ebx
  109cfb:	5e                   	pop    %esi
  109cfc:	5d                   	pop    %ebp
  109cfd:	c3                   	ret    

00109cfe <z_impl_device_get_binding>:

struct device *z_impl_device_get_binding(const char *name)
{
  109cfe:	55                   	push   %ebp
  109cff:	89 e5                	mov    %esp,%ebp
  109d01:	56                   	push   %esi
  109d02:	53                   	push   %ebx
	/* Split the search into two loops: in the common scenario, where
	 * device names are stored in ROM (and are referenced by the user
	 * with CONFIG_* macros), only cheap pointer comparisons will be
	 * performed.  Reserve string comparisons for a fallback.
	 */
	for (info = __device_init_start; info != __device_init_end; info++) {
  109d03:	bb d8 32 11 00       	mov    $0x1132d8,%ebx
{
  109d08:	8b 75 08             	mov    0x8(%ebp),%esi
	for (info = __device_init_start; info != __device_init_end; info++) {
  109d0b:	81 fb 04 34 11 00    	cmp    $0x113404,%ebx
  109d11:	74 11                	je     109d24 <z_impl_device_get_binding+0x26>
		if ((info->driver_api != NULL) &&
  109d13:	83 7b 04 00          	cmpl   $0x0,0x4(%ebx)
  109d17:	74 06                	je     109d1f <z_impl_device_get_binding+0x21>
		    (info->config->name == name)) {
  109d19:	8b 03                	mov    (%ebx),%eax
		if ((info->driver_api != NULL) &&
  109d1b:	39 30                	cmp    %esi,(%eax)
  109d1d:	74 31                	je     109d50 <z_impl_device_get_binding+0x52>
	for (info = __device_init_start; info != __device_init_end; info++) {
  109d1f:	83 c3 0c             	add    $0xc,%ebx
  109d22:	eb e7                	jmp    109d0b <z_impl_device_get_binding+0xd>
			return info;
		}
	}

	for (info = __device_init_start; info != __device_init_end; info++) {
  109d24:	bb d8 32 11 00       	mov    $0x1132d8,%ebx
  109d29:	81 fb 04 34 11 00    	cmp    $0x113404,%ebx
  109d2f:	74 1d                	je     109d4e <z_impl_device_get_binding+0x50>
		if (info->driver_api == NULL) {
  109d31:	83 7b 04 00          	cmpl   $0x0,0x4(%ebx)
  109d35:	75 05                	jne    109d3c <z_impl_device_get_binding+0x3e>
	for (info = __device_init_start; info != __device_init_end; info++) {
  109d37:	83 c3 0c             	add    $0xc,%ebx
  109d3a:	eb ed                	jmp    109d29 <z_impl_device_get_binding+0x2b>
			continue;
		}

		if (strcmp(name, info->config->name) == 0) {
  109d3c:	8b 03                	mov    (%ebx),%eax
  109d3e:	ff 30                	pushl  (%eax)
  109d40:	56                   	push   %esi
  109d41:	e8 43 d0 ff ff       	call   106d89 <strcmp>
  109d46:	5a                   	pop    %edx
  109d47:	85 c0                	test   %eax,%eax
  109d49:	59                   	pop    %ecx
  109d4a:	75 eb                	jne    109d37 <z_impl_device_get_binding+0x39>
  109d4c:	eb 02                	jmp    109d50 <z_impl_device_get_binding+0x52>
			return info;
		}
	}

	return NULL;
  109d4e:	31 db                	xor    %ebx,%ebx
}
  109d50:	8d 65 f8             	lea    -0x8(%ebp),%esp
  109d53:	89 d8                	mov    %ebx,%eax
  109d55:	5b                   	pop    %ebx
  109d56:	5e                   	pop    %esi
  109d57:	5d                   	pop    %ebp
  109d58:	c3                   	ret    

00109d59 <device_busy_set>:
	atomic_set_bit((atomic_t *) __device_busy_start,
				 (busy_dev - __device_init_start));
#else
	ARG_UNUSED(busy_dev);
#endif
}
  109d59:	c3                   	ret    

00109d5a <device_busy_clear>:
  109d5a:	c3                   	ret    

00109d5b <bg_thread_main>:
 * init functions, then invokes application's main() routine.
 *
 * @return N/A
 */
static void bg_thread_main(void *unused1, void *unused2, void *unused3)
{
  109d5b:	55                   	push   %ebp
  109d5c:	89 e5                	mov    %esp,%ebp
	static const unsigned int boot_delay = CONFIG_BOOT_DELAY;
#else
	static const unsigned int boot_delay;
#endif

	z_sys_device_do_config_level(_SYS_INIT_LEVEL_POST_KERNEL);
  109d5e:	6a 02                	push   $0x2
  109d60:	e8 63 ff ff ff       	call   109cc8 <z_sys_device_do_config_level>
		k_busy_wait(CONFIG_BOOT_DELAY * USEC_PER_MSEC);
	}
	PRINT_BOOT_BANNER();

	/* Final init level before app starts */
	z_sys_device_do_config_level(_SYS_INIT_LEVEL_APPLICATION);
  109d65:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
  109d6c:	e8 57 ff ff ff       	call   109cc8 <z_sys_device_do_config_level>
  109d71:	58                   	pop    %eax
	extern void __do_init_array_aux(void);
	__do_global_ctors_aux();
	__do_init_array_aux();
#endif

	z_init_static_threads();
  109d72:	e8 36 11 00 00       	call   10aead <z_init_static_threads>
	__main_time_stamp = (u64_t)k_cycle_get_32();
#endif

	extern void main(void);

	main();
  109d77:	e8 a0 65 ff ff       	call   10031c <main>

	/* Mark nonessenrial since main() has no more work to do */
	_main_thread->base.user_options &= ~K_ESSENTIAL;
  109d7c:	80 25 ac 09 11 00 fe 	andb   $0xfe,0x1109ac

	/* Dump coverage data once the main() has exited. */
	gcov_coverage_dump();
} /* LCOV_EXCL_LINE ... because we just dumped final coverage data */
  109d83:	c9                   	leave  
  109d84:	c3                   	ret    

00109d85 <z_cstart>:
 * cleared/zeroed.
 *
 * @return Does not return
 */
FUNC_NORETURN void z_cstart(void)
{
  109d85:	55                   	push   %ebp
  109d86:	89 e5                	mov    %esp,%ebp
  109d88:	57                   	push   %edi
  109d89:	83 ec 70             	sub    $0x70,%esp
	/* gcov hook needed to get the coverage report.*/
	gcov_static_init();

	if (IS_ENABLED(CONFIG_LOG)) {
		log_core_init();
  109d8c:	e8 60 72 ff ff       	call   100ff1 <log_core_init>

	/* perform any architecture-specific initialization */
	kernel_arch_init();

#ifdef CONFIG_MULTITHREADING
	struct k_thread dummy_thread = {
  109d91:	8d 7d 8c             	lea    -0x74(%ebp),%edi
  109d94:	31 c0                	xor    %eax,%eax
  109d96:	b9 1c 00 00 00       	mov    $0x1c,%ecx
  109d9b:	f3 ab                	rep stos %eax,%es:(%edi)
#ifdef CONFIG_USERSPACE
	z_app_shmem_bss_zero();
#endif

	/* perform basic hardware initialization */
	z_sys_device_do_config_level(_SYS_INIT_LEVEL_PRE_KERNEL_1);
  109d9d:	6a 00                	push   $0x0
	_current = &dummy_thread;
  109d9f:	8d 45 8c             	lea    -0x74(%ebp),%eax
  109da2:	a3 28 0a 11 00       	mov    %eax,0x110a28
 *
 * @return N/A
 */
static inline void kernel_arch_init(void)
{
	_kernel.nested = 0;
  109da7:	c7 05 20 0a 11 00 00 	movl   $0x0,0x110a20
  109dae:	00 00 00 
	_kernel.irq_stack = Z_THREAD_STACK_BUFFER(_interrupt_stack) +
  109db1:	c7 05 24 0a 11 00 b8 	movl   $0x112fb8,0x110a24
  109db8:	2f 11 00 
	struct k_thread dummy_thread = {
  109dbb:	c6 45 99 01          	movb   $0x1,-0x67(%ebp)
	z_sys_device_do_config_level(_SYS_INIT_LEVEL_PRE_KERNEL_1);
  109dbf:	e8 04 ff ff ff       	call   109cc8 <z_sys_device_do_config_level>
	z_sys_device_do_config_level(_SYS_INIT_LEVEL_PRE_KERNEL_2);
  109dc4:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  109dcb:	e8 f8 fe ff ff       	call   109cc8 <z_sys_device_do_config_level>
  109dd0:	59                   	pop    %ecx
	dummy_thread->base.user_options = K_ESSENTIAL;
  109dd1:	66 c7 45 98 01 01    	movw   $0x101,-0x68(%ebp)
	z_sched_init();
  109dd7:	e8 75 0b 00 00       	call   10a951 <z_sched_init>
	z_setup_new_thread(_main_thread, _main_stack,
  109ddc:	68 67 f0 10 00       	push   $0x10f067
	_kernel.ready_q.cache = _main_thread;
  109de1:	c7 05 40 0a 11 00 a0 	movl   $0x1109a0,0x110a40
  109de8:	09 11 00 
	z_setup_new_thread(_main_thread, _main_stack,
  109deb:	6a 01                	push   $0x1
  109ded:	6a 00                	push   $0x0
  109def:	6a 00                	push   $0x0
  109df1:	6a 00                	push   $0x0
  109df3:	6a 00                	push   $0x0
  109df5:	68 5b 9d 10 00       	push   $0x109d5b
  109dfa:	68 00 04 00 00       	push   $0x400
  109dff:	68 b8 23 11 00       	push   $0x1123b8
  109e04:	68 a0 09 11 00       	push   $0x1109a0
  109e09:	e8 7f 0f 00 00       	call   10ad8d <z_setup_new_thread>
	thread->base.thread_state &= ~_THREAD_SUSPENDED;
}

static inline void z_mark_thread_as_started(struct k_thread *thread)
{
	thread->base.thread_state &= ~_THREAD_PRESTART;
  109e0e:	a0 ad 09 11 00       	mov    0x1109ad,%al
  109e13:	83 c4 28             	add    $0x28,%esp
  109e16:	88 c2                	mov    %al,%dl
  109e18:	83 e2 fb             	and    $0xfffffffb,%edx
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
  109e1b:	a8 1b                	test   $0x1b,%al
	thread->base.thread_state &= ~_THREAD_PRESTART;
  109e1d:	88 15 ad 09 11 00    	mov    %dl,0x1109ad
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
  109e23:	75 14                	jne    109e39 <z_cstart+0xb4>
	return true;
}

static ALWAYS_INLINE void z_ready_thread(struct k_thread *thread)
{
	if (z_is_thread_ready(thread)) {
  109e25:	83 3d b8 09 11 00 00 	cmpl   $0x0,0x1109b8
  109e2c:	75 0b                	jne    109e39 <z_cstart+0xb4>
		z_add_thread_to_ready_q(thread);
  109e2e:	68 a0 09 11 00       	push   $0x1109a0
  109e33:	e8 4c 07 00 00       	call   10a584 <z_add_thread_to_ready_q>
  109e38:	5a                   	pop    %edx
	z_setup_new_thread(thr, stack,
  109e39:	68 6c f0 10 00       	push   $0x10f06c
  109e3e:	6a 01                	push   $0x1
  109e40:	6a 0f                	push   $0xf
  109e42:	6a 00                	push   $0x0
  109e44:	6a 00                	push   $0x0
  109e46:	6a 00                	push   $0x0
  109e48:	68 b6 b7 10 00       	push   $0x10b7b6
  109e4d:	68 00 01 00 00       	push   $0x100
  109e52:	68 b8 22 11 00       	push   $0x1122b8
  109e57:	68 20 09 11 00       	push   $0x110920
  109e5c:	e8 2c 0f 00 00       	call   10ad8d <z_setup_new_thread>
  109e61:	83 c4 28             	add    $0x28,%esp
	_kernel.cpus[0].idle_thread = _idle_thread;
  109e64:	c7 05 2c 0a 11 00 20 	movl   $0x110920,0x110a2c
  109e6b:	09 11 00 
	thread->base.thread_state &= ~_THREAD_PRESTART;
  109e6e:	80 25 2d 09 11 00 fb 	andb   $0xfb,0x11092d
	list->head = (sys_dnode_t *)list;
  109e75:	c7 05 38 0a 11 00 38 	movl   $0x110a38,0x110a38
  109e7c:	0a 11 00 
	list->tail = (sys_dnode_t *)list;
  109e7f:	c7 05 3c 0a 11 00 38 	movl   $0x110a38,0x110a3c
  109e86:	0a 11 00 
	__asm__ volatile (
  109e89:	9c                   	pushf  
  109e8a:	fa                   	cli    
  109e8b:	58                   	pop    %eax
#ifndef CONFIG_ARM
#ifdef CONFIG_TRACING
	sys_trace_thread_switched_out();
#endif
#endif
	ret = __swap(key);
  109e8c:	50                   	push   %eax
  109e8d:	e8 03 ca ff ff       	call   106895 <__swap>
  109e92:	58                   	pop    %eax

00109e93 <init_mem_slab_module>:
{
	ARG_UNUSED(dev);

	struct k_mem_slab *slab;

	for (slab = _k_mem_slab_list_start;
  109e93:	b8 20 34 11 00       	mov    $0x113420,%eax
  109e98:	3d 3c 34 11 00       	cmp    $0x11343c,%eax
  109e9d:	72 03                	jb     109ea2 <init_mem_slab_module+0xf>
		create_free_list(slab);
		SYS_TRACING_OBJ_INIT(k_mem_slab, slab);
		z_object_init(slab);
	}
	return 0;
}
  109e9f:	31 c0                	xor    %eax,%eax
  109ea1:	c3                   	ret    
{
  109ea2:	55                   	push   %ebp
  109ea3:	89 e5                	mov    %esp,%ebp
  109ea5:	56                   	push   %esi
  109ea6:	53                   	push   %ebx
	slab->free_list = NULL;
  109ea7:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
	p = slab->buffer;
  109eae:	8b 50 10             	mov    0x10(%eax),%edx
	for (j = 0U; j < slab->num_blocks; j++) {
  109eb1:	8b 58 08             	mov    0x8(%eax),%ebx
  109eb4:	31 c9                	xor    %ecx,%ecx
  109eb6:	39 d9                	cmp    %ebx,%ecx
  109eb8:	74 0e                	je     109ec8 <init_mem_slab_module+0x35>
		*(char **)p = slab->free_list;
  109eba:	8b 70 14             	mov    0x14(%eax),%esi
	for (j = 0U; j < slab->num_blocks; j++) {
  109ebd:	41                   	inc    %ecx
		*(char **)p = slab->free_list;
  109ebe:	89 32                	mov    %esi,(%edx)
		slab->free_list = p;
  109ec0:	89 50 14             	mov    %edx,0x14(%eax)
		p += slab->block_size;
  109ec3:	03 50 0c             	add    0xc(%eax),%edx
  109ec6:	eb ee                	jmp    109eb6 <init_mem_slab_module+0x23>
	     slab++) {
  109ec8:	83 c0 1c             	add    $0x1c,%eax
	for (slab = _k_mem_slab_list_start;
  109ecb:	3d 3c 34 11 00       	cmp    $0x11343c,%eax
  109ed0:	72 d5                	jb     109ea7 <init_mem_slab_module+0x14>
}
  109ed2:	5b                   	pop    %ebx
  109ed3:	31 c0                	xor    %eax,%eax
  109ed5:	5e                   	pop    %esi
  109ed6:	5d                   	pop    %ebp
  109ed7:	c3                   	ret    

00109ed8 <k_mem_slab_init>:
SYS_INIT(init_mem_slab_module, PRE_KERNEL_1,
	 CONFIG_KERNEL_INIT_PRIORITY_OBJECTS);

void k_mem_slab_init(struct k_mem_slab *slab, void *buffer,
		    size_t block_size, u32_t num_blocks)
{
  109ed8:	55                   	push   %ebp
	for (j = 0U; j < slab->num_blocks; j++) {
  109ed9:	31 c9                	xor    %ecx,%ecx
{
  109edb:	89 e5                	mov    %esp,%ebp
  109edd:	57                   	push   %edi
  109ede:	56                   	push   %esi
  109edf:	8b 45 08             	mov    0x8(%ebp),%eax
  109ee2:	53                   	push   %ebx
  109ee3:	8b 55 0c             	mov    0xc(%ebp),%edx
  109ee6:	8b 75 10             	mov    0x10(%ebp),%esi
  109ee9:	8b 5d 14             	mov    0x14(%ebp),%ebx
	/* block size must be word aligned */
	__ASSERT((slab->block_size & (sizeof(void *) - 1)) == 0,
		 "block size not word aligned");

	slab->num_blocks = num_blocks;
	slab->block_size = block_size;
  109eec:	89 70 0c             	mov    %esi,0xc(%eax)
	slab->num_blocks = num_blocks;
  109eef:	89 58 08             	mov    %ebx,0x8(%eax)
	slab->buffer = buffer;
  109ef2:	89 50 10             	mov    %edx,0x10(%eax)
	slab->num_used = 0U;
  109ef5:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
	slab->free_list = NULL;
  109efc:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
	for (j = 0U; j < slab->num_blocks; j++) {
  109f03:	39 cb                	cmp    %ecx,%ebx
  109f05:	74 0d                	je     109f14 <k_mem_slab_init+0x3c>
		*(char **)p = slab->free_list;
  109f07:	8b 78 14             	mov    0x14(%eax),%edi
	for (j = 0U; j < slab->num_blocks; j++) {
  109f0a:	41                   	inc    %ecx
		*(char **)p = slab->free_list;
  109f0b:	89 3a                	mov    %edi,(%edx)
		slab->free_list = p;
  109f0d:	89 50 14             	mov    %edx,0x14(%eax)
		p += slab->block_size;
  109f10:	01 f2                	add    %esi,%edx
  109f12:	eb ef                	jmp    109f03 <k_mem_slab_init+0x2b>
	list->head = (sys_dnode_t *)list;
  109f14:	89 00                	mov    %eax,(%eax)
	list->tail = (sys_dnode_t *)list;
  109f16:	89 40 04             	mov    %eax,0x4(%eax)
	create_free_list(slab);
	z_waitq_init(&slab->wait_q);
	SYS_TRACING_OBJ_INIT(k_mem_slab, slab);

	z_object_init(slab);
}
  109f19:	5b                   	pop    %ebx
  109f1a:	5e                   	pop    %esi
  109f1b:	5f                   	pop    %edi
  109f1c:	5d                   	pop    %ebp
  109f1d:	c3                   	ret    

00109f1e <k_mem_slab_alloc>:

int k_mem_slab_alloc(struct k_mem_slab *slab, void **mem, s32_t timeout)
{
  109f1e:	55                   	push   %ebp
  109f1f:	89 e5                	mov    %esp,%ebp
  109f21:	56                   	push   %esi
  109f22:	53                   	push   %ebx
  109f23:	8b 45 08             	mov    0x8(%ebp),%eax
  109f26:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  109f29:	8b 75 10             	mov    0x10(%ebp),%esi
  109f2c:	9c                   	pushf  
  109f2d:	fa                   	cli    
  109f2e:	59                   	pop    %ecx

	/* block size must be word aligned */
	__ASSERT((slab->block_size & (sizeof(void *) - 1)) == 0,
		 "block size not word aligned");

	if (slab->free_list != NULL) {
  109f2f:	8b 50 14             	mov    0x14(%eax),%edx
  109f32:	85 d2                	test   %edx,%edx
  109f34:	74 0e                	je     109f44 <k_mem_slab_alloc+0x26>
		/* take a free block */
		*mem = slab->free_list;
  109f36:	89 13                	mov    %edx,(%ebx)
		slab->free_list = *(char **)(slab->free_list);
  109f38:	8b 12                	mov    (%edx),%edx
		slab->num_used++;
  109f3a:	ff 40 18             	incl   0x18(%eax)
		slab->free_list = *(char **)(slab->free_list);
  109f3d:	89 50 14             	mov    %edx,0x14(%eax)
		result = 0;
  109f40:	31 c0                	xor    %eax,%eax
  109f42:	eb 32                	jmp    109f76 <k_mem_slab_alloc+0x58>
	} else if (timeout == K_NO_WAIT) {
  109f44:	85 f6                	test   %esi,%esi
  109f46:	75 0d                	jne    109f55 <k_mem_slab_alloc+0x37>
		/* don't wait for a free block to become available */
		*mem = NULL;
  109f48:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
		result = -ENOMEM;
  109f4e:	b8 f4 ff ff ff       	mov    $0xfffffff4,%eax
  109f53:	eb 21                	jmp    109f76 <k_mem_slab_alloc+0x58>
	} else {
		/* wait for a free block or timeout */
		result = z_pend_curr(&lock, key, &slab->wait_q, timeout);
  109f55:	56                   	push   %esi
  109f56:	50                   	push   %eax
  109f57:	51                   	push   %ecx
  109f58:	68 56 0b 11 00       	push   $0x110b56
  109f5d:	e8 c7 08 00 00       	call   10a829 <z_pend_curr>
  109f62:	83 c4 10             	add    $0x10,%esp
		if (result == 0) {
  109f65:	85 c0                	test   %eax,%eax
  109f67:	75 14                	jne    109f7d <k_mem_slab_alloc+0x5f>
			*mem = _current->base.swap_data;
  109f69:	8b 15 28 0a 11 00    	mov    0x110a28,%edx
  109f6f:	8b 52 14             	mov    0x14(%edx),%edx
  109f72:	89 13                	mov    %edx,(%ebx)
  109f74:	eb 07                	jmp    109f7d <k_mem_slab_alloc+0x5f>
  109f76:	0f ba e1 09          	bt     $0x9,%ecx
  109f7a:	73 01                	jae    109f7d <k_mem_slab_alloc+0x5f>
	__asm__ volatile (
  109f7c:	fb                   	sti    
	}

	k_spin_unlock(&lock, key);

	return result;
}
  109f7d:	8d 65 f8             	lea    -0x8(%ebp),%esp
  109f80:	5b                   	pop    %ebx
  109f81:	5e                   	pop    %esi
  109f82:	5d                   	pop    %ebp
  109f83:	c3                   	ret    

00109f84 <k_mem_slab_free>:

void k_mem_slab_free(struct k_mem_slab *slab, void **mem)
{
  109f84:	55                   	push   %ebp
  109f85:	89 e5                	mov    %esp,%ebp
  109f87:	57                   	push   %edi
  109f88:	56                   	push   %esi
  109f89:	53                   	push   %ebx
  109f8a:	8b 7d 0c             	mov    0xc(%ebp),%edi
  109f8d:	8b 5d 08             	mov    0x8(%ebp),%ebx
	__asm__ volatile (
  109f90:	9c                   	pushf  
  109f91:	fa                   	cli    
  109f92:	5e                   	pop    %esi
	k_spinlock_key_t key = k_spin_lock(&lock);
	struct k_thread *pending_thread = z_unpend_first_thread(&slab->wait_q);
  109f93:	53                   	push   %ebx
  109f94:	e8 6b 09 00 00       	call   10a904 <z_unpend_first_thread>
  109f99:	5a                   	pop    %edx

	if (pending_thread != NULL) {
  109f9a:	85 c0                	test   %eax,%eax
  109f9c:	74 37                	je     109fd5 <k_mem_slab_free+0x51>
static ALWAYS_INLINE void
z_set_thread_return_value(struct k_thread *thread, unsigned int value)
{
	/* write into 'eax' slot created in z_swap() entry */

	*(unsigned int *)(thread->callee_saved.esp) = value;
  109f9e:	8b 48 28             	mov    0x28(%eax),%ecx
		z_set_thread_return_value_with_data(pending_thread, 0, *mem);
  109fa1:	8b 17                	mov    (%edi),%edx
  109fa3:	c7 01 00 00 00 00    	movl   $0x0,(%ecx)
	thread->base.swap_data = data;
  109fa9:	89 50 14             	mov    %edx,0x14(%eax)
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
  109fac:	f6 40 0d 1f          	testb  $0x1f,0xd(%eax)
  109fb0:	75 0d                	jne    109fbf <k_mem_slab_free+0x3b>
	if (z_is_thread_ready(thread)) {
  109fb2:	83 78 18 00          	cmpl   $0x0,0x18(%eax)
  109fb6:	75 07                	jne    109fbf <k_mem_slab_free+0x3b>
		z_add_thread_to_ready_q(thread);
  109fb8:	50                   	push   %eax
  109fb9:	e8 c6 05 00 00       	call   10a584 <z_add_thread_to_ready_q>
  109fbe:	58                   	pop    %eax
		z_ready_thread(pending_thread);
		z_reschedule(&lock, key);
  109fbf:	89 75 0c             	mov    %esi,0xc(%ebp)
  109fc2:	c7 45 08 56 0b 11 00 	movl   $0x110b56,0x8(%ebp)
		**(char ***)mem = slab->free_list;
		slab->free_list = *(char **)mem;
		slab->num_used--;
		k_spin_unlock(&lock, key);
	}
}
  109fc9:	8d 65 f4             	lea    -0xc(%ebp),%esp
  109fcc:	5b                   	pop    %ebx
  109fcd:	5e                   	pop    %esi
  109fce:	5f                   	pop    %edi
  109fcf:	5d                   	pop    %ebp
		z_reschedule(&lock, key);
  109fd0:	e9 c5 04 00 00       	jmp    10a49a <z_reschedule>
		**(char ***)mem = slab->free_list;
  109fd5:	8b 07                	mov    (%edi),%eax
  109fd7:	8b 53 14             	mov    0x14(%ebx),%edx
  109fda:	89 10                	mov    %edx,(%eax)
		slab->free_list = *(char **)mem;
  109fdc:	8b 07                	mov    (%edi),%eax
		slab->num_used--;
  109fde:	ff 4b 18             	decl   0x18(%ebx)
  109fe1:	0f ba e6 09          	bt     $0x9,%esi
		slab->free_list = *(char **)mem;
  109fe5:	89 43 14             	mov    %eax,0x14(%ebx)
  109fe8:	73 01                	jae    109feb <k_mem_slab_free+0x67>
	__asm__ volatile (
  109fea:	fb                   	sti    
}
  109feb:	8d 65 f4             	lea    -0xc(%ebp),%esp
  109fee:	5b                   	pop    %ebx
  109fef:	5e                   	pop    %esi
  109ff0:	5f                   	pop    %edi
  109ff1:	5d                   	pop    %ebp
  109ff2:	c3                   	ret    

00109ff3 <z_impl_k_msgq_put>:
	}
}


int z_impl_k_msgq_put(struct k_msgq *q, void *data, s32_t timeout)
{
  109ff3:	55                   	push   %ebp
  109ff4:	89 e5                	mov    %esp,%ebp
  109ff6:	57                   	push   %edi
  109ff7:	56                   	push   %esi
  109ff8:	53                   	push   %ebx
  109ff9:	51                   	push   %ecx
  109ffa:	8b 5d 08             	mov    0x8(%ebp),%ebx
  109ffd:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  10a000:	8b 55 10             	mov    0x10(%ebp),%edx
	__ASSERT(!z_is_in_isr() || timeout == K_NO_WAIT, "");

	k_spinlock_key_t key = k_spin_lock(&q->lock);
  10a003:	8d 7b 08             	lea    0x8(%ebx),%edi
	__asm__ volatile (
  10a006:	9c                   	pushf  
  10a007:	fa                   	cli    
  10a008:	5e                   	pop    %esi
	struct k_thread *pending_thread;
	int result;

	if (q->used_msgs < q->max_msgs) {
  10a009:	8b 43 0c             	mov    0xc(%ebx),%eax
  10a00c:	39 43 20             	cmp    %eax,0x20(%ebx)
  10a00f:	73 79                	jae    10a08a <z_impl_k_msgq_put+0x97>
  10a011:	89 4d 0c             	mov    %ecx,0xc(%ebp)
		/* message queue isn't full */
		pending_thread = z_unpend_first_thread(&q->wait_q);
  10a014:	53                   	push   %ebx
  10a015:	e8 ea 08 00 00       	call   10a904 <z_unpend_first_thread>
  10a01a:	5a                   	pop    %edx
		if (pending_thread != NULL) {
  10a01b:	85 c0                	test   %eax,%eax
  10a01d:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  10a020:	74 3e                	je     10a060 <z_impl_k_msgq_put+0x6d>
			/* give message to waiting thread */
			(void)memcpy(pending_thread->base.swap_data, data,
  10a022:	ff 73 08             	pushl  0x8(%ebx)
  10a025:	89 45 f0             	mov    %eax,-0x10(%ebp)
  10a028:	51                   	push   %ecx
  10a029:	ff 70 14             	pushl  0x14(%eax)
  10a02c:	e8 e1 cd ff ff       	call   106e12 <memcpy>
  10a031:	8b 55 f0             	mov    -0x10(%ebp),%edx
  10a034:	8b 42 28             	mov    0x28(%edx),%eax
  10a037:	83 c4 0c             	add    $0xc,%esp
  10a03a:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
  10a040:	f6 42 0d 1f          	testb  $0x1f,0xd(%edx)
  10a044:	75 0d                	jne    10a053 <z_impl_k_msgq_put+0x60>
	if (z_is_thread_ready(thread)) {
  10a046:	83 7a 18 00          	cmpl   $0x0,0x18(%edx)
  10a04a:	75 07                	jne    10a053 <z_impl_k_msgq_put+0x60>
		z_add_thread_to_ready_q(thread);
  10a04c:	52                   	push   %edx
  10a04d:	e8 32 05 00 00       	call   10a584 <z_add_thread_to_ready_q>
  10a052:	59                   	pop    %ecx
			       q->msg_size);
			/* wake up waiting thread */
			z_set_thread_return_value(pending_thread, 0);
			z_ready_thread(pending_thread);
			z_reschedule(&q->lock, key);
  10a053:	56                   	push   %esi
  10a054:	57                   	push   %edi
  10a055:	e8 40 04 00 00       	call   10a49a <z_reschedule>
  10a05a:	58                   	pop    %eax
			return 0;
  10a05b:	31 c0                	xor    %eax,%eax
			z_reschedule(&q->lock, key);
  10a05d:	5a                   	pop    %edx
			return 0;
  10a05e:	eb 50                	jmp    10a0b0 <z_impl_k_msgq_put+0xbd>
		} else {
			/* put message in queue */
			(void)memcpy(q->write_ptr, data, q->msg_size);
  10a060:	ff 73 08             	pushl  0x8(%ebx)
  10a063:	51                   	push   %ecx
  10a064:	ff 73 1c             	pushl  0x1c(%ebx)
  10a067:	e8 a6 cd ff ff       	call   106e12 <memcpy>
			q->write_ptr += q->msg_size;
  10a06c:	8b 43 08             	mov    0x8(%ebx),%eax
  10a06f:	03 43 1c             	add    0x1c(%ebx),%eax
			(void)memcpy(q->write_ptr, data, q->msg_size);
  10a072:	83 c4 0c             	add    $0xc,%esp
			q->write_ptr += q->msg_size;
  10a075:	89 43 1c             	mov    %eax,0x1c(%ebx)
			if (q->write_ptr == q->buffer_end) {
  10a078:	3b 43 14             	cmp    0x14(%ebx),%eax
  10a07b:	75 06                	jne    10a083 <z_impl_k_msgq_put+0x90>
				q->write_ptr = q->buffer_start;
  10a07d:	8b 43 10             	mov    0x10(%ebx),%eax
  10a080:	89 43 1c             	mov    %eax,0x1c(%ebx)
			}
			q->used_msgs++;
  10a083:	ff 43 20             	incl   0x20(%ebx)
		}
		result = 0;
  10a086:	31 c0                	xor    %eax,%eax
  10a088:	eb 1f                	jmp    10a0a9 <z_impl_k_msgq_put+0xb6>
	} else if (timeout == K_NO_WAIT) {
		/* don't wait for message space to become available */
		result = -ENOMSG;
  10a08a:	b8 b0 ff ff ff       	mov    $0xffffffb0,%eax
	} else if (timeout == K_NO_WAIT) {
  10a08f:	85 d2                	test   %edx,%edx
  10a091:	74 16                	je     10a0a9 <z_impl_k_msgq_put+0xb6>
	} else {
		/* wait for put message success, failure, or timeout */
		_current->base.swap_data = data;
  10a093:	a1 28 0a 11 00       	mov    0x110a28,%eax
  10a098:	89 48 14             	mov    %ecx,0x14(%eax)
		return z_pend_curr(&q->lock, key, &q->wait_q, timeout);
  10a09b:	52                   	push   %edx
  10a09c:	53                   	push   %ebx
  10a09d:	56                   	push   %esi
  10a09e:	57                   	push   %edi
  10a09f:	e8 85 07 00 00       	call   10a829 <z_pend_curr>
  10a0a4:	83 c4 10             	add    $0x10,%esp
  10a0a7:	eb 07                	jmp    10a0b0 <z_impl_k_msgq_put+0xbd>
  10a0a9:	0f ba e6 09          	bt     $0x9,%esi
  10a0ad:	73 01                	jae    10a0b0 <z_impl_k_msgq_put+0xbd>
	__asm__ volatile (
  10a0af:	fb                   	sti    
	}

	k_spin_unlock(&q->lock, key);

	return result;
}
  10a0b0:	8d 65 f4             	lea    -0xc(%ebp),%esp
  10a0b3:	5b                   	pop    %ebx
  10a0b4:	5e                   	pop    %esi
  10a0b5:	5f                   	pop    %edi
  10a0b6:	5d                   	pop    %ebp
  10a0b7:	c3                   	ret    

0010a0b8 <z_impl_k_msgq_get>:
	return 0;
}
#endif

int z_impl_k_msgq_get(struct k_msgq *q, void *data, s32_t timeout)
{
  10a0b8:	55                   	push   %ebp
  10a0b9:	89 e5                	mov    %esp,%ebp
  10a0bb:	57                   	push   %edi
  10a0bc:	56                   	push   %esi
  10a0bd:	53                   	push   %ebx
  10a0be:	51                   	push   %ecx
  10a0bf:	8b 5d 08             	mov    0x8(%ebp),%ebx
  10a0c2:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  10a0c5:	8b 55 10             	mov    0x10(%ebp),%edx
	__ASSERT(!z_is_in_isr() || timeout == K_NO_WAIT, "");

	k_spinlock_key_t key = k_spin_lock(&q->lock);
  10a0c8:	8d 7b 08             	lea    0x8(%ebx),%edi
	__asm__ volatile (
  10a0cb:	9c                   	pushf  
  10a0cc:	fa                   	cli    
  10a0cd:	5e                   	pop    %esi
	struct k_thread *pending_thread;
	int result;

	if (q->used_msgs > 0) {
  10a0ce:	83 7b 20 00          	cmpl   $0x0,0x20(%ebx)
  10a0d2:	0f 84 8c 00 00 00    	je     10a164 <z_impl_k_msgq_get+0xac>
		/* take first available message from queue */
		(void)memcpy(data, q->read_ptr, q->msg_size);
  10a0d8:	ff 73 08             	pushl  0x8(%ebx)
  10a0db:	ff 73 18             	pushl  0x18(%ebx)
  10a0de:	51                   	push   %ecx
  10a0df:	e8 2e cd ff ff       	call   106e12 <memcpy>
		q->read_ptr += q->msg_size;
  10a0e4:	8b 43 08             	mov    0x8(%ebx),%eax
		(void)memcpy(data, q->read_ptr, q->msg_size);
  10a0e7:	83 c4 0c             	add    $0xc,%esp
		q->read_ptr += q->msg_size;
  10a0ea:	03 43 18             	add    0x18(%ebx),%eax
  10a0ed:	89 43 18             	mov    %eax,0x18(%ebx)
		if (q->read_ptr == q->buffer_end) {
  10a0f0:	3b 43 14             	cmp    0x14(%ebx),%eax
  10a0f3:	75 06                	jne    10a0fb <z_impl_k_msgq_get+0x43>
			q->read_ptr = q->buffer_start;
  10a0f5:	8b 43 10             	mov    0x10(%ebx),%eax
  10a0f8:	89 43 18             	mov    %eax,0x18(%ebx)
		}
		q->used_msgs--;
  10a0fb:	ff 4b 20             	decl   0x20(%ebx)

		/* handle first thread waiting to write (if any) */
		pending_thread = z_unpend_first_thread(&q->wait_q);
  10a0fe:	53                   	push   %ebx
  10a0ff:	e8 00 08 00 00       	call   10a904 <z_unpend_first_thread>
  10a104:	5a                   	pop    %edx
  10a105:	89 c2                	mov    %eax,%edx
			z_set_thread_return_value(pending_thread, 0);
			z_ready_thread(pending_thread);
			z_reschedule(&q->lock, key);
			return 0;
		}
		result = 0;
  10a107:	31 c0                	xor    %eax,%eax
		if (pending_thread != NULL) {
  10a109:	85 d2                	test   %edx,%edx
  10a10b:	74 76                	je     10a183 <z_impl_k_msgq_get+0xcb>
			(void)memcpy(q->write_ptr, pending_thread->base.swap_data,
  10a10d:	ff 73 08             	pushl  0x8(%ebx)
  10a110:	ff 72 14             	pushl  0x14(%edx)
  10a113:	ff 73 1c             	pushl  0x1c(%ebx)
  10a116:	89 55 f0             	mov    %edx,-0x10(%ebp)
  10a119:	e8 f4 cc ff ff       	call   106e12 <memcpy>
			q->write_ptr += q->msg_size;
  10a11e:	8b 43 08             	mov    0x8(%ebx),%eax
			(void)memcpy(q->write_ptr, pending_thread->base.swap_data,
  10a121:	83 c4 0c             	add    $0xc,%esp
			q->write_ptr += q->msg_size;
  10a124:	03 43 1c             	add    0x1c(%ebx),%eax
			if (q->write_ptr == q->buffer_end) {
  10a127:	8b 55 f0             	mov    -0x10(%ebp),%edx
			q->write_ptr += q->msg_size;
  10a12a:	89 43 1c             	mov    %eax,0x1c(%ebx)
			if (q->write_ptr == q->buffer_end) {
  10a12d:	3b 43 14             	cmp    0x14(%ebx),%eax
  10a130:	75 06                	jne    10a138 <z_impl_k_msgq_get+0x80>
				q->write_ptr = q->buffer_start;
  10a132:	8b 43 10             	mov    0x10(%ebx),%eax
  10a135:	89 43 1c             	mov    %eax,0x1c(%ebx)
			q->used_msgs++;
  10a138:	ff 43 20             	incl   0x20(%ebx)
  10a13b:	8b 42 28             	mov    0x28(%edx),%eax
  10a13e:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
  10a144:	f6 42 0d 1f          	testb  $0x1f,0xd(%edx)
  10a148:	75 0d                	jne    10a157 <z_impl_k_msgq_get+0x9f>
	if (z_is_thread_ready(thread)) {
  10a14a:	83 7a 18 00          	cmpl   $0x0,0x18(%edx)
  10a14e:	75 07                	jne    10a157 <z_impl_k_msgq_get+0x9f>
		z_add_thread_to_ready_q(thread);
  10a150:	52                   	push   %edx
  10a151:	e8 2e 04 00 00       	call   10a584 <z_add_thread_to_ready_q>
  10a156:	59                   	pop    %ecx
			z_reschedule(&q->lock, key);
  10a157:	56                   	push   %esi
  10a158:	57                   	push   %edi
  10a159:	e8 3c 03 00 00       	call   10a49a <z_reschedule>
  10a15e:	58                   	pop    %eax
			return 0;
  10a15f:	31 c0                	xor    %eax,%eax
			z_reschedule(&q->lock, key);
  10a161:	5a                   	pop    %edx
			return 0;
  10a162:	eb 26                	jmp    10a18a <z_impl_k_msgq_get+0xd2>
	} else if (timeout == K_NO_WAIT) {
		/* don't wait for a message to become available */
		result = -ENOMSG;
  10a164:	b8 b0 ff ff ff       	mov    $0xffffffb0,%eax
	} else if (timeout == K_NO_WAIT) {
  10a169:	85 d2                	test   %edx,%edx
  10a16b:	74 16                	je     10a183 <z_impl_k_msgq_get+0xcb>
	} else {
		/* wait for get message success or timeout */
		_current->base.swap_data = data;
  10a16d:	a1 28 0a 11 00       	mov    0x110a28,%eax
  10a172:	89 48 14             	mov    %ecx,0x14(%eax)
		return z_pend_curr(&q->lock, key, &q->wait_q, timeout);
  10a175:	52                   	push   %edx
  10a176:	53                   	push   %ebx
  10a177:	56                   	push   %esi
  10a178:	57                   	push   %edi
  10a179:	e8 ab 06 00 00       	call   10a829 <z_pend_curr>
  10a17e:	83 c4 10             	add    $0x10,%esp
  10a181:	eb 07                	jmp    10a18a <z_impl_k_msgq_get+0xd2>
  10a183:	0f ba e6 09          	bt     $0x9,%esi
  10a187:	73 01                	jae    10a18a <z_impl_k_msgq_get+0xd2>
	__asm__ volatile (
  10a189:	fb                   	sti    
	}

	k_spin_unlock(&q->lock, key);

	return result;
}
  10a18a:	8d 65 f4             	lea    -0xc(%ebp),%esp
  10a18d:	5b                   	pop    %ebx
  10a18e:	5e                   	pop    %esi
  10a18f:	5f                   	pop    %edi
  10a190:	5d                   	pop    %ebp
  10a191:	c3                   	ret    

0010a192 <z_impl_k_msgq_peek>:
	return z_impl_k_msgq_get(q, (void *)data, timeout);
}
#endif

int z_impl_k_msgq_peek(struct k_msgq *q, void *data)
{
  10a192:	55                   	push   %ebp
  10a193:	89 e5                	mov    %esp,%ebp
  10a195:	53                   	push   %ebx
  10a196:	8b 55 08             	mov    0x8(%ebp),%edx
	__asm__ volatile (
  10a199:	9c                   	pushf  
  10a19a:	fa                   	cli    
  10a19b:	5b                   	pop    %ebx
	k_spinlock_key_t key = k_spin_lock(&q->lock);
	int result;

	if (q->used_msgs > 0) {
  10a19c:	b8 b0 ff ff ff       	mov    $0xffffffb0,%eax
  10a1a1:	83 7a 20 00          	cmpl   $0x0,0x20(%edx)
  10a1a5:	74 13                	je     10a1ba <z_impl_k_msgq_peek+0x28>
		/* take first available message from queue */
		(void)memcpy(data, q->read_ptr, q->msg_size);
  10a1a7:	ff 72 08             	pushl  0x8(%edx)
  10a1aa:	ff 72 18             	pushl  0x18(%edx)
  10a1ad:	ff 75 0c             	pushl  0xc(%ebp)
  10a1b0:	e8 5d cc ff ff       	call   106e12 <memcpy>
  10a1b5:	83 c4 0c             	add    $0xc,%esp
		result = 0;
  10a1b8:	31 c0                	xor    %eax,%eax
  10a1ba:	0f ba e3 09          	bt     $0x9,%ebx
  10a1be:	73 01                	jae    10a1c1 <z_impl_k_msgq_peek+0x2f>
	__asm__ volatile (
  10a1c0:	fb                   	sti    
	}

	k_spin_unlock(&q->lock, key);

	return result;
}
  10a1c1:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  10a1c4:	c9                   	leave  
  10a1c5:	c3                   	ret    

0010a1c6 <z_impl_k_mutex_init>:
SYS_INIT(init_mutex_module, PRE_KERNEL_1, CONFIG_KERNEL_INIT_PRIORITY_OBJECTS);

#endif /* CONFIG_OBJECT_TRACING */

void z_impl_k_mutex_init(struct k_mutex *mutex)
{
  10a1c6:	55                   	push   %ebp
  10a1c7:	89 e5                	mov    %esp,%ebp
  10a1c9:	8b 45 08             	mov    0x8(%ebp),%eax
	mutex->owner = NULL;
  10a1cc:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
	mutex->lock_count = 0U;
  10a1d3:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
	list->head = (sys_dnode_t *)list;
  10a1da:	89 00                	mov    %eax,(%eax)
	list->tail = (sys_dnode_t *)list;
  10a1dc:	89 40 04             	mov    %eax,0x4(%eax)
	z_waitq_init(&mutex->wait_q);

	SYS_TRACING_OBJ_INIT(k_mutex, mutex);
	z_object_init(mutex);
	sys_trace_end_call(SYS_TRACE_ID_MUTEX_INIT);
}
  10a1df:	5d                   	pop    %ebp
  10a1e0:	c3                   	ret    

0010a1e1 <z_impl_k_mutex_lock>:
		z_thread_priority_set(mutex->owner, new_prio);
	}
}

int z_impl_k_mutex_lock(struct k_mutex *mutex, s32_t timeout)
{
  10a1e1:	55                   	push   %ebp
  10a1e2:	89 e5                	mov    %esp,%ebp
  10a1e4:	57                   	push   %edi
  10a1e5:	56                   	push   %esi
  10a1e6:	53                   	push   %ebx
  10a1e7:	50                   	push   %eax
{
#ifdef CONFIG_PREEMPT_ENABLED
	__ASSERT(!z_is_in_isr(), "");
	__ASSERT(_current->base.sched_locked != 1, "");

	--_current->base.sched_locked;
  10a1e8:	a1 28 0a 11 00       	mov    0x110a28,%eax
  10a1ed:	8b 5d 08             	mov    0x8(%ebp),%ebx
  10a1f0:	8b 75 0c             	mov    0xc(%ebp),%esi
  10a1f3:	fe 48 0f             	decb   0xf(%eax)
	k_spinlock_key_t key;

	sys_trace_void(SYS_TRACE_ID_MUTEX_LOCK);
	z_sched_lock();

	if (likely((mutex->lock_count == 0U) || (mutex->owner == _current))) {
  10a1f6:	8b 53 0c             	mov    0xc(%ebx),%edx
  10a1f9:	a1 28 0a 11 00       	mov    0x110a28,%eax
  10a1fe:	85 d2                	test   %edx,%edx
  10a200:	74 0c                	je     10a20e <z_impl_k_mutex_lock+0x2d>
  10a202:	8b 4b 08             	mov    0x8(%ebx),%ecx
  10a205:	39 c1                	cmp    %eax,%ecx
  10a207:	75 1f                	jne    10a228 <z_impl_k_mutex_lock+0x47>

		mutex->owner_orig_prio = (mutex->lock_count == 0U) ?
					_current->base.prio :
  10a209:	8b 4b 10             	mov    0x10(%ebx),%ecx
  10a20c:	eb 04                	jmp    10a212 <z_impl_k_mutex_lock+0x31>
  10a20e:	0f be 48 0e          	movsbl 0xe(%eax),%ecx
					mutex->owner_orig_prio;

		mutex->lock_count++;
  10a212:	42                   	inc    %edx
		mutex->owner = _current;
  10a213:	89 43 08             	mov    %eax,0x8(%ebx)
		mutex->owner_orig_prio = (mutex->lock_count == 0U) ?
  10a216:	89 4b 10             	mov    %ecx,0x10(%ebx)
		mutex->lock_count++;
  10a219:	89 53 0c             	mov    %edx,0xc(%ebx)

		K_DEBUG("%p took mutex %p, count: %d, orig prio: %d\n",
			_current, mutex, mutex->lock_count,
			mutex->owner_orig_prio);

		k_sched_unlock();
  10a21c:	e8 3c 03 00 00       	call   10a55d <k_sched_unlock>
		sys_trace_end_call(SYS_TRACE_ID_MUTEX_LOCK);

		return 0;
  10a221:	31 c0                	xor    %eax,%eax
  10a223:	e9 a4 00 00 00       	jmp    10a2cc <z_impl_k_mutex_lock+0xeb>
	}

	if (unlikely(timeout == (s32_t)K_NO_WAIT)) {
  10a228:	85 f6                	test   %esi,%esi
  10a22a:	75 0f                	jne    10a23b <z_impl_k_mutex_lock+0x5a>
		k_sched_unlock();
  10a22c:	e8 2c 03 00 00       	call   10a55d <k_sched_unlock>
		sys_trace_end_call(SYS_TRACE_ID_MUTEX_LOCK);
		return -EBUSY;
  10a231:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
  10a236:	e9 91 00 00 00       	jmp    10a2cc <z_impl_k_mutex_lock+0xeb>
	}

	new_prio = new_prio_for_inheritance(_current->base.prio,
  10a23b:	0f be 50 0e          	movsbl 0xe(%eax),%edx
  10a23f:	0f be 41 0e          	movsbl 0xe(%ecx),%eax
  10a243:	39 d0                	cmp    %edx,%eax
  10a245:	7e 02                	jle    10a249 <z_impl_k_mutex_lock+0x68>
  10a247:	89 d0                	mov    %edx,%eax
  10a249:	85 c0                	test   %eax,%eax
  10a24b:	79 02                	jns    10a24f <z_impl_k_mutex_lock+0x6e>
  10a24d:	31 c0                	xor    %eax,%eax
	__asm__ volatile (
  10a24f:	9c                   	pushf  
  10a250:	fa                   	cli    
  10a251:	5f                   	pop    %edi

	key = k_spin_lock(&lock);

	K_DEBUG("adjusting prio up on mutex %p\n", mutex);

	if (z_is_prio_higher(new_prio, mutex->owner->base.prio)) {
  10a252:	8b 53 08             	mov    0x8(%ebx),%edx
  10a255:	0f be 4a 0e          	movsbl 0xe(%edx),%ecx
  10a259:	39 c8                	cmp    %ecx,%eax
  10a25b:	7d 09                	jge    10a266 <z_impl_k_mutex_lock+0x85>
		z_thread_priority_set(mutex->owner, new_prio);
  10a25d:	50                   	push   %eax
  10a25e:	52                   	push   %edx
  10a25f:	e8 e6 05 00 00       	call   10a84a <z_thread_priority_set>
  10a264:	59                   	pop    %ecx
  10a265:	58                   	pop    %eax
		adjust_owner_prio(mutex, new_prio);
	}

	int got_mutex = z_pend_curr(&lock, key, &mutex->wait_q, timeout);
  10a266:	56                   	push   %esi
  10a267:	53                   	push   %ebx
  10a268:	57                   	push   %edi
  10a269:	68 56 0b 11 00       	push   $0x110b56
  10a26e:	e8 b6 05 00 00       	call   10a829 <z_pend_curr>
  10a273:	83 c4 10             	add    $0x10,%esp
	K_DEBUG("on mutex %p got_mutex value: %d\n", mutex, got_mutex);

	K_DEBUG("%p got mutex %p (y/n): %c\n", _current, mutex,
		got_mutex ? 'y' : 'n');

	if (got_mutex == 0) {
  10a276:	89 45 f0             	mov    %eax,-0x10(%ebp)
  10a279:	85 c0                	test   %eax,%eax
  10a27b:	75 0a                	jne    10a287 <z_impl_k_mutex_lock+0xa6>
		k_sched_unlock();
  10a27d:	e8 db 02 00 00       	call   10a55d <k_sched_unlock>
		sys_trace_end_call(SYS_TRACE_ID_MUTEX_LOCK);
		return 0;
  10a282:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10a285:	eb 45                	jmp    10a2cc <z_impl_k_mutex_lock+0xeb>
	return list->head == list;
  10a287:	8b 13                	mov    (%ebx),%edx
  10a289:	8b 43 10             	mov    0x10(%ebx),%eax
	return sys_dlist_is_empty(list) ? NULL : list->head;
  10a28c:	39 d3                	cmp    %edx,%ebx
  10a28e:	74 14                	je     10a2a4 <z_impl_k_mutex_lock+0xc3>

	struct k_thread *waiter = z_waitq_head(&mutex->wait_q);

	new_prio = mutex->owner_orig_prio;
	new_prio = (waiter != NULL) ?
		new_prio_for_inheritance(waiter->base.prio, new_prio) :
  10a290:	85 d2                	test   %edx,%edx
  10a292:	74 10                	je     10a2a4 <z_impl_k_mutex_lock+0xc3>
  10a294:	0f be 52 0e          	movsbl 0xe(%edx),%edx
  10a298:	39 d0                	cmp    %edx,%eax
  10a29a:	7e 02                	jle    10a29e <z_impl_k_mutex_lock+0xbd>
  10a29c:	89 d0                	mov    %edx,%eax
  10a29e:	85 c0                	test   %eax,%eax
  10a2a0:	79 02                	jns    10a2a4 <z_impl_k_mutex_lock+0xc3>
  10a2a2:	31 c0                	xor    %eax,%eax
  10a2a4:	9c                   	pushf  
  10a2a5:	fa                   	cli    
  10a2a6:	5e                   	pop    %esi
		new_prio;

	K_DEBUG("adjusting prio down on mutex %p\n", mutex);

	key = k_spin_lock(&lock);
	adjust_owner_prio(mutex, new_prio);
  10a2a7:	8b 53 08             	mov    0x8(%ebx),%edx
	if (mutex->owner->base.prio != new_prio) {
  10a2aa:	0f be 4a 0e          	movsbl 0xe(%edx),%ecx
  10a2ae:	39 c8                	cmp    %ecx,%eax
  10a2b0:	74 09                	je     10a2bb <z_impl_k_mutex_lock+0xda>
		z_thread_priority_set(mutex->owner, new_prio);
  10a2b2:	50                   	push   %eax
  10a2b3:	52                   	push   %edx
  10a2b4:	e8 91 05 00 00       	call   10a84a <z_thread_priority_set>
  10a2b9:	58                   	pop    %eax
  10a2ba:	5a                   	pop    %edx
  10a2bb:	0f ba e6 09          	bt     $0x9,%esi
  10a2bf:	73 01                	jae    10a2c2 <z_impl_k_mutex_lock+0xe1>
	__asm__ volatile (
  10a2c1:	fb                   	sti    
	k_spin_unlock(&lock, key);

	k_sched_unlock();
  10a2c2:	e8 96 02 00 00       	call   10a55d <k_sched_unlock>

	sys_trace_end_call(SYS_TRACE_ID_MUTEX_LOCK);
	return -EAGAIN;
  10a2c7:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
}
  10a2cc:	8d 65 f4             	lea    -0xc(%ebp),%esp
  10a2cf:	5b                   	pop    %ebx
  10a2d0:	5e                   	pop    %esi
  10a2d1:	5f                   	pop    %edi
  10a2d2:	5d                   	pop    %ebp
  10a2d3:	c3                   	ret    

0010a2d4 <z_impl_k_mutex_unlock>:
	return z_impl_k_mutex_lock((struct k_mutex *)mutex, (s32_t)timeout);
}
#endif

void z_impl_k_mutex_unlock(struct k_mutex *mutex)
{
  10a2d4:	55                   	push   %ebp
  10a2d5:	a1 28 0a 11 00       	mov    0x110a28,%eax
  10a2da:	89 e5                	mov    %esp,%ebp
  10a2dc:	57                   	push   %edi
  10a2dd:	56                   	push   %esi
  10a2de:	53                   	push   %ebx
  10a2df:	8b 5d 08             	mov    0x8(%ebp),%ebx
  10a2e2:	fe 48 0f             	decb   0xf(%eax)
	sys_trace_void(SYS_TRACE_ID_MUTEX_UNLOCK);
	z_sched_lock();

	K_DEBUG("mutex %p lock_count: %d\n", mutex, mutex->lock_count);

	if (mutex->lock_count - 1U != 0U) {
  10a2e5:	8b 43 0c             	mov    0xc(%ebx),%eax
  10a2e8:	83 f8 01             	cmp    $0x1,%eax
  10a2eb:	74 06                	je     10a2f3 <z_impl_k_mutex_unlock+0x1f>
		mutex->lock_count--;
  10a2ed:	48                   	dec    %eax
  10a2ee:	89 43 0c             	mov    %eax,0xc(%ebx)
		goto k_mutex_unlock_return;
  10a2f1:	eb 66                	jmp    10a359 <z_impl_k_mutex_unlock+0x85>
	__asm__ volatile (
  10a2f3:	9c                   	pushf  
  10a2f4:	fa                   	cli    
  10a2f5:	5f                   	pop    %edi
	}

	k_spinlock_key_t key = k_spin_lock(&lock);

	adjust_owner_prio(mutex, mutex->owner_orig_prio);
  10a2f6:	8b 43 08             	mov    0x8(%ebx),%eax
  10a2f9:	8b 53 10             	mov    0x10(%ebx),%edx
	if (mutex->owner->base.prio != new_prio) {
  10a2fc:	0f be 48 0e          	movsbl 0xe(%eax),%ecx
  10a300:	39 ca                	cmp    %ecx,%edx
  10a302:	74 09                	je     10a30d <z_impl_k_mutex_unlock+0x39>
		z_thread_priority_set(mutex->owner, new_prio);
  10a304:	52                   	push   %edx
  10a305:	50                   	push   %eax
  10a306:	e8 3f 05 00 00       	call   10a84a <z_thread_priority_set>
  10a30b:	59                   	pop    %ecx
  10a30c:	5e                   	pop    %esi

	new_owner = z_unpend_first_thread(&mutex->wait_q);
  10a30d:	53                   	push   %ebx
  10a30e:	e8 f1 05 00 00       	call   10a904 <z_unpend_first_thread>
  10a313:	81 e7 00 02 00 00    	and    $0x200,%edi
  10a319:	5a                   	pop    %edx
  10a31a:	89 c6                	mov    %eax,%esi

	mutex->owner = new_owner;
  10a31c:	89 43 08             	mov    %eax,0x8(%ebx)

	K_DEBUG("new owner of mutex %p: %p (prio: %d)\n",
		mutex, new_owner, new_owner ? new_owner->base.prio : -1000);

	if (new_owner != NULL) {
  10a31f:	85 c0                	test   %eax,%eax
  10a321:	74 2a                	je     10a34d <z_impl_k_mutex_unlock+0x79>
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
  10a323:	f6 40 0d 1f          	testb  $0x1f,0xd(%eax)
  10a327:	75 0d                	jne    10a336 <z_impl_k_mutex_unlock+0x62>
	if (z_is_thread_ready(thread)) {
  10a329:	83 78 18 00          	cmpl   $0x0,0x18(%eax)
  10a32d:	75 07                	jne    10a336 <z_impl_k_mutex_unlock+0x62>
		z_add_thread_to_ready_q(thread);
  10a32f:	50                   	push   %eax
  10a330:	e8 4f 02 00 00       	call   10a584 <z_add_thread_to_ready_q>
  10a335:	58                   	pop    %eax
  10a336:	85 ff                	test   %edi,%edi
  10a338:	74 01                	je     10a33b <z_impl_k_mutex_unlock+0x67>
	__asm__ volatile (
  10a33a:	fb                   	sti    
  10a33b:	8b 46 28             	mov    0x28(%esi),%eax
  10a33e:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		/*
		 * new owner is already of higher or equal prio than first
		 * waiter since the wait queue is priority-based: no need to
		 * ajust its priority
		 */
		mutex->owner_orig_prio = new_owner->base.prio;
  10a344:	0f be 46 0e          	movsbl 0xe(%esi),%eax
  10a348:	89 43 10             	mov    %eax,0x10(%ebx)
  10a34b:	eb 0c                	jmp    10a359 <z_impl_k_mutex_unlock+0x85>
	} else {
		mutex->lock_count = 0U;
  10a34d:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
  10a354:	85 ff                	test   %edi,%edi
  10a356:	74 01                	je     10a359 <z_impl_k_mutex_unlock+0x85>
  10a358:	fb                   	sti    
	}


k_mutex_unlock_return:
	k_sched_unlock();
}
  10a359:	8d 65 f4             	lea    -0xc(%ebp),%esp
  10a35c:	5b                   	pop    %ebx
  10a35d:	5e                   	pop    %esi
  10a35e:	5f                   	pop    %edi
  10a35f:	5d                   	pop    %ebp
	k_sched_unlock();
  10a360:	e9 f8 01 00 00       	jmp    10a55d <k_sched_unlock>

0010a365 <sys_dlist_remove>:
	node->prev->next = node->next;
  10a365:	8b 48 04             	mov    0x4(%eax),%ecx
  10a368:	8b 10                	mov    (%eax),%edx
  10a36a:	89 11                	mov    %edx,(%ecx)
	node->next->prev = node->prev;
  10a36c:	89 4a 04             	mov    %ecx,0x4(%edx)
	node->next = NULL;
  10a36f:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	node->prev = NULL;
  10a375:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
	sys_dnode_init(node);
}
  10a37c:	c3                   	ret    

0010a37d <z_is_thread_ready>:
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
  10a37d:	f6 40 0d 1f          	testb  $0x1f,0xd(%eax)
  10a381:	75 0c                	jne    10a38f <z_is_thread_ready+0x12>
  10a383:	83 78 18 00          	cmpl   $0x0,0x18(%eax)
  10a387:	0f 94 c0             	sete   %al
  10a38a:	0f b6 c0             	movzbl %al,%eax
  10a38d:	eb 02                	jmp    10a391 <z_is_thread_ready+0x14>
  10a38f:	31 c0                	xor    %eax,%eax
  10a391:	83 e0 01             	and    $0x1,%eax
}
  10a394:	c3                   	ret    

0010a395 <reset_time_slice>:
 */
static struct k_thread *pending_current;
#endif

static void reset_time_slice(void)
{
  10a395:	55                   	push   %ebp
  10a396:	89 e5                	mov    %esp,%ebp
	/* Add the elapsed time since the last announced tick to the
	 * slice count, as we'll see those "expired" ticks arrive in a
	 * FUTURE z_time_slice() call.
	 */
	_current_cpu->slice_ticks = slice_time + z_clock_elapsed();
  10a398:	e8 0b c4 ff ff       	call   1067a8 <z_clock_elapsed>

	z_set_timeout_expiry(slice_time, false);
  10a39d:	6a 00                	push   $0x0
	_current_cpu->slice_ticks = slice_time + z_clock_elapsed();
  10a39f:	8b 15 4c 0b 11 00    	mov    0x110b4c,%edx
  10a3a5:	01 d0                	add    %edx,%eax
	z_set_timeout_expiry(slice_time, false);
  10a3a7:	52                   	push   %edx
	_current_cpu->slice_ticks = slice_time + z_clock_elapsed();
  10a3a8:	a3 30 0a 11 00       	mov    %eax,0x110a30
	z_set_timeout_expiry(slice_time, false);
  10a3ad:	e8 5a 0d 00 00       	call   10b10c <z_set_timeout_expiry>
  10a3b2:	58                   	pop    %eax
  10a3b3:	5a                   	pop    %edx
}
  10a3b4:	c9                   	leave  
  10a3b5:	c3                   	ret    

0010a3b6 <z_is_t1_higher_prio_than_t2>:
{
  10a3b6:	55                   	push   %ebp
  10a3b7:	89 e5                	mov    %esp,%ebp
	if (t1->base.prio < t2->base.prio) {
  10a3b9:	8b 45 0c             	mov    0xc(%ebp),%eax
  10a3bc:	8b 55 08             	mov    0x8(%ebp),%edx
}
  10a3bf:	5d                   	pop    %ebp
	if (t1->base.prio < t2->base.prio) {
  10a3c0:	8a 40 0e             	mov    0xe(%eax),%al
  10a3c3:	38 42 0e             	cmp    %al,0xe(%edx)
  10a3c6:	0f 9c c0             	setl   %al
}
  10a3c9:	c3                   	ret    

0010a3ca <k_sched_time_slice_set>:

void k_sched_time_slice_set(s32_t slice, int prio)
{
  10a3ca:	55                   	push   %ebp
  10a3cb:	89 e5                	mov    %esp,%ebp
  10a3cd:	57                   	push   %edi
  10a3ce:	56                   	push   %esi
  10a3cf:	53                   	push   %ebx
  10a3d0:	50                   	push   %eax
	__asm__ volatile (
  10a3d1:	9c                   	pushf  
  10a3d2:	fa                   	cli    
  10a3d3:	8f 45 f0             	popl   -0x10(%ebp)
static inline int sys_clock_hw_cycles_per_sec(void)
{
#if defined(CONFIG_TIMER_READS_ITS_FREQUENCY_AT_RUNTIME)
	extern int z_clock_hw_cycles_per_sec;

	return z_clock_hw_cycles_per_sec;
  10a3d6:	8b 1d cc 32 11 00    	mov    0x1132cc,%ebx
{
#ifdef CONFIG_SYS_CLOCK_EXISTS

#ifdef _NEED_PRECISE_TICK_MS_CONVERSION
	/* use 64-bit math to keep precision */
	return (s32_t)ceiling_fraction(
  10a3dc:	b8 e8 03 00 00       	mov    $0x3e8,%eax
  10a3e1:	f7 eb                	imul   %ebx
  10a3e3:	6a 00                	push   $0x0
	LOCKED(&sched_spinlock) {
		_current_cpu->slice_ticks = 0;
  10a3e5:	c7 05 30 0a 11 00 00 	movl   $0x0,0x110a30
  10a3ec:	00 00 00 
  10a3ef:	6a 64                	push   $0x64
  10a3f1:	52                   	push   %edx
  10a3f2:	50                   	push   %eax
  10a3f3:	e8 a8 5c ff ff       	call   1000a0 <__divdi3>
  10a3f8:	89 c6                	mov    %eax,%esi
  10a3fa:	89 d8                	mov    %ebx,%eax
  10a3fc:	89 d7                	mov    %edx,%edi
  10a3fe:	83 c4 10             	add    $0x10,%esp
  10a401:	f7 6d 08             	imull  0x8(%ebp)
  10a404:	89 f1                	mov    %esi,%ecx
  10a406:	89 fb                	mov    %edi,%ebx
  10a408:	83 c1 ff             	add    $0xffffffff,%ecx
  10a40b:	57                   	push   %edi
  10a40c:	83 d3 ff             	adc    $0xffffffff,%ebx
  10a40f:	01 c8                	add    %ecx,%eax
  10a411:	11 da                	adc    %ebx,%edx
  10a413:	56                   	push   %esi
  10a414:	52                   	push   %edx
  10a415:	50                   	push   %eax
  10a416:	e8 85 5c ff ff       	call   1000a0 <__divdi3>
  10a41b:	83 c4 10             	add    $0x10,%esp
  10a41e:	a3 4c 0b 11 00       	mov    %eax,0x110b4c
		slice_time = z_ms_to_ticks(slice);
		slice_max_prio = prio;
  10a423:	8b 45 0c             	mov    0xc(%ebp),%eax
  10a426:	a3 48 0b 11 00       	mov    %eax,0x110b48
		reset_time_slice();
  10a42b:	e8 65 ff ff ff       	call   10a395 <reset_time_slice>
  10a430:	0f ba 65 f0 09       	btl    $0x9,-0x10(%ebp)
  10a435:	73 01                	jae    10a438 <k_sched_time_slice_set+0x6e>
	__asm__ volatile (
  10a437:	fb                   	sti    
	}
}
  10a438:	8d 65 f4             	lea    -0xc(%ebp),%esp
  10a43b:	5b                   	pop    %ebx
  10a43c:	5e                   	pop    %esi
  10a43d:	5f                   	pop    %edi
  10a43e:	5d                   	pop    %ebp
  10a43f:	c3                   	ret    

0010a440 <z_unpend_thread_no_timeout>:

	return ret;
}

ALWAYS_INLINE void z_unpend_thread_no_timeout(struct k_thread *thread)
{
  10a440:	55                   	push   %ebp
  10a441:	89 e5                	mov    %esp,%ebp
  10a443:	56                   	push   %esi
  10a444:	53                   	push   %ebx
  10a445:	8b 5d 08             	mov    0x8(%ebp),%ebx
	__asm__ volatile (
  10a448:	9c                   	pushf  
  10a449:	fa                   	cli    
  10a44a:	5e                   	pop    %esi
	}
#endif

	__ASSERT_NO_MSG(!is_idle(thread));

	sys_dlist_remove(&thread->base.qnode_dlist);
  10a44b:	89 d8                	mov    %ebx,%eax
  10a44d:	e8 13 ff ff ff       	call   10a365 <sys_dlist_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
  10a452:	80 63 0d fd          	andb   $0xfd,0xd(%ebx)
  10a456:	0f ba e6 09          	bt     $0x9,%esi
  10a45a:	73 01                	jae    10a45d <z_unpend_thread_no_timeout+0x1d>
	__asm__ volatile (
  10a45c:	fb                   	sti    
	thread->base.pended_on = NULL;
  10a45d:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
}
  10a464:	5b                   	pop    %ebx
  10a465:	5e                   	pop    %esi
  10a466:	5d                   	pop    %ebp
  10a467:	c3                   	ret    

0010a468 <z_unpend_thread>:
{
  10a468:	55                   	push   %ebp
  10a469:	89 e5                	mov    %esp,%ebp
  10a46b:	56                   	push   %esi
  10a46c:	53                   	push   %ebx
  10a46d:	8b 5d 08             	mov    0x8(%ebp),%ebx
	__asm__ volatile (
  10a470:	9c                   	pushf  
  10a471:	fa                   	cli    
  10a472:	5e                   	pop    %esi
	sys_dlist_remove(&thread->base.qnode_dlist);
  10a473:	89 d8                	mov    %ebx,%eax
  10a475:	e8 eb fe ff ff       	call   10a365 <sys_dlist_remove>
  10a47a:	80 63 0d fd          	andb   $0xfd,0xd(%ebx)
  10a47e:	0f ba e6 09          	bt     $0x9,%esi
  10a482:	73 01                	jae    10a485 <z_unpend_thread+0x1d>
	__asm__ volatile (
  10a484:	fb                   	sti    
	thread->base.pended_on = NULL;
  10a485:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
	z_add_timeout(&th->base.timeout, z_thread_timeout, ticks);
}

static inline int z_abort_thread_timeout(struct k_thread *thread)
{
	return z_abort_timeout(&thread->base.timeout);
  10a48c:	83 c3 18             	add    $0x18,%ebx
  10a48f:	89 5d 08             	mov    %ebx,0x8(%ebp)
}
  10a492:	5b                   	pop    %ebx
  10a493:	5e                   	pop    %esi
  10a494:	5d                   	pop    %ebp
  10a495:	e9 35 0c 00 00       	jmp    10b0cf <z_abort_timeout>

0010a49a <z_reschedule>:
{
  10a49a:	55                   	push   %ebp
  10a49b:	89 e5                	mov    %esp,%ebp
	if (resched()) {
  10a49d:	83 3d 20 0a 11 00 00 	cmpl   $0x0,0x110a20
{
  10a4a4:	8b 45 0c             	mov    0xc(%ebp),%eax
	if (resched()) {
  10a4a7:	75 09                	jne    10a4b2 <z_reschedule+0x18>
  10a4a9:	89 45 08             	mov    %eax,0x8(%ebp)
}
  10a4ac:	5d                   	pop    %ebp
  10a4ad:	e9 e3 c3 ff ff       	jmp    106895 <__swap>
  10a4b2:	0f ba e0 09          	bt     $0x9,%eax
  10a4b6:	73 01                	jae    10a4b9 <z_reschedule+0x1f>
  10a4b8:	fb                   	sti    
  10a4b9:	5d                   	pop    %ebp
  10a4ba:	c3                   	ret    

0010a4bb <z_reschedule_irqlock>:
{
  10a4bb:	55                   	push   %ebp
  10a4bc:	89 e5                	mov    %esp,%ebp
	if (resched()) {
  10a4be:	83 3d 20 0a 11 00 00 	cmpl   $0x0,0x110a20
{
  10a4c5:	8b 45 08             	mov    0x8(%ebp),%eax
	if (resched()) {
  10a4c8:	75 06                	jne    10a4d0 <z_reschedule_irqlock+0x15>
}
  10a4ca:	5d                   	pop    %ebp
  10a4cb:	e9 c5 c3 ff ff       	jmp    106895 <__swap>
  10a4d0:	0f ba e0 09          	bt     $0x9,%eax
  10a4d4:	73 01                	jae    10a4d7 <z_reschedule_irqlock+0x1c>
  10a4d6:	fb                   	sti    
  10a4d7:	5d                   	pop    %ebp
  10a4d8:	c3                   	ret    

0010a4d9 <z_reschedule_unlocked>:
{
  10a4d9:	55                   	push   %ebp
  10a4da:	89 e5                	mov    %esp,%ebp
	__asm__ volatile (
  10a4dc:	9c                   	pushf  
  10a4dd:	fa                   	cli    
  10a4de:	58                   	pop    %eax
	(void) z_reschedule_irqlock(z_arch_irq_lock());
  10a4df:	50                   	push   %eax
  10a4e0:	e8 d6 ff ff ff       	call   10a4bb <z_reschedule_irqlock>
  10a4e5:	58                   	pop    %eax
}
  10a4e6:	c9                   	leave  
  10a4e7:	c3                   	ret    

0010a4e8 <k_sched_lock>:
  10a4e8:	9c                   	pushf  
  10a4e9:	fa                   	cli    
  10a4ea:	5a                   	pop    %edx
	--_current->base.sched_locked;
  10a4eb:	a1 28 0a 11 00       	mov    0x110a28,%eax
  10a4f0:	fe 48 0f             	decb   0xf(%eax)
  10a4f3:	0f ba e2 09          	bt     $0x9,%edx
  10a4f7:	73 01                	jae    10a4fa <k_sched_lock+0x12>
	__asm__ volatile (
  10a4f9:	fb                   	sti    
}
  10a4fa:	c3                   	ret    

0010a4fb <z_priq_dumb_best>:
}

struct k_thread *z_priq_dumb_best(sys_dlist_t *pq)
{
  10a4fb:	55                   	push   %ebp
  10a4fc:	89 e5                	mov    %esp,%ebp
  10a4fe:	8b 55 08             	mov    0x8(%ebp),%edx
	return list->head == list;
  10a501:	8b 02                	mov    (%edx),%eax
	struct k_thread *t = NULL;
	sys_dnode_t *n = sys_dlist_peek_head(pq);

	if (n != NULL) {
  10a503:	85 c0                	test   %eax,%eax
  10a505:	74 04                	je     10a50b <z_priq_dumb_best+0x10>
  10a507:	39 c2                	cmp    %eax,%edx
  10a509:	75 02                	jne    10a50d <z_priq_dumb_best+0x12>
	struct k_thread *t = NULL;
  10a50b:	31 c0                	xor    %eax,%eax
		t = CONTAINER_OF(n, struct k_thread, base.qnode_dlist);
	}
	return t;
}
  10a50d:	5d                   	pop    %ebp
  10a50e:	c3                   	ret    

0010a50f <update_cache>:
{
  10a50f:	55                   	push   %ebp
  10a510:	89 c1                	mov    %eax,%ecx
  10a512:	89 e5                	mov    %esp,%ebp
  10a514:	53                   	push   %ebx
	struct k_thread *th = _priq_run_best(&_kernel.ready_q.runq);
  10a515:	68 44 0a 11 00       	push   $0x110a44
  10a51a:	e8 dc ff ff ff       	call   10a4fb <z_priq_dumb_best>
  10a51f:	5a                   	pop    %edx
	return th ? th : _current_cpu->idle_thread;
  10a520:	8b 1d 2c 0a 11 00    	mov    0x110a2c,%ebx
  10a526:	85 c0                	test   %eax,%eax
  10a528:	74 02                	je     10a52c <update_cache+0x1d>
  10a52a:	89 c3                	mov    %eax,%ebx
	if (preempt_ok != 0) {
  10a52c:	a1 28 0a 11 00       	mov    0x110a28,%eax
  10a531:	85 c9                	test   %ecx,%ecx
  10a533:	75 14                	jne    10a549 <update_cache+0x3a>
	if (z_is_thread_prevented_from_running(_current)) {
  10a535:	f6 40 0d 1f          	testb  $0x1f,0xd(%eax)
  10a539:	75 0e                	jne    10a549 <update_cache+0x3a>
	if (is_preempt(_current) || is_metairq(th)) {
  10a53b:	66 83 78 0e 7f       	cmpw   $0x7f,0xe(%eax)
  10a540:	76 07                	jbe    10a549 <update_cache+0x3a>
		_kernel.ready_q.cache = _current;
  10a542:	a3 40 0a 11 00       	mov    %eax,0x110a40
  10a547:	eb 0f                	jmp    10a558 <update_cache+0x49>
		if (th != _current) {
  10a549:	39 c3                	cmp    %eax,%ebx
  10a54b:	74 05                	je     10a552 <update_cache+0x43>
			reset_time_slice();
  10a54d:	e8 43 fe ff ff       	call   10a395 <reset_time_slice>
		_kernel.ready_q.cache = th;
  10a552:	89 1d 40 0a 11 00    	mov    %ebx,0x110a40
}
  10a558:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  10a55b:	c9                   	leave  
  10a55c:	c3                   	ret    

0010a55d <k_sched_unlock>:
{
  10a55d:	55                   	push   %ebp
  10a55e:	89 e5                	mov    %esp,%ebp
  10a560:	53                   	push   %ebx
	__asm__ volatile (
  10a561:	9c                   	pushf  
  10a562:	fa                   	cli    
  10a563:	5b                   	pop    %ebx
		++_current->base.sched_locked;
  10a564:	a1 28 0a 11 00       	mov    0x110a28,%eax
  10a569:	fe 40 0f             	incb   0xf(%eax)
		update_cache(1);
  10a56c:	b8 01 00 00 00       	mov    $0x1,%eax
  10a571:	e8 99 ff ff ff       	call   10a50f <update_cache>
  10a576:	0f ba e3 09          	bt     $0x9,%ebx
  10a57a:	73 01                	jae    10a57d <k_sched_unlock+0x20>
	__asm__ volatile (
  10a57c:	fb                   	sti    
}
  10a57d:	5b                   	pop    %ebx
  10a57e:	5d                   	pop    %ebp
	z_reschedule_unlocked();
  10a57f:	e9 55 ff ff ff       	jmp    10a4d9 <z_reschedule_unlocked>

0010a584 <z_add_thread_to_ready_q>:
{
  10a584:	55                   	push   %ebp
  10a585:	89 e5                	mov    %esp,%ebp
  10a587:	56                   	push   %esi
  10a588:	53                   	push   %ebx
  10a589:	8b 45 08             	mov    0x8(%ebp),%eax
	__asm__ volatile (
  10a58c:	9c                   	pushf  
  10a58d:	fa                   	cli    
  10a58e:	5b                   	pop    %ebx
  10a58f:	8b 15 44 0a 11 00    	mov    0x110a44,%edx
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
  10a595:	85 d2                	test   %edx,%edx
  10a597:	74 2f                	je     10a5c8 <z_add_thread_to_ready_q+0x44>
  10a599:	81 fa 44 0a 11 00    	cmp    $0x110a44,%edx
  10a59f:	74 27                	je     10a5c8 <z_add_thread_to_ready_q+0x44>
	if (t1->base.prio < t2->base.prio) {
  10a5a1:	8a 48 0e             	mov    0xe(%eax),%cl
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
  10a5a4:	8b 35 48 0a 11 00    	mov    0x110a48,%esi
  10a5aa:	3a 4a 0e             	cmp    0xe(%edx),%cl
  10a5ad:	7d 0f                	jge    10a5be <z_add_thread_to_ready_q+0x3a>
	node->prev = successor->prev;
  10a5af:	8b 4a 04             	mov    0x4(%edx),%ecx
	node->next = successor;
  10a5b2:	89 10                	mov    %edx,(%eax)
	node->prev = successor->prev;
  10a5b4:	89 48 04             	mov    %ecx,0x4(%eax)
	successor->prev->next = node;
  10a5b7:	89 01                	mov    %eax,(%ecx)
	successor->prev = node;
  10a5b9:	89 42 04             	mov    %eax,0x4(%edx)
  10a5bc:	eb 26                	jmp    10a5e4 <z_add_thread_to_ready_q+0x60>
	return (node == list->tail) ? NULL : node->next;
  10a5be:	39 d6                	cmp    %edx,%esi
  10a5c0:	74 06                	je     10a5c8 <z_add_thread_to_ready_q+0x44>
  10a5c2:	8b 12                	mov    (%edx),%edx
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
  10a5c4:	85 d2                	test   %edx,%edx
  10a5c6:	75 e2                	jne    10a5aa <z_add_thread_to_ready_q+0x26>
	node->prev = list->tail;
  10a5c8:	8b 15 48 0a 11 00    	mov    0x110a48,%edx
	node->next = list;
  10a5ce:	c7 00 44 0a 11 00    	movl   $0x110a44,(%eax)
	node->prev = list->tail;
  10a5d4:	89 50 04             	mov    %edx,0x4(%eax)
	list->tail->next = node;
  10a5d7:	8b 15 48 0a 11 00    	mov    0x110a48,%edx
  10a5dd:	89 02                	mov    %eax,(%edx)
	list->tail = node;
  10a5df:	a3 48 0a 11 00       	mov    %eax,0x110a48
	thread->base.thread_state |= states;
  10a5e4:	80 48 0d 40          	orb    $0x40,0xd(%eax)
		update_cache(0);
  10a5e8:	31 c0                	xor    %eax,%eax
  10a5ea:	e8 20 ff ff ff       	call   10a50f <update_cache>
  10a5ef:	0f ba e3 09          	bt     $0x9,%ebx
  10a5f3:	73 01                	jae    10a5f6 <z_add_thread_to_ready_q+0x72>
	__asm__ volatile (
  10a5f5:	fb                   	sti    
}
  10a5f6:	5b                   	pop    %ebx
  10a5f7:	5e                   	pop    %esi
  10a5f8:	5d                   	pop    %ebp
  10a5f9:	c3                   	ret    

0010a5fa <z_thread_timeout>:
{
  10a5fa:	55                   	push   %ebp
  10a5fb:	89 e5                	mov    %esp,%ebp
  10a5fd:	57                   	push   %edi
  10a5fe:	56                   	push   %esi
  10a5ff:	53                   	push   %ebx
  10a600:	8b 5d 08             	mov    0x8(%ebp),%ebx
	struct k_thread *th = CONTAINER_OF(to, struct k_thread, base.timeout);
  10a603:	8d 73 e8             	lea    -0x18(%ebx),%esi
	if (th->base.pended_on != NULL) {
  10a606:	83 7b f0 00          	cmpl   $0x0,-0x10(%ebx)
  10a60a:	74 1c                	je     10a628 <z_thread_timeout+0x2e>
	__asm__ volatile (
  10a60c:	9c                   	pushf  
  10a60d:	fa                   	cli    
  10a60e:	5f                   	pop    %edi
	sys_dlist_remove(&thread->base.qnode_dlist);
  10a60f:	89 f0                	mov    %esi,%eax
  10a611:	e8 4f fd ff ff       	call   10a365 <sys_dlist_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
  10a616:	80 63 f5 fd          	andb   $0xfd,-0xb(%ebx)
  10a61a:	0f ba e7 09          	bt     $0x9,%edi
  10a61e:	73 01                	jae    10a621 <z_thread_timeout+0x27>
	__asm__ volatile (
  10a620:	fb                   	sti    
	thread->base.pended_on = NULL;
  10a621:	c7 43 f0 00 00 00 00 	movl   $0x0,-0x10(%ebx)
	thread->base.thread_state &= ~_THREAD_SUSPENDED;
  10a628:	80 63 f5 eb          	andb   $0xeb,-0xb(%ebx)
	if (z_is_thread_ready(thread)) {
  10a62c:	89 f0                	mov    %esi,%eax
  10a62e:	e8 4a fd ff ff       	call   10a37d <z_is_thread_ready>
  10a633:	84 c0                	test   %al,%al
  10a635:	74 0c                	je     10a643 <z_thread_timeout+0x49>
}
  10a637:	5b                   	pop    %ebx
		z_add_thread_to_ready_q(thread);
  10a638:	89 75 08             	mov    %esi,0x8(%ebp)
  10a63b:	5e                   	pop    %esi
  10a63c:	5f                   	pop    %edi
  10a63d:	5d                   	pop    %ebp
  10a63e:	e9 41 ff ff ff       	jmp    10a584 <z_add_thread_to_ready_q>
  10a643:	5b                   	pop    %ebx
  10a644:	5e                   	pop    %esi
  10a645:	5f                   	pop    %edi
  10a646:	5d                   	pop    %ebp
  10a647:	c3                   	ret    

0010a648 <z_move_thread_to_end_of_prio_q>:
{
  10a648:	55                   	push   %ebp
  10a649:	89 e5                	mov    %esp,%ebp
  10a64b:	56                   	push   %esi
  10a64c:	53                   	push   %ebx
  10a64d:	8b 5d 08             	mov    0x8(%ebp),%ebx
	__asm__ volatile (
  10a650:	9c                   	pushf  
  10a651:	fa                   	cli    
  10a652:	5e                   	pop    %esi
	sys_dlist_remove(&thread->base.qnode_dlist);
  10a653:	89 d8                	mov    %ebx,%eax
  10a655:	e8 0b fd ff ff       	call   10a365 <sys_dlist_remove>
	return list->head == list;
  10a65a:	a1 44 0a 11 00       	mov    0x110a44,%eax
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
  10a65f:	85 c0                	test   %eax,%eax
  10a661:	74 2e                	je     10a691 <z_move_thread_to_end_of_prio_q+0x49>
  10a663:	3d 44 0a 11 00       	cmp    $0x110a44,%eax
  10a668:	74 27                	je     10a691 <z_move_thread_to_end_of_prio_q+0x49>
	if (t1->base.prio < t2->base.prio) {
  10a66a:	8a 53 0e             	mov    0xe(%ebx),%dl
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
  10a66d:	8b 0d 48 0a 11 00    	mov    0x110a48,%ecx
  10a673:	3a 50 0e             	cmp    0xe(%eax),%dl
  10a676:	7d 0f                	jge    10a687 <z_move_thread_to_end_of_prio_q+0x3f>
	node->prev = successor->prev;
  10a678:	8b 50 04             	mov    0x4(%eax),%edx
	node->next = successor;
  10a67b:	89 03                	mov    %eax,(%ebx)
	node->prev = successor->prev;
  10a67d:	89 53 04             	mov    %edx,0x4(%ebx)
	successor->prev->next = node;
  10a680:	89 1a                	mov    %ebx,(%edx)
	successor->prev = node;
  10a682:	89 58 04             	mov    %ebx,0x4(%eax)
  10a685:	eb 25                	jmp    10a6ac <z_move_thread_to_end_of_prio_q+0x64>
	return (node == list->tail) ? NULL : node->next;
  10a687:	39 c1                	cmp    %eax,%ecx
  10a689:	74 06                	je     10a691 <z_move_thread_to_end_of_prio_q+0x49>
  10a68b:	8b 00                	mov    (%eax),%eax
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
  10a68d:	85 c0                	test   %eax,%eax
  10a68f:	75 e2                	jne    10a673 <z_move_thread_to_end_of_prio_q+0x2b>
	node->prev = list->tail;
  10a691:	a1 48 0a 11 00       	mov    0x110a48,%eax
	node->next = list;
  10a696:	c7 03 44 0a 11 00    	movl   $0x110a44,(%ebx)
	node->prev = list->tail;
  10a69c:	89 43 04             	mov    %eax,0x4(%ebx)
	list->tail->next = node;
  10a69f:	a1 48 0a 11 00       	mov    0x110a48,%eax
  10a6a4:	89 18                	mov    %ebx,(%eax)
	list->tail = node;
  10a6a6:	89 1d 48 0a 11 00    	mov    %ebx,0x110a48
	thread->base.thread_state |= states;
  10a6ac:	80 4b 0d 40          	orb    $0x40,0xd(%ebx)
		update_cache(thread == _current);
  10a6b0:	31 c0                	xor    %eax,%eax
  10a6b2:	39 1d 28 0a 11 00    	cmp    %ebx,0x110a28
  10a6b8:	0f 94 c0             	sete   %al
  10a6bb:	e8 4f fe ff ff       	call   10a50f <update_cache>
  10a6c0:	0f ba e6 09          	bt     $0x9,%esi
  10a6c4:	73 01                	jae    10a6c7 <z_move_thread_to_end_of_prio_q+0x7f>
	__asm__ volatile (
  10a6c6:	fb                   	sti    
}
  10a6c7:	5b                   	pop    %ebx
  10a6c8:	5e                   	pop    %esi
  10a6c9:	5d                   	pop    %ebp
  10a6ca:	c3                   	ret    

0010a6cb <z_time_slice>:
{
  10a6cb:	55                   	push   %ebp
  10a6cc:	89 e5                	mov    %esp,%ebp
	if (slice_time && sliceable(_current)) {
  10a6ce:	83 3d 4c 0b 11 00 00 	cmpl   $0x0,0x110b4c
{
  10a6d5:	8b 4d 08             	mov    0x8(%ebp),%ecx
	if (slice_time && sliceable(_current)) {
  10a6d8:	74 47                	je     10a721 <z_time_slice+0x56>
  10a6da:	a1 28 0a 11 00       	mov    0x110a28,%eax
		&& !z_is_thread_timeout_active(t);
  10a6df:	66 83 78 0e 7f       	cmpw   $0x7f,0xe(%eax)
  10a6e4:	77 3b                	ja     10a721 <z_time_slice+0x56>
		&& !z_is_prio_higher(t->base.prio, slice_max_prio)
  10a6e6:	0f be 50 0e          	movsbl 0xe(%eax),%edx
  10a6ea:	39 15 48 0b 11 00    	cmp    %edx,0x110b48
  10a6f0:	7f 2f                	jg     10a721 <z_time_slice+0x56>
		&& !is_idle(t)
  10a6f2:	3b 05 04 de 10 00    	cmp    0x10de04,%eax
  10a6f8:	74 27                	je     10a721 <z_time_slice+0x56>
		&& !z_is_thread_timeout_active(t);
  10a6fa:	83 78 18 00          	cmpl   $0x0,0x18(%eax)
  10a6fe:	75 21                	jne    10a721 <z_time_slice+0x56>
		if (ticks >= _current_cpu->slice_ticks) {
  10a700:	8b 15 30 0a 11 00    	mov    0x110a30,%edx
  10a706:	39 ca                	cmp    %ecx,%edx
  10a708:	7f 0d                	jg     10a717 <z_time_slice+0x4c>
			z_move_thread_to_end_of_prio_q(_current);
  10a70a:	50                   	push   %eax
  10a70b:	e8 38 ff ff ff       	call   10a648 <z_move_thread_to_end_of_prio_q>
  10a710:	58                   	pop    %eax
}
  10a711:	c9                   	leave  
			reset_time_slice();
  10a712:	e9 7e fc ff ff       	jmp    10a395 <reset_time_slice>
			_current_cpu->slice_ticks -= ticks;
  10a717:	29 ca                	sub    %ecx,%edx
  10a719:	89 15 30 0a 11 00    	mov    %edx,0x110a30
  10a71f:	eb 0a                	jmp    10a72b <z_time_slice+0x60>
		_current_cpu->slice_ticks = 0;
  10a721:	c7 05 30 0a 11 00 00 	movl   $0x0,0x110a30
  10a728:	00 00 00 
}
  10a72b:	c9                   	leave  
  10a72c:	c3                   	ret    

0010a72d <z_remove_thread_from_ready_q>:
{
  10a72d:	55                   	push   %ebp
  10a72e:	89 e5                	mov    %esp,%ebp
  10a730:	56                   	push   %esi
  10a731:	53                   	push   %ebx
  10a732:	8b 5d 08             	mov    0x8(%ebp),%ebx
	__asm__ volatile (
  10a735:	9c                   	pushf  
  10a736:	fa                   	cli    
  10a737:	5e                   	pop    %esi
		if (z_is_thread_queued(thread)) {
  10a738:	f6 43 0d 40          	testb  $0x40,0xd(%ebx)
  10a73c:	74 0b                	je     10a749 <z_remove_thread_from_ready_q+0x1c>
	sys_dlist_remove(&thread->base.qnode_dlist);
  10a73e:	89 d8                	mov    %ebx,%eax
  10a740:	e8 20 fc ff ff       	call   10a365 <sys_dlist_remove>
	thread->base.thread_state &= ~states;
  10a745:	80 63 0d bf          	andb   $0xbf,0xd(%ebx)
		update_cache(thread == _current);
  10a749:	31 c0                	xor    %eax,%eax
  10a74b:	39 1d 28 0a 11 00    	cmp    %ebx,0x110a28
  10a751:	0f 94 c0             	sete   %al
  10a754:	e8 b6 fd ff ff       	call   10a50f <update_cache>
  10a759:	0f ba e6 09          	bt     $0x9,%esi
  10a75d:	73 01                	jae    10a760 <z_remove_thread_from_ready_q+0x33>
	__asm__ volatile (
  10a75f:	fb                   	sti    
}
  10a760:	5b                   	pop    %ebx
  10a761:	5e                   	pop    %esi
  10a762:	5d                   	pop    %ebp
  10a763:	c3                   	ret    

0010a764 <pend>:
{
  10a764:	55                   	push   %ebp
  10a765:	89 e5                	mov    %esp,%ebp
  10a767:	57                   	push   %edi
  10a768:	56                   	push   %esi
  10a769:	89 d6                	mov    %edx,%esi
  10a76b:	53                   	push   %ebx
  10a76c:	89 c3                	mov    %eax,%ebx
  10a76e:	83 ec 10             	sub    $0x10,%esp
  10a771:	89 4d ec             	mov    %ecx,-0x14(%ebp)
	z_remove_thread_from_ready_q(thread);
  10a774:	50                   	push   %eax
  10a775:	e8 b3 ff ff ff       	call   10a72d <z_remove_thread_from_ready_q>
  10a77a:	58                   	pop    %eax
	thread->base.thread_state |= _THREAD_PENDING;
  10a77b:	80 4b 0d 02          	orb    $0x2,0xd(%ebx)
	if (wait_q != NULL) {
  10a77f:	85 f6                	test   %esi,%esi
  10a781:	74 3f                	je     10a7c2 <pend+0x5e>
	return list->head == list;
  10a783:	8b 06                	mov    (%esi),%eax
		thread->base.pended_on = wait_q;
  10a785:	89 73 08             	mov    %esi,0x8(%ebx)
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
  10a788:	39 c6                	cmp    %eax,%esi
  10a78a:	74 26                	je     10a7b2 <pend+0x4e>
  10a78c:	85 c0                	test   %eax,%eax
  10a78e:	74 22                	je     10a7b2 <pend+0x4e>
	if (t1->base.prio < t2->base.prio) {
  10a790:	8a 53 0e             	mov    0xe(%ebx),%dl
  10a793:	3a 50 0e             	cmp    0xe(%eax),%dl
  10a796:	7d 0f                	jge    10a7a7 <pend+0x43>
	node->prev = successor->prev;
  10a798:	8b 50 04             	mov    0x4(%eax),%edx
	node->next = successor;
  10a79b:	89 03                	mov    %eax,(%ebx)
	node->prev = successor->prev;
  10a79d:	89 53 04             	mov    %edx,0x4(%ebx)
	successor->prev->next = node;
  10a7a0:	89 1a                	mov    %ebx,(%edx)
	successor->prev = node;
  10a7a2:	89 58 04             	mov    %ebx,0x4(%eax)
  10a7a5:	eb 1b                	jmp    10a7c2 <pend+0x5e>
	return (node == list->tail) ? NULL : node->next;
  10a7a7:	3b 46 04             	cmp    0x4(%esi),%eax
  10a7aa:	74 06                	je     10a7b2 <pend+0x4e>
  10a7ac:	8b 00                	mov    (%eax),%eax
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
  10a7ae:	85 c0                	test   %eax,%eax
  10a7b0:	75 e1                	jne    10a793 <pend+0x2f>
	node->prev = list->tail;
  10a7b2:	8b 46 04             	mov    0x4(%esi),%eax
	node->next = list;
  10a7b5:	89 33                	mov    %esi,(%ebx)
	node->prev = list->tail;
  10a7b7:	89 43 04             	mov    %eax,0x4(%ebx)
	list->tail->next = node;
  10a7ba:	8b 46 04             	mov    0x4(%esi),%eax
  10a7bd:	89 18                	mov    %ebx,(%eax)
	list->tail = node;
  10a7bf:	89 5e 04             	mov    %ebx,0x4(%esi)
	if (timeout != K_FOREVER) {
  10a7c2:	83 7d ec ff          	cmpl   $0xffffffff,-0x14(%ebp)
  10a7c6:	74 59                	je     10a821 <pend+0xbd>
	return z_clock_hw_cycles_per_sec;
  10a7c8:	a1 cc 32 11 00       	mov    0x1132cc,%eax
	return (s32_t)ceiling_fraction(
  10a7cd:	6a 00                	push   $0x0
	return z_clock_hw_cycles_per_sec;
  10a7cf:	89 45 f0             	mov    %eax,-0x10(%ebp)
	return (s32_t)ceiling_fraction(
  10a7d2:	b8 e8 03 00 00       	mov    $0x3e8,%eax
  10a7d7:	f7 6d f0             	imull  -0x10(%ebp)
  10a7da:	6a 64                	push   $0x64
  10a7dc:	52                   	push   %edx
  10a7dd:	50                   	push   %eax
  10a7de:	e8 bd 58 ff ff       	call   1000a0 <__divdi3>
  10a7e3:	83 c4 10             	add    $0x10,%esp
  10a7e6:	89 c6                	mov    %eax,%esi
  10a7e8:	83 c0 ff             	add    $0xffffffff,%eax
  10a7eb:	89 d7                	mov    %edx,%edi
  10a7ed:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  10a7f0:	8b 45 ec             	mov    -0x14(%ebp),%eax
  10a7f3:	83 d2 ff             	adc    $0xffffffff,%edx
  10a7f6:	57                   	push   %edi
  10a7f7:	89 55 e8             	mov    %edx,-0x18(%ebp)
  10a7fa:	56                   	push   %esi
  10a7fb:	f7 6d f0             	imull  -0x10(%ebp)
  10a7fe:	03 45 e4             	add    -0x1c(%ebp),%eax
  10a801:	13 55 e8             	adc    -0x18(%ebp),%edx
	z_add_timeout(&th->base.timeout, z_thread_timeout, ticks);
  10a804:	83 c3 18             	add    $0x18,%ebx
  10a807:	52                   	push   %edx
  10a808:	50                   	push   %eax
  10a809:	e8 92 58 ff ff       	call   1000a0 <__divdi3>
  10a80e:	83 c4 10             	add    $0x10,%esp
		s32_t ticks = _TICK_ALIGN + z_ms_to_ticks(timeout);
  10a811:	40                   	inc    %eax
  10a812:	50                   	push   %eax
  10a813:	68 fa a5 10 00       	push   $0x10a5fa
  10a818:	53                   	push   %ebx
  10a819:	e8 ff 07 00 00       	call   10b01d <z_add_timeout>
  10a81e:	83 c4 0c             	add    $0xc,%esp
}
  10a821:	8d 65 f4             	lea    -0xc(%ebp),%esp
  10a824:	5b                   	pop    %ebx
  10a825:	5e                   	pop    %esi
  10a826:	5f                   	pop    %edi
  10a827:	5d                   	pop    %ebp
  10a828:	c3                   	ret    

0010a829 <z_pend_curr>:
{
  10a829:	55                   	push   %ebp
	pend(_current, wait_q, timeout);
  10a82a:	a1 28 0a 11 00       	mov    0x110a28,%eax
{
  10a82f:	89 e5                	mov    %esp,%ebp
  10a831:	53                   	push   %ebx
	pend(_current, wait_q, timeout);
  10a832:	8b 4d 14             	mov    0x14(%ebp),%ecx
  10a835:	8b 55 10             	mov    0x10(%ebp),%edx
{
  10a838:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	pend(_current, wait_q, timeout);
  10a83b:	e8 24 ff ff ff       	call   10a764 <pend>
  10a840:	89 5d 08             	mov    %ebx,0x8(%ebp)
}
  10a843:	5b                   	pop    %ebx
  10a844:	5d                   	pop    %ebp
  10a845:	e9 4b c0 ff ff       	jmp    106895 <__swap>

0010a84a <z_thread_priority_set>:
{
  10a84a:	55                   	push   %ebp
  10a84b:	89 e5                	mov    %esp,%ebp
  10a84d:	57                   	push   %edi
  10a84e:	56                   	push   %esi
  10a84f:	53                   	push   %ebx
  10a850:	51                   	push   %ecx
  10a851:	8b 5d 08             	mov    0x8(%ebp),%ebx
  10a854:	8b 75 0c             	mov    0xc(%ebp),%esi
	__asm__ volatile (
  10a857:	9c                   	pushf  
  10a858:	fa                   	cli    
  10a859:	5f                   	pop    %edi
		need_sched = z_is_thread_ready(thread);
  10a85a:	89 d8                	mov    %ebx,%eax
  10a85c:	e8 1c fb ff ff       	call   10a37d <z_is_thread_ready>
  10a861:	88 45 f3             	mov    %al,-0xd(%ebp)
		if (need_sched) {
  10a864:	84 c0                	test   %al,%al
  10a866:	74 6f                	je     10a8d7 <z_thread_priority_set+0x8d>
  10a868:	89 f2                	mov    %esi,%edx
	sys_dlist_remove(&thread->base.qnode_dlist);
  10a86a:	89 d8                	mov    %ebx,%eax
  10a86c:	88 55 f2             	mov    %dl,-0xe(%ebp)
  10a86f:	e8 f1 fa ff ff       	call   10a365 <sys_dlist_remove>
			thread->base.prio = prio;
  10a874:	89 f0                	mov    %esi,%eax
  10a876:	88 43 0e             	mov    %al,0xe(%ebx)
	return list->head == list;
  10a879:	a1 44 0a 11 00       	mov    0x110a44,%eax
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
  10a87e:	85 c0                	test   %eax,%eax
  10a880:	74 2e                	je     10a8b0 <z_thread_priority_set+0x66>
  10a882:	3d 44 0a 11 00       	cmp    $0x110a44,%eax
  10a887:	74 27                	je     10a8b0 <z_thread_priority_set+0x66>
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
  10a889:	8b 0d 48 0a 11 00    	mov    0x110a48,%ecx
  10a88f:	8a 55 f2             	mov    -0xe(%ebp),%dl
	if (t1->base.prio < t2->base.prio) {
  10a892:	3a 50 0e             	cmp    0xe(%eax),%dl
  10a895:	7d 0f                	jge    10a8a6 <z_thread_priority_set+0x5c>
	node->prev = successor->prev;
  10a897:	8b 50 04             	mov    0x4(%eax),%edx
	node->next = successor;
  10a89a:	89 03                	mov    %eax,(%ebx)
	node->prev = successor->prev;
  10a89c:	89 53 04             	mov    %edx,0x4(%ebx)
	successor->prev->next = node;
  10a89f:	89 1a                	mov    %ebx,(%edx)
	successor->prev = node;
  10a8a1:	89 58 04             	mov    %ebx,0x4(%eax)
  10a8a4:	eb 25                	jmp    10a8cb <z_thread_priority_set+0x81>
	return (node == list->tail) ? NULL : node->next;
  10a8a6:	39 c1                	cmp    %eax,%ecx
  10a8a8:	74 06                	je     10a8b0 <z_thread_priority_set+0x66>
  10a8aa:	8b 00                	mov    (%eax),%eax
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
  10a8ac:	85 c0                	test   %eax,%eax
  10a8ae:	75 e2                	jne    10a892 <z_thread_priority_set+0x48>
	node->prev = list->tail;
  10a8b0:	a1 48 0a 11 00       	mov    0x110a48,%eax
	node->next = list;
  10a8b5:	c7 03 44 0a 11 00    	movl   $0x110a44,(%ebx)
	node->prev = list->tail;
  10a8bb:	89 43 04             	mov    %eax,0x4(%ebx)
	list->tail->next = node;
  10a8be:	a1 48 0a 11 00       	mov    0x110a48,%eax
  10a8c3:	89 18                	mov    %ebx,(%eax)
	list->tail = node;
  10a8c5:	89 1d 48 0a 11 00    	mov    %ebx,0x110a48
			update_cache(1);
  10a8cb:	b8 01 00 00 00       	mov    $0x1,%eax
  10a8d0:	e8 3a fc ff ff       	call   10a50f <update_cache>
  10a8d5:	eb 05                	jmp    10a8dc <z_thread_priority_set+0x92>
			thread->base.prio = prio;
  10a8d7:	89 f0                	mov    %esi,%eax
  10a8d9:	88 43 0e             	mov    %al,0xe(%ebx)
  10a8dc:	0f ba e7 09          	bt     $0x9,%edi
  10a8e0:	73 01                	jae    10a8e3 <z_thread_priority_set+0x99>
	__asm__ volatile (
  10a8e2:	fb                   	sti    
	if (need_sched && _current->base.sched_locked == 0) {
  10a8e3:	80 7d f3 00          	cmpb   $0x0,-0xd(%ebp)
  10a8e7:	74 15                	je     10a8fe <z_thread_priority_set+0xb4>
  10a8e9:	a1 28 0a 11 00       	mov    0x110a28,%eax
  10a8ee:	80 78 0f 00          	cmpb   $0x0,0xf(%eax)
  10a8f2:	75 0a                	jne    10a8fe <z_thread_priority_set+0xb4>
}
  10a8f4:	5a                   	pop    %edx
  10a8f5:	5b                   	pop    %ebx
  10a8f6:	5e                   	pop    %esi
  10a8f7:	5f                   	pop    %edi
  10a8f8:	5d                   	pop    %ebp
		z_reschedule_unlocked();
  10a8f9:	e9 db fb ff ff       	jmp    10a4d9 <z_reschedule_unlocked>
}
  10a8fe:	58                   	pop    %eax
  10a8ff:	5b                   	pop    %ebx
  10a900:	5e                   	pop    %esi
  10a901:	5f                   	pop    %edi
  10a902:	5d                   	pop    %ebp
  10a903:	c3                   	ret    

0010a904 <z_unpend_first_thread>:
{
  10a904:	55                   	push   %ebp
  10a905:	89 e5                	mov    %esp,%ebp
  10a907:	56                   	push   %esi
  10a908:	53                   	push   %ebx
	__asm__ volatile (
  10a909:	9c                   	pushf  
  10a90a:	fa                   	cli    
  10a90b:	59                   	pop    %ecx
		ret = _priq_wait_best(&wait_q->waitq);
  10a90c:	ff 75 08             	pushl  0x8(%ebp)
  10a90f:	e8 e7 fb ff ff       	call   10a4fb <z_priq_dumb_best>
  10a914:	5a                   	pop    %edx
  10a915:	89 c3                	mov    %eax,%ebx
  10a917:	0f ba e1 09          	bt     $0x9,%ecx
  10a91b:	73 01                	jae    10a91e <z_unpend_first_thread+0x1a>
	__asm__ volatile (
  10a91d:	fb                   	sti    

static inline struct k_thread *z_unpend1_no_timeout(_wait_q_t *wait_q)
{
	struct k_thread *thread = z_find_first_thread_to_unpend(wait_q, NULL);

	if (thread != NULL) {
  10a91e:	85 db                	test   %ebx,%ebx
  10a920:	74 26                	je     10a948 <z_unpend_first_thread+0x44>
	__asm__ volatile (
  10a922:	9c                   	pushf  
  10a923:	fa                   	cli    
  10a924:	5e                   	pop    %esi
	sys_dlist_remove(&thread->base.qnode_dlist);
  10a925:	89 d8                	mov    %ebx,%eax
  10a927:	e8 39 fa ff ff       	call   10a365 <sys_dlist_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
  10a92c:	80 63 0d fd          	andb   $0xfd,0xd(%ebx)
  10a930:	0f ba e6 09          	bt     $0x9,%esi
  10a934:	73 01                	jae    10a937 <z_unpend_first_thread+0x33>
	__asm__ volatile (
  10a936:	fb                   	sti    
	return z_abort_timeout(&thread->base.timeout);
  10a937:	8d 43 18             	lea    0x18(%ebx),%eax
	thread->base.pended_on = NULL;
  10a93a:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
  10a941:	50                   	push   %eax
  10a942:	e8 88 07 00 00       	call   10b0cf <z_abort_timeout>
  10a947:	58                   	pop    %eax
}
  10a948:	8d 65 f8             	lea    -0x8(%ebp),%esp
  10a94b:	89 d8                	mov    %ebx,%eax
  10a94d:	5b                   	pop    %ebx
  10a94e:	5e                   	pop    %esi
  10a94f:	5d                   	pop    %ebp
  10a950:	c3                   	ret    

0010a951 <z_sched_init>:

	return need_sched;
}

void z_sched_init(void)
{
  10a951:	55                   	push   %ebp
	list->head = (sys_dnode_t *)list;
  10a952:	c7 05 44 0a 11 00 44 	movl   $0x110a44,0x110a44
  10a959:	0a 11 00 
  10a95c:	89 e5                	mov    %esp,%ebp
		sys_dlist_init(&_kernel.ready_q.runq.queues[i]);
	}
#endif

#ifdef CONFIG_TIMESLICING
	k_sched_time_slice_set(CONFIG_TIMESLICE_SIZE,
  10a95e:	6a 00                	push   $0x0
  10a960:	6a 00                	push   $0x0
	list->tail = (sys_dnode_t *)list;
  10a962:	c7 05 48 0a 11 00 44 	movl   $0x110a44,0x110a48
  10a969:	0a 11 00 
  10a96c:	e8 59 fa ff ff       	call   10a3ca <k_sched_time_slice_set>
  10a971:	58                   	pop    %eax
  10a972:	5a                   	pop    %edx
		CONFIG_TIMESLICE_PRIORITY);
#endif
}
  10a973:	c9                   	leave  
  10a974:	c3                   	ret    

0010a975 <z_impl_k_yield>:
}
#endif
#endif

void z_impl_k_yield(void)
{
  10a975:	55                   	push   %ebp
	__ASSERT(!z_is_in_isr(), "");

	if (!is_idle(_current)) {
  10a976:	a1 04 de 10 00       	mov    0x10de04,%eax
{
  10a97b:	89 e5                	mov    %esp,%ebp
  10a97d:	56                   	push   %esi
  10a97e:	53                   	push   %ebx
	if (!is_idle(_current)) {
  10a97f:	39 05 28 0a 11 00    	cmp    %eax,0x110a28
  10a985:	74 76                	je     10a9fd <z_impl_k_yield+0x88>
	__asm__ volatile (
  10a987:	9c                   	pushf  
  10a988:	fa                   	cli    
  10a989:	5b                   	pop    %ebx
	sys_dlist_remove(&thread->base.qnode_dlist);
  10a98a:	a1 28 0a 11 00       	mov    0x110a28,%eax
  10a98f:	e8 d1 f9 ff ff       	call   10a365 <sys_dlist_remove>
	return list->head == list;
  10a994:	a1 44 0a 11 00       	mov    0x110a44,%eax
		LOCKED(&sched_spinlock) {
			if (!IS_ENABLED(CONFIG_SMP) ||
			    z_is_thread_queued(_current)) {
				_priq_run_remove(&_kernel.ready_q.runq,
						 _current);
				_priq_run_add(&_kernel.ready_q.runq,
  10a999:	8b 15 28 0a 11 00    	mov    0x110a28,%edx
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
  10a99f:	3d 44 0a 11 00       	cmp    $0x110a44,%eax
  10a9a4:	74 2b                	je     10a9d1 <z_impl_k_yield+0x5c>
  10a9a6:	85 c0                	test   %eax,%eax
  10a9a8:	74 27                	je     10a9d1 <z_impl_k_yield+0x5c>
	if (t1->base.prio < t2->base.prio) {
  10a9aa:	8a 4a 0e             	mov    0xe(%edx),%cl
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
  10a9ad:	8b 35 48 0a 11 00    	mov    0x110a48,%esi
  10a9b3:	3a 48 0e             	cmp    0xe(%eax),%cl
  10a9b6:	7d 0f                	jge    10a9c7 <z_impl_k_yield+0x52>
	node->prev = successor->prev;
  10a9b8:	8b 48 04             	mov    0x4(%eax),%ecx
	node->next = successor;
  10a9bb:	89 02                	mov    %eax,(%edx)
	node->prev = successor->prev;
  10a9bd:	89 4a 04             	mov    %ecx,0x4(%edx)
	successor->prev->next = node;
  10a9c0:	89 11                	mov    %edx,(%ecx)
	successor->prev = node;
  10a9c2:	89 50 04             	mov    %edx,0x4(%eax)
  10a9c5:	eb 25                	jmp    10a9ec <z_impl_k_yield+0x77>
	return (node == list->tail) ? NULL : node->next;
  10a9c7:	39 f0                	cmp    %esi,%eax
  10a9c9:	74 06                	je     10a9d1 <z_impl_k_yield+0x5c>
  10a9cb:	8b 00                	mov    (%eax),%eax
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
  10a9cd:	85 c0                	test   %eax,%eax
  10a9cf:	75 e2                	jne    10a9b3 <z_impl_k_yield+0x3e>
	node->prev = list->tail;
  10a9d1:	a1 48 0a 11 00       	mov    0x110a48,%eax
	node->next = list;
  10a9d6:	c7 02 44 0a 11 00    	movl   $0x110a44,(%edx)
	node->prev = list->tail;
  10a9dc:	89 42 04             	mov    %eax,0x4(%edx)
	list->tail->next = node;
  10a9df:	a1 48 0a 11 00       	mov    0x110a48,%eax
  10a9e4:	89 10                	mov    %edx,(%eax)
	list->tail = node;
  10a9e6:	89 15 48 0a 11 00    	mov    %edx,0x110a48
					      _current);
			}
			update_cache(1);
  10a9ec:	b8 01 00 00 00       	mov    $0x1,%eax
  10a9f1:	e8 19 fb ff ff       	call   10a50f <update_cache>
  10a9f6:	0f ba e3 09          	bt     $0x9,%ebx
  10a9fa:	73 01                	jae    10a9fd <z_impl_k_yield+0x88>
	__asm__ volatile (
  10a9fc:	fb                   	sti    
	__asm__ volatile (
  10a9fd:	9c                   	pushf  
  10a9fe:	fa                   	cli    
  10a9ff:	58                   	pop    %eax
  10aa00:	50                   	push   %eax
  10aa01:	e8 8f be ff ff       	call   106895 <__swap>
  10aa06:	58                   	pop    %eax
		}
	}
	z_swap_unlocked();
}
  10aa07:	8d 65 f8             	lea    -0x8(%ebp),%esp
  10aa0a:	5b                   	pop    %ebx
  10aa0b:	5e                   	pop    %esi
  10aa0c:	5d                   	pop    %ebp
  10aa0d:	c3                   	ret    

0010aa0e <z_impl_k_sleep>:
#ifdef CONFIG_USERSPACE
Z_SYSCALL_HANDLER0_SIMPLE_VOID(k_yield);
#endif

s32_t z_impl_k_sleep(s32_t duration)
{
  10aa0e:	55                   	push   %ebp
  10aa0f:	89 e5                	mov    %esp,%ebp
  10aa11:	57                   	push   %edi
  10aa12:	56                   	push   %esi
  10aa13:	53                   	push   %ebx
  10aa14:	83 ec 08             	sub    $0x8,%esp
  10aa17:	8b 75 08             	mov    0x8(%ebp),%esi
	__ASSERT(!z_is_in_isr(), "");

	K_DEBUG("thread %p for %d ns\n", _current, duration);

	/* wait of 0 ms is treated as a 'yield' */
	if (duration == 0) {
  10aa1a:	85 f6                	test   %esi,%esi
  10aa1c:	75 0a                	jne    10aa28 <z_impl_k_sleep+0x1a>
K_SYSCALL_DECLARE0_VOID(K_SYSCALL_K_YIELD, k_yield)
  10aa1e:	e8 52 ff ff ff       	call   10a975 <z_impl_k_yield>
		k_yield();
		return 0;
  10aa23:	e9 a9 00 00 00       	jmp    10aad1 <z_impl_k_sleep+0xc3>
	return z_clock_hw_cycles_per_sec;
  10aa28:	8b 3d cc 32 11 00    	mov    0x1132cc,%edi
	return (s32_t)ceiling_fraction(
  10aa2e:	b8 e8 03 00 00       	mov    $0x3e8,%eax
  10aa33:	f7 ef                	imul   %edi
  10aa35:	6a 00                	push   $0x0
  10aa37:	6a 64                	push   $0x64
  10aa39:	52                   	push   %edx
  10aa3a:	50                   	push   %eax
  10aa3b:	e8 60 56 ff ff       	call   1000a0 <__divdi3>
  10aa40:	83 c4 10             	add    $0x10,%esp
  10aa43:	89 c1                	mov    %eax,%ecx
  10aa45:	83 c0 ff             	add    $0xffffffff,%eax
  10aa48:	89 d3                	mov    %edx,%ebx
  10aa4a:	89 45 ec             	mov    %eax,-0x14(%ebp)
  10aa4d:	89 f0                	mov    %esi,%eax
  10aa4f:	83 d2 ff             	adc    $0xffffffff,%edx
  10aa52:	53                   	push   %ebx
  10aa53:	89 55 f0             	mov    %edx,-0x10(%ebp)
  10aa56:	51                   	push   %ecx
  10aa57:	f7 ef                	imul   %edi
  10aa59:	03 45 ec             	add    -0x14(%ebp),%eax
  10aa5c:	13 55 f0             	adc    -0x10(%ebp),%edx
  10aa5f:	52                   	push   %edx
  10aa60:	50                   	push   %eax
  10aa61:	e8 3a 56 ff ff       	call   1000a0 <__divdi3>
  10aa66:	83 c4 10             	add    $0x10,%esp
	}

	ticks = _TICK_ALIGN + z_ms_to_ticks(duration);
  10aa69:	8d 70 01             	lea    0x1(%eax),%esi
	expected_wakeup_time = ticks + z_tick_get_32();
  10aa6c:	e8 e1 07 00 00       	call   10b252 <z_tick_get_32>
  10aa71:	8d 1c 06             	lea    (%esi,%eax,1),%ebx
  10aa74:	9c                   	pushf  
  10aa75:	fa                   	cli    
  10aa76:	5f                   	pop    %edi
	k_spinlock_key_t key = k_spin_lock(&local_lock);

#if defined(CONFIG_TIMESLICING) && defined(CONFIG_SWAP_NONATOMIC)
	pending_current = _current;
#endif
	z_remove_thread_from_ready_q(_current);
  10aa77:	ff 35 28 0a 11 00    	pushl  0x110a28
  10aa7d:	e8 ab fc ff ff       	call   10a72d <z_remove_thread_from_ready_q>
	z_add_timeout(&th->base.timeout, z_thread_timeout, ticks);
  10aa82:	a1 28 0a 11 00       	mov    0x110a28,%eax
  10aa87:	89 34 24             	mov    %esi,(%esp)
  10aa8a:	83 c0 18             	add    $0x18,%eax
  10aa8d:	68 fa a5 10 00       	push   $0x10a5fa
	if (ticks > 0) {
		return __ticks_to_ms(ticks);
	}
#endif

	return 0;
  10aa92:	31 f6                	xor    %esi,%esi
  10aa94:	50                   	push   %eax
  10aa95:	e8 83 05 00 00       	call   10b01d <z_add_timeout>
	z_mark_thread_as_suspended(_current);
  10aa9a:	a1 28 0a 11 00       	mov    0x110a28,%eax
  10aa9f:	83 c4 0c             	add    $0xc,%esp
	thread->base.thread_state |= _THREAD_SUSPENDED;
  10aaa2:	80 48 0d 10          	orb    $0x10,0xd(%eax)
  10aaa6:	57                   	push   %edi
  10aaa7:	e8 e9 bd ff ff       	call   106895 <__swap>
  10aaac:	58                   	pop    %eax
	ticks = expected_wakeup_time - z_tick_get_32();
  10aaad:	e8 a0 07 00 00       	call   10b252 <z_tick_get_32>
  10aab2:	29 c3                	sub    %eax,%ebx
  10aab4:	89 d8                	mov    %ebx,%eax
	if (ticks > 0) {
  10aab6:	85 db                	test   %ebx,%ebx
  10aab8:	7e 17                	jle    10aad1 <z_impl_k_sleep+0xc3>
{
#ifdef CONFIG_SYS_CLOCK_EXISTS

#ifdef _NEED_PRECISE_TICK_MS_CONVERSION
	/* use 64-bit math to keep precision */
	return (u64_t)ticks * MSEC_PER_SEC / (u64_t)CONFIG_SYS_CLOCK_TICKS_PER_SEC;
  10aaba:	b9 e8 03 00 00       	mov    $0x3e8,%ecx
  10aabf:	6a 00                	push   $0x0
  10aac1:	f7 e9                	imul   %ecx
  10aac3:	6a 64                	push   $0x64
  10aac5:	52                   	push   %edx
  10aac6:	50                   	push   %eax
  10aac7:	e8 f1 56 ff ff       	call   1001bd <__udivdi3>
  10aacc:	83 c4 10             	add    $0x10,%esp
  10aacf:	89 c6                	mov    %eax,%esi
}
  10aad1:	8d 65 f4             	lea    -0xc(%ebp),%esp
  10aad4:	89 f0                	mov    %esi,%eax
  10aad6:	5b                   	pop    %ebx
  10aad7:	5e                   	pop    %esi
  10aad8:	5f                   	pop    %edi
  10aad9:	5d                   	pop    %ebp
  10aada:	c3                   	ret    

0010aadb <z_impl_k_wakeup>:
	return z_impl_k_sleep(duration);
}
#endif

void z_impl_k_wakeup(k_tid_t thread)
{
  10aadb:	55                   	push   %ebp
  10aadc:	89 e5                	mov    %esp,%ebp
  10aade:	53                   	push   %ebx
  10aadf:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (z_is_thread_pending(thread)) {
  10aae2:	f6 43 0d 02          	testb  $0x2,0xd(%ebx)
  10aae6:	75 36                	jne    10ab1e <z_impl_k_wakeup+0x43>
	return z_abort_timeout(&thread->base.timeout);
  10aae8:	8d 43 18             	lea    0x18(%ebx),%eax
  10aaeb:	50                   	push   %eax
  10aaec:	e8 de 05 00 00       	call   10b0cf <z_abort_timeout>
  10aaf1:	5a                   	pop    %edx
		return;
	}

	if (z_abort_thread_timeout(thread) < 0) {
  10aaf2:	85 c0                	test   %eax,%eax
  10aaf4:	78 28                	js     10ab1e <z_impl_k_wakeup+0x43>
	thread->base.thread_state &= ~_THREAD_SUSPENDED;
  10aaf6:	80 63 0d ef          	andb   $0xef,0xd(%ebx)
	if (z_is_thread_ready(thread)) {
  10aafa:	89 d8                	mov    %ebx,%eax
  10aafc:	e8 7c f8 ff ff       	call   10a37d <z_is_thread_ready>
  10ab01:	84 c0                	test   %al,%al
  10ab03:	74 07                	je     10ab0c <z_impl_k_wakeup+0x31>
		z_add_thread_to_ready_q(thread);
  10ab05:	53                   	push   %ebx
  10ab06:	e8 79 fa ff ff       	call   10a584 <z_add_thread_to_ready_q>
  10ab0b:	58                   	pop    %eax
	}

	z_mark_thread_as_not_suspended(thread);
	z_ready_thread(thread);

	if (!z_is_in_isr()) {
  10ab0c:	83 3d 20 0a 11 00 00 	cmpl   $0x0,0x110a20
  10ab13:	75 09                	jne    10ab1e <z_impl_k_wakeup+0x43>

	if (IS_ENABLED(CONFIG_SMP) &&
	    !IS_ENABLED(CONFIG_SCHED_IPI_SUPPORTED)) {
		z_sched_ipi();
	}
}
  10ab15:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  10ab18:	c9                   	leave  
		z_reschedule_unlocked();
  10ab19:	e9 bb f9 ff ff       	jmp    10a4d9 <z_reschedule_unlocked>
}
  10ab1e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  10ab21:	c9                   	leave  
  10ab22:	c3                   	ret    

0010ab23 <z_impl_k_current_get>:
#endif

k_tid_t z_impl_k_current_get(void)
{
	return _current;
}
  10ab23:	a1 28 0a 11 00       	mov    0x110a28,%eax
  10ab28:	c3                   	ret    

0010ab29 <z_impl_k_sem_init>:

#endif /* CONFIG_OBJECT_TRACING */

void z_impl_k_sem_init(struct k_sem *sem, unsigned int initial_count,
		      unsigned int limit)
{
  10ab29:	55                   	push   %ebp
  10ab2a:	89 e5                	mov    %esp,%ebp
  10ab2c:	8b 45 08             	mov    0x8(%ebp),%eax
	__ASSERT(limit != 0U, "limit cannot be zero");
	__ASSERT(initial_count <= limit, "count cannot be greater than limit");

	sys_trace_void(SYS_TRACE_ID_SEMA_INIT);
	sem->count = initial_count;
  10ab2f:	8b 55 0c             	mov    0xc(%ebp),%edx
  10ab32:	89 50 08             	mov    %edx,0x8(%eax)
	sem->limit = limit;
  10ab35:	8b 55 10             	mov    0x10(%ebp),%edx
  10ab38:	89 50 0c             	mov    %edx,0xc(%eax)
	z_waitq_init(&sem->wait_q);
#if defined(CONFIG_POLL)
	sys_dlist_init(&sem->poll_events);
  10ab3b:	8d 50 10             	lea    0x10(%eax),%edx
	list->head = (sys_dnode_t *)list;
  10ab3e:	89 00                	mov    %eax,(%eax)
	list->tail = (sys_dnode_t *)list;
  10ab40:	89 40 04             	mov    %eax,0x4(%eax)
	list->head = (sys_dnode_t *)list;
  10ab43:	89 50 10             	mov    %edx,0x10(%eax)
	list->tail = (sys_dnode_t *)list;
  10ab46:	89 50 14             	mov    %edx,0x14(%eax)

	SYS_TRACING_OBJ_INIT(k_sem, sem);

	z_object_init(sem);
	sys_trace_end_call(SYS_TRACE_ID_SEMA_INIT);
}
  10ab49:	5d                   	pop    %ebp
  10ab4a:	c3                   	ret    

0010ab4b <z_impl_k_sem_give>:
		handle_poll_events(sem);
	}
}

void z_impl_k_sem_give(struct k_sem *sem)
{
  10ab4b:	55                   	push   %ebp
  10ab4c:	89 e5                	mov    %esp,%ebp
  10ab4e:	57                   	push   %edi
  10ab4f:	56                   	push   %esi
  10ab50:	53                   	push   %ebx
  10ab51:	8b 5d 08             	mov    0x8(%ebp),%ebx
  10ab54:	9c                   	pushf  
  10ab55:	fa                   	cli    
  10ab56:	5e                   	pop    %esi
	struct k_thread *thread = z_unpend_first_thread(&sem->wait_q);
  10ab57:	53                   	push   %ebx
  10ab58:	e8 a7 fd ff ff       	call   10a904 <z_unpend_first_thread>
  10ab5d:	5a                   	pop    %edx
	if (thread != NULL) {
  10ab5e:	85 c0                	test   %eax,%eax
  10ab60:	74 20                	je     10ab82 <z_impl_k_sem_give+0x37>
  10ab62:	89 c7                	mov    %eax,%edi
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
  10ab64:	f6 40 0d 1f          	testb  $0x1f,0xd(%eax)
  10ab68:	75 0d                	jne    10ab77 <z_impl_k_sem_give+0x2c>
	if (z_is_thread_ready(thread)) {
  10ab6a:	83 78 18 00          	cmpl   $0x0,0x18(%eax)
  10ab6e:	75 07                	jne    10ab77 <z_impl_k_sem_give+0x2c>
		z_add_thread_to_ready_q(thread);
  10ab70:	50                   	push   %eax
  10ab71:	e8 0e fa ff ff       	call   10a584 <z_add_thread_to_ready_q>
  10ab76:	58                   	pop    %eax
  10ab77:	8b 47 28             	mov    0x28(%edi),%eax
  10ab7a:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  10ab80:	eb 1d                	jmp    10ab9f <z_impl_k_sem_give+0x54>
	sem->count += (sem->count != sem->limit) ? 1U : 0U;
  10ab82:	8b 53 08             	mov    0x8(%ebx),%edx
  10ab85:	31 c0                	xor    %eax,%eax
  10ab87:	39 53 0c             	cmp    %edx,0xc(%ebx)
  10ab8a:	0f 95 c0             	setne  %al
  10ab8d:	01 d0                	add    %edx,%eax
	z_handle_obj_poll_events(&sem->poll_events, K_POLL_STATE_SEM_AVAILABLE);
  10ab8f:	83 c3 10             	add    $0x10,%ebx
	sem->count += (sem->count != sem->limit) ? 1U : 0U;
  10ab92:	89 43 f8             	mov    %eax,-0x8(%ebx)
	z_handle_obj_poll_events(&sem->poll_events, K_POLL_STATE_SEM_AVAILABLE);
  10ab95:	6a 02                	push   $0x2
  10ab97:	53                   	push   %ebx
  10ab98:	e8 58 0b 00 00       	call   10b6f5 <z_handle_obj_poll_events>
  10ab9d:	59                   	pop    %ecx
  10ab9e:	5b                   	pop    %ebx
	k_spinlock_key_t key = k_spin_lock(&lock);

	sys_trace_void(SYS_TRACE_ID_SEMA_GIVE);
	do_sem_give(sem);
	sys_trace_end_call(SYS_TRACE_ID_SEMA_GIVE);
	z_reschedule(&lock, key);
  10ab9f:	56                   	push   %esi
  10aba0:	68 56 0b 11 00       	push   $0x110b56
  10aba5:	e8 f0 f8 ff ff       	call   10a49a <z_reschedule>
  10abaa:	58                   	pop    %eax
  10abab:	5a                   	pop    %edx
}
  10abac:	8d 65 f4             	lea    -0xc(%ebp),%esp
  10abaf:	5b                   	pop    %ebx
  10abb0:	5e                   	pop    %esi
  10abb1:	5f                   	pop    %edi
  10abb2:	5d                   	pop    %ebp
  10abb3:	c3                   	ret    

0010abb4 <z_impl_k_sem_take>:
#ifdef CONFIG_USERSPACE
Z_SYSCALL_HANDLER1_SIMPLE_VOID(k_sem_give, K_OBJ_SEM, struct k_sem *);
#endif

int z_impl_k_sem_take(struct k_sem *sem, s32_t timeout)
{
  10abb4:	55                   	push   %ebp
  10abb5:	89 e5                	mov    %esp,%ebp
  10abb7:	53                   	push   %ebx
  10abb8:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10abbb:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  10abbe:	9c                   	pushf  
  10abbf:	fa                   	cli    
  10abc0:	5a                   	pop    %edx
	__ASSERT(((z_is_in_isr() == false) || (timeout == K_NO_WAIT)), "");

	sys_trace_void(SYS_TRACE_ID_SEMA_TAKE);
	k_spinlock_key_t key = k_spin_lock(&lock);

	if (likely(sem->count > 0U)) {
  10abc1:	8b 41 08             	mov    0x8(%ecx),%eax
  10abc4:	85 c0                	test   %eax,%eax
  10abc6:	74 08                	je     10abd0 <z_impl_k_sem_take+0x1c>
		sem->count--;
  10abc8:	48                   	dec    %eax
  10abc9:	89 41 08             	mov    %eax,0x8(%ecx)
		k_spin_unlock(&lock, key);
		sys_trace_end_call(SYS_TRACE_ID_SEMA_TAKE);
		return 0;
  10abcc:	31 c0                	xor    %eax,%eax
  10abce:	eb 09                	jmp    10abd9 <z_impl_k_sem_take+0x25>
	}

	if (timeout == K_NO_WAIT) {
  10abd0:	85 db                	test   %ebx,%ebx
  10abd2:	75 0e                	jne    10abe2 <z_impl_k_sem_take+0x2e>
		k_spin_unlock(&lock, key);
		sys_trace_end_call(SYS_TRACE_ID_SEMA_TAKE);
		return -EBUSY;
  10abd4:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
  10abd9:	0f ba e2 09          	bt     $0x9,%edx
  10abdd:	73 13                	jae    10abf2 <z_impl_k_sem_take+0x3e>
	__asm__ volatile (
  10abdf:	fb                   	sti    
  10abe0:	eb 10                	jmp    10abf2 <z_impl_k_sem_take+0x3e>
	}

	sys_trace_end_call(SYS_TRACE_ID_SEMA_TAKE);

	int ret = z_pend_curr(&lock, key, &sem->wait_q, timeout);
  10abe2:	53                   	push   %ebx
  10abe3:	51                   	push   %ecx
  10abe4:	52                   	push   %edx
  10abe5:	68 56 0b 11 00       	push   $0x110b56
  10abea:	e8 3a fc ff ff       	call   10a829 <z_pend_curr>
  10abef:	83 c4 10             	add    $0x10,%esp
	return ret;
}
  10abf2:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  10abf5:	c9                   	leave  
  10abf6:	c3                   	ret    

0010abf7 <z_is_thread_ready>:
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
  10abf7:	f6 40 0d 1f          	testb  $0x1f,0xd(%eax)
  10abfb:	75 0c                	jne    10ac09 <z_is_thread_ready+0x12>
  10abfd:	83 78 18 00          	cmpl   $0x0,0x18(%eax)
  10ac01:	0f 94 c0             	sete   %al
  10ac04:	0f b6 c0             	movzbl %al,%eax
  10ac07:	eb 02                	jmp    10ac0b <z_is_thread_ready+0x14>
  10ac09:	31 c0                	xor    %eax,%eax
  10ac0b:	83 e0 01             	and    $0x1,%eax
}
  10ac0e:	c3                   	ret    

0010ac0f <schedule_new_thread.part.8>:
Z_SYSCALL_HANDLER1_SIMPLE_VOID(k_thread_start, K_OBJ_THREAD, struct k_thread *);
#endif
#endif

#ifdef CONFIG_MULTITHREADING
static void schedule_new_thread(struct k_thread *thread, s32_t delay)
  10ac0f:	55                   	push   %ebp
  10ac10:	89 e5                	mov    %esp,%ebp
  10ac12:	57                   	push   %edi
  10ac13:	56                   	push   %esi
  10ac14:	53                   	push   %ebx
  10ac15:	89 d3                	mov    %edx,%ebx
  10ac17:	83 ec 08             	sub    $0x8,%esp
  10ac1a:	89 45 f0             	mov    %eax,-0x10(%ebp)
	return z_clock_hw_cycles_per_sec;
  10ac1d:	8b 0d cc 32 11 00    	mov    0x1132cc,%ecx
	return (s32_t)ceiling_fraction(
  10ac23:	b8 e8 03 00 00       	mov    $0x3e8,%eax
  10ac28:	f7 e9                	imul   %ecx
  10ac2a:	6a 00                	push   $0x0
  10ac2c:	89 4d ec             	mov    %ecx,-0x14(%ebp)
  10ac2f:	6a 64                	push   $0x64
  10ac31:	52                   	push   %edx
  10ac32:	50                   	push   %eax
  10ac33:	e8 68 54 ff ff       	call   1000a0 <__divdi3>
  10ac38:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  10ac3b:	89 c6                	mov    %eax,%esi
  10ac3d:	89 d8                	mov    %ebx,%eax
  10ac3f:	89 d7                	mov    %edx,%edi
  10ac41:	f7 e9                	imul   %ecx
  10ac43:	83 c4 10             	add    $0x10,%esp
  10ac46:	89 c1                	mov    %eax,%ecx
  10ac48:	89 f0                	mov    %esi,%eax
  10ac4a:	89 d3                	mov    %edx,%ebx
  10ac4c:	83 c0 ff             	add    $0xffffffff,%eax
  10ac4f:	89 fa                	mov    %edi,%edx
  10ac51:	83 d2 ff             	adc    $0xffffffff,%edx
  10ac54:	57                   	push   %edi
  10ac55:	01 c1                	add    %eax,%ecx
  10ac57:	56                   	push   %esi
  10ac58:	11 d3                	adc    %edx,%ebx
  10ac5a:	53                   	push   %ebx
  10ac5b:	51                   	push   %ecx
  10ac5c:	e8 3f 54 ff ff       	call   1000a0 <__divdi3>
  10ac61:	83 c4 10             	add    $0x10,%esp
{
#ifdef CONFIG_SYS_CLOCK_EXISTS
	if (delay == 0) {
		k_thread_start(thread);
	} else {
		s32_t ticks = _TICK_ALIGN + z_ms_to_ticks(delay);
  10ac64:	40                   	inc    %eax
	z_add_timeout(&th->base.timeout, z_thread_timeout, ticks);
  10ac65:	50                   	push   %eax
  10ac66:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10ac69:	68 fa a5 10 00       	push   $0x10a5fa
  10ac6e:	83 c0 18             	add    $0x18,%eax
  10ac71:	50                   	push   %eax
  10ac72:	e8 a6 03 00 00       	call   10b01d <z_add_timeout>
  10ac77:	83 c4 0c             	add    $0xc,%esp
	}
#else
	ARG_UNUSED(delay);
	k_thread_start(thread);
#endif
}
  10ac7a:	8d 65 f4             	lea    -0xc(%ebp),%esp
  10ac7d:	5b                   	pop    %ebx
  10ac7e:	5e                   	pop    %esi
  10ac7f:	5f                   	pop    %edi
  10ac80:	5d                   	pop    %ebp
  10ac81:	c3                   	ret    

0010ac82 <k_is_in_isr>:
	return z_is_in_isr();
  10ac82:	83 3d 20 0a 11 00 00 	cmpl   $0x0,0x110a20
  10ac89:	0f 95 c0             	setne  %al
}
  10ac8c:	c3                   	ret    

0010ac8d <z_is_thread_essential>:
	return (_current->base.user_options & K_ESSENTIAL) == K_ESSENTIAL;
  10ac8d:	a1 28 0a 11 00       	mov    0x110a28,%eax
  10ac92:	8a 40 0c             	mov    0xc(%eax),%al
  10ac95:	83 e0 01             	and    $0x1,%eax
}
  10ac98:	c3                   	ret    

0010ac99 <z_impl_k_busy_wait>:
{
  10ac99:	55                   	push   %ebp
		(u64_t)sys_clock_hw_cycles_per_sec() /
  10ac9a:	a1 cc 32 11 00       	mov    0x1132cc,%eax
{
  10ac9f:	89 e5                	mov    %esp,%ebp
  10aca1:	56                   	push   %esi
  10aca2:	53                   	push   %ebx
		(u64_t)sys_clock_hw_cycles_per_sec() /
  10aca3:	89 c3                	mov    %eax,%ebx
  10aca5:	c1 fb 1f             	sar    $0x1f,%ebx
{
  10aca8:	8b 55 08             	mov    0x8(%ebp),%edx
		(u64_t)usec_to_wait *
  10acab:	89 d9                	mov    %ebx,%ecx
		(u64_t)sys_clock_hw_cycles_per_sec() /
  10acad:	6a 00                	push   $0x0
		(u64_t)usec_to_wait *
  10acaf:	0f af ca             	imul   %edx,%ecx
  10acb2:	f7 e2                	mul    %edx
		(u64_t)sys_clock_hw_cycles_per_sec() /
  10acb4:	68 40 42 0f 00       	push   $0xf4240
		(u64_t)usec_to_wait *
  10acb9:	01 ca                	add    %ecx,%edx
		(u64_t)sys_clock_hw_cycles_per_sec() /
  10acbb:	52                   	push   %edx
  10acbc:	50                   	push   %eax
  10acbd:	e8 fb 54 ff ff       	call   1001bd <__udivdi3>
  10acc2:	83 c4 10             	add    $0x10,%esp
  10acc5:	89 c3                	mov    %eax,%ebx
	u32_t start_cycles = k_cycle_get_32();
  10acc7:	e8 fa ba ff ff       	call   1067c6 <z_timer_cycle_get_32>
  10accc:	89 c6                	mov    %eax,%esi
		u32_t current_cycles = k_cycle_get_32();
  10acce:	e8 f3 ba ff ff       	call   1067c6 <z_timer_cycle_get_32>
		if ((current_cycles - start_cycles) >= cycles_to_wait) {
  10acd3:	29 f0                	sub    %esi,%eax
  10acd5:	39 d8                	cmp    %ebx,%eax
  10acd7:	72 f5                	jb     10acce <z_impl_k_busy_wait+0x35>
}
  10acd9:	8d 65 f8             	lea    -0x8(%ebp),%esp
  10acdc:	5b                   	pop    %ebx
  10acdd:	5e                   	pop    %esi
  10acde:	5d                   	pop    %ebp
  10acdf:	c3                   	ret    

0010ace0 <z_thread_monitor_exit>:
{
  10ace0:	55                   	push   %ebp
  10ace1:	89 e5                	mov    %esp,%ebp
  10ace3:	53                   	push   %ebx
  10ace4:	8b 55 08             	mov    0x8(%ebp),%edx
	__asm__ volatile (
  10ace7:	9c                   	pushf  
  10ace8:	fa                   	cli    
  10ace9:	5b                   	pop    %ebx
	if (thread == _kernel.threads) {
  10acea:	a1 4c 0a 11 00       	mov    0x110a4c,%eax
  10acef:	39 d0                	cmp    %edx,%eax
  10acf1:	75 13                	jne    10ad06 <z_thread_monitor_exit+0x26>
		_kernel.threads = _kernel.threads->next_thread;
  10acf3:	8b 40 44             	mov    0x44(%eax),%eax
  10acf6:	a3 4c 0a 11 00       	mov    %eax,0x110a4c
  10acfb:	eb 15                	jmp    10ad12 <z_thread_monitor_exit+0x32>
			(thread != prev_thread->next_thread)) {
  10acfd:	8b 48 44             	mov    0x44(%eax),%ecx
		while ((prev_thread != NULL) &&
  10ad00:	39 d1                	cmp    %edx,%ecx
  10ad02:	74 08                	je     10ad0c <z_thread_monitor_exit+0x2c>
  10ad04:	89 c8                	mov    %ecx,%eax
  10ad06:	85 c0                	test   %eax,%eax
  10ad08:	75 f3                	jne    10acfd <z_thread_monitor_exit+0x1d>
  10ad0a:	eb 06                	jmp    10ad12 <z_thread_monitor_exit+0x32>
			prev_thread->next_thread = thread->next_thread;
  10ad0c:	8b 52 44             	mov    0x44(%edx),%edx
  10ad0f:	89 50 44             	mov    %edx,0x44(%eax)
  10ad12:	0f ba e3 09          	bt     $0x9,%ebx
  10ad16:	73 01                	jae    10ad19 <z_thread_monitor_exit+0x39>
	__asm__ volatile (
  10ad18:	fb                   	sti    
}
  10ad19:	5b                   	pop    %ebx
  10ad1a:	5d                   	pop    %ebp
  10ad1b:	c3                   	ret    

0010ad1c <z_impl_k_thread_name_set>:
{
  10ad1c:	55                   	push   %ebp
  10ad1d:	89 e5                	mov    %esp,%ebp
  10ad1f:	53                   	push   %ebx
  10ad20:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (thread == NULL) {
  10ad23:	85 db                	test   %ebx,%ebx
  10ad25:	75 06                	jne    10ad2d <z_impl_k_thread_name_set+0x11>
		thread = _current;
  10ad27:	8b 1d 28 0a 11 00    	mov    0x110a28,%ebx
	strncpy(thread->name, value, CONFIG_THREAD_MAX_NAME_LEN);
  10ad2d:	6a 20                	push   $0x20
  10ad2f:	8d 43 48             	lea    0x48(%ebx),%eax
  10ad32:	ff 75 0c             	pushl  0xc(%ebp)
  10ad35:	50                   	push   %eax
  10ad36:	e8 dd bf ff ff       	call   106d18 <strncpy>
	thread->name[CONFIG_THREAD_MAX_NAME_LEN - 1] = '\0';
  10ad3b:	c6 43 67 00          	movb   $0x0,0x67(%ebx)
	strncpy(thread->name, value, CONFIG_THREAD_MAX_NAME_LEN);
  10ad3f:	83 c4 0c             	add    $0xc,%esp
}
  10ad42:	31 c0                	xor    %eax,%eax
  10ad44:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  10ad47:	c9                   	leave  
  10ad48:	c3                   	ret    

0010ad49 <z_impl_k_thread_start>:
{
  10ad49:	55                   	push   %ebp
  10ad4a:	89 e5                	mov    %esp,%ebp
  10ad4c:	53                   	push   %ebx
  10ad4d:	8b 55 08             	mov    0x8(%ebp),%edx
	__asm__ volatile (
  10ad50:	9c                   	pushf  
  10ad51:	fa                   	cli    
  10ad52:	5b                   	pop    %ebx
	if (z_has_thread_started(thread)) {
  10ad53:	8a 42 0d             	mov    0xd(%edx),%al
  10ad56:	a8 04                	test   $0x4,%al
  10ad58:	75 09                	jne    10ad63 <z_impl_k_thread_start+0x1a>
  10ad5a:	0f ba e3 09          	bt     $0x9,%ebx
  10ad5e:	73 28                	jae    10ad88 <z_impl_k_thread_start+0x3f>
	__asm__ volatile (
  10ad60:	fb                   	sti    
  10ad61:	eb 25                	jmp    10ad88 <z_impl_k_thread_start+0x3f>
	thread->base.thread_state &= ~_THREAD_PRESTART;
  10ad63:	83 e0 fb             	and    $0xfffffffb,%eax
  10ad66:	88 42 0d             	mov    %al,0xd(%edx)
	if (z_is_thread_ready(thread)) {
  10ad69:	89 d0                	mov    %edx,%eax
  10ad6b:	e8 87 fe ff ff       	call   10abf7 <z_is_thread_ready>
  10ad70:	84 c0                	test   %al,%al
  10ad72:	74 07                	je     10ad7b <z_impl_k_thread_start+0x32>
		z_add_thread_to_ready_q(thread);
  10ad74:	52                   	push   %edx
  10ad75:	e8 0a f8 ff ff       	call   10a584 <z_add_thread_to_ready_q>
  10ad7a:	59                   	pop    %ecx
	z_reschedule(&lock, key);
  10ad7b:	53                   	push   %ebx
  10ad7c:	68 56 0b 11 00       	push   $0x110b56
  10ad81:	e8 14 f7 ff ff       	call   10a49a <z_reschedule>
  10ad86:	58                   	pop    %eax
  10ad87:	5a                   	pop    %edx
}
  10ad88:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  10ad8b:	c9                   	leave  
  10ad8c:	c3                   	ret    

0010ad8d <z_setup_new_thread>:
void z_setup_new_thread(struct k_thread *new_thread,
		       k_thread_stack_t *stack, size_t stack_size,
		       k_thread_entry_t entry,
		       void *p1, void *p2, void *p3,
		       int prio, u32_t options, const char *name)
{
  10ad8d:	55                   	push   %ebp
  10ad8e:	89 e5                	mov    %esp,%ebp
  10ad90:	57                   	push   %edi
  10ad91:	56                   	push   %esi
  10ad92:	53                   	push   %ebx
  10ad93:	8b 75 18             	mov    0x18(%ebp),%esi
	stack_size = STACK_ROUND_DOWN(stack_size
			- sizeof(*new_thread->userspace_local_data));
#endif
#endif

	z_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
  10ad96:	ff 75 28             	pushl  0x28(%ebp)
  10ad99:	ff 75 24             	pushl  0x24(%ebp)
  10ad9c:	ff 75 20             	pushl  0x20(%ebp)
  10ad9f:	ff 75 1c             	pushl  0x1c(%ebp)
{
  10ada2:	8b 7d 14             	mov    0x14(%ebp),%edi
  10ada5:	8b 5d 08             	mov    0x8(%ebp),%ebx
	z_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
  10ada8:	56                   	push   %esi
  10ada9:	57                   	push   %edi
  10adaa:	ff 75 10             	pushl  0x10(%ebp)
  10adad:	ff 75 0c             	pushl  0xc(%ebp)
  10adb0:	53                   	push   %ebx
  10adb1:	e8 71 bb ff ff       	call   106927 <z_new_thread>
#endif

#ifdef CONFIG_THREAD_MONITOR
	new_thread->entry.pEntry = entry;
	new_thread->entry.parameter1 = p1;
	new_thread->entry.parameter2 = p2;
  10adb6:	8b 45 1c             	mov    0x1c(%ebp),%eax
	z_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
  10adb9:	83 c4 24             	add    $0x24,%esp
	new_thread->entry.parameter2 = p2;
  10adbc:	89 43 3c             	mov    %eax,0x3c(%ebx)
	new_thread->entry.parameter3 = p3;
  10adbf:	8b 45 20             	mov    0x20(%ebp),%eax
	new_thread->entry.pEntry = entry;
  10adc2:	89 7b 34             	mov    %edi,0x34(%ebx)
	new_thread->entry.parameter1 = p1;
  10adc5:	89 73 38             	mov    %esi,0x38(%ebx)
	new_thread->entry.parameter3 = p3;
  10adc8:	89 43 40             	mov    %eax,0x40(%ebx)
	__asm__ volatile (
  10adcb:	9c                   	pushf  
  10adcc:	fa                   	cli    
  10adcd:	58                   	pop    %eax
  10adce:	0f ba e0 09          	bt     $0x9,%eax

	k_spinlock_key_t key = k_spin_lock(&lock);

	new_thread->next_thread = _kernel.threads;
  10add2:	8b 0d 4c 0a 11 00    	mov    0x110a4c,%ecx
  10add8:	89 4b 44             	mov    %ecx,0x44(%ebx)
	_kernel.threads = new_thread;
  10addb:	89 1d 4c 0a 11 00    	mov    %ebx,0x110a4c
  10ade1:	73 01                	jae    10ade4 <z_setup_new_thread+0x57>
	__asm__ volatile (
  10ade3:	fb                   	sti    
	k_spin_unlock(&lock, key);
#endif
#ifdef CONFIG_THREAD_NAME
	if (name != NULL) {
  10ade4:	83 7d 2c 00          	cmpl   $0x0,0x2c(%ebp)
  10ade8:	74 15                	je     10adff <z_setup_new_thread+0x72>
		strncpy(new_thread->name, name,
  10adea:	6a 1f                	push   $0x1f
  10adec:	8d 43 48             	lea    0x48(%ebx),%eax
  10adef:	ff 75 2c             	pushl  0x2c(%ebp)
  10adf2:	50                   	push   %eax
  10adf3:	e8 20 bf ff ff       	call   106d18 <strncpy>
  10adf8:	83 c4 0c             	add    $0xc,%esp
			CONFIG_THREAD_MAX_NAME_LEN - 1);
		/* Ensure NULL termination, truncate if longer */
		new_thread->name[CONFIG_THREAD_MAX_NAME_LEN - 1] = '\0';
  10adfb:	c6 43 67 00          	movb   $0x0,0x67(%ebx)
	}
#endif
#ifdef CONFIG_SCHED_DEADLINE
	new_thread->base.prio_deadline = 0;
#endif
	new_thread->resource_pool = _current->resource_pool;
  10adff:	a1 28 0a 11 00       	mov    0x110a28,%eax
  10ae04:	8b 40 6c             	mov    0x6c(%eax),%eax
  10ae07:	89 43 6c             	mov    %eax,0x6c(%ebx)
	sys_trace_thread_create(new_thread);
}
  10ae0a:	8d 65 f4             	lea    -0xc(%ebp),%esp
  10ae0d:	5b                   	pop    %ebx
  10ae0e:	5e                   	pop    %esi
  10ae0f:	5f                   	pop    %edi
  10ae10:	5d                   	pop    %ebp
  10ae11:	c3                   	ret    

0010ae12 <z_impl_k_thread_create>:
k_tid_t z_impl_k_thread_create(struct k_thread *new_thread,
			      k_thread_stack_t *stack,
			      size_t stack_size, k_thread_entry_t entry,
			      void *p1, void *p2, void *p3,
			      int prio, u32_t options, s32_t delay)
{
  10ae12:	55                   	push   %ebp
  10ae13:	89 e5                	mov    %esp,%ebp
  10ae15:	56                   	push   %esi
  10ae16:	53                   	push   %ebx
#if defined(CONFIG_TEST) && defined(CONFIG_ARCH_HAS_USERSPACE) && !defined(CONFIG_USERSPACE)
	__ASSERT((options & K_USER) == 0,
		 "Platform is capable of user mode, and test thread created with K_USER option, but CONFIG_TEST_USERSPACE or CONFIG_USERSPACE is not set\n");
#endif

	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
  10ae17:	6a 00                	push   $0x0
{
  10ae19:	8b 5d 08             	mov    0x8(%ebp),%ebx
	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
  10ae1c:	ff 75 28             	pushl  0x28(%ebp)
  10ae1f:	ff 75 24             	pushl  0x24(%ebp)
  10ae22:	ff 75 20             	pushl  0x20(%ebp)
  10ae25:	ff 75 1c             	pushl  0x1c(%ebp)
  10ae28:	ff 75 18             	pushl  0x18(%ebp)
  10ae2b:	ff 75 14             	pushl  0x14(%ebp)
  10ae2e:	ff 75 10             	pushl  0x10(%ebp)
  10ae31:	ff 75 0c             	pushl  0xc(%ebp)
{
  10ae34:	8b 75 2c             	mov    0x2c(%ebp),%esi
	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
  10ae37:	53                   	push   %ebx
  10ae38:	e8 50 ff ff ff       	call   10ad8d <z_setup_new_thread>
  10ae3d:	83 c4 28             	add    $0x28,%esp
			  prio, options, NULL);

	if (delay != K_FOREVER) {
  10ae40:	83 fe ff             	cmp    $0xffffffff,%esi
  10ae43:	74 16                	je     10ae5b <z_impl_k_thread_create+0x49>
	if (delay == 0) {
  10ae45:	85 f6                	test   %esi,%esi
  10ae47:	75 09                	jne    10ae52 <z_impl_k_thread_create+0x40>
K_SYSCALL_DECLARE1_VOID(K_SYSCALL_K_THREAD_START, k_thread_start, k_tid_t, thread)
  10ae49:	53                   	push   %ebx
  10ae4a:	e8 fa fe ff ff       	call   10ad49 <z_impl_k_thread_start>
  10ae4f:	58                   	pop    %eax
  10ae50:	eb 09                	jmp    10ae5b <z_impl_k_thread_create+0x49>
  10ae52:	89 f2                	mov    %esi,%edx
  10ae54:	89 d8                	mov    %ebx,%eax
  10ae56:	e8 b4 fd ff ff       	call   10ac0f <schedule_new_thread.part.8>
		schedule_new_thread(new_thread, delay);
	}

	return new_thread;
}
  10ae5b:	8d 65 f8             	lea    -0x8(%ebp),%esp
  10ae5e:	89 d8                	mov    %ebx,%eax
  10ae60:	5b                   	pop    %ebx
  10ae61:	5e                   	pop    %esi
  10ae62:	5d                   	pop    %ebp
  10ae63:	c3                   	ret    

0010ae64 <z_thread_single_abort>:
#ifdef CONFIG_USERSPACE
Z_SYSCALL_HANDLER1_SIMPLE_VOID(k_thread_resume, K_OBJ_THREAD, k_tid_t);
#endif

void z_thread_single_abort(struct k_thread *thread)
{
  10ae64:	55                   	push   %ebp
  10ae65:	89 e5                	mov    %esp,%ebp
  10ae67:	53                   	push   %ebx
  10ae68:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (thread->fn_abort != NULL) {
  10ae6b:	8b 43 30             	mov    0x30(%ebx),%eax
  10ae6e:	85 c0                	test   %eax,%eax
  10ae70:	74 02                	je     10ae74 <z_thread_single_abort+0x10>
		thread->fn_abort();
  10ae72:	ff d0                	call   *%eax

	if (IS_ENABLED(CONFIG_SMP)) {
		z_sched_abort(thread);
	}

	if (z_is_thread_ready(thread)) {
  10ae74:	89 d8                	mov    %ebx,%eax
  10ae76:	e8 7c fd ff ff       	call   10abf7 <z_is_thread_ready>
  10ae7b:	84 c0                	test   %al,%al
  10ae7d:	74 08                	je     10ae87 <z_thread_single_abort+0x23>
		z_remove_thread_from_ready_q(thread);
  10ae7f:	53                   	push   %ebx
  10ae80:	e8 a8 f8 ff ff       	call   10a72d <z_remove_thread_from_ready_q>
  10ae85:	eb 1c                	jmp    10aea3 <z_thread_single_abort+0x3f>
	} else {
		if (z_is_thread_pending(thread)) {
  10ae87:	f6 43 0d 02          	testb  $0x2,0xd(%ebx)
  10ae8b:	74 07                	je     10ae94 <z_thread_single_abort+0x30>
			z_unpend_thread_no_timeout(thread);
  10ae8d:	53                   	push   %ebx
  10ae8e:	e8 ad f5 ff ff       	call   10a440 <z_unpend_thread_no_timeout>
  10ae93:	5a                   	pop    %edx
		}
		if (z_is_thread_timeout_active(thread)) {
  10ae94:	83 7b 18 00          	cmpl   $0x0,0x18(%ebx)
  10ae98:	74 0a                	je     10aea4 <z_thread_single_abort+0x40>
	return z_abort_timeout(&thread->base.timeout);
  10ae9a:	8d 43 18             	lea    0x18(%ebx),%eax
  10ae9d:	50                   	push   %eax
  10ae9e:	e8 2c 02 00 00       	call   10b0cf <z_abort_timeout>
  10aea3:	58                   	pop    %eax
			(void)z_abort_thread_timeout(thread);
		}
	}

	thread->base.thread_state |= _THREAD_DEAD;
  10aea4:	80 4b 0d 08          	orb    $0x8,0xd(%ebx)
	z_object_uninit(thread);

	/* Revoke permissions on thread's ID so that it may be recycled */
	z_thread_perms_all_clear(thread);
#endif
}
  10aea8:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  10aeab:	c9                   	leave  
  10aeac:	c3                   	ret    

0010aead <z_init_static_threads>:
	}
}
#endif /* CONFIG_USERSPACE */

void z_init_static_threads(void)
{
  10aead:	55                   	push   %ebp
  10aeae:	89 e5                	mov    %esp,%ebp
  10aeb0:	53                   	push   %ebx
	_FOREACH_STATIC_THREAD(thread_data) {
  10aeb1:	bb 20 34 11 00       	mov    $0x113420,%ebx
  10aeb6:	81 fb 20 34 11 00    	cmp    $0x113420,%ebx
  10aebc:	73 2f                	jae    10aeed <z_init_static_threads+0x40>
		z_setup_new_thread(
  10aebe:	ff 73 2c             	pushl  0x2c(%ebx)
  10aec1:	ff 73 20             	pushl  0x20(%ebx)
  10aec4:	ff 73 1c             	pushl  0x1c(%ebx)
  10aec7:	ff 73 18             	pushl  0x18(%ebx)
  10aeca:	ff 73 14             	pushl  0x14(%ebx)
  10aecd:	ff 73 10             	pushl  0x10(%ebx)
  10aed0:	ff 73 0c             	pushl  0xc(%ebx)
  10aed3:	ff 73 08             	pushl  0x8(%ebx)
  10aed6:	ff 73 04             	pushl  0x4(%ebx)
  10aed9:	ff 33                	pushl  (%ebx)
  10aedb:	e8 ad fe ff ff       	call   10ad8d <z_setup_new_thread>
			thread_data->init_p3,
			thread_data->init_prio,
			thread_data->init_options,
			thread_data->init_name);

		thread_data->init_thread->init_data = thread_data;
  10aee0:	8b 03                	mov    (%ebx),%eax
		z_setup_new_thread(
  10aee2:	83 c4 28             	add    $0x28,%esp
		thread_data->init_thread->init_data = thread_data;
  10aee5:	89 58 2c             	mov    %ebx,0x2c(%eax)
	_FOREACH_STATIC_THREAD(thread_data) {
  10aee8:	83 c3 30             	add    $0x30,%ebx
  10aeeb:	eb c9                	jmp    10aeb6 <z_init_static_threads+0x9>
	 * until they are all started.
	 *
	 * Note that static threads defined using the legacy API have a
	 * delay of K_FOREVER.
	 */
	k_sched_lock();
  10aeed:	e8 f6 f5 ff ff       	call   10a4e8 <k_sched_lock>
	_FOREACH_STATIC_THREAD(thread_data) {
  10aef2:	bb 20 34 11 00       	mov    $0x113420,%ebx
  10aef7:	81 fb 20 34 11 00    	cmp    $0x113420,%ebx
  10aefd:	73 21                	jae    10af20 <z_init_static_threads+0x73>
		if (thread_data->init_delay != K_FOREVER) {
  10aeff:	8b 53 24             	mov    0x24(%ebx),%edx
  10af02:	83 fa ff             	cmp    $0xffffffff,%edx
  10af05:	74 14                	je     10af1b <z_init_static_threads+0x6e>
			schedule_new_thread(thread_data->init_thread,
  10af07:	8b 03                	mov    (%ebx),%eax
	if (delay == 0) {
  10af09:	85 d2                	test   %edx,%edx
  10af0b:	75 09                	jne    10af16 <z_init_static_threads+0x69>
  10af0d:	50                   	push   %eax
  10af0e:	e8 36 fe ff ff       	call   10ad49 <z_impl_k_thread_start>
  10af13:	58                   	pop    %eax
  10af14:	eb 05                	jmp    10af1b <z_init_static_threads+0x6e>
  10af16:	e8 f4 fc ff ff       	call   10ac0f <schedule_new_thread.part.8>
	_FOREACH_STATIC_THREAD(thread_data) {
  10af1b:	83 c3 30             	add    $0x30,%ebx
  10af1e:	eb d7                	jmp    10aef7 <z_init_static_threads+0x4a>
					    thread_data->init_delay);
		}
	}
	k_sched_unlock();
}
  10af20:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  10af23:	c9                   	leave  
	k_sched_unlock();
  10af24:	e9 34 f6 ff ff       	jmp    10a55d <k_sched_unlock>

0010af29 <z_init_thread_base>:
#endif

void z_init_thread_base(struct _thread_base *thread_base, int priority,
		       u32_t initial_state, unsigned int options)
{
  10af29:	55                   	push   %ebp
  10af2a:	89 e5                	mov    %esp,%ebp
  10af2c:	8b 45 08             	mov    0x8(%ebp),%eax
	/* k_q_node is initialized upon first insertion in a list */

	thread_base->user_options = (u8_t)options;
  10af2f:	8b 55 14             	mov    0x14(%ebp),%edx
  10af32:	88 50 0c             	mov    %dl,0xc(%eax)
	thread_base->thread_state = (u8_t)initial_state;
  10af35:	8b 55 10             	mov    0x10(%ebp),%edx
  10af38:	88 50 0d             	mov    %dl,0xd(%eax)

	thread_base->prio = priority;
  10af3b:	8b 55 0c             	mov    0xc(%ebp),%edx
  10af3e:	88 50 0e             	mov    %dl,0xe(%eax)

	thread_base->sched_locked = 0U;
  10af41:	c6 40 0f 00          	movb   $0x0,0xf(%eax)
	node->next = NULL;
  10af45:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
	node->prev = NULL;
  10af4c:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)

	/* swap_data does not need to be initialized */

	z_init_thread_timeout(thread_base);
}
  10af53:	5d                   	pop    %ebp
  10af54:	c3                   	ret    

0010af55 <z_impl_k_thread_abort>:

extern void z_thread_single_abort(struct k_thread *thread);

#if !defined(CONFIG_ARCH_HAS_THREAD_ABORT)
void z_impl_k_thread_abort(k_tid_t thread)
{
  10af55:	55                   	push   %ebp
  10af56:	89 e5                	mov    %esp,%ebp
  10af58:	56                   	push   %esi
  10af59:	53                   	push   %ebx
  10af5a:	50                   	push   %eax
  10af5b:	8b 5d 08             	mov    0x8(%ebp),%ebx
	__asm__ volatile (
  10af5e:	9c                   	pushf  
  10af5f:	fa                   	cli    
  10af60:	5e                   	pop    %esi
	k_spinlock_key_t key = k_spin_lock(&lock);

	__ASSERT((thread->base.user_options & K_ESSENTIAL) == 0U,
		 "essential thread aborted");

	z_thread_single_abort(thread);
  10af61:	53                   	push   %ebx
  10af62:	e8 fd fe ff ff       	call   10ae64 <z_thread_single_abort>
	z_thread_monitor_exit(thread);
  10af67:	89 1c 24             	mov    %ebx,(%esp)
  10af6a:	e8 71 fd ff ff       	call   10ace0 <z_thread_monitor_exit>

	z_reschedule(&lock, key);
  10af6f:	8d 45 f7             	lea    -0x9(%ebp),%eax
  10af72:	89 34 24             	mov    %esi,(%esp)
  10af75:	50                   	push   %eax
  10af76:	e8 1f f5 ff ff       	call   10a49a <z_reschedule>
  10af7b:	5a                   	pop    %edx
  10af7c:	59                   	pop    %ecx
}
  10af7d:	8d 65 f8             	lea    -0x8(%ebp),%esp
  10af80:	5b                   	pop    %ebx
  10af81:	5e                   	pop    %esi
  10af82:	5d                   	pop    %ebp
  10af83:	c3                   	ret    

0010af84 <sys_kernel_version_get>:
 * @return kernel version
 */
u32_t sys_kernel_version_get(void)
{
	return KERNELVERSION;
}
  10af84:	b8 00 01 0e 01       	mov    $0x10e0100,%eax
  10af89:	c3                   	ret    

0010af8a <elapsed>:
	sys_dlist_remove(&t->node);
}

static s32_t elapsed(void)
{
	return announce_remaining == 0 ? z_clock_elapsed() : 0;
  10af8a:	83 3d 50 0b 11 00 00 	cmpl   $0x0,0x110b50
  10af91:	75 05                	jne    10af98 <elapsed+0xe>
  10af93:	e9 10 b8 ff ff       	jmp    1067a8 <z_clock_elapsed>
}
  10af98:	31 c0                	xor    %eax,%eax
  10af9a:	c3                   	ret    

0010af9b <next_timeout>:

static s32_t next_timeout(void)
{
	int maxw = can_wait_forever ? K_FOREVER : INT_MAX;
  10af9b:	80 3d 56 0b 11 00 01 	cmpb   $0x1,0x110b56
  10afa2:	19 d2                	sbb    %edx,%edx
{
  10afa4:	55                   	push   %ebp
  10afa5:	89 e5                	mov    %esp,%ebp
  10afa7:	56                   	push   %esi
	int maxw = can_wait_forever ? K_FOREVER : INT_MAX;
  10afa8:	81 e2 00 00 00 80    	and    $0x80000000,%edx
{
  10afae:	53                   	push   %ebx
	return list->head == list;
  10afaf:	8b 1d d0 32 11 00    	mov    0x1132d0,%ebx
	int maxw = can_wait_forever ? K_FOREVER : INT_MAX;
  10afb5:	4a                   	dec    %edx
	struct _timeout *to = first();
	s32_t ret = to == NULL ? maxw : MAX(0, to->dticks - elapsed());
  10afb6:	85 db                	test   %ebx,%ebx
  10afb8:	74 22                	je     10afdc <next_timeout+0x41>
  10afba:	81 fb d0 32 11 00    	cmp    $0x1132d0,%ebx
  10afc0:	74 1a                	je     10afdc <next_timeout+0x41>
  10afc2:	8b 73 08             	mov    0x8(%ebx),%esi
  10afc5:	e8 c0 ff ff ff       	call   10af8a <elapsed>
  10afca:	31 d2                	xor    %edx,%edx
  10afcc:	39 c6                	cmp    %eax,%esi
  10afce:	78 0c                	js     10afdc <next_timeout+0x41>
  10afd0:	8b 5b 08             	mov    0x8(%ebx),%ebx
  10afd3:	e8 b2 ff ff ff       	call   10af8a <elapsed>
  10afd8:	89 da                	mov    %ebx,%edx
  10afda:	29 c2                	sub    %eax,%edx

#ifdef CONFIG_TIMESLICING
	if (_current_cpu->slice_ticks && _current_cpu->slice_ticks < ret) {
  10afdc:	a1 30 0a 11 00       	mov    0x110a30,%eax
  10afe1:	85 c0                	test   %eax,%eax
  10afe3:	74 04                	je     10afe9 <next_timeout+0x4e>
  10afe5:	39 d0                	cmp    %edx,%eax
  10afe7:	7c 02                	jl     10afeb <next_timeout+0x50>
  10afe9:	89 d0                	mov    %edx,%eax
		ret = _current_cpu->slice_ticks;
	}
#endif
	return ret;
}
  10afeb:	5b                   	pop    %ebx
  10afec:	5e                   	pop    %esi
  10afed:	5d                   	pop    %ebp
  10afee:	c3                   	ret    

0010afef <remove_timeout>:
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
  10afef:	8b 10                	mov    (%eax),%edx
  10aff1:	85 c0                	test   %eax,%eax
  10aff3:	74 12                	je     10b007 <remove_timeout+0x18>
	return (node == list->tail) ? NULL : node->next;
  10aff5:	3b 05 d4 32 11 00    	cmp    0x1132d4,%eax
  10affb:	74 0a                	je     10b007 <remove_timeout+0x18>
	if (next(t) != NULL) {
  10affd:	85 d2                	test   %edx,%edx
  10afff:	74 06                	je     10b007 <remove_timeout+0x18>
		next(t)->dticks += t->dticks;
  10b001:	8b 48 08             	mov    0x8(%eax),%ecx
  10b004:	01 4a 08             	add    %ecx,0x8(%edx)
	node->prev->next = node->next;
  10b007:	8b 48 04             	mov    0x4(%eax),%ecx
  10b00a:	89 11                	mov    %edx,(%ecx)
	node->next->prev = node->prev;
  10b00c:	89 4a 04             	mov    %ecx,0x4(%edx)
	node->next = NULL;
  10b00f:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	node->prev = NULL;
  10b015:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
}
  10b01c:	c3                   	ret    

0010b01d <z_add_timeout>:

void z_add_timeout(struct _timeout *to, _timeout_func_t fn, s32_t ticks)
{
  10b01d:	55                   	push   %ebp
  10b01e:	89 e5                	mov    %esp,%ebp
  10b020:	57                   	push   %edi
  10b021:	56                   	push   %esi
  10b022:	53                   	push   %ebx
  10b023:	8b 5d 08             	mov    0x8(%ebp),%ebx
	__ASSERT(!sys_dnode_is_linked(&to->node), "");
	to->fn = fn;
  10b026:	8b 45 0c             	mov    0xc(%ebp),%eax
  10b029:	89 43 0c             	mov    %eax,0xc(%ebx)
  10b02c:	9c                   	pushf  
  10b02d:	fa                   	cli    
  10b02e:	5e                   	pop    %esi
	ticks = MAX(1, ticks);

	LOCKED(&timeout_lock) {
		struct _timeout *t;

		to->dticks = ticks + elapsed();
  10b02f:	e8 56 ff ff ff       	call   10af8a <elapsed>
	ticks = MAX(1, ticks);
  10b034:	8b 55 10             	mov    0x10(%ebp),%edx
  10b037:	85 d2                	test   %edx,%edx
  10b039:	7f 05                	jg     10b040 <z_add_timeout+0x23>
  10b03b:	ba 01 00 00 00       	mov    $0x1,%edx
		to->dticks = ticks + elapsed();
  10b040:	01 c2                	add    %eax,%edx
	return list->head == list;
  10b042:	a1 d0 32 11 00       	mov    0x1132d0,%eax
  10b047:	89 53 08             	mov    %edx,0x8(%ebx)
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
  10b04a:	8b 0d d4 32 11 00    	mov    0x1132d4,%ecx
	return sys_dlist_is_empty(list) ? NULL : list->head;
  10b050:	3d d0 32 11 00       	cmp    $0x1132d0,%eax
  10b055:	74 2f                	je     10b086 <z_add_timeout+0x69>
		for (t = first(); t != NULL; t = next(t)) {
  10b057:	85 c0                	test   %eax,%eax
  10b059:	74 2b                	je     10b086 <z_add_timeout+0x69>
			__ASSERT(t->dticks >= 0, "");

			if (t->dticks > to->dticks) {
  10b05b:	8b 78 08             	mov    0x8(%eax),%edi
  10b05e:	8b 53 08             	mov    0x8(%ebx),%edx
  10b061:	39 d7                	cmp    %edx,%edi
  10b063:	7e 14                	jle    10b079 <z_add_timeout+0x5c>
				t->dticks -= to->dticks;
  10b065:	29 d7                	sub    %edx,%edi
	node->prev = successor->prev;
  10b067:	8b 50 04             	mov    0x4(%eax),%edx
  10b06a:	89 78 08             	mov    %edi,0x8(%eax)
  10b06d:	89 53 04             	mov    %edx,0x4(%ebx)
	node->next = successor;
  10b070:	89 03                	mov    %eax,(%ebx)
	successor->prev->next = node;
  10b072:	89 1a                	mov    %ebx,(%edx)
	successor->prev = node;
  10b074:	89 58 04             	mov    %ebx,0x4(%eax)
				break;
			}
			to->dticks -= t->dticks;
		}

		if (t == NULL) {
  10b077:	eb 28                	jmp    10b0a1 <z_add_timeout+0x84>
			to->dticks -= t->dticks;
  10b079:	29 fa                	sub    %edi,%edx
	return (node == list->tail) ? NULL : node->next;
  10b07b:	39 c1                	cmp    %eax,%ecx
  10b07d:	89 53 08             	mov    %edx,0x8(%ebx)
  10b080:	74 04                	je     10b086 <z_add_timeout+0x69>
  10b082:	8b 00                	mov    (%eax),%eax
  10b084:	eb d1                	jmp    10b057 <z_add_timeout+0x3a>
	node->prev = list->tail;
  10b086:	a1 d4 32 11 00       	mov    0x1132d4,%eax
	node->next = list;
  10b08b:	c7 03 d0 32 11 00    	movl   $0x1132d0,(%ebx)
	node->prev = list->tail;
  10b091:	89 43 04             	mov    %eax,0x4(%ebx)
	list->tail->next = node;
  10b094:	a1 d4 32 11 00       	mov    0x1132d4,%eax
  10b099:	89 18                	mov    %ebx,(%eax)
	list->tail = node;
  10b09b:	89 1d d4 32 11 00    	mov    %ebx,0x1132d4
	return list->head == list;
  10b0a1:	a1 d0 32 11 00       	mov    0x1132d0,%eax
			sys_dlist_append(&timeout_list, &to->node);
		}

		if (to == first()) {
  10b0a6:	39 c3                	cmp    %eax,%ebx
  10b0a8:	75 16                	jne    10b0c0 <z_add_timeout+0xa3>
  10b0aa:	3d d0 32 11 00       	cmp    $0x1132d0,%eax
  10b0af:	74 0f                	je     10b0c0 <z_add_timeout+0xa3>
			z_clock_set_timeout(next_timeout(), false);
  10b0b1:	e8 e5 fe ff ff       	call   10af9b <next_timeout>
  10b0b6:	6a 00                	push   $0x0
  10b0b8:	50                   	push   %eax
  10b0b9:	e8 64 b6 ff ff       	call   106722 <z_clock_set_timeout>
  10b0be:	58                   	pop    %eax
  10b0bf:	5a                   	pop    %edx
  10b0c0:	0f ba e6 09          	bt     $0x9,%esi
  10b0c4:	73 01                	jae    10b0c7 <z_add_timeout+0xaa>
	__asm__ volatile (
  10b0c6:	fb                   	sti    
		}
	}
}
  10b0c7:	8d 65 f4             	lea    -0xc(%ebp),%esp
  10b0ca:	5b                   	pop    %ebx
  10b0cb:	5e                   	pop    %esi
  10b0cc:	5f                   	pop    %edi
  10b0cd:	5d                   	pop    %ebp
  10b0ce:	c3                   	ret    

0010b0cf <z_abort_timeout>:

int z_abort_timeout(struct _timeout *to)
{
  10b0cf:	55                   	push   %ebp
  10b0d0:	89 e5                	mov    %esp,%ebp
  10b0d2:	53                   	push   %ebx
  10b0d3:	8b 45 08             	mov    0x8(%ebp),%eax
	__asm__ volatile (
  10b0d6:	9c                   	pushf  
  10b0d7:	fa                   	cli    
  10b0d8:	5b                   	pop    %ebx
	return node->next != NULL;
  10b0d9:	ba ea ff ff ff       	mov    $0xffffffea,%edx
	int ret = -EINVAL;

	LOCKED(&timeout_lock) {
		if (sys_dnode_is_linked(&to->node)) {
  10b0de:	83 38 00             	cmpl   $0x0,(%eax)
  10b0e1:	74 07                	je     10b0ea <z_abort_timeout+0x1b>
			remove_timeout(to);
  10b0e3:	e8 07 ff ff ff       	call   10afef <remove_timeout>
			ret = 0;
  10b0e8:	31 d2                	xor    %edx,%edx
  10b0ea:	0f ba e3 09          	bt     $0x9,%ebx
  10b0ee:	73 01                	jae    10b0f1 <z_abort_timeout+0x22>
	__asm__ volatile (
  10b0f0:	fb                   	sti    
		}
	}

	return ret;
}
  10b0f1:	5b                   	pop    %ebx
  10b0f2:	89 d0                	mov    %edx,%eax
  10b0f4:	5d                   	pop    %ebp
  10b0f5:	c3                   	ret    

0010b0f6 <z_get_next_timeout_expiry>:

	return ticks - elapsed();
}

s32_t z_get_next_timeout_expiry(void)
{
  10b0f6:	55                   	push   %ebp
  10b0f7:	89 e5                	mov    %esp,%ebp
  10b0f9:	53                   	push   %ebx
	__asm__ volatile (
  10b0fa:	9c                   	pushf  
  10b0fb:	fa                   	cli    
  10b0fc:	5b                   	pop    %ebx
	s32_t ret = K_FOREVER;

	LOCKED(&timeout_lock) {
		ret = next_timeout();
  10b0fd:	e8 99 fe ff ff       	call   10af9b <next_timeout>
  10b102:	0f ba e3 09          	bt     $0x9,%ebx
  10b106:	73 01                	jae    10b109 <z_get_next_timeout_expiry+0x13>
	__asm__ volatile (
  10b108:	fb                   	sti    
	}
	return ret;
}
  10b109:	5b                   	pop    %ebx
  10b10a:	5d                   	pop    %ebp
  10b10b:	c3                   	ret    

0010b10c <z_set_timeout_expiry>:

void z_set_timeout_expiry(s32_t ticks, bool idle)
{
  10b10c:	55                   	push   %ebp
  10b10d:	89 e5                	mov    %esp,%ebp
  10b10f:	57                   	push   %edi
  10b110:	56                   	push   %esi
  10b111:	53                   	push   %ebx
  10b112:	8b 75 08             	mov    0x8(%ebp),%esi
  10b115:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	__asm__ volatile (
  10b118:	9c                   	pushf  
  10b119:	fa                   	cli    
  10b11a:	5f                   	pop    %edi
	LOCKED(&timeout_lock) {
		int next = next_timeout();
  10b11b:	e8 7b fe ff ff       	call   10af9b <next_timeout>
		bool sooner = (next == K_FOREVER) || (ticks < next);
  10b120:	83 f8 ff             	cmp    $0xffffffff,%eax
  10b123:	0f 94 c1             	sete   %cl
  10b126:	39 f0                	cmp    %esi,%eax
  10b128:	0f 9f c2             	setg   %dl
		 * what we have.  Also don't try to set a timeout when
		 * one is about to expire: drivers have internal logic
		 * that will bump the timeout to the "next" tick if
		 * it's not considered to be settable as directed.
		 */
		if (sooner && !imminent) {
  10b12b:	08 d1                	or     %dl,%cl
  10b12d:	74 0f                	je     10b13e <z_set_timeout_expiry+0x32>
  10b12f:	48                   	dec    %eax
  10b130:	7e 0c                	jle    10b13e <z_set_timeout_expiry+0x32>
			z_clock_set_timeout(ticks, idle);
  10b132:	0f b6 db             	movzbl %bl,%ebx
  10b135:	53                   	push   %ebx
  10b136:	56                   	push   %esi
  10b137:	e8 e6 b5 ff ff       	call   106722 <z_clock_set_timeout>
  10b13c:	58                   	pop    %eax
  10b13d:	5a                   	pop    %edx
  10b13e:	0f ba e7 09          	bt     $0x9,%edi
  10b142:	73 01                	jae    10b145 <z_set_timeout_expiry+0x39>
	__asm__ volatile (
  10b144:	fb                   	sti    
		}
	}
}
  10b145:	8d 65 f4             	lea    -0xc(%ebp),%esp
  10b148:	5b                   	pop    %ebx
  10b149:	5e                   	pop    %esi
  10b14a:	5f                   	pop    %edi
  10b14b:	5d                   	pop    %ebp
  10b14c:	c3                   	ret    

0010b14d <z_clock_announce>:

void z_clock_announce(s32_t ticks)
{
  10b14d:	55                   	push   %ebp
  10b14e:	89 e5                	mov    %esp,%ebp
  10b150:	57                   	push   %edi
  10b151:	56                   	push   %esi
  10b152:	53                   	push   %ebx
  10b153:	83 ec 0c             	sub    $0xc,%esp
  10b156:	8b 5d 08             	mov    0x8(%ebp),%ebx
#ifdef CONFIG_TIMESLICING
	z_time_slice(ticks);
  10b159:	53                   	push   %ebx
  10b15a:	e8 6c f5 ff ff       	call   10a6cb <z_time_slice>
  10b15f:	5e                   	pop    %esi
	__asm__ volatile (
  10b160:	9c                   	pushf  
  10b161:	fa                   	cli    
  10b162:	58                   	pop    %eax
#endif

	k_spinlock_key_t key = k_spin_lock(&timeout_lock);

	announce_remaining = ticks;
  10b163:	89 1d 50 0b 11 00    	mov    %ebx,0x110b50
	return list->head == list;
  10b169:	25 00 02 00 00       	and    $0x200,%eax
  10b16e:	8b 1d d0 32 11 00    	mov    0x1132d0,%ebx
	return t == NULL ? NULL : CONTAINER_OF(t, struct _timeout, node);
  10b174:	8b 35 50 0a 11 00    	mov    0x110a50,%esi
  10b17a:	8b 3d 54 0a 11 00    	mov    0x110a54,%edi
  10b180:	8b 15 50 0b 11 00    	mov    0x110b50,%edx
  10b186:	89 75 ec             	mov    %esi,-0x14(%ebp)
  10b189:	89 7d f0             	mov    %edi,-0x10(%ebp)
  10b18c:	89 45 e8             	mov    %eax,-0x18(%ebp)

	while (first() != NULL && first()->dticks <= announce_remaining) {
  10b18f:	85 db                	test   %ebx,%ebx
  10b191:	74 54                	je     10b1e7 <z_clock_announce+0x9a>
  10b193:	81 fb d0 32 11 00    	cmp    $0x1132d0,%ebx
  10b199:	74 4c                	je     10b1e7 <z_clock_announce+0x9a>
  10b19b:	8b 43 08             	mov    0x8(%ebx),%eax
  10b19e:	39 d0                	cmp    %edx,%eax
  10b1a0:	7f 40                	jg     10b1e2 <z_clock_announce+0x95>
		struct _timeout *t = first();
		int dt = t->dticks;

		curr_tick += dt;
  10b1a2:	89 c6                	mov    %eax,%esi
  10b1a4:	89 c7                	mov    %eax,%edi
  10b1a6:	c1 ff 1f             	sar    $0x1f,%edi
  10b1a9:	03 75 ec             	add    -0x14(%ebp),%esi
  10b1ac:	13 7d f0             	adc    -0x10(%ebp),%edi
		announce_remaining -= dt;
		t->dticks = 0;
  10b1af:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
		announce_remaining -= dt;
  10b1b6:	29 c2                	sub    %eax,%edx
		remove_timeout(t);
  10b1b8:	89 d8                	mov    %ebx,%eax
		curr_tick += dt;
  10b1ba:	89 35 50 0a 11 00    	mov    %esi,0x110a50
  10b1c0:	89 3d 54 0a 11 00    	mov    %edi,0x110a54
		announce_remaining -= dt;
  10b1c6:	89 15 50 0b 11 00    	mov    %edx,0x110b50
		remove_timeout(t);
  10b1cc:	e8 1e fe ff ff       	call   10afef <remove_timeout>
  10b1d1:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
  10b1d5:	74 01                	je     10b1d8 <z_clock_announce+0x8b>
	__asm__ volatile (
  10b1d7:	fb                   	sti    

		k_spin_unlock(&timeout_lock, key);
		t->fn(t);
  10b1d8:	53                   	push   %ebx
  10b1d9:	ff 53 0c             	call   *0xc(%ebx)
  10b1dc:	59                   	pop    %ecx
	__asm__ volatile (
  10b1dd:	9c                   	pushf  
  10b1de:	fa                   	cli    
  10b1df:	58                   	pop    %eax
#endif

#ifdef SPIN_VALIDATE
	z_spin_lock_set_owner(l);
#endif
	return k;
  10b1e0:	eb 87                	jmp    10b169 <z_clock_announce+0x1c>
		key = k_spin_lock(&timeout_lock);
	}

	if (first() != NULL) {
		first()->dticks -= announce_remaining;
  10b1e2:	29 d0                	sub    %edx,%eax
  10b1e4:	89 43 08             	mov    %eax,0x8(%ebx)
	}

	curr_tick += announce_remaining;
  10b1e7:	89 d6                	mov    %edx,%esi
  10b1e9:	89 d7                	mov    %edx,%edi
  10b1eb:	c1 ff 1f             	sar    $0x1f,%edi
  10b1ee:	03 75 ec             	add    -0x14(%ebp),%esi
  10b1f1:	13 7d f0             	adc    -0x10(%ebp),%edi
  10b1f4:	89 35 50 0a 11 00    	mov    %esi,0x110a50
  10b1fa:	89 3d 54 0a 11 00    	mov    %edi,0x110a54
	announce_remaining = 0;
  10b200:	c7 05 50 0b 11 00 00 	movl   $0x0,0x110b50
  10b207:	00 00 00 

	z_clock_set_timeout(next_timeout(), false);
  10b20a:	e8 8c fd ff ff       	call   10af9b <next_timeout>
  10b20f:	6a 00                	push   $0x0
  10b211:	50                   	push   %eax
  10b212:	e8 0b b5 ff ff       	call   106722 <z_clock_set_timeout>
  10b217:	58                   	pop    %eax
  10b218:	5a                   	pop    %edx
  10b219:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
  10b21d:	74 01                	je     10b220 <z_clock_announce+0xd3>
	__asm__ volatile (
  10b21f:	fb                   	sti    

	k_spin_unlock(&timeout_lock, key);
}
  10b220:	8d 65 f4             	lea    -0xc(%ebp),%esp
  10b223:	5b                   	pop    %ebx
  10b224:	5e                   	pop    %esi
  10b225:	5f                   	pop    %edi
  10b226:	5d                   	pop    %ebp
  10b227:	c3                   	ret    

0010b228 <z_tick_get>:
{
	can_wait_forever = 1;
}

s64_t z_tick_get(void)
{
  10b228:	55                   	push   %ebp
  10b229:	89 e5                	mov    %esp,%ebp
  10b22b:	56                   	push   %esi
  10b22c:	53                   	push   %ebx
	__asm__ volatile (
  10b22d:	9c                   	pushf  
  10b22e:	fa                   	cli    
  10b22f:	5e                   	pop    %esi
	u64_t t = 0U;

	LOCKED(&timeout_lock) {
		t = curr_tick + z_clock_elapsed();
  10b230:	e8 73 b5 ff ff       	call   1067a8 <z_clock_elapsed>
  10b235:	8b 0d 50 0a 11 00    	mov    0x110a50,%ecx
  10b23b:	0f ba e6 09          	bt     $0x9,%esi
  10b23f:	8b 1d 54 0a 11 00    	mov    0x110a54,%ebx
  10b245:	73 01                	jae    10b248 <z_tick_get+0x20>
	__asm__ volatile (
  10b247:	fb                   	sti    
  10b248:	31 d2                	xor    %edx,%edx
  10b24a:	01 c8                	add    %ecx,%eax
  10b24c:	11 da                	adc    %ebx,%edx
	}
	return t;
}
  10b24e:	5b                   	pop    %ebx
  10b24f:	5e                   	pop    %esi
  10b250:	5d                   	pop    %ebp
  10b251:	c3                   	ret    

0010b252 <z_tick_get_32>:

u32_t z_tick_get_32(void)
{
  10b252:	55                   	push   %ebp
  10b253:	89 e5                	mov    %esp,%ebp
#ifdef CONFIG_TICKLESS_KERNEL
	return (u32_t)z_tick_get();
  10b255:	e8 ce ff ff ff       	call   10b228 <z_tick_get>
#else
	return (u32_t)curr_tick;
#endif
}
  10b25a:	5d                   	pop    %ebp
  10b25b:	c3                   	ret    

0010b25c <z_impl_k_uptime_get>:

s64_t z_impl_k_uptime_get(void)
{
  10b25c:	55                   	push   %ebp
  10b25d:	89 e5                	mov    %esp,%ebp
  10b25f:	51                   	push   %ecx
	return __ticks_to_ms(z_tick_get());
  10b260:	e8 c3 ff ff ff       	call   10b228 <z_tick_get>
	return (u64_t)ticks * MSEC_PER_SEC / (u64_t)CONFIG_SYS_CLOCK_TICKS_PER_SEC;
  10b265:	6a 00                	push   $0x0
  10b267:	69 ca e8 03 00 00    	imul   $0x3e8,%edx,%ecx
  10b26d:	ba e8 03 00 00       	mov    $0x3e8,%edx
  10b272:	6a 64                	push   $0x64
  10b274:	f7 e2                	mul    %edx
  10b276:	01 ca                	add    %ecx,%edx
  10b278:	52                   	push   %edx
  10b279:	50                   	push   %eax
  10b27a:	e8 3e 4f ff ff       	call   1001bd <__udivdi3>
  10b27f:	83 c4 10             	add    $0x10,%esp
}
  10b282:	c9                   	leave  
  10b283:	c3                   	ret    

0010b284 <z_timer_expiration_handler>:
 * @param t  Timeout used by the timer.
 *
 * @return N/A
 */
void z_timer_expiration_handler(struct _timeout *t)
{
  10b284:	55                   	push   %ebp
  10b285:	89 e5                	mov    %esp,%ebp
  10b287:	56                   	push   %esi
  10b288:	53                   	push   %ebx
  10b289:	8b 5d 08             	mov    0x8(%ebp),%ebx

	/*
	 * if the timer is periodic, start it again; don't add _TICK_ALIGN
	 * since we're already aligned to a tick boundary
	 */
	if (timer->period > 0) {
  10b28c:	8b 43 20             	mov    0x20(%ebx),%eax
  10b28f:	85 c0                	test   %eax,%eax
  10b291:	7e 0f                	jle    10b2a2 <z_timer_expiration_handler+0x1e>
		z_add_timeout(&timer->timeout, z_timer_expiration_handler,
  10b293:	50                   	push   %eax
  10b294:	68 84 b2 10 00       	push   $0x10b284
  10b299:	53                   	push   %ebx
  10b29a:	e8 7e fd ff ff       	call   10b01d <z_add_timeout>
  10b29f:	83 c4 0c             	add    $0xc,%esp

	/* update timer's status */
	timer->status += 1U;

	/* invoke timer expiry function */
	if (timer->expiry_fn != NULL) {
  10b2a2:	8b 43 18             	mov    0x18(%ebx),%eax
	timer->status += 1U;
  10b2a5:	ff 43 24             	incl   0x24(%ebx)
	if (timer->expiry_fn != NULL) {
  10b2a8:	85 c0                	test   %eax,%eax
  10b2aa:	74 04                	je     10b2b0 <z_timer_expiration_handler+0x2c>
		timer->expiry_fn(timer);
  10b2ac:	53                   	push   %ebx
  10b2ad:	ff d0                	call   *%eax
  10b2af:	59                   	pop    %ecx
  10b2b0:	8b 73 10             	mov    0x10(%ebx),%esi
	}

	thread = z_waitq_head(&timer->wait_q);

	if (thread == NULL) {
  10b2b3:	85 f6                	test   %esi,%esi
  10b2b5:	74 2a                	je     10b2e1 <z_timer_expiration_handler+0x5d>
	sys_dlist_init(&w->waitq);
}

static inline struct k_thread *z_waitq_head(_wait_q_t *w)
{
	return (struct k_thread *)sys_dlist_peek_head(&w->waitq);
  10b2b7:	83 c3 10             	add    $0x10,%ebx
  10b2ba:	39 de                	cmp    %ebx,%esi
  10b2bc:	74 23                	je     10b2e1 <z_timer_expiration_handler+0x5d>
	 * place a thread can be taken off this pend queue, and b) the
	 * only place a thread can be put on the pend queue is at
	 * thread level, which of course cannot interrupt the current
	 * context.
	 */
	z_unpend_thread_no_timeout(thread);
  10b2be:	56                   	push   %esi
  10b2bf:	e8 7c f1 ff ff       	call   10a440 <z_unpend_thread_no_timeout>
  10b2c4:	5a                   	pop    %edx
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
  10b2c5:	f6 46 0d 1f          	testb  $0x1f,0xd(%esi)
  10b2c9:	75 0d                	jne    10b2d8 <z_timer_expiration_handler+0x54>
	if (z_is_thread_ready(thread)) {
  10b2cb:	83 7e 18 00          	cmpl   $0x0,0x18(%esi)
  10b2cf:	75 07                	jne    10b2d8 <z_timer_expiration_handler+0x54>
		z_add_thread_to_ready_q(thread);
  10b2d1:	56                   	push   %esi
  10b2d2:	e8 ad f2 ff ff       	call   10a584 <z_add_thread_to_ready_q>
  10b2d7:	58                   	pop    %eax
  10b2d8:	8b 46 28             	mov    0x28(%esi),%eax
  10b2db:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

	z_ready_thread(thread);

	z_set_thread_return_value(thread, 0);
}
  10b2e1:	8d 65 f8             	lea    -0x8(%ebp),%esp
  10b2e4:	5b                   	pop    %ebx
  10b2e5:	5e                   	pop    %esi
  10b2e6:	5d                   	pop    %ebp
  10b2e7:	c3                   	ret    

0010b2e8 <k_timer_init>:


void k_timer_init(struct k_timer *timer,
			 k_timer_expiry_t expiry_fn,
			 k_timer_stop_t stop_fn)
{
  10b2e8:	55                   	push   %ebp
  10b2e9:	89 e5                	mov    %esp,%ebp
  10b2eb:	8b 45 08             	mov    0x8(%ebp),%eax
	timer->expiry_fn = expiry_fn;
  10b2ee:	8b 55 0c             	mov    0xc(%ebp),%edx
  10b2f1:	89 50 18             	mov    %edx,0x18(%eax)
	timer->stop_fn = stop_fn;
  10b2f4:	8b 55 10             	mov    0x10(%ebp),%edx
  10b2f7:	89 50 1c             	mov    %edx,0x1c(%eax)
	sys_dlist_init(&w->waitq);
  10b2fa:	8d 50 10             	lea    0x10(%eax),%edx
	timer->status = 0U;
  10b2fd:	c7 40 24 00 00 00 00 	movl   $0x0,0x24(%eax)
	list->head = (sys_dnode_t *)list;
  10b304:	89 50 10             	mov    %edx,0x10(%eax)
	list->tail = (sys_dnode_t *)list;
  10b307:	89 50 14             	mov    %edx,0x14(%eax)
	node->next = NULL;
  10b30a:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	node->prev = NULL;
  10b310:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)

	z_waitq_init(&timer->wait_q);
	z_init_timeout(&timer->timeout, z_timer_expiration_handler);
	SYS_TRACING_OBJ_INIT(k_timer, timer);

	timer->user_data = NULL;
  10b317:	c7 40 28 00 00 00 00 	movl   $0x0,0x28(%eax)

	z_object_init(timer);
}
  10b31e:	5d                   	pop    %ebp
  10b31f:	c3                   	ret    

0010b320 <z_impl_k_timer_start>:


void z_impl_k_timer_start(struct k_timer *timer, s32_t duration, s32_t period)
{
  10b320:	55                   	push   %ebp
  10b321:	89 e5                	mov    %esp,%ebp
  10b323:	57                   	push   %edi
  10b324:	56                   	push   %esi
  10b325:	53                   	push   %ebx
  10b326:	83 ec 14             	sub    $0x14,%esp
	return z_clock_hw_cycles_per_sec;
  10b329:	a1 cc 32 11 00       	mov    0x1132cc,%eax
  10b32e:	8b 5d 08             	mov    0x8(%ebp),%ebx
  10b331:	89 45 e8             	mov    %eax,-0x18(%ebp)
	return (s32_t)ceiling_fraction(
  10b334:	b8 e8 03 00 00       	mov    $0x3e8,%eax
  10b339:	f7 6d e8             	imull  -0x18(%ebp)
  10b33c:	6a 00                	push   $0x0
  10b33e:	6a 64                	push   $0x64
  10b340:	52                   	push   %edx
  10b341:	50                   	push   %eax
  10b342:	e8 59 4d ff ff       	call   1000a0 <__divdi3>
  10b347:	83 c4 10             	add    $0x10,%esp
  10b34a:	89 c6                	mov    %eax,%esi
  10b34c:	83 c0 ff             	add    $0xffffffff,%eax
  10b34f:	89 d7                	mov    %edx,%edi
  10b351:	89 45 e0             	mov    %eax,-0x20(%ebp)
  10b354:	8b 45 e8             	mov    -0x18(%ebp),%eax
  10b357:	83 d2 ff             	adc    $0xffffffff,%edx
  10b35a:	57                   	push   %edi
  10b35b:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  10b35e:	56                   	push   %esi
  10b35f:	f7 6d 10             	imull  0x10(%ebp)
  10b362:	03 45 e0             	add    -0x20(%ebp),%eax
  10b365:	13 55 e4             	adc    -0x1c(%ebp),%edx
  10b368:	52                   	push   %edx
  10b369:	50                   	push   %eax
  10b36a:	e8 31 4d ff ff       	call   1000a0 <__divdi3>
	__ASSERT(duration >= 0 && period >= 0 &&
		 (duration != 0 || period != 0), "invalid parameters\n");

	volatile s32_t period_in_ticks, duration_in_ticks;

	period_in_ticks = z_ms_to_ticks(period);
  10b36f:	89 45 ec             	mov    %eax,-0x14(%ebp)
  10b372:	8b 45 e8             	mov    -0x18(%ebp),%eax
  10b375:	f7 6d 0c             	imull  0xc(%ebp)
  10b378:	83 c4 10             	add    $0x10,%esp
  10b37b:	03 45 e0             	add    -0x20(%ebp),%eax
  10b37e:	13 55 e4             	adc    -0x1c(%ebp),%edx
  10b381:	57                   	push   %edi
  10b382:	56                   	push   %esi
  10b383:	52                   	push   %edx
  10b384:	50                   	push   %eax
  10b385:	e8 16 4d ff ff       	call   1000a0 <__divdi3>
  10b38a:	83 c4 10             	add    $0x10,%esp
	duration_in_ticks = z_ms_to_ticks(duration);
  10b38d:	89 45 f0             	mov    %eax,-0x10(%ebp)

	(void)z_abort_timeout(&timer->timeout);
  10b390:	53                   	push   %ebx
  10b391:	e8 39 fd ff ff       	call   10b0cf <z_abort_timeout>
  10b396:	58                   	pop    %eax
	timer->period = period_in_ticks;
  10b397:	8b 45 ec             	mov    -0x14(%ebp),%eax
  10b39a:	89 43 20             	mov    %eax,0x20(%ebx)
	timer->status = 0U;
	z_add_timeout(&timer->timeout, z_timer_expiration_handler,
  10b39d:	8b 45 f0             	mov    -0x10(%ebp),%eax
	timer->status = 0U;
  10b3a0:	c7 43 24 00 00 00 00 	movl   $0x0,0x24(%ebx)
	z_add_timeout(&timer->timeout, z_timer_expiration_handler,
  10b3a7:	89 5d 08             	mov    %ebx,0x8(%ebp)
  10b3aa:	89 45 10             	mov    %eax,0x10(%ebp)
  10b3ad:	c7 45 0c 84 b2 10 00 	movl   $0x10b284,0xc(%ebp)
		     duration_in_ticks);
}
  10b3b4:	8d 65 f4             	lea    -0xc(%ebp),%esp
  10b3b7:	5b                   	pop    %ebx
  10b3b8:	5e                   	pop    %esi
  10b3b9:	5f                   	pop    %edi
  10b3ba:	5d                   	pop    %ebp
	z_add_timeout(&timer->timeout, z_timer_expiration_handler,
  10b3bb:	e9 5d fc ff ff       	jmp    10b01d <z_add_timeout>

0010b3c0 <z_impl_k_timer_status_sync>:
#ifdef CONFIG_USERSPACE
Z_SYSCALL_HANDLER1_SIMPLE(k_timer_status_get, K_OBJ_TIMER, struct k_timer *);
#endif

u32_t z_impl_k_timer_status_sync(struct k_timer *timer)
{
  10b3c0:	55                   	push   %ebp
  10b3c1:	89 e5                	mov    %esp,%ebp
  10b3c3:	53                   	push   %ebx
  10b3c4:	8b 5d 08             	mov    0x8(%ebp),%ebx
	__asm__ volatile (
  10b3c7:	9c                   	pushf  
  10b3c8:	fa                   	cli    
  10b3c9:	5a                   	pop    %edx
	__ASSERT(!z_is_in_isr(), "");

	k_spinlock_key_t key = k_spin_lock(&lock);
	u32_t result = timer->status;
  10b3ca:	8b 43 24             	mov    0x24(%ebx),%eax

	if (result == 0U) {
  10b3cd:	85 c0                	test   %eax,%eax
  10b3cf:	75 1f                	jne    10b3f0 <z_impl_k_timer_status_sync+0x30>
		if (!z_is_inactive_timeout(&timer->timeout)) {
  10b3d1:	83 3b 00             	cmpl   $0x0,(%ebx)
  10b3d4:	74 1a                	je     10b3f0 <z_impl_k_timer_status_sync+0x30>
			/* wait for timer to expire or stop */
			(void)z_pend_curr(&lock, key, &timer->wait_q, K_FOREVER);
  10b3d6:	6a ff                	push   $0xffffffff
  10b3d8:	8d 43 10             	lea    0x10(%ebx),%eax
  10b3db:	50                   	push   %eax
  10b3dc:	52                   	push   %edx
  10b3dd:	68 57 0b 11 00       	push   $0x110b57
  10b3e2:	e8 42 f4 ff ff       	call   10a829 <z_pend_curr>
  10b3e7:	83 c4 10             	add    $0x10,%esp
  10b3ea:	9c                   	pushf  
  10b3eb:	fa                   	cli    
  10b3ec:	5a                   	pop    %edx

			/* get updated timer status */
			key = k_spin_lock(&lock);
			result = timer->status;
  10b3ed:	8b 43 24             	mov    0x24(%ebx),%eax
  10b3f0:	0f ba e2 09          	bt     $0x9,%edx
		}
	} else {
		/* timer has already expired at least once */
	}

	timer->status = 0U;
  10b3f4:	c7 43 24 00 00 00 00 	movl   $0x0,0x24(%ebx)
  10b3fb:	73 01                	jae    10b3fe <z_impl_k_timer_status_sync+0x3e>
	__asm__ volatile (
  10b3fd:	fb                   	sti    
	k_spin_unlock(&lock, key);

	return result;
}
  10b3fe:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  10b401:	c9                   	leave  
  10b402:	c3                   	ret    

0010b403 <clear_event_registrations>:

/* must be called with interrupts locked */
static inline void clear_event_registrations(struct k_poll_event *events,
					      int last_registered,
					      k_spinlock_key_t key)
{
  10b403:	55                   	push   %ebp
  10b404:	89 e5                	mov    %esp,%ebp
  10b406:	57                   	push   %edi
  10b407:	56                   	push   %esi
  10b408:	be 01 00 00 00       	mov    $0x1,%esi
  10b40d:	53                   	push   %ebx
  10b40e:	89 cb                	mov    %ecx,%ebx
	for (; last_registered >= 0; last_registered--) {
  10b410:	6b ca 14             	imul   $0x14,%edx,%ecx
  10b413:	01 c8                	add    %ecx,%eax
  10b415:	85 d2                	test   %edx,%edx
  10b417:	78 48                	js     10b461 <clear_event_registrations+0x5e>
	switch (event->type) {
  10b419:	8a 48 0d             	mov    0xd(%eax),%cl
	event->poller = NULL;
  10b41c:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
	switch (event->type) {
  10b423:	83 e1 0f             	and    $0xf,%ecx
  10b426:	80 f9 04             	cmp    $0x4,%cl
  10b429:	77 26                	ja     10b451 <clear_event_registrations+0x4e>
  10b42b:	89 f7                	mov    %esi,%edi
  10b42d:	d3 e7                	shl    %cl,%edi
  10b42f:	89 f9                	mov    %edi,%ecx
  10b431:	80 e1 16             	and    $0x16,%cl
  10b434:	74 1b                	je     10b451 <clear_event_registrations+0x4e>
	if (remove && sys_dnode_is_linked(&event->_node)) {
  10b436:	8b 08                	mov    (%eax),%ecx
  10b438:	85 c9                	test   %ecx,%ecx
  10b43a:	74 15                	je     10b451 <clear_event_registrations+0x4e>
	node->prev->next = node->next;
  10b43c:	8b 78 04             	mov    0x4(%eax),%edi
  10b43f:	89 0f                	mov    %ecx,(%edi)
	node->next->prev = node->prev;
  10b441:	89 79 04             	mov    %edi,0x4(%ecx)
	node->next = NULL;
  10b444:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	node->prev = NULL;
  10b44a:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  10b451:	0f ba e3 09          	bt     $0x9,%ebx
  10b455:	73 01                	jae    10b458 <clear_event_registrations+0x55>
  10b457:	fb                   	sti    
	__asm__ volatile (
  10b458:	9c                   	pushf  
  10b459:	fa                   	cli    
  10b45a:	5b                   	pop    %ebx
	for (; last_registered >= 0; last_registered--) {
  10b45b:	4a                   	dec    %edx
  10b45c:	83 e8 14             	sub    $0x14,%eax
  10b45f:	eb b4                	jmp    10b415 <clear_event_registrations+0x12>
		clear_event_registration(&events[last_registered]);
		k_spin_unlock(&lock, key);
		key = k_spin_lock(&lock);
	}
}
  10b461:	5b                   	pop    %ebx
  10b462:	5e                   	pop    %esi
  10b463:	5f                   	pop    %edi
  10b464:	5d                   	pop    %ebp
  10b465:	c3                   	ret    

0010b466 <signal_poll_event>:
}
#endif

/* must be called with interrupts locked */
static int signal_poll_event(struct k_poll_event *event, u32_t state)
{
  10b466:	55                   	push   %ebp
  10b467:	89 e5                	mov    %esp,%ebp
  10b469:	57                   	push   %edi
  10b46a:	56                   	push   %esi
  10b46b:	89 d6                	mov    %edx,%esi
  10b46d:	53                   	push   %ebx
  10b46e:	89 c3                	mov    %eax,%ebx
	if (!event->poller) {
  10b470:	8b 40 08             	mov    0x8(%eax),%eax
  10b473:	85 c0                	test   %eax,%eax
  10b475:	74 45                	je     10b4bc <signal_poll_event+0x56>
		goto ready_event;
	}

	struct k_thread *thread = event->poller->thread;
  10b477:	8b 38                	mov    (%eax),%edi

	__ASSERT(event->poller->thread != NULL,
		 "poller should have a thread\n");

	event->poller->is_polling = false;
  10b479:	c6 40 04 00          	movb   $0x0,0x4(%eax)

	if (!z_is_thread_pending(thread)) {
  10b47d:	f6 47 0d 02          	testb  $0x2,0xd(%edi)
  10b481:	74 39                	je     10b4bc <signal_poll_event+0x56>
		goto ready_event;
	}

	if (z_is_thread_timeout_expired(thread)) {
		return -EAGAIN;
  10b483:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
	if (z_is_thread_timeout_expired(thread)) {
  10b488:	83 7f 20 fe          	cmpl   $0xfffffffe,0x20(%edi)
  10b48c:	74 52                	je     10b4e0 <signal_poll_event+0x7a>
	}

	z_unpend_thread(thread);
  10b48e:	57                   	push   %edi
  10b48f:	e8 d4 ef ff ff       	call   10a468 <z_unpend_thread>
	z_set_thread_return_value(thread,
  10b494:	31 c0                	xor    %eax,%eax
  10b496:	83 fe 08             	cmp    $0x8,%esi
  10b499:	0f 95 c0             	setne  %al
	z_unpend_thread(thread);
  10b49c:	5a                   	pop    %edx
  10b49d:	8b 57 28             	mov    0x28(%edi),%edx
	z_set_thread_return_value(thread,
  10b4a0:	8d 04 85 fc ff ff ff 	lea    -0x4(,%eax,4),%eax
  10b4a7:	89 02                	mov    %eax,(%edx)
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
  10b4a9:	f6 47 0d 1f          	testb  $0x1f,0xd(%edi)
  10b4ad:	75 0d                	jne    10b4bc <signal_poll_event+0x56>
				 state == K_POLL_STATE_CANCELLED ? -EINTR : 0);

	if (!z_is_thread_ready(thread)) {
  10b4af:	83 7f 18 00          	cmpl   $0x0,0x18(%edi)
  10b4b3:	75 07                	jne    10b4bc <signal_poll_event+0x56>
		z_add_thread_to_ready_q(thread);
  10b4b5:	57                   	push   %edi
  10b4b6:	e8 c9 f0 ff ff       	call   10a584 <z_add_thread_to_ready_q>
  10b4bb:	58                   	pop    %eax
	event->state |= state;
  10b4bc:	8b 4b 0c             	mov    0xc(%ebx),%ecx
	event->poller = NULL;
  10b4bf:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
	event->state |= state;
  10b4c6:	89 ca                	mov    %ecx,%edx
  10b4c8:	81 e1 ff 0f fe ff    	and    $0xfffe0fff,%ecx
  10b4ce:	c1 ea 0c             	shr    $0xc,%edx

	z_ready_thread(thread);

ready_event:
	set_event_ready(event, state);
	return 0;
  10b4d1:	31 c0                	xor    %eax,%eax
	event->state |= state;
  10b4d3:	09 f2                	or     %esi,%edx
  10b4d5:	83 e2 1f             	and    $0x1f,%edx
  10b4d8:	c1 e2 0c             	shl    $0xc,%edx
  10b4db:	09 ca                	or     %ecx,%edx
  10b4dd:	89 53 0c             	mov    %edx,0xc(%ebx)
}
  10b4e0:	8d 65 f4             	lea    -0xc(%ebp),%esp
  10b4e3:	5b                   	pop    %ebx
  10b4e4:	5e                   	pop    %esi
  10b4e5:	5f                   	pop    %edi
  10b4e6:	5d                   	pop    %ebp
  10b4e7:	c3                   	ret    

0010b4e8 <add_event>:
{
  10b4e8:	55                   	push   %ebp
  10b4e9:	89 e5                	mov    %esp,%ebp
  10b4eb:	57                   	push   %edi
  10b4ec:	56                   	push   %esi
  10b4ed:	89 d6                	mov    %edx,%esi
  10b4ef:	53                   	push   %ebx
  10b4f0:	53                   	push   %ebx
  10b4f1:	89 c3                	mov    %eax,%ebx
  10b4f3:	8b 40 04             	mov    0x4(%eax),%eax
	return sys_dlist_is_empty(list) ? NULL : list->tail;
  10b4f6:	3b 1b                	cmp    (%ebx),%ebx
  10b4f8:	74 26                	je     10b520 <add_event+0x38>
	if ((pending == NULL) ||
  10b4fa:	85 c0                	test   %eax,%eax
  10b4fc:	74 22                	je     10b520 <add_event+0x38>
		z_is_t1_higher_prio_than_t2(pending->poller->thread,
  10b4fe:	ff 31                	pushl  (%ecx)
  10b500:	8b 40 08             	mov    0x8(%eax),%eax
  10b503:	89 4d f0             	mov    %ecx,-0x10(%ebp)
  10b506:	ff 30                	pushl  (%eax)
  10b508:	e8 a9 ee ff ff       	call   10a3b6 <z_is_t1_higher_prio_than_t2>
  10b50d:	5f                   	pop    %edi
	if ((pending == NULL) ||
  10b50e:	84 c0                	test   %al,%al
		z_is_t1_higher_prio_than_t2(pending->poller->thread,
  10b510:	5a                   	pop    %edx
	if ((pending == NULL) ||
  10b511:	75 0d                	jne    10b520 <add_event+0x38>
	return list->head == list;
  10b513:	8b 3b                	mov    (%ebx),%edi
	SYS_DLIST_FOR_EACH_CONTAINER(events, pending, _node) {
  10b515:	39 fb                	cmp    %edi,%ebx
  10b517:	74 07                	je     10b520 <add_event+0x38>
  10b519:	85 ff                	test   %edi,%edi
  10b51b:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  10b51e:	75 12                	jne    10b532 <add_event+0x4a>
	node->prev = list->tail;
  10b520:	8b 43 04             	mov    0x4(%ebx),%eax
	node->next = list;
  10b523:	89 1e                	mov    %ebx,(%esi)
	node->prev = list->tail;
  10b525:	89 46 04             	mov    %eax,0x4(%esi)
	list->tail->next = node;
  10b528:	8b 43 04             	mov    0x4(%ebx),%eax
  10b52b:	89 30                	mov    %esi,(%eax)
	list->tail = node;
  10b52d:	89 73 04             	mov    %esi,0x4(%ebx)
  10b530:	eb 32                	jmp    10b564 <add_event+0x7c>
		if (z_is_t1_higher_prio_than_t2(poller->thread,
  10b532:	8b 47 08             	mov    0x8(%edi),%eax
  10b535:	89 4d f0             	mov    %ecx,-0x10(%ebp)
  10b538:	ff 30                	pushl  (%eax)
  10b53a:	ff 31                	pushl  (%ecx)
  10b53c:	e8 75 ee ff ff       	call   10a3b6 <z_is_t1_higher_prio_than_t2>
  10b541:	5a                   	pop    %edx
  10b542:	84 c0                	test   %al,%al
  10b544:	59                   	pop    %ecx
  10b545:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  10b548:	74 0f                	je     10b559 <add_event+0x71>
	node->prev = successor->prev;
  10b54a:	8b 47 04             	mov    0x4(%edi),%eax
	node->next = successor;
  10b54d:	89 3e                	mov    %edi,(%esi)
	node->prev = successor->prev;
  10b54f:	89 46 04             	mov    %eax,0x4(%esi)
	successor->prev->next = node;
  10b552:	89 30                	mov    %esi,(%eax)
	successor->prev = node;
  10b554:	89 77 04             	mov    %esi,0x4(%edi)
			return;
  10b557:	eb 0b                	jmp    10b564 <add_event+0x7c>
	return (node == list->tail) ? NULL : node->next;
  10b559:	39 7b 04             	cmp    %edi,0x4(%ebx)
  10b55c:	74 c2                	je     10b520 <add_event+0x38>
  10b55e:	8b 3f                	mov    (%edi),%edi
	SYS_DLIST_FOR_EACH_CONTAINER(events, pending, _node) {
  10b560:	85 ff                	test   %edi,%edi
  10b562:	eb ba                	jmp    10b51e <add_event+0x36>
}
  10b564:	8d 65 f4             	lea    -0xc(%ebp),%esp
  10b567:	5b                   	pop    %ebx
  10b568:	5e                   	pop    %esi
  10b569:	5f                   	pop    %edi
  10b56a:	5d                   	pop    %ebp
  10b56b:	c3                   	ret    

0010b56c <k_poll_event_init>:
{
  10b56c:	55                   	push   %ebp
  10b56d:	89 e5                	mov    %esp,%ebp
  10b56f:	8b 45 08             	mov    0x8(%ebp),%eax
	event->type = type;
  10b572:	8a 4d 0c             	mov    0xc(%ebp),%cl
  10b575:	83 e1 0f             	and    $0xf,%ecx
  10b578:	8a 50 0d             	mov    0xd(%eax),%dl
	event->poller = NULL;
  10b57b:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
	event->type = type;
  10b582:	83 e2 f0             	and    $0xfffffff0,%edx
  10b585:	09 ca                	or     %ecx,%edx
  10b587:	88 50 0d             	mov    %dl,0xd(%eax)
	event->mode = mode;
  10b58a:	8a 55 10             	mov    0x10(%ebp),%dl
  10b58d:	83 e2 01             	and    $0x1,%edx
  10b590:	8d 0c 12             	lea    (%edx,%edx,1),%ecx
  10b593:	8a 50 0e             	mov    0xe(%eax),%dl
  10b596:	83 e2 fd             	and    $0xfffffffd,%edx
  10b599:	09 ca                	or     %ecx,%edx
  10b59b:	88 50 0e             	mov    %dl,0xe(%eax)
	event->state = K_POLL_STATE_NOT_READY;
  10b59e:	81 60 0c ff 0f 02 00 	andl   $0x20fff,0xc(%eax)
	event->obj = obj;
  10b5a5:	8b 55 14             	mov    0x14(%ebp),%edx
  10b5a8:	89 50 10             	mov    %edx,0x10(%eax)
}
  10b5ab:	5d                   	pop    %ebp
  10b5ac:	c3                   	ret    

0010b5ad <z_impl_k_poll>:
{
  10b5ad:	55                   	push   %ebp
  10b5ae:	89 e5                	mov    %esp,%ebp
  10b5b0:	57                   	push   %edi
  10b5b1:	56                   	push   %esi
	for (int ii = 0; ii < num_events; ii++) {
  10b5b2:	31 ff                	xor    %edi,%edi
{
  10b5b4:	53                   	push   %ebx
	int last_registered = -1, rc;
  10b5b5:	83 ce ff             	or     $0xffffffff,%esi
{
  10b5b8:	83 ec 14             	sub    $0x14,%esp
	struct _poller poller = { .thread = _current, .is_polling = true, };
  10b5bb:	c6 45 e8 01          	movb   $0x1,-0x18(%ebp)
  10b5bf:	a1 28 0a 11 00       	mov    0x110a28,%eax
  10b5c4:	8b 5d 08             	mov    0x8(%ebp),%ebx
  10b5c7:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	for (int ii = 0; ii < num_events; ii++) {
  10b5ca:	3b 7d 0c             	cmp    0xc(%ebp),%edi
  10b5cd:	0f 8d bc 00 00 00    	jge    10b68f <z_impl_k_poll+0xe2>
  10b5d3:	9c                   	pushf  
  10b5d4:	fa                   	cli    
  10b5d5:	8f 45 e0             	popl   -0x20(%ebp)
	switch (event->type) {
  10b5d8:	8a 43 0d             	mov    0xd(%ebx),%al
  10b5db:	83 e0 0f             	and    $0xf,%eax
  10b5de:	3c 02                	cmp    $0x2,%al
  10b5e0:	74 0a                	je     10b5ec <z_impl_k_poll+0x3f>
  10b5e2:	3c 04                	cmp    $0x4,%al
  10b5e4:	74 16                	je     10b5fc <z_impl_k_poll+0x4f>
  10b5e6:	3c 01                	cmp    $0x1,%al
  10b5e8:	75 57                	jne    10b641 <z_impl_k_poll+0x94>
  10b5ea:	eb 1f                	jmp    10b60b <z_impl_k_poll+0x5e>
K_SYSCALL_DECLARE1(K_SYSCALL_K_SEM_COUNT_GET, k_sem_count_get, unsigned int, struct k_sem *, sem)
  10b5ec:	8b 53 10             	mov    0x10(%ebx),%edx
		if (k_sem_count_get(event->sem) > 0) {
  10b5ef:	83 7a 08 00          	cmpl   $0x0,0x8(%edx)
  10b5f3:	74 4c                	je     10b641 <z_impl_k_poll+0x94>
			*state = K_POLL_STATE_SEM_AVAILABLE;
  10b5f5:	b9 02 00 00 00       	mov    $0x2,%ecx
  10b5fa:	eb 1d                	jmp    10b619 <z_impl_k_poll+0x6c>
 *
 * @return a boolean, true if it's empty, false otherwise
 */
static inline bool sys_sflist_is_empty(sys_sflist_t *list);

Z_GENLIST_IS_EMPTY(sflist)
  10b5fc:	8b 53 10             	mov    0x10(%ebx),%edx
			*state = K_POLL_STATE_FIFO_DATA_AVAILABLE;
  10b5ff:	b9 04 00 00 00       	mov    $0x4,%ecx
		if (!k_queue_is_empty(event->queue)) {
  10b604:	83 3a 00             	cmpl   $0x0,(%edx)
  10b607:	75 10                	jne    10b619 <z_impl_k_poll+0x6c>
  10b609:	eb 36                	jmp    10b641 <z_impl_k_poll+0x94>
		if (event->signal->signaled != 0U) {
  10b60b:	8b 53 10             	mov    0x10(%ebx),%edx
			*state = K_POLL_STATE_SIGNALED;
  10b60e:	b9 01 00 00 00       	mov    $0x1,%ecx
		if (event->signal->signaled != 0U) {
  10b613:	83 7a 08 00          	cmpl   $0x0,0x8(%edx)
  10b617:	74 28                	je     10b641 <z_impl_k_poll+0x94>
	event->state |= state;
  10b619:	8b 53 0c             	mov    0xc(%ebx),%edx
	event->poller = NULL;
  10b61c:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
	event->state |= state;
  10b623:	89 d0                	mov    %edx,%eax
  10b625:	81 e2 ff 0f fe ff    	and    $0xfffe0fff,%edx
  10b62b:	c1 e8 0c             	shr    $0xc,%eax
  10b62e:	83 e0 1f             	and    $0x1f,%eax
  10b631:	09 c8                	or     %ecx,%eax
  10b633:	c1 e0 0c             	shl    $0xc,%eax
  10b636:	09 d0                	or     %edx,%eax
  10b638:	89 43 0c             	mov    %eax,0xc(%ebx)
			poller.is_polling = false;
  10b63b:	c6 45 e8 00          	movb   $0x0,-0x18(%ebp)
  10b63f:	eb 3d                	jmp    10b67e <z_impl_k_poll+0xd1>
		} else if (timeout != K_NO_WAIT && poller.is_polling) {
  10b641:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  10b645:	74 37                	je     10b67e <z_impl_k_poll+0xd1>
  10b647:	8a 55 e8             	mov    -0x18(%ebp),%dl
  10b64a:	84 d2                	test   %dl,%dl
  10b64c:	74 30                	je     10b67e <z_impl_k_poll+0xd1>
	switch (event->type) {
  10b64e:	3c 02                	cmp    $0x2,%al
  10b650:	74 0d                	je     10b65f <z_impl_k_poll+0xb2>
  10b652:	3c 04                	cmp    $0x4,%al
  10b654:	74 11                	je     10b667 <z_impl_k_poll+0xba>
  10b656:	fe c8                	dec    %al
  10b658:	75 1d                	jne    10b677 <z_impl_k_poll+0xca>
		add_event(&event->signal->poll_events, event, poller);
  10b65a:	8b 43 10             	mov    0x10(%ebx),%eax
  10b65d:	eb 0e                	jmp    10b66d <z_impl_k_poll+0xc0>
		add_event(&event->sem->poll_events, event, poller);
  10b65f:	8b 43 10             	mov    0x10(%ebx),%eax
  10b662:	83 c0 10             	add    $0x10,%eax
  10b665:	eb 06                	jmp    10b66d <z_impl_k_poll+0xc0>
		add_event(&event->queue->poll_events, event, poller);
  10b667:	8b 43 10             	mov    0x10(%ebx),%eax
  10b66a:	83 c0 08             	add    $0x8,%eax
		add_event(&event->signal->poll_events, event, poller);
  10b66d:	8d 4d e4             	lea    -0x1c(%ebp),%ecx
  10b670:	89 da                	mov    %ebx,%edx
  10b672:	e8 71 fe ff ff       	call   10b4e8 <add_event>
	event->poller = poller;
  10b677:	8d 45 e4             	lea    -0x1c(%ebp),%eax
				++last_registered;
  10b67a:	46                   	inc    %esi
	event->poller = poller;
  10b67b:	89 43 08             	mov    %eax,0x8(%ebx)
  10b67e:	0f ba 65 e0 09       	btl    $0x9,-0x20(%ebp)
  10b683:	73 01                	jae    10b686 <z_impl_k_poll+0xd9>
	__asm__ volatile (
  10b685:	fb                   	sti    
	for (int ii = 0; ii < num_events; ii++) {
  10b686:	47                   	inc    %edi
  10b687:	83 c3 14             	add    $0x14,%ebx
  10b68a:	e9 3b ff ff ff       	jmp    10b5ca <z_impl_k_poll+0x1d>
	__asm__ volatile (
  10b68f:	9c                   	pushf  
  10b690:	fa                   	cli    
  10b691:	5b                   	pop    %ebx
	if (!poller.is_polling) {
  10b692:	8a 45 e8             	mov    -0x18(%ebp),%al
  10b695:	84 c0                	test   %al,%al
  10b697:	75 10                	jne    10b6a9 <z_impl_k_poll+0xfc>
		clear_event_registrations(events, last_registered, key);
  10b699:	89 d9                	mov    %ebx,%ecx
  10b69b:	89 f2                	mov    %esi,%edx
  10b69d:	8b 45 08             	mov    0x8(%ebp),%eax
		return 0;
  10b6a0:	31 ff                	xor    %edi,%edi
		clear_event_registrations(events, last_registered, key);
  10b6a2:	e8 5c fd ff ff       	call   10b403 <clear_event_registrations>
  10b6a7:	eb 3b                	jmp    10b6e4 <z_impl_k_poll+0x137>
	poller.is_polling = false;
  10b6a9:	c6 45 e8 00          	movb   $0x0,-0x18(%ebp)
		return -EAGAIN;
  10b6ad:	bf f5 ff ff ff       	mov    $0xfffffff5,%edi
	if (timeout == K_NO_WAIT) {
  10b6b2:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  10b6b6:	74 2c                	je     10b6e4 <z_impl_k_poll+0x137>
	int swap_rc = z_pend_curr(&lock, key, &wait_q, timeout);
  10b6b8:	ff 75 10             	pushl  0x10(%ebp)
	_wait_q_t wait_q = Z_WAIT_Q_INIT(&wait_q);
  10b6bb:	8d 45 ec             	lea    -0x14(%ebp),%eax
	int swap_rc = z_pend_curr(&lock, key, &wait_q, timeout);
  10b6be:	50                   	push   %eax
	_wait_q_t wait_q = Z_WAIT_Q_INIT(&wait_q);
  10b6bf:	89 45 ec             	mov    %eax,-0x14(%ebp)
	int swap_rc = z_pend_curr(&lock, key, &wait_q, timeout);
  10b6c2:	53                   	push   %ebx
	_wait_q_t wait_q = Z_WAIT_Q_INIT(&wait_q);
  10b6c3:	89 45 f0             	mov    %eax,-0x10(%ebp)
	int swap_rc = z_pend_curr(&lock, key, &wait_q, timeout);
  10b6c6:	68 57 0b 11 00       	push   $0x110b57
  10b6cb:	e8 59 f1 ff ff       	call   10a829 <z_pend_curr>
  10b6d0:	83 c4 10             	add    $0x10,%esp
  10b6d3:	89 c7                	mov    %eax,%edi
  10b6d5:	9c                   	pushf  
  10b6d6:	fa                   	cli    
  10b6d7:	5b                   	pop    %ebx
	clear_event_registrations(events, last_registered, key);
  10b6d8:	89 d9                	mov    %ebx,%ecx
  10b6da:	89 f2                	mov    %esi,%edx
  10b6dc:	8b 45 08             	mov    0x8(%ebp),%eax
  10b6df:	e8 1f fd ff ff       	call   10b403 <clear_event_registrations>
  10b6e4:	0f ba e3 09          	bt     $0x9,%ebx
  10b6e8:	73 01                	jae    10b6eb <z_impl_k_poll+0x13e>
	__asm__ volatile (
  10b6ea:	fb                   	sti    
}
  10b6eb:	8d 65 f4             	lea    -0xc(%ebp),%esp
  10b6ee:	89 f8                	mov    %edi,%eax
  10b6f0:	5b                   	pop    %ebx
  10b6f1:	5e                   	pop    %esi
  10b6f2:	5f                   	pop    %edi
  10b6f3:	5d                   	pop    %ebp
  10b6f4:	c3                   	ret    

0010b6f5 <z_handle_obj_poll_events>:

void z_handle_obj_poll_events(sys_dlist_t *events, u32_t state)
{
  10b6f5:	55                   	push   %ebp
  10b6f6:	89 e5                	mov    %esp,%ebp
  10b6f8:	53                   	push   %ebx
  10b6f9:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10b6fc:	8b 55 0c             	mov    0xc(%ebp),%edx
	return list->head == list;
  10b6ff:	8b 01                	mov    (%ecx),%eax

static inline sys_dnode_t *sys_dlist_get(sys_dlist_t *list)
{
	sys_dnode_t *node = NULL;

	if (!sys_dlist_is_empty(list)) {
  10b701:	39 c1                	cmp    %eax,%ecx
  10b703:	74 1e                	je     10b723 <z_handle_obj_poll_events+0x2e>
	node->prev->next = node->next;
  10b705:	8b 58 04             	mov    0x4(%eax),%ebx
  10b708:	8b 08                	mov    (%eax),%ecx
  10b70a:	89 0b                	mov    %ecx,(%ebx)
	node->next->prev = node->prev;
  10b70c:	89 59 04             	mov    %ebx,0x4(%ecx)
	node->next = NULL;
  10b70f:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	node->prev = NULL;
  10b715:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)

	poll_event = (struct k_poll_event *)sys_dlist_get(events);
	if (poll_event != NULL) {
		(void) signal_poll_event(poll_event, state);
	}
}
  10b71c:	5b                   	pop    %ebx
  10b71d:	5d                   	pop    %ebp
		(void) signal_poll_event(poll_event, state);
  10b71e:	e9 43 fd ff ff       	jmp    10b466 <signal_poll_event>
}
  10b723:	5b                   	pop    %ebx
  10b724:	5d                   	pop    %ebp
  10b725:	c3                   	ret    

0010b726 <z_impl_k_poll_signal_init>:

void z_impl_k_poll_signal_init(struct k_poll_signal *signal)
{
  10b726:	55                   	push   %ebp
  10b727:	89 e5                	mov    %esp,%ebp
  10b729:	8b 45 08             	mov    0x8(%ebp),%eax
	list->head = (sys_dnode_t *)list;
  10b72c:	89 00                	mov    %eax,(%eax)
	list->tail = (sys_dnode_t *)list;
  10b72e:	89 40 04             	mov    %eax,0x4(%eax)
	sys_dlist_init(&signal->poll_events);
	signal->signaled = 0U;
  10b731:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
	/* signal->result is left unitialized */
	z_object_init(signal);
}
  10b738:	5d                   	pop    %ebp
  10b739:	c3                   	ret    

0010b73a <z_impl_k_poll_signal_check>:
}
#endif

void z_impl_k_poll_signal_check(struct k_poll_signal *signal,
			       unsigned int *signaled, int *result)
{
  10b73a:	55                   	push   %ebp
  10b73b:	89 e5                	mov    %esp,%ebp
  10b73d:	8b 45 08             	mov    0x8(%ebp),%eax
	*signaled = signal->signaled;
  10b740:	8b 55 0c             	mov    0xc(%ebp),%edx
  10b743:	8b 48 08             	mov    0x8(%eax),%ecx
  10b746:	89 0a                	mov    %ecx,(%edx)
	*result = signal->result;
  10b748:	8b 50 0c             	mov    0xc(%eax),%edx
  10b74b:	8b 45 10             	mov    0x10(%ebp),%eax
  10b74e:	89 10                	mov    %edx,(%eax)
}
  10b750:	5d                   	pop    %ebp
  10b751:	c3                   	ret    

0010b752 <z_impl_k_poll_signal_raise>:
	return 0;
}
#endif

int z_impl_k_poll_signal_raise(struct k_poll_signal *signal, int result)
{
  10b752:	55                   	push   %ebp
  10b753:	89 e5                	mov    %esp,%ebp
  10b755:	53                   	push   %ebx
  10b756:	51                   	push   %ecx
  10b757:	8b 55 08             	mov    0x8(%ebp),%edx
	__asm__ volatile (
  10b75a:	9c                   	pushf  
  10b75b:	fa                   	cli    
  10b75c:	5b                   	pop    %ebx
	k_spinlock_key_t key = k_spin_lock(&lock);
	struct k_poll_event *poll_event;

	signal->result = result;
  10b75d:	8b 45 0c             	mov    0xc(%ebp),%eax
	signal->signaled = 1U;
  10b760:	c7 42 08 01 00 00 00 	movl   $0x1,0x8(%edx)
	signal->result = result;
  10b767:	89 42 0c             	mov    %eax,0xc(%edx)
	return list->head == list;
  10b76a:	8b 02                	mov    (%edx),%eax
	if (!sys_dlist_is_empty(list)) {
  10b76c:	39 c2                	cmp    %eax,%edx
  10b76e:	75 0d                	jne    10b77d <z_impl_k_poll_signal_raise+0x2b>

	poll_event = (struct k_poll_event *)sys_dlist_get(&signal->poll_events);
	if (poll_event == NULL) {
		k_spin_unlock(&lock, key);
		return 0;
  10b770:	31 c0                	xor    %eax,%eax
  10b772:	0f ba e3 09          	bt     $0x9,%ebx
  10b776:	73 39                	jae    10b7b1 <z_impl_k_poll_signal_raise+0x5f>
	__asm__ volatile (
  10b778:	fb                   	sti    
  10b779:	31 c0                	xor    %eax,%eax
  10b77b:	eb 34                	jmp    10b7b1 <z_impl_k_poll_signal_raise+0x5f>
	node->prev->next = node->next;
  10b77d:	8b 48 04             	mov    0x4(%eax),%ecx
  10b780:	8b 10                	mov    (%eax),%edx
  10b782:	89 11                	mov    %edx,(%ecx)
	node->next->prev = node->prev;
  10b784:	89 4a 04             	mov    %ecx,0x4(%edx)
	}

	int rc = signal_poll_event(poll_event, K_POLL_STATE_SIGNALED);
  10b787:	ba 01 00 00 00       	mov    $0x1,%edx
	node->next = NULL;
  10b78c:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	node->prev = NULL;
  10b792:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  10b799:	e8 c8 fc ff ff       	call   10b466 <signal_poll_event>

	z_reschedule(&lock, key);
  10b79e:	53                   	push   %ebx
  10b79f:	68 57 0b 11 00       	push   $0x110b57
	int rc = signal_poll_event(poll_event, K_POLL_STATE_SIGNALED);
  10b7a4:	89 45 f8             	mov    %eax,-0x8(%ebp)
	z_reschedule(&lock, key);
  10b7a7:	e8 ee ec ff ff       	call   10a49a <z_reschedule>
  10b7ac:	58                   	pop    %eax
  10b7ad:	5a                   	pop    %edx
	return rc;
  10b7ae:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
  10b7b1:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  10b7b4:	c9                   	leave  
  10b7b5:	c3                   	ret    

0010b7b6 <idle>:
#else
#define IDLE_YIELD_IF_COOP() do { } while (false)
#endif

void idle(void *unused1, void *unused2, void *unused3)
{
  10b7b6:	55                   	push   %ebp
  10b7b7:	89 e5                	mov    %esp,%ebp
	__asm__ volatile (
  10b7b9:	9c                   	pushf  
  10b7ba:	fa                   	cli    
  10b7bb:	58                   	pop    %eax
	s32_t ticks = z_get_next_timeout_expiry();
  10b7bc:	e8 35 f9 ff ff       	call   10b0f6 <z_get_next_timeout_expiry>
	z_set_timeout_expiry((ticks < IDLE_THRESH) ? 1 : ticks, true);
  10b7c1:	83 f8 02             	cmp    $0x2,%eax
  10b7c4:	7f 05                	jg     10b7cb <idle+0x15>
  10b7c6:	b8 01 00 00 00       	mov    $0x1,%eax
  10b7cb:	6a 01                	push   $0x1
  10b7cd:	50                   	push   %eax
  10b7ce:	e8 39 f9 ff ff       	call   10b10c <z_set_timeout_expiry>
  10b7d3:	58                   	pop    %eax
  10b7d4:	5a                   	pop    %edx
	k_cpu_idle();
  10b7d5:	e8 17 b0 ff ff       	call   1067f1 <k_cpu_idle>
  10b7da:	eb dd                	jmp    10b7b9 <idle+0x3>

0010b7dc <init_static_pools>:
	z_waitq_init(&p->wait_q);
	z_sys_mem_pool_base_init(&p->base);
}

int init_static_pools(struct device *unused)
{
  10b7dc:	55                   	push   %ebp
  10b7dd:	89 e5                	mov    %esp,%ebp
  10b7df:	53                   	push   %ebx
	ARG_UNUSED(unused);
	struct k_mem_pool *p;

	for (p = _k_mem_pool_list_start; p < _k_mem_pool_list_end; p++) {
  10b7e0:	bb 3c 34 11 00       	mov    $0x11343c,%ebx
  10b7e5:	81 fb 3c 34 11 00    	cmp    $0x11343c,%ebx
  10b7eb:	73 15                	jae    10b802 <init_static_pools+0x26>
  10b7ed:	8d 43 14             	lea    0x14(%ebx),%eax
	z_sys_mem_pool_base_init(&p->base);
  10b7f0:	53                   	push   %ebx
	list->head = (sys_dnode_t *)list;
  10b7f1:	89 43 14             	mov    %eax,0x14(%ebx)
	list->tail = (sys_dnode_t *)list;
  10b7f4:	89 43 18             	mov    %eax,0x18(%ebx)
  10b7f7:	e8 73 4b ff ff       	call   10036f <z_sys_mem_pool_base_init>
	for (p = _k_mem_pool_list_start; p < _k_mem_pool_list_end; p++) {
  10b7fc:	83 c3 1c             	add    $0x1c,%ebx
	z_sys_mem_pool_base_init(&p->base);
  10b7ff:	58                   	pop    %eax
  10b800:	eb e3                	jmp    10b7e5 <init_static_pools+0x9>
		k_mem_pool_init(p);
	}

	return 0;
}
  10b802:	31 c0                	xor    %eax,%eax
  10b804:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  10b807:	c9                   	leave  
  10b808:	c3                   	ret    

0010b809 <_OffsetAbsSyms>:

/* size of the MMU_REGION structure. Used by linker scripts */

GEN_ABSOLUTE_SYM(__MMU_REGION_SIZEOF, sizeof(struct mmu_region));

GEN_ABS_SYM_END
  10b809:	c3                   	ret    

0010b80a <_handle_exc_0_vector_0_stub>:
  10b80a:	6a 00                	push   $0x0
  10b80c:	68 10 6b 10 00       	push   $0x106b10
  10b811:	e9 de af ff ff       	jmp    1067f4 <_exception_enter>

0010b816 <_handle_exc_2_vector_2_stub>:
  10b816:	6a 00                	push   $0x0
  10b818:	68 1d 6b 10 00       	push   $0x106b1d
  10b81d:	e9 d2 af ff ff       	jmp    1067f4 <_exception_enter>

0010b822 <_handle_exc_4_vector_4_stub>:
  10b822:	6a 00                	push   $0x0
  10b824:	68 2d 6b 10 00       	push   $0x106b2d
  10b829:	e9 c6 af ff ff       	jmp    1067f4 <_exception_enter>

0010b82e <_handle_exc_5_vector_5_stub>:
  10b82e:	6a 00                	push   $0x0
  10b830:	68 3d 6b 10 00       	push   $0x106b3d
  10b835:	e9 ba af ff ff       	jmp    1067f4 <_exception_enter>

0010b83a <_handle_exc_6_vector_6_stub>:
  10b83a:	6a 00                	push   $0x0
  10b83c:	68 4d 6b 10 00       	push   $0x106b4d
  10b841:	e9 ae af ff ff       	jmp    1067f4 <_exception_enter>

0010b846 <_handle_exc_7_vector_7_stub>:
  10b846:	6a 00                	push   $0x0
  10b848:	68 5d 6b 10 00       	push   $0x106b5d
  10b84d:	e9 a2 af ff ff       	jmp    1067f4 <_exception_enter>

0010b852 <_handle_exc_8_vector_8_stub>:
  10b852:	6a 00                	push   $0x0
  10b854:	68 6d 6b 10 00       	push   $0x106b6d
  10b859:	e9 96 af ff ff       	jmp    1067f4 <_exception_enter>

0010b85e <_handle_exc_10_vector_10_stub>:
  10b85e:	68 7d 6b 10 00       	push   $0x106b7d
  10b863:	e9 8c af ff ff       	jmp    1067f4 <_exception_enter>

0010b868 <_handle_exc_11_vector_11_stub>:
  10b868:	68 8d 6b 10 00       	push   $0x106b8d
  10b86d:	e9 82 af ff ff       	jmp    1067f4 <_exception_enter>

0010b872 <_handle_exc_12_vector_12_stub>:
  10b872:	68 9d 6b 10 00       	push   $0x106b9d
  10b877:	e9 78 af ff ff       	jmp    1067f4 <_exception_enter>

0010b87c <_handle_exc_13_vector_13_stub>:
  10b87c:	68 ad 6b 10 00       	push   $0x106bad
  10b881:	e9 6e af ff ff       	jmp    1067f4 <_exception_enter>

0010b886 <_handle_exc_16_vector_16_stub>:
  10b886:	6a 00                	push   $0x0
  10b888:	68 bd 6b 10 00       	push   $0x106bbd
  10b88d:	e9 62 af ff ff       	jmp    1067f4 <_exception_enter>

0010b892 <_handle_exc_17_vector_17_stub>:
  10b892:	68 cd 6b 10 00       	push   $0x106bcd
  10b897:	e9 58 af ff ff       	jmp    1067f4 <_exception_enter>

0010b89c <_handle_exc_18_vector_18_stub>:
  10b89c:	6a 00                	push   $0x0
  10b89e:	68 dd 6b 10 00       	push   $0x106bdd
  10b8a3:	e9 4c af ff ff       	jmp    1067f4 <_exception_enter>

0010b8a8 <_page_fault_handler_vector_14_stub>:
  10b8a8:	68 ed 6b 10 00       	push   $0x106bed
  10b8ad:	e9 42 af ff ff       	jmp    1067f4 <_exception_enter>
